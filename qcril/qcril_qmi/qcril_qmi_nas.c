/******************************************************************************
  @file    qcril_qmi_nas_s.c
  @brief   qcril qmi - NAS

  DESCRIPTION
    Handles RIL requests, Callbacks, indications for QMI NAS.

  ---------------------------------------------------------------------------

  Copyright (c) 2010-2014 Qualcomm Technologies, Inc. All Rights Reserved.
  Qualcomm Technologies Proprietary and Confidential.
  ---------------------------------------------------------------------------
******************************************************************************/


//===========================================================================
//
//                           INCLUDE FILES
//
//===========================================================================

#include <errno.h>
#include <cutils/memory.h>
#include <cutils/properties.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#ifdef QMI_RIL_UTF
#include <signal.h>
#include <time.h>
#endif

#include "ril.h"
#include <telephony/librilutils.h>
#include "IxErrno.h"
#include "comdef.h"
#include "qcrili.h"
#include "qcril_reqlist.h"
#include "qcril_arb.h"
#include "qcril_qmi_nas.h"
#include "qcril_db.h"
#include "qcril_qmi_client.h"
#include "qcril_cm_util.h"
#include "qcril_cm_ss.h"
#include "qcril_qmi_sms.h"
#include "qcril_qmi_voice.h"
#include "qcril_qmi_nas2.h"
#include "qcril_arb.h"
#include "qcril_data.h"
#include "qcril_other.h"
#include "qcril_pbm.h"
#include "qcril_qmi_coex.h"
#include "qcril_uim_card.h"
#include "qcril_other.h"
#include "qcril_qmi_ims_socket.h"
#include "qcril_qmi_imsa.h"
#include "qcril_am.h"

#include "qmi_ril_platform_dep.h"

#include "time_genoff.h"

// required for glibc compile
#include <limits.h>

//===========================================================================

//                    INTERNAL DEFINITIONS AND TYPES

//===========================================================================

#define NAS_NIL                     QMI_RIL_ZERO

#define NAS_ZERO                    QMI_RIL_ZERO

#define NAS_NITZ_STR_BUF_MAX       (30)
#define NAS_SMALL_STR_BUF_MAX       (16)

#define NAS_RADIO_IF_NONE           0x00 // - None (no service)
#define NAS_RADIO_IF_CDMA2000       0x01 // - cdma2000 1X
#define NAS_RADIO_IF_CDMA2000_HRPD  0x02 // - cdma2000 HRPD (1xEV-DO)
#define NAS_RADIO_IF_AMPS           0x03 // - AMPS
#define NAS_RADIO_IF_GSM            0x04 // - GSM
#define NAS_RADIO_IF_UMTS           0x05 // - UMTS
#define NAS_RADIO_IF_LTE            0x08 // - LTE
#define NAS_RADIO_IF_TDSCDMA        0x09 // - TDSCDMA

#define NAS_UNKNOWN                 (-1)
#define NAS_SIGNAL_STRENGTH_UNK     (-1)
#define NAS_SIGNAL_STRENGTH_UNK_GW  (99)

#define NAS_MCC_MNC_MAX_SIZE       (QCRIL_MCC_MNC_MAX_SIZE)
#define NAS_3GPP2_MCC_MAX_SIZE     (5)

#define NAS_REQ_MASK_SIG_STRENGTH_RSSI          0x0001
#define NAS_REQ_MASK_SIG_STRENGTH_ECIO          0x0002
#define NAS_REQ_MASK_SIG_STRENGTH_IO            0x0004
#define NAS_REQ_MASK_SIG_STRENGTH_SINR          0x0008
#define NAS_REQ_MASK_SIG_STRENGTH_ERROR_RATE    0x0010
#define NAS_REQ_MASK_SIG_STRENGTH_RSRQ          0x0020
#define NAS_REQ_MASK_SIG_STRENGTH_MANDATORY_FLD 0x0040
#define NAS_REQ_MASK_SIG_STRENGTH_VALID_MASK    ( NAS_REQ_MASK_SIG_STRENGTH_RSSI | \
                                                  NAS_REQ_MASK_SIG_STRENGTH_ECIO | \
                                                  NAS_REQ_MASK_SIG_STRENGTH_IO |   \
                                                  NAS_REQ_MASK_SIG_STRENGTH_SINR |  \
                                                  NAS_REQ_MASK_SIG_STRENGTH_ERROR_RATE | \
                                                  NAS_REQ_MASK_SIG_STRENGTH_RSRQ )

#define NAS_CMN_EMERGENCY_MODE_OFF         0x00
#define NAS_CMN_EMERGENCY_MODE_ON          0x01

#define NAS_REQ_REPORT                               (1)
#define NAS_REQ_DO_NOT_REPORT                        (0)



#define NAS_VAL_NOT_REGISTERED                       (0)
#define NAS_VAL_REGISTERED                           (1)
#define NAS_VAL_NOT_REGISTERED_SEARCHING             (2)
#define NAS_VAL_REGISTRATION_DENIED                  (3)
#define NAS_VAL_REGISTRATION_UNKNOWN                 (4)

#define NAS_VAL_RTRE_CARD_ONLY                       (0x01)
#define NAS_VAL_RTRE_NV_ONLY                         (0x02)

#define NAS_VAL_NO_SERVICE                           (0)
#define NAS_VAL_LIMITED_SERVICE                      (1)
#define NAS_VAL_SERVICE_AVAILABLE                    (2)
#define NAS_VAL_LIMITED_REGIONAL_SERVICE             (3)
#define NAS_VAL_POWER_SAVE_OR_DEEP_SLEEP             (4)

#define DMS_VAL_ONLINE                                0x00
#define DMS_VAL_LOW_POWER                             0x01
#define DMS_VAL_FACTORY_TEST_MODE                     0x02
#define DMS_VAL_OFFLINE                               0x03
#define DMS_VAL_RESETTING                             0x04
#define DMS_VAL_SHUTTING_DOWN                         0x05

#define NAS_VAL_ROAMING_ROAMING                       (0)
#define NAS_VAL_ROAMING_HOME                          (1)
#define NAS_VAL_ROAMING_FLASHING                      (2)
#define NAS_VAL_ROAMING_HOME_EX_64                    (64)
#define NAS_VAL_ROAMING_HOME_EX_65                    (65)
#define NAS_VAL_ROAMING_HOME_EX_76                    (76)
#define NAS_VAL_ROAMING_HOME_EX_83                    (83)

#define NAS_CMN_DEFAULT_MODEM                         (0)

#define NAS_VAL_RADIO_TECH_3GPP                       0x02
#define NAS_VAL_RADIO_TECH_3GPP2                      0x01
#define NAS_VAL_RADIO_TECH_UNKNOWN                    0x00

#define NAS_VAL_DATA_TECH_NONE                        0x00

#define NAS_VAL_DATA_ATTACH_UNKNOWN                   (0)
#define NAS_VAL_DATA_ATTACH_ATTACHED                  (1)
#define NAS_VAL_DATA_ATTACH_DETACHED                  (2)

#define NAS_VAL_CS_ATTACH_UNKNOWN                     (0)
#define NAS_VAL_CS_ATTACH_ATTACHED                    (1)
#define NAS_VAL_CS_ATTACH_DETACHED                    (2)

#define NAS_VAL_BAND_PREF_BC0_A                       ( (uint64_t) 1 << 0 )
#define NAS_VAL_BAND_PREF_BC0_B                       ( (uint64_t) 1 << 1 )
#define NAS_VAL_BAND_PREF_BC1                         ( (uint64_t) 1 << 2 )
#define NAS_VAL_BAND_PREF_BC2                         ( (uint64_t) 1 << 3 )
#define NAS_VAL_BAND_PREF_BC3                         ( (uint64_t) 1 << 4 )
#define NAS_VAL_BAND_PREF_BC4                         ( (uint64_t) 1 << 5 )
#define NAS_VAL_BAND_PREF_BC5                         ( (uint64_t) 1 << 6 )
#define NAS_VAL_BAND_PREF_GSM_DCS_1800                ( (uint64_t) 1 << 7 )
#define NAS_VAL_BAND_PREF_GSM_EGSM_900                ( (uint64_t) 1 << 8 )
#define NAS_VAL_BAND_PREF_GSM_PGSM_900                ( (uint64_t) 1 << 9 )
#define NAS_VAL_BAND_PREF_BC6                         ( (uint64_t) 1 << 10 )
#define NAS_VAL_BAND_PREF_BC7                         ( (uint64_t) 1 << 11 )
#define NAS_VAL_BAND_PREF_BC8                         ( (uint64_t) 1 << 12 )
#define NAS_VAL_BAND_PREF_BC9                         ( (uint64_t) 1 << 13 )
#define NAS_VAL_BAND_PREF_BC10                        ( (uint64_t) 1 << 14 )
#define NAS_VAL_BAND_PREF_BC11                        ( (uint64_t) 1 << 15 )
#define NAS_VAL_BAND_PREF_GSM_450                     ( (uint64_t) 1 << 16 )
#define NAS_VAL_BAND_PREF_GSM_480                     ( (uint64_t) 1 << 17 )
#define NAS_VAL_BAND_PREF_GSM_750                     ( (uint64_t) 1 << 18 )
#define NAS_VAL_BAND_PREF_GSM_850                     ( (uint64_t) 1 << 19 )
#define NAS_VAL_BAND_PREF_GSM_RGSM_900                ( (uint64_t) 1 << 20 )
#define NAS_VAL_BAND_PREF_GSM_PCS_1900                ( (uint64_t) 1 << 21 )
#define NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000            ( (uint64_t) 1 << 22 )
#define NAS_VAL_BAND_PREF_WCDMA_II_PCS_1900           ( (uint64_t) 1 << 23 )
#define NAS_VAL_BAND_PREF_WCDMA_III_1700              ( (uint64_t) 1 << 24 )
#define NAS_VAL_BAND_PREF_WCDMA_IV_1700               ( (uint64_t) 1 << 25 )
#define NAS_VAL_BAND_PREF_WCDMA_V_850                 ( (uint64_t) 1 << 26 )
#define NAS_VAL_BAND_PREF_WCDMA_VI_800                ( (uint64_t) 1 << 27 )
#define NAS_VAL_BAND_PREF_BC12                        ( (uint64_t) 1 << 28 )
#define NAS_VAL_BAND_PREF_BC14                        ( (uint64_t) 1 << 29 )
#define NAS_VAL_BAND_PREF_BC15                        ( (uint64_t) 1 << 31 )
#define NAS_VAL_BAND_PREF_WCDMA_VII_2600              ( (uint64_t) 1 << 48 )
#define NAS_VAL_BAND_PREF_WCDMA_VIII_900              ( (uint64_t) 1 << 49 )
#define NAS_VAL_BAND_PREF_WCDMA_IX_1700               ( (uint64_t) 1 << 50 )
#define NAS_VAL_BAND_PREF_BBC16                       ( (uint64_t) 1 << 56 )
#define NAS_VAL_BAND_PREF_BC17                        ( (uint64_t) 1 << 57 )
#define NAS_VAL_BAND_PREF_BC18                        ( (uint64_t) 1 << 58 )
#define NAS_VAL_BAND_PREF_BC19                        ( (uint64_t) 1 << 59 )

#define NAS_VAL_BAND_PREF_COMB_ANY                   (NAS_VAL_BAND_PREF_BC0_A  | \
                                                      NAS_VAL_BAND_PREF_BC0_B  | \
                                                      NAS_VAL_BAND_PREF_BC1    | \
                                                      NAS_VAL_BAND_PREF_BC2    | \
                                                      NAS_VAL_BAND_PREF_BC3    | \
                                                      NAS_VAL_BAND_PREF_BC4    | \
                                                      NAS_VAL_BAND_PREF_BC5    | \
                                                      NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                      NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                      NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                      NAS_VAL_BAND_PREF_BC6    | \
                                                      NAS_VAL_BAND_PREF_BC7    | \
                                                      NAS_VAL_BAND_PREF_BC8    | \
                                                      NAS_VAL_BAND_PREF_BC9    | \
                                                      NAS_VAL_BAND_PREF_BC10   | \
                                                      NAS_VAL_BAND_PREF_BC11   | \
                                                      NAS_VAL_BAND_PREF_GSM_450 | \
                                                      NAS_VAL_BAND_PREF_GSM_480 | \
                                                      NAS_VAL_BAND_PREF_GSM_750 | \
                                                      NAS_VAL_BAND_PREF_GSM_850 | \
                                                      NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                      NAS_VAL_BAND_PREF_GSM_PCS_1900 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_II_PCS_1900 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_III_1700 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_IV_1700 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_V_850 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_VI_800 | \
                                                      NAS_VAL_BAND_PREF_BC12 | \
                                                      NAS_VAL_BAND_PREF_BC14 | \
                                                      NAS_VAL_BAND_PREF_BC15 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_VII_2600 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_VIII_900 | \
                                                      NAS_VAL_BAND_PREF_WCDMA_IX_1700 | \
                                                      NAS_VAL_BAND_PREF_BBC16 | \
                                                      NAS_VAL_BAND_PREF_BC17 | \
                                                      NAS_VAL_BAND_PREF_BC18 | \
                                                      NAS_VAL_BAND_PREF_BC19)

#define NAS_VAL_BAND_PREF_COMB_EURO                   ( NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                        NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                        NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                        NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                        NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 )

#define NAS_VAL_BAND_PREF_COMB_US                      ( NAS_VAL_BAND_PREF_GSM_850 | \
                                                         NAS_VAL_BAND_PREF_GSM_PCS_1900 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_V_850 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_II_PCS_1900 )

#define NAS_VAL_BAND_PREF_COMB_JPN                     ( NAS_VAL_BAND_PREF_WCDMA_VI_800 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 )

#define NAS_VAL_BAND_PREF_COMB_AUS                     ( NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_V_850 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_I_IMT_2000 )

#define NAS_VAL_BAND_PREF_COMB_AUS2                    ( NAS_VAL_BAND_PREF_GSM_EGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_PGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_RGSM_900 | \
                                                         NAS_VAL_BAND_PREF_GSM_DCS_1800 | \
                                                         NAS_VAL_BAND_PREF_WCDMA_V_850 )

#define NAS_VAL_BAND_PREF_COMB_CELLULAR                 ( NAS_VAL_BAND_PREF_BC0_A | \
                                                          NAS_VAL_BAND_PREF_BC0_B )

#define NAS_VAL_BAND_PREF_COMB_PCS                      ( NAS_VAL_BAND_PREF_BC1 )

#define NAS_VAL_BAND_PREF_COMB_JTACS                    ( NAS_VAL_BAND_PREF_BC3 )

#define NAS_VAL_BAND_PREF_COMB_KOREAN_PCS               ( NAS_VAL_BAND_PREF_BC4 )

#define NAS_VAL_BAND_PREF_COMB_450_MHZ                  ( NAS_VAL_BAND_PREF_BC5 )

#define NAS_VAL_BAND_PREF_COMB_2_GHZ                    ( NAS_VAL_BAND_PREF_BC6 )

#define NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ            ( NAS_VAL_BAND_PREF_BC7 )

#define NAS_VAL_BAND_PREF_COMB_1800_MHZ                 ( NAS_VAL_BAND_PREF_BC8 )

#define NAS_VAL_BAND_PREF_COMB_900_MHZ                  ( NAS_VAL_BAND_PREF_BC9 )

#define NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ              ( NAS_VAL_BAND_PREF_BC10 )

#define NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR           ( NAS_VAL_BAND_PREF_BC11 )

#define NAS_VAL_BAND_PREF_COMB_AWS                      ( NAS_VAL_BAND_PREF_BC15 )

#define NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ               ( NAS_VAL_BAND_PREF_BBC16 )

#define NAS_VAL_SRV_CAPABILITY_NO_SERVICE               0x00
#define NAS_VAL_SRV_CAPABILITY_CS_ONLY                  0x01
#define NAS_VAL_SRV_CAPABILITY_PS_ONLY                  0x02
#define NAS_VAL_SRV_CAPABILITY_CS_AND_PS                0x03
#define NAS_VAL_SRV_CAPABILITY_SYS_FOUND_NOT_YET_REG    0x04
#define RIL_VAL_BAND_ANY        (0)
#define RIL_VAL_BAND_EURO       (1)
#define RIL_VAL_BAND_US         (2)
#define RIL_VAL_BAND_JPN        (3)
#define RIL_VAL_BAND_AUS        (4)
#define RIL_VAL_BAND_AUS2       (5)
#define RIL_VAL_BAND_CELLULAR   (6)
#define RIL_VAL_BAND_PCS        (7)
#define RIL_VAL_BAND_JTACS      (8)
#define RIL_VAL_BAND_KOREAN_PCS (9)
#define RIL_VAL_BAND_450_MHZ    (10)
#define RIL_VAL_BAND_2_GHZ      (11)
#define RIL_VAL_BAND_UPPER_700_MHZ      (12)
#define RIL_VAL_BAND_1800_MHZ   (13)
#define RIL_VAL_BAND_900_MHZ    (14)
#define RIL_VAL_BAND_SEC_800_MHZ   (15)
#define RIL_VAL_BAND_SEC_EUOROPEAN_PAMR   (16)
#define RIL_VAL_BAND_SEC_AWS    (17)
#define RIL_VAL_BAND_SEC_US_2_5_GHZ  (18)

#define NAS_RIL_MAX_BAND_CAPACITY_LIST_SIZE  (32)

#define NAS_VAL_TDD_LTE_BAND_MASK (0xFFFFFFFF00000000)
#define NAS_VAL_FDD_LTE_BAND_MASK (0xFFFFFFFF)


#define NAS_NW_SCAN_RES_ENTRY_PREFERRED              ( (uint8_t) 1 << 6 )
#define NAS_NW_SCAN_RES_ENTRY_NOT_PREFERRED          ( (uint8_t) 1 << 7 )
#define NAS_NW_SCAN_RES_ENTRY_FORBIDDEN              ( (uint8_t) 1 << 4 )
#define NAS_NW_SCAN_RES_ENTRY_NOT_FORBIDDEN          ( (uint8_t) 1 << 5 )
#define NAS_NW_SCAN_RES_ENTRY_HOME                   ( (uint8_t) 1 << 2 )
#define NAS_NW_SCAN_RES_ENTRY_ROAM                   ( (uint8_t) 1 << 3 )
#define NAS_NW_SCAN_RES_ENTRY_CUR_SERVING            ( (uint8_t) 1 << 0 )
#define NAS_NW_SCAN_RES_ENTRY_AVAILABLE              ( (uint8_t) 1 << 1 )


#define NAS_DMS_PRL_VER_RESP_MAX_LEN                (6)
#define QCRIL_QMI_NAS_REGISTRATION_REJECT_CAUSE_ILLEGAL_MS     (3)

#define NAS_VAL_ROAM_PREF_CDMA_AUTOMATIC            (0x00)
#define NAS_VAL_ROAM_PREF_CDMA_HOME_ONLY            (0x01)
#define NAS_VAL_ROAM_PREF_CDMA_ROAM_ONLY            (0x02)
#define NAS_VAL_ROAM_PREF_CDMA_HOME_AND_AFFILIATES  (0x03)


#define RIL_VAL_RADIO_POWER_MODE_LPM                0
#define RIL_VAL_RADIO_POWER_MODE_ONLINE             1
#define RIL_VAL_RADIO_POWER_MODE_OFF                2

#define QMI_RIL_OP_NAME_NITZ_PLMN                "persist.radio.nitz_plmn_"
#define QMI_RIL_OP_NAME_NITZ_LONS_0              "persist.radio.nitz_lons_0_"
#define QMI_RIL_OP_NAME_NITZ_LONS_1              "persist.radio.nitz_lons_1_"
#define QMI_RIL_OP_NAME_NITZ_LONS_2              "persist.radio.nitz_lons_2_"
#define QMI_RIL_OP_NAME_NITZ_LONS_3              "persist.radio.nitz_lons_3_"
#define QMI_RIL_OP_NAME_NITZ_SONS_0              "persist.radio.nitz_sons_0_"
#define QMI_RIL_OP_NAME_NITZ_SONS_1              "persist.radio.nitz_sons_1_"
#define QMI_RIL_OP_NAME_NITZ_SONS_2              "persist.radio.nitz_sons_2_"
#define QMI_RIL_OP_NAME_NITZ_SONS_3              "persist.radio.nitz_sons_3_"

#define QMI_RIL_TUNE_AWAY                        "persist.radio.tuneaway_"
#define QMI_RIL_LTE_TUNE_AWAY                    "persist.radio.lte_tuneaway_"
#define QMI_RIL_PAGING_PRIORITY                  "persist.radio.paging_priority_"

#define QMI_RIL_SIMO_CS_PS_SVLTE                 "ro.ril.svlte1x"
#define QMI_RIL_SIMO_CS_PS_SVDO                  "ro.ril.svdo"
#define QMI_RIL_APM_ON                           "persist.radio.airplane_mode_on"
#define QMI_RIL_FILL_EONS                        "persist.radio.fill_eons"
#define QMI_RIL_SNAPSHOT_FEATURE_ENABLED         "persist.radio.snapshot_enabled"
#define QMI_RIL_SNAPSHOT_TIMER_VALUE             "persist.radio.snapshot_timer"
#define QMI_RIL_GET_MODE_PREF_FROM_NV_10         "persist.radio.mode_pref_nv10"
#define QMI_RIL_LIMIT_SYS_INFO                   "persist.radio.limit_sys_info"

#define QMI_RIL_TELEPHONY_EONS_SUPPORTED         "persist.radio.eons.enabled"
#define QMI_RIL_PREFER_SPN_OVER_PLMN_NAME        "persist.radio.prefer_spn"
#define QMI_RIL_ALWAYS_SEND_PLMN_NAME            "persist.radio.always_send_plmn"
#define QMI_RIL_PROCESS_DUPLICATE_NW_SCAN_NAMES  "persist.radio.proc_nw_scan"
#define QMI_RIL_SGLTE_EONS_PREF_DOMAIN_PROPERTY  "persist.radio.sglte.eons_domain"
#define QMI_RIL_SGLTE_EONS_PREF_ROAMING_PROPERTY "persist.radio.sglte.eons_roam"
#define QMI_RIL_CONSIDER_LTE_LTD_SRV_VRTE_UPDATE "persist.radio.lte_vrte_ltd"
#define QMI_RIL_CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE "persist.radio.3gpp_drte_ltd"
#define QMI_RIL_PROVISION_EMERGENCY_CALL_IN_LPM  "persist.radio.prov_emer_in_lpm"
#define QMI_RIL_RELAY_OPRT_CHANGE                "persist.radio.relay_oprt_change"
#define QMI_RIL_REG_DENIED_ON_REJ_CAUSE          "persist.radio.reg_den_rej_cause"
#define QMI_RIL_1X_ROAM_MTU_SIZE                 "persist.radio.1x_roam_mtu_size"
#define QMI_RIL_MANUAL_NW_REJECT_COUNTER_ENABLE  "persist.radio.manual_nw_rej_ct"
#define QMI_RIL_IGNORE_SRV_DOMAIN_CAMPED_TIMER   "persist.radio.ignore_dom_time"

#define QMI_RIL_MANUAL_NW_REJECT_MAX_COUNT       (4)


#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED                  "persist.radio.custom_ecc"
#define QMI_RIL_CUSTOM_NW_EMERGENCY_NUMBERS_ENABLED               "persist.radio.custom_nw_ecc"
#define QMI_RIL_CUSTOM_HARDCODED_EMERGENCY_NUMBERS_LIST_PREFIX    "persist.radio.ecc_hard_"

#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_MAX_COUNT                            (20)
#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_COUNT_PROPERTY_SUFFFIX               "count"
#define QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_PROPERTIES_DELIMITER                 ","
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_START_DELIMITER       '{'
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_END_DELIMITER         '}'
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_INTERNAL_DELIMITER_1  ','
#define QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_INTERNAL_DELIMITER_2  ':'


#define QMI_RIL_VRTE_LOGIC_CONSIDER_DATA           1
#define QMI_RIL_VRTE_LOGIC_SKIP_MODE_PREF          2

#define RIL_VAL_REG_UNKNOWN                                 4
#define RIL_VAL_REG_REGISTERED_HOME_NET                     1
#define RIL_VAL_REG_NOT_REGISTERED_SEARCHING                2
#define RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING            0
#define RIL_VAL_REG_REGISTRATION_DENIED                     3
#define RIL_VAL_REG_REGISTERED_ROAMING                      5
#define RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV        12
#define RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV             13

#define RIL_VAL_REG_MANAGED_ROAMING_CAUSE                   10

#define QCRIL_QMI_NAS_GET_DEVICE_SERIAL_NUMBERS_SYNC_TIMEOUT   5000
#define QCRIL_QMI_NAS_GET_3GPP2_INFO_SYNC_TIMEOUT       5000
#define QCRIL_QMI_DMS_SET_OPERATING_MODE_SYNC_TIMEOUT   74000

#define NAS_SYS_EGPRS_SUPPORT_NOT_AVAIL             0x00
#define NAS_SYS_EGPRS_SUPPORT_AVAIL                 0x01

#define NAS_SYS_DTM_SUPPORT_NOT_AVAIL               0x00
#define NAS_SYS_DTM_SUPPORT_AVAIL                   0x01

#define QCRIL_ALWAYS_REPORT_RESTRICTED_STATE  "persist.radio.report_rstate"
#define QCRIL_FORCE_NW_SEARCH                 "persist.radio.force_nw_search"
#define QCRIL_ADD_POWER_SAVE                  "persist.radio.add_power_save"
#define QCRIL_APM_SIM_NOT_PWDN                "persist.radio.apm_sim_not_pwdn"
#define QCRIL_NO_WAIT_FOR_CARD                "persist.radio.no_wait_for_card"
#define QCRIL_IS_VOIP_ENABLED                 "persist.radio.is_voip_enabled"
#define QCRIL_VOICE_SUPPORT_ON_LTE            "persist.radio.voice_on_lte"
#define QCRIL_DATA_DORMANCY_NO_TOGGLE         "persist.radio.data_no_toggle"
#define QCRIL_USE_SE_TABLE_ONLY               "persist.radio.use_se_table_only"
#define QCRIL_DFR_MODE_PREF_SET_UNTIL_ONLINE  "persist.radio.dfr_mode_set"
#define QCRIL_ERI_64_HOME                     "persist.radio.eri64_as_home"
#define QCRIL_DO_NOT_CONSIDER_MANAGED_ROAM    "persist.radio.no_cons_man_roam"
#define QCRIL_CSG_INFO_AVAILABLE              "persist.radio.csg_info_avlbl"
#define QCRIL_APM_MDM_NOT_PWDN                "persist.radio.apm_mdm_not_pwdn"

#define QMI_RIL_WAIT_FOR_PBM_IND                 "persist.radio.wait_for_pbm"
#define QMI_RIL_WAIT_FOR_PBM_IND_TIMER           "persist.radio.wait_for_pbm_time"
#define QMI_RIL_WAIT_FOR_PBM_IND_TIMER_DEFAULT   (90)

#define QMI_RIL_SIB16_SUPPORT                 "persist.radio.sib16_support"

#define QMI_RIL_FULL_LTE_BAND_PREF            "persist.radio.lte_full_band"
//like adb shell setprop persist.radio.lte_full_band 0x7ff5bdf3fff

#define QCRIL_CELL_INFO_RATE_SWEEP_LIMIT          "persist.radio.cinfo_sweep_limit"

#define QCRIL_IS_RAT_TLV_SUPPORTED            "is_rat_tlv_supported"
#define QCRIL_IS_RIL_VRTE_LEARNING_ENABLED    "is_ril_vrte_learning_enabled"

#define NAS_CELL_LOCATION_VALID(resp_ptr) \
   ((resp_ptr) && ((resp_ptr)->geran_info_valid || \
    (resp_ptr)->umts_info_valid || \
    (resp_ptr)->cdma_info_valid || \
    (resp_ptr)->lte_intra_valid || \
    (resp_ptr)->lte_inter_valid || \
    (resp_ptr)->lte_gsm_valid || \
    (resp_ptr)->lte_wcdma_valid || \
    (resp_ptr)->umts_cell_id_valid || \
    (resp_ptr)->wcdma_lte_valid))

#define NAS_CELL_ID_NOT_PRESENT USHRT_MAX

#define QCRIL_MS_TO_TIMEVAL( tvptr, ms ) \
    do { \
        (tvptr)->tv_sec = ms / 1000; \
        (tvptr)->tv_usec = (ms % 1000) * 1000000; \
    } while(0);

#define QCRIL_MCC_FROM_BCD_PLMN(plmn) \
  (((plmn)[0] & 0x0f) * 100 + ((plmn)[0] >> 4) * 10 + ((plmn)[1] & 0x0f))

#define QCRIL_MNC_FROM_BCD_PLMN(plmn) \
  (((plmn)[1] >> 4) == 0x0f) ? (((plmn)[2] & 0x0f) * 10 + ((plmn)[2] >> 4)) : \
  (((plmn)[1] >> 4) + ((plmn)[2] >> 4) * 10 + ((plmn)[2] & 0x0f) * 100)

/* Operator name  System Property */
#define QCRIL_OPERATOR_PROP              "persist.env.spec"
#define QCRIL_CT_OPERATOR_NAME           "ChinaTelecom"

typedef enum
{
  QMI_RIL_NAS_SUBSCRIPTION_DEACTIVATED = 0,        /* subscription deactivated at modem */
  QMI_RIL_NAS_SUBSCRIPTION_ACTIVATED = 1     /* subscription activated at modem */
}qcril_nas_subscription_status;

#define MCC_MNC_PCS_DIGIT_LEN   (6)
#define MCC_MNC_PCS_DIGIT_POS   (3)

#define NAS_REQUEST_CONCURRENCY_NUM (1)
#define NAS_REQUEST_PENDING_NUM (50)

#define QMI_RIL_NAS_ECIO_DELTA                               (10)
#define QMI_RIL_NAS_TDS_ECIO_DELTA                           (1)
#define QMI_RIL_NAS_RSSI_DELTA                               (50)
#define QMI_RIL_NAS_TDS_RSSI_DELTA                           (5)
#define QMI_RIL_NAS_SINR_DELTA                               (1)
#define QMI_RIL_NAS_SNR_DELTA                                (40)
#define QMI_RIL_NAS_RSRQ_DELTA                               (20)
#define QMI_RIL_NAS_RSRP_DELTA                               (60)
#define QMI_RIL_NAS_RSCP_DELTA                               (40)

#define QMI_DMS_IMEISV_MAX_VALUE                                             (99)

#define QMI_DMS_RADIO_POWER_MULTIPLE_RILD_MAX_RETRIES                        (10)
#define QMI_NAS_REJ_CAUSE_PLMN_NOT_ALLOWED                                  (13)
#define QMI_NAS_REJ_CAUSE_NO_SUITABLE_CELL_LA                               (15)

//Permanent Reg Rejection Causes
#define IMSI_UNKNOWN_IN_HLR                             0x02
#define ILLEGAL_MS                                      0x03
#define ILLEGAL_ME                                      0x06
#define GPRS_SERVICES_NOT_ALLOWED                       0x07
#define GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED 0x08
#define PLMN_NOT_ALLOWED                                0x0B
#define LA_NOT_ALLOWED                                  0x0C
#define NATIONAL_ROAMING_NOT_ALLOWED                    0x0D
#define GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN          0x0E
#define NO_SUITABLE_CELLS_IN_LA                         0x0F
#define CSG_NOT_AUTHORIZED                              0x19

/* Network Failure rejection cause */
#define QCRIL_REJECT_CAUSE_NETWORK_FAIL                 (0x11)

typedef enum
{
    QMI_RIL_NAS_NW_SELECT_NONE = 0,
    QMI_RIL_NAS_NW_SELECT_WAKING_UP,
    QMI_RIL_NAS_NW_SELECT_AWAKEN,
    QMI_RIL_NAS_NW_SELECT_SETTING_PREF,
    QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD,
    QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD,
    QMI_RIL_NAS_NW_SELECT_AWAITING_REG,
    QMI_RIL_NAS_NW_SELECT_CANCELLING_REQ,
    QMI_RIL_NAS_NW_SELECT_DONE,
    QMI_RIL_NAS_NW_SELECT_ROLLBACK
} qmi_ril_nas_nw_select_state_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN = 0,
    QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_WAITING,
    QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_DONE,
} qmi_ril_dms_radio_pwr_multiple_rild_radio_power_sync_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_REQUEST_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_REQUEST_BOOTUP_RADIO_POWER_OFF,
    QMI_RIL_DMS_RADIO_PWR_REQUEST_OTHER,
} qmi_ril_dms_radio_pwr_request_e_type;


typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_STATE_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_STATE_INITIALIZED,
    QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_CARD_STATUS,
    QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_CARD_STATUS,
    QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET,
    QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_OP_MODE,
    QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET,
    QMI_RIL_DMS_RADIO_PWR_STATE_DONE,
    QMI_RIL_DMS_RADIO_PWR_STATE_INITIATING_MULTIPLE_RILD_SYNC,
    QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_MULTIPLE_RILD_SYNC,
    QMI_RIL_DMS_RADIO_PWR_STATE_MULTIPLE_RILD_SYNC_DONE,
} qmi_ril_dms_radio_pwr_state_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM,
    QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD,
} qmi_ril_dms_radio_pwr_signal_cond_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_COMMAND_INITIATE = 0,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_TRIGGER_MODEM,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_TRIGGER_CARD,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_TIMEOUT,
    QMI_RIL_DMS_RADIO_PWR_COMMAND_COMPLETE
} qmi_ril_dms_radio_pwr_command_e_type;

typedef enum
{
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE = 0,
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE,
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NO_ACTION,
    QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE,
} qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION,
    QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON
} qmi_ril_embms_op_enable_transaction_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_NONE,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_INITIATE,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_CON,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_IND,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_DATA_CON,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT,
    QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT
} qmi_ril_embms_op_enable_transaction_command_e_type;

typedef enum
{
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND
} qmi_ril_embms_op_disable_transaction_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_NONE,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_INITIATE,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_CON,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_DATA_IND,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT,
    QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_HALT
} qmi_ril_embms_op_disable_transaction_command_e_type;

typedef enum
{
    QMI_RIL_EMBMS_IN_COVERAGE = 0,
    QMI_RIL_EMBMS_OUT_OF_COVERAGE,
    QMI_RIL_EMBMS_OUT_OF_COVERAGE_DUE_TO_UEMODE,
    QMI_RIL_EMBMS_OUT_OF_COVERAGE_E911,
} qmi_ril_embms_coverage_state_e_type;

typedef enum
{
    QMI_RIL_EMBMS_RESP_CODE_MIN = -1,
    QMI_RIL_EMBMS_SUCCESS = 0,
    QMI_RIL_EMBMS_ERROR_UNKNOWN = 1,
    QMI_RIL_EMBMS_RESP_CODE_MAX
} qmi_ril_embms_resp_code_e_type;

#define QMI_RIL_EMBMS_LOG_PACKET_ID_MIN (0x1757)
#define QMI_RIL_EMBMS_LOG_PACKET_ID_MAX (0x17D7)
#define QMI_RIL_EMBMS_MIN_SIB_MCC_MNC_PARSE_LEN 6 // byte stream like: mcc[0] = '0', we parse from 0] = '0'. This is at least 6 chars

#define QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION  ( QMI_RIL_RTE_WCDMA )

typedef enum
{
    QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE = 0,
    QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING
} qmi_ril_nas_restricted_details_state_e_type;

typedef enum
{
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_NONE = 0,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_RESET,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_REPOST,
    QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHANGE_REPOST
} qmi_ril_nas_restricted_details_event_e_type;

typedef enum
{
    QMI_RIL_NAS_DO_NOT_PREFER_SPN = 0,
    QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_NAME_ONLY,
    QMI_RIL_NAS_PREFER_SPN_FOR_NW_SCAN_ONLY,
    QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_AND_NW_SCAN,
    QMI_RIL_NAS_PREFER_MAX_VALUE
} qmi_ril_nas_spn_plmn_name_preference_e_type;


/* Index to MCC that is used for finding emergency number */
typedef enum {
    QCRIL_IMSI_MCC_MATCH_INDEX = 0,
    QCRIL_NW_MCC_MATCH_INDEX,
    QCRIL_MCC_MATCH_MAX
} qcril_mcc_match_index;

//radio power process handling
#define RADIO_POWER_LOCK() do { \
        QCRIL_LOG_INFO("LOCK RADIO_POWER_LOCK"); \
        pthread_mutex_lock(&nas_common_info.radio_pwr_mutex); \
    } while(0)

#define RADIO_POWER_UNLOCK() do { \
        QCRIL_LOG_INFO("UNLOCK RADIO_POWER_LOCK"); \
        pthread_mutex_unlock(&nas_common_info.radio_pwr_mutex); \
    }while(0)

#define RADIO_POWER_WAIT()      qcril_qmi_nas_radio_power_process_condition_wait_helper();
#define RADIO_POWER_SIGNAL()    pthread_cond_signal(&nas_common_info.radio_pwr_cond_var);

#define NAS_NW_SEL_LOCK() do { \
        QCRIL_LOG_INFO("LOCK NAS_NW_SEL_LOCK"); \
        pthread_mutex_lock(&nas_common_info.nw_sel_lock_mutex); \
    }while(0)

#define NAS_NW_SEL_UNLOCK() do { \
        QCRIL_LOG_INFO("UNLOCK NAS_NW_SEL_LOCK"); \
        pthread_mutex_unlock(&nas_common_info.nw_sel_lock_mutex); \
    }while(0)



// cache handling
#define NAS_CACHE_LOCK() do { \
        QCRIL_LOG_INFO("LOCK NAS_CACHE_LOCK"); \
        pthread_mutex_lock(&nas_common_info.cache_lock_mutex); \
    }while(0)

#define NAS_CACHE_UNLOCK() do { \
        QCRIL_LOG_INFO("UNLOCK NAS_CACHE_LOCK"); \
        pthread_mutex_unlock(&nas_common_info.cache_lock_mutex); \
    }while(0)

#define NAS_CACHE_STORE_ENTRY_ARR( placeholder, value )   {   if (value ## _valid) { \
                                                                                         if ( placeholder ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE;  }   \
                                                                                         placeholder = qcril_malloc( sizeof( * placeholder ) ); \
                                                                                         if ( placeholder ) { memcpy(placeholder, value, sizeof(* placeholder) );  placeholder ## _len = value ## _len; placeholder ## _valid = TRUE; } \
                                                                                   } \
                                                           }

#define NAS_CACHE_STORE_ENTRY( placeholder, value ) {   if (value ## _valid) { \
                                                                                         if ( placeholder ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE;  }   \
                                                                                         placeholder = qcril_malloc( sizeof( * placeholder ) ); \
                                                                                         if ( placeholder ) { memcpy(placeholder, & value, sizeof(* placeholder) ); placeholder ## _valid = TRUE; } \
                                                                             } \
                                                    }
#define NAS_CACHE_STORE_ENTRY_VALID_VAL( placeholder, value ) {   \
                                                                                         if ( placeholder ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE;  }   \
                                                                                         placeholder = qcril_malloc( sizeof( * placeholder ) ); \
                                                                                         if ( placeholder ) { memcpy(placeholder, & value, sizeof(* placeholder) ); placeholder ## _valid = TRUE;  } \
                                                              }


#define NAS_CACHE_IS_ENTRY_VALID( placeholder )                                          (placeholder ## _valid)
#define NAS_CACHE_IS_ENTRY_VALID_ARR( placeholder )                                          ( (placeholder ## _valid) && (NULL != placeholder) )

#define NAS_CACHE_INVALIDATE_ENTRY( placeholder )         { if ((placeholder ## _valid) && ( NULL != placeholder ) ) { qcril_free( placeholder ); placeholder = NULL;  placeholder ## _valid = FALSE; } }

#define NAS_CACHE_STORE_TINY_ENTRY( placeholder, value ) {   if (value ## _valid) { \
                                                                                          placeholder = value; placeholder ## _valid = TRUE;  \
                                                                             } \
                                                         }

#define NAS_CACHE_STORE_TINY_ENTRY_VAL( placeholder, value ) {  placeholder = value; placeholder ## _valid = TRUE;  }

#define NAS_CACHE_INVALIDATE_TINY_ENTRY( placeholder )         { if ( placeholder ## _valid  ) { placeholder ## _valid = FALSE; } }

typedef struct
{
    int                                cs_rejected;
    int                                ps_rejected;

    uint8_t                            cs_reject_cause;
    uint8_t                            ps_reject_cause;
    int                                cs_reject_cause_relayed;
    int                                ps_reject_cause_relayed;
    int                                cs_reject_cause_expired;
    int                                ps_reject_cause_expired;

    char                               org_mcc [NAS_MCC_MNC_MAX_V01];
    char                               org_mnc [NAS_MCC_MNC_MAX_V01];

    char                               data_org_mcc [NAS_MCC_MNC_MAX_V01];
    char                               data_org_mnc [NAS_MCC_MNC_MAX_V01];

    int                                cs_rejected_managed_roaming;

    int                                cs_rejected_assumed;

} qmi_ril_reg_reject_cached_summary_type;

typedef enum
{
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_EXPIRED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED,
  QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED
} qmi_ril_reg_reject_perception_event_e_type;

typedef struct
{
  qmi_ril_nw_reg_rte_kind_type rte_kind;
  qmi_ril_nw_reg_rte_type      rte;
} qmi_ril_reg_reject_tmr_expry_passover_type;

typedef struct
{
  int      valid;
  uint32_t registration_state;
  int      lac_valid;
  uint32_t lac;
  int      cid_valid;
  uint32_t cid;
  uint32_t data_radio_tech;
  uint32_t tac;
  int      tac_valid;
} qmi_ril_nw_reg_data_reg_snapshot_info_type;

typedef struct
{
  int32_t dbg_trace_id;

  /*  SIB Length */
  uint16_t current_size; /**< Current length (in bytes) of the interrogated serving cell SIB. */

  /*  SIB Sequence */
  uint8_t sequence; /**< Expected equence number for next QMI IND. */

  /*  SIB Buffer */
  qcril_binary_data_type bin_data;
} nas_srv_cell_sib_info_type;

struct nas_cached_info_type
{
  // ** from nas_operator_name_data_ind_msg_v01
  uint8_t service_provider_name_valid;
  nas_service_provider_name_type_v01 * service_provider_name;

  uint8_t operator_plmn_list_valid;
  uint32_t operator_plmn_list_len;
  struct { nas_operator_plmn_list_type_v01 arr[NAS_OPERATOR_PLMN_LIST_MAX_V01]; } * operator_plmn_list;

  uint8_t plmn_network_name_valid;
  uint32_t plmn_network_name_len;
  struct { nas_plmn_network_name_type_v01 arr[NAS_PLMN_NETWORK_NAME_LIST_MAX_V01]; } * plmn_network_name;

  uint8_t plmn_name_valid;
  struct { char data[NAS_PLMN_NAME_MAX_V01 + 1]; } * plmn_name;

  uint8_t nitz_information_valid;
  nas_plmn_network_name_type_v01 * nitz_information;

  uint8_t plmn_id_valid;
  nas_plmn_id_ext_type_v01 * plmn_id;

  uint8_t spn_valid;
  nas_spn_type_v01 * spn;

  uint8_t short_name_valid;
  nas_plmn_name_type_v01 * short_name;

  uint8_t long_name_valid;
  nas_plmn_name_type_v01 * long_name;

  // ** from nas_system_selection_preference_ind_msg_v01
  uint8_t emergency_mode_valid;
  uint8_t emergency_mode;

  uint8_t mode_pref_valid;
  uint16_t mode_pref;

  uint8_t acq_order_valid;
  uint32_t acq_order_len;
  struct { nas_radio_if_enum_v01 arr[NAS_ACQ_ORDER_LIST_MAX_V01]; } *acq_order;

  uint8_t prev_mode_pref_valid;
  uint16_t prev_mode_pref;

  uint8_t gw_acq_order_pref_valid;
  uint16_t gw_acq_order_pref;

  uint8_t band_pref_valid;
  uint64_t band_pref;

  uint8_t prl_pref_valid;
  uint16_t prl_pref;

  uint8_t roam_pref_valid;
  uint16_t roam_pref;

  uint8_t lte_band_pref_valid;
  uint64_t lte_band_pref;

  uint8_t deferred_lte_band_pref_valid;
  uint64_t deferred_lte_band_pref;
  qcril_qmi_band_pref_e_type deferred_lte_band_pref_map;

  uint8_t net_sel_pref_valid;
  uint8_t net_sel_pref;


  uint8_t srv_domain_pref_valid;
  uint8_t srv_domain_pref;

  uint8_t lte_disable_cause_valid;
  nas_lte_disable_cause_enum_type_v01 lte_disable_cause;

  uint8_t rat_disabled_mask_valid;
  mode_pref_mask_type_v01 rat_disabled_mask;

  // ** from nas_serving_system_ind_msg_v01
  uint8_t serving_system_valid;
  nas_serving_system_type_v01 * serving_system;

  uint8_t roaming_indicator_valid;
  uint8_t roaming_indicator;

  uint8_t data_capabilities_valid;
  uint32_t data_capabilities_len;
  struct { nas_data_capabilites_enum_v01 arr[NAS_DATA_CAPABILITIES_LIST_MAX_V01]; } * data_capabilities;

  uint8_t current_plmn_valid;
  nas_plmn_type_v01 * current_plmn;

  uint8_t cdma_system_id_valid;
  nas_cdma_system_id_type_v01 * cdma_system_id;

  uint8_t cdma_base_station_info_valid;
  nas_cdma_base_station_info_type_v01 * cdma_base_station_info;

  uint8_t roaming_indicator_list_valid;
  uint32_t roaming_indicator_list_len;
  struct { nas_roaming_indicator_type_v01 arr[NAS_ROAMING_INDICATOR_LIST_MAX_V01]; } * roaming_indicator_list;

  uint8_t cdma_sys_id_valid;
  nas_cdma_system_id_type_v01 cdma_sys_id;

  uint8_t roam_status_valid;
  nas_roam_status_enum_type_v01 roam_status;
  uint8_t voice_roam_status_reported;

  uint8_t is_sys_prl_match_valid;
  uint8_t is_sys_prl_match;

  uint8_t def_roam_ind_valid;
  uint8_t def_roam_ind;

  uint8_t nas_3gpp_time_zone_valid;
  nas_3gpp_time_zone_type_v01 * nas_3gpp_time_zone;

  uint8_t p_rev_in_use_valid;
  uint8_t p_rev_in_use;

  uint8_t tac_valid;
  uint16_t tac;

  uint8_t call_barring_status_valid;
  nas_gw_sys_info3_type_v01 * call_barring_status;

  uint8_t umts_psc_valid;
  uint16_t umts_psc;

  uint8_t mnc_includes_pcs_digit_valid;
  nas_mnc_pcs_digit_include_status_type_v01 * mnc_includes_pcs_digit;

  uint8_t hs_call_status_valid;
  nas_hs_support_enum_type_v01 hs_call_status;


  // ** from nas_event_report_ind_msg_v01
  uint8_t rf_band_info_list_valid;
  uint32_t rf_band_info_list_len;
  struct { nas_rf_band_info_type_v01 arr[NAS_RADIO_IF_LIST_MAX_V01]; } * rf_band_info_list;

  uint8_t registration_reject_reason_valid;
  nas_registration_reject_reason_type_v01 * registration_reject_reason;

  uint8_t signal_strength_list_valid;
  uint32_t signal_strength_list_len;
  struct { nas_signal_strength_list_type_v01 arr[NAS_SIG_STRENGTH_LIST_MAX_V01]; } * signal_strength_list;

  uint8_t rssi_valid;
  uint32_t rssi_len;
  struct { nas_rssi_type_v01 arr[NAS_RSSI_LIST_MAX_V01]; } * rssi;

  uint8_t ecio_valid;
  uint32_t ecio_len;
  struct { nas_ecio_type_v01 arr[NAS_ECIO_LIST_MAX_V01]; } * ecio;

  uint8_t io_valid;
  int32_t io;

  uint8_t sinr_valid;
  uint8_t sinr;

  uint8_t error_rate_valid;
  uint32_t error_rate_len;
  struct { nas_error_rate_type_v01 arr[NAS_ERROR_RATE_LIST_MAX_V01]; } * error_rate;

  uint8_t rsrq_valid;
  nas_rsrq_type_v01 * rsrq;

  uint8_t lac_valid;
  uint16_t lac;

  uint8_t cell_id_valid;
  uint32_t cell_id;

  uint8_t ccs_valid;
  uint8_t ccs;

  uint8_t prl_ind_valid;
  uint8_t prl_ind;

  uint8_t detailed_service_info_valid;
  nas_ss_detailed_service_info_type_v01 * detailed_service_info;

  uint8_t cdma_system_id_ext_valid;
  nas_cdma_system_id_ext_type_v01 cdma_system_id_ext;

  uint8_t hdr_personality_valid;
  nas_hdr_personality_enum_v01 hdr_personality;

  uint8_t dsds_standby_pref_valid;
  nas_standby_pref_type_v01 dsds_standby_pref;

  uint8_t dsds_is_priority_subs_valid;
  nas_is_priority_subs_enum_v01 dsds_is_priority_subs;

  uint8_t dsds_is_active_valid;
  nas_active_subs_info_enum_v01 dsds_is_active;

  uint8_t voice_system_id_valid;
  uint32 voice_system_id;

  uint8_t cdma_srv_status_info_valid;
  nas_3gpp2_srv_status_info_type_v01 * cdma_srv_status_info;

  uint8_t hdr_srv_status_info_valid;
  nas_3gpp2_srv_status_info_type_v01 * hdr_srv_status_info;

  uint8_t gsm_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * gsm_srv_status_info;

  uint8_t wcdma_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * wcdma_srv_status_info;

  uint8_t tdscdma_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * tdscdma_srv_status_info;


  uint8_t lte_srv_status_info_valid;
  nas_3gpp_srv_status_info_type_v01 * lte_srv_status_info;

  uint8_t cdma_sys_info_valid;
  nas_cdma_sys_info_type_v01 * cdma_sys_info;

  uint8_t hdr_sys_info_valid;
  nas_hdr_sys_info_type_v01 * hdr_sys_info;

  uint8_t gsm_sys_info_valid;
  nas_gsm_sys_info_type_v01 * gsm_sys_info;

  uint8_t wcdma_sys_info_valid;
  nas_wcdma_sys_info_type_v01 * wcdma_sys_info;

  uint8_t tdscdma_sys_info_valid;
  nas_tdscdma_sys_info_type_v01 * tdscdma_sys_info;

  uint8_t lte_sys_info_valid;
  nas_lte_sys_info_type_v01 * lte_sys_info;

  uint8_t cdma_sys_info2_valid;
  nas_cdma_sys_info2_type_v01 * cdma_sys_info2;

  uint8_t hdr_sys_info2_valid;
  nas_hdr_sys_info2_type_v01 * hdr_sys_info2;

  uint8_t gsm_sys_info2_valid;
  nas_gsm_sys_info2_type_v01 * gsm_sys_info2;

  uint8_t wcdma_sys_info2_valid;
  nas_wcdma_sys_info2_type_v01 * wcdma_sys_info2;

  uint8_t lte_sys_info2_valid;
  nas_lte_sys_info2_type_v01 * lte_sys_info2;

  uint8_t gsm_sys_info3_valid;
  nas_gw_sys_info3_type_v01 * gsm_sys_info3;

  uint8_t wcdma_sys_info3_valid;
  nas_gw_sys_info3_type_v01 * wcdma_sys_info3;

  uint8_t lte_cell_status_valid;
  nas_cell_access_status_e_type_v01 lte_cell_status;

  uint8_t voice_support_on_lte_valid;
  uint8_t voice_support_on_lte;

  uint8_t cdma_sig_info_valid;
  nas_common_sig_info_param_type_v01 *cdma_sig_info;

  uint8_t hdr_sig_info_valid;
  nas_hdr_sig_info_type_v01 *hdr_sig_info;

  uint8_t gsm_sig_info_valid;
  int8_t gsm_sig_info;

  uint8_t wcdma_sig_info_valid;
  nas_common_sig_info_param_type_v01 *wcdma_sig_info;

  uint8_t rscp_valid;
  int8_t rscp;

  uint8_t lte_sig_info_valid;
  nas_lte_sig_info_type_v01 *lte_sig_info;

  uint8_t gsm_bit_err_rate_valid;
  uint8_t gsm_bit_err_rate;

  uint8_t wcdma_block_err_rate_valid;
  uint8_t wcdma_block_err_rate;

  uint8_t tdscdma_block_err_rate_valid;
  uint8_t tdscdma_block_err_rate;

  uint8_t lte_sib16_acquired_valid;
  uint8_t lte_sib16_acquired;
  uint8_t sntp_available_valid;
  uint8_t sntp_available;
  uint8_t day_light_saving_valid;
  uint8_t day_light_saving;
  uint8_t leap_seconds_valid;
  int8_t  leap_seconds;
  uint8_t local_time_offset_valid;
  int8_t  local_time_offset;

  char  * persistent_cached_nitz_op_name_long;
  char  * persistent_cached_nitz_op_name_short;
  char persistent_cached_mobile_country_code[NAS_MCC_MNC_MAX_SIZE];
  char persistent_cached_mobile_network_code[NAS_MCC_MNC_MAX_SIZE];

  qmi_ril_emergency_callback_mode_state_type eme_cbm;

  // handle sending unsol ecbm
  boolean nas_enter_ecbm_propagation_pending;
  boolean eme_call_end_recently;
  boolean is_eme_ip_call;
  uint32  eme_call_end_recently_tcb_id;

  // only applicable when sys_info supported
  qmi_ril_nw_reg_rte_type voice_rte;
  qmi_ril_nw_reg_rte_type data_rte;
  qmi_ril_nw_reg_rte_type ims_rte;

  // nw select tracking
  qmi_ril_nas_nw_select_state_e_type nw_select_state;
  qmi_client_type                    nw_select_nas_client;
  uint32                             nw_select_timeout_watch;
  uint32                             nw_select_limited_timeout_watch;
  int                                nw_select_nw_reg_received;
  RIL_Errno                          nw_select_nw_reg_result;
  int                                nw_select_nw_set_pref_ackd;
  RIL_Errno                          nw_select_nw_set_pref_result;
  int nw_select_is_manual;
  char nw_select_manual_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char nw_select_manual_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  int nw_select_is_current;
  int nw_select_is_modem_sel_pref_auto;

  // initial attach request state
  qmi_ril_nas_init_apn_attch_state_e_type init_attch_state;
  uint32                                  init_attch_timeout_watch;

  // reg reject tracking
  qmi_ril_reg_reject_cached_summary_type reg_reject_sys_info [QMI_RIL_RTE_CAP];
  qmi_ril_reg_reject_cached_summary_type reg_reject_legacy;
  uint32                                 reg_reject_expiry_tmr_id[ QMI_RIL_RTE_KIND_CAP ];
  uint8_t managed_roaming_radio_if_valid;
  nas_radio_if_enum_v01 managed_roaming_radio_if;



  // PRL version change relaying support
  uint16_t                           prl_version;
  int                                prl_version_is_set;

  // IMS registration
  int                                is_registered_on_ims;

  // eMBMS
  uint8_t                            embms_enabled;
  uint8_t                            embms_ssr_in_progress;
  uint8_t                            embms_enable_success_sent_to_atel;
  uint8_t                            embms_cell_id_sent_after_enabled;
  uint8_t                            embms_coverage_sent_after_enabled;

  qmi_ril_embms_op_enable_transaction_state_e_type
                                     embms_enable_txn_state;
  qmi_ril_embms_op_disable_transaction_state_e_type
                                     embms_disable_txn_state;
  uint32                             embms_enable_timeout_timerid;
  uint32                             embms_disable_timeout_timerid;
  uint8_t                            embms_disable_resp_call_id;

  uint8_t                            lte_embms_coverage_valid;
  uint8_t                            lte_embms_coverage;

  uint8_t                            embms_coverage_status_valid;
  nas_lte_rrc_embms_coverage_status_enum_v01
                                     embms_coverage_status;

  int32_t                            embms_enable_dbg_trace_id;
  int32_t                            embms_disable_dbg_trace_id;

  uint8_t                            is_embms_available;

  uint8_t sim_rej_info_valid;
  nas_sim_rej_info_enum_type_v01 sim_rej_info;

  //voice radio tech reported to Telephony
  RIL_RadioTechnology          reported_voice_radio_tech;

  // is considered registared cache
  int                                is_considered_registered_cached_result_valid;
  int                                is_considered_registered_cached_result;

  /* cache is valid when is_considered_registered_cached_result_valid is valid */
  qmi_ril_nw_reg_rte_type            registered_cached_rtes[QMI_RIL_RTE_LAST];

  // is in service on technology cache
  int                                is_in_service_of_technology_cache_result_valid;
  int                                is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 + NAS_SELECTED_NETWORK_3GPP_V01 ];

  // rte change propagation expiry
  uint32                             rte_change_propagation_change_expiry;

  // data reg report snapshot (applicable for in service only)
  qmi_ril_nw_reg_data_reg_snapshot_info_type
                                     data_reg_report_snapshot;
  uint32                             data_reg_report_expiry;
  uint32                             extrapolation_ban_expiry;

  qmi_ril_nw_reg_rat_confidence_tag_type
                                     voice_rte_confidence_tag;
  qmi_ril_nw_reg_rat_confidence_tag_type
                                     data_rte_confidence_tag;
  qmi_ril_nw_reg_rat_confidence_tag_type
                                     ims_rte_confidence_tag;

  uint8_t                            centralized_eons_supported_valid;
  uint8_t                            centralized_eons_supported;

  qmi_ril_nas_restricted_details_state_e_type
                                     restricted_details_state;
  int                                cached_restricted_details;

  //Simultaneous Voice and Data Capability
  uint8_t simul_voice_and_data_capability_valid;
  dms_simul_voice_and_data_capability_mask_v01 simul_voice_and_data_capability;

  //Device feature mode
  uint8_t subs_device_feature_mode_valid;
  dms_device_subs_feature_mode_enum_v01 subs_device_feature_mode;

  //last considered Telephony data technology as part of VOICE_REGISTRATION_STATE handling
  uint8_t                            considered_data_technology_valid;
  int                                considered_data_technology;

  //last reported Telephony data technology through DATA_REGISTRATION_STATE
  uint8_t                            reported_data_technology_valid;
  int                                reported_data_technology;

  //last reported Telephony data registration status through DATA_REGISTRATION_STATE
  uint8_t                            reported_data_reg_status_valid;
  int                                reported_data_reg_status;

  //last reported Telephony pref data technology for DATA_REGISTRATION_STATE
  uint8_t                            reported_pref_data_technology_valid;
  qcril_arb_pref_data_tech_e_type    reported_pref_data_technology;

  // deferred mode pref
  int                                deferred_mode_pref_set_valid;
  int                                deferred_mode_pref_set_android_param;

  // deferred acq order
  uint8_t                            deferred_acq_order_valid;
  uint32_t                           deferred_acq_order_len;
  nas_radio_if_enum_v01              deferred_acq_order[NAS_ACQ_ORDER_LIST_MAX_V01];
  qcril_qmi_acq_order_e_type         deferred_acq_order_map;

  int                                data_reg_roaming_status_latest;
  int                                data_reg_roaming_status_latest_val;
  uint32                             data_reg_roaming_status_latest_expiry;

  // common ind subscription status
  int                                common_indications_is_subscribed;

  // emergency number added for designated country
  uint32         designated_number_added_for_designated_country_status;
  char           designated_number_mcc [QCRIL_MCC_MATCH_MAX][ NAS_MCC_MNC_MAX_V01 ];
  char           mcc_from_imsi_cache [ NAS_MCC_MNC_MAX_V01 ];
  char           mcc_from_device_reg [ NAS_MCC_MNC_MAX_V01 + 1];

  qmi_ril_nw_reg_rte_type sglte_current_eons_rte;

  nas_get_cell_location_info_resp_msg_v01      *cell_location_info;
  uint64_t cell_location_info_time;

  uint8_t wcdma_csg_info_valid;
  nas_csg_info_type_v01 *wcdma_csg_info;

  uint8_t lte_csg_info_valid;
  nas_csg_info_type_v01 *lte_csg_info;

  /*  LTE Voice Domain */
  uint8_t lte_voice_status_valid;
  nas_lte_voice_status_enum_type_v01 lte_voice_status;

  /*  LTE SMS Domain */
  uint8_t lte_sms_status_valid;
  nas_sms_status_enum_type_v01 lte_sms_status;

  uint32_t sys_sel_pref_tmr;
  uint8_t is_indication_received;

  /* serv cell sib info*/
  nas_srv_cell_sib_info_type sib_info;

  /* track if voice radio tech is calculated atleast once */
  uint8_t is_calculated_vrte_used;
};

#ifndef QMI_RIL_UTF
typedef struct
{
  log_hdr_type hdr;
  int8_t log_payload[LOG_PACKET_SIZE_MAX_V01];
} qcril_qmi_nas_embms_log_type;
#endif

#define  QMI_RIL_NWREG_INVALID_TUPLE_ID                                                                 (-1)

#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NONE                                                 ((uint32)0)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED             ((uint32)1 << 8)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED                   ((uint32)1 << 9)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED                                         ((uint32)1 << 10)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH                                       ((uint32)1 << 11)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH                                     ((uint32)1 << 12)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED                             ((uint32)1 << 13)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED                                       ((uint32)1 << 14)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH                                         ((uint32)1 << 15)


#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH_IDX_MASK                              ((uint32)0x00FF)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK                                ((uint32)0xFF000000)
#define  QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK_NUM_SHIFT                      (24)

struct nas_dms_cached_info_type
{
    // ** from dms_event_report_ind_msg_v01
    uint8_t operating_mode_valid;
    dms_operating_mode_enum_v01 operating_mode;

    uint8_t band_capability_valid;
    uint64_t band_capability;

    int card_shutdown_initiated;

    uint8_t max_subscriptions;
    uint8_t max_subscriptions_active;

    uint8_t current_sub_capability_valid;
    uint32_t current_sub_capability;

    uint8_t subs_voice_data_capability_valid;
    uint8_t subs_voice_data_capability;

    uint8_t max_active_data_subs_valid;
    uint8_t max_active_data_subs;
};

struct nas_evt_post_info_type
{
  void * ril_evt_payload;
  int    ril_evt_payload_len;
  int    ril_evt;
  int    engaged;
};

#define MAX_NOF_NAS_EVT_POST_REC       (4)

#define NAS_REG_STATE_RESP_MAX_ARR_SIZE (15)

typedef struct
{
  char *registration_info_array[ NAS_REG_STATE_RESP_MAX_ARR_SIZE ];
  char registration_state[ 3 ];
  char lac[ 7 ];
  char cid[ 11 ];
  char radio_tech[ 3 ];
  char base_id[ 6 ];
  char base_latitude[ 12 ];
  char base_longitude[ 12 ];
  char ccs[ 4 ];
  char prl_ind[ 4 ];
  char sid[ 6 ];
  char nid[ 6 ];
  char roam_status[ 4 ];
  char def_roam_ind[ 4 ];
  char reg_reject_cause[12];
  char primary_scrambling_code[12];
} qcril_qmi_nas_registration_state_resp_helper_type;

#define NAS_REG_DATA_STATE_RESP_MAX_ARR_SIZE (11)

#define NAS_REG_DATA_MAX_DATA_CALLS 20

typedef struct
{
  char *registration_info_array[ NAS_REG_DATA_STATE_RESP_MAX_ARR_SIZE ];
  char registration_state[ 3 ];
  char lac[ 7 ];
  char cid[ 11 ];
  char data_radio_tech[ 3 ];
  char registration_denied_cause[ 12 ];
  char max_data_call_no[12];
  char tac[ 7 ];          // "16-bit Tracking Area Code", hence 5 chars in dec plus null terminator, but keep 7 for consistency with lac
  char phys_cell_id[ 4 ]; // "0-503 Physical Cell Identifier", hence 3 chars in decimal representation plus null terminator
  char eci[ 10 ];         // "28-bit E-UTRAN Cell Identifier", hence 9 characters in decimal representation plus null terminator
  char csgid[ 10 ];       // "27-bit Closed Subscriber Group Identity",  hence 9 characters in decimal representation plus null terminator
  char tadv[ 3 ];         // "6-bit timing advance value", hence 2 digits plus null terminator
} qcril_qmi_nas_registration_data_state_resp_helper_type;

#define NAS_OPERATOR_RESP_MAX_ARR_SIZE (3)

#define NAS_OPERATOR_RESP_MAX_EONS_LEN (512)

#define NAS_OPERATOR_RESP_MAX_MCC_MNC_LEN (16) //length of MNC_MNC should be 5-7 characters. Extra space is a safeguard.

#define NAS_MCC_WILDCARD_ENTRY 0x33
#define NAS_MNC_WILDCARD_ENTRY 0x37
#define NAS_MCC_MNC_WILDCARD_ENTRY 0xFF
#define NAS_PLACEHOLDER_MCC_STR "123" //any 3 digit entry would suffice
#define NAS_PLACEHOLDER_MNC_STR "456" //any 3 digit entry would suffice

typedef struct
{
  char *operator_info_array[ NAS_OPERATOR_RESP_MAX_ARR_SIZE ];
  char long_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
  char short_eons[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
  char mcc_mnc_ascii[ NAS_OPERATOR_RESP_MAX_MCC_MNC_LEN ];
} qcril_qmi_operator_resp_helper_type;


#define NAS_NW_SCAN_RESP_ENTRY_SIZE     (5)

#define NAS_NW_SCAN_RESP_MCCMNC_SIZE    (12)

#define NAS_NW_SCAN_RESP_RAT_SIZE       (3)

typedef struct
{
    char *nw_scan_info_array[ NAS_NW_SCAN_RESP_ENTRY_SIZE * NAS_3GPP_NETWORK_INFO_LIST_MAX_V01 ];
    char long_eons [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
    char short_eons [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_OPERATOR_RESP_MAX_EONS_LEN ];
    char mccmnc_info [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_NW_SCAN_RESP_MCCMNC_SIZE ] ;
    char rat [ NAS_3GPP_NETWORK_INFO_LIST_MAX_V01] [ NAS_NW_SCAN_RESP_RAT_SIZE ] ;
} qcril_qmi_nw_scan_resp_helper_type;

typedef struct
{
  RIL_DcRtInfo *data_call_real_time_info_list_ptr [ QCRIL_DATA_MAX_CALL_RECORDS ];
  RIL_DcRtInfo data_call_real_time_info_list [ QCRIL_DATA_MAX_CALL_RECORDS ];
} qcril_qmi_nas_dc_rt_info_helper_type;


typedef struct
{
  int                      pwr_oprt_in_progress;                // Indicates whether the power down or up operation is in progress
  qcril_card_status_e_type status;                              // Card status
  int                      card_ever_present;
  char                     iccid[QMI_DMS_UIM_ID_MAX_V01 + 1];
  int                      iccid_len;
  int                      valid;
  char                     mcc[QCRIL_MCC_MNC_MAX_SIZE];
  char                     mnc[QCRIL_MCC_MNC_MAX_SIZE];
} qcril_qmi_nas_dms_card_info_type;

struct nas_dsds_runtime_info_type
{
    RIL_SelectUiccSub           cur_info;
    int                         is_tune_away;
    nas_standby_pref_enum_v01   standby_pref;
    nas_subs_type_enum_v01      paging_priority;
    nas_subs_type_enum_v01      default_voice_sub;
    nas_subs_type_enum_v01      default_data_sub;
    int                         valid;
    qcril_modem_stack_id_e_type modem_stack_id;
    qcril_instance_id_e_type    default_data_instance_id;
    int                         is_default_data_set;
    int                         is_lte_tune_away;
};

typedef struct
{
    boolean                         is_not_bootup_radio_power_on;
    boolean                         radio_power_process_pending;
    int                             apm_mdm_not_pwdn;
} qcril_qmi_modem_power_runtime_info_type;


typedef struct
{
    uint16_t cdma_ecio_delta;
    uint16_t cdma_rssi_delta;
    uint16_t gsm_rssi_delta;
    uint16_t hdr_ecio_delta;
    uint16_t hdr_rssi_delta;
    uint16_t hdr_sinr_delta;
    uint16_t lte_rsrp_delta;
    uint16_t lte_rsrq_delta;
    uint16_t lte_rssi_delta;
    uint16_t lte_snr_delta;
    uint16_t tdscdma_ecio_delta;
    uint16_t tdscdma_rscp_delta;
    uint16_t tdscdma_rssi_delta;
    uint16_t tdscdma_sinr_delta;
    uint16_t wcdma_ecio_delta;
    uint16_t wcdma_rssi_delta;
} qcril_qmi_sig_delta_info_type;



struct nas_common_runtime_info_type
{
    int location_updates_enabled;
    int is_screen_off;
    int apm_sim_not_pwdn;
    int no_wait_for_card;
    int add_power_save_enabled;
    int force_nw_search;
    int limit_sys_info_logic_change;
    int data_snapshot_feature_enabled;
    int data_snapshot_timer_value;
    int data_snapshot_timer_value_valid;
    int registered_sys_serv_ind;
    int fill_eons;
    int voice_support_on_lte;
    int voice_support_on_lte_valid;
    int use_se_table_only;
    int dfr_mode_pref_set_until_online;
    int data_dormancy_no_toggle;
    int data_dormancy_ind_enabled;
    int data_limited_sys_ind_toggle;
    int always_report_restricted_state;
    int get_mode_pref_from_nv_10;
    qmi_ril_nas_spn_plmn_name_preference_e_type prefer_spn_over_plmn_name;
    boolean                                     always_send_plmn_name;

    int process_duplicate_nw_scan_names;
    int csg_info_available;
    int roam_mtu_size_1x;

    int ignore_srv_domain_camped_timer;
    int ignore_srv_domain_camped_timer_id_valid;
    uint32 ignore_srv_domain_camped_timer_id;
    int prev_srv_domain_valid;
    nas_service_domain_enum_type_v01 prev_srv_domain;

    int sglte_eons_is_domain_cs;
    int sglte_eons_is_roam_enabled;
    int sglte_eons_is_set;
    int consider_lte_ltd_srv_vrte_update;
    int consider_3gpp_ltd_srv_drte_update;
    int do_not_consider_managed_roam;
    int is_restore_prev_mode_pref;

    int is_rat_tlv_supported;

    int wait_for_pbm_ind;
    int wait_for_pbm_ind_timer;
    int wait_for_pbm_ind_timer_id_valid;
    uint32 wait_for_pbm_ind_timer_id;

    uint8 permanent_lte_band_pref_valid;
    uint64_t permanent_lte_band_pref;

    int is_reg_denied_on_rej_cause;

    int manual_nw_reject_cause_counter_enabled;
    int manual_nw_reject_cause_counter;

    int sib16_support;

    int prov_emer_call_in_lpm;
    int relay_oprt_change;

    int eri_64_home;

    int ct_operator_name;

    qcril_qmi_nas_dms_card_info_type card_info[ QMI_UIM_MAX_CARD_COUNT ];
    struct nas_dsds_runtime_info_type dsds;

    pthread_mutex_t     cache_lock_mutex;
    pthread_mutexattr_t cache_lock_mtx_atr;

    pthread_mutex_t     nw_sel_lock_mutex;
    pthread_mutexattr_t nw_sel_lock_mtx_atr;

    // radio power tracking
    qmi_ril_dms_radio_pwr_request_e_type        radio_power_request_type;
    qmi_ril_dms_radio_pwr_cancel_e_type         radio_power_cancel_type;
    boolean                                     is_radio_power_check_enabled;
    pthread_mutex_t                             radio_pwr_mutex;
    pthread_mutexattr_t                         radio_pwr_mutex_atr;
    pthread_cond_t                              radio_pwr_cond_var;
    qmi_ril_dms_radio_pwr_signal_cond_e_type    radio_pwr_signal_cond;
    qmi_ril_dms_radio_pwr_multiple_rild_radio_power_sync_e_type  radio_power_sync_type;
    int                                         radio_power_multiple_rild_process_complete_num;
    int                                         radio_power_multiple_rild_process_timer_valid;
    uint32                                      radio_power_multiple_rild_process_timer;
    qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type radio_pwr_prov_emer_call_lpm_state;
    dms_operating_mode_enum_v01                 radio_pwr_prov_emer_call_desired_modem_operating_mode;

    qcril_data_hndl_t nas_data_control_handle;

    int custom_emergency_numbers_enabled;
    char *custom_hardcoded_emergency_numbers_list;
    int custom_emergency_numbers_enabled_for_nw;
    int unsol_cell_info_rate; // Value set by telephony for minimum period between updates

    int unsol_cell_info_rate_sweep_limit; // Maximum timer value between polls for cell info
                                          // Should be high enough to give good battery performance,
                                          // yet low enough to alow enough location updates.
                                          // If this is less than or equal to unsol_cell_info_rate,
                                          // No exponential backoff happens.
    int unsol_cell_info_current_rate; // Current timer value for polling.
    boolean cell_info_poll_timer_id_valid;                      // Timer id of currently scheduled poll
    uint32 cell_info_poll_timer_id;                      // Timer id of currently scheduled poll
    qcril_qmi_modem_power_runtime_info_type modem_power_info;

    mode_pref_mask_type_v01 rat_disabled_mask_during_on_demand_attach;
    
    /* rtre config info */
    nas_rtre_cfg_enum_v01  nas_rtre_cfg;

    /* is voice radio tech learning enabled */
    uint8_t is_ril_vrte_learning_enabled;

    // sig config info
    qcril_qmi_sig_delta_info_type sig_config;
};

enum
{
  NAS_CDMA_SUBSCRIPTION_INFO_MDN = 0,
  NAS_CDMA_SUBSCRIPTION_INFO_H_SID,
  NAS_CDMA_SUBSCRIPTION_INFO_H_NID,
  NAS_CDMA_SUBSCRIPTION_INFO_MIN,
  NAS_CDMA_SUBSCRIPTION_INFO_PRL_VER,
  NAS_CDMA_SUBSCRIPTION_INFO_MAX
};


#define NAS_SID_NID_ELEMENT_MAX_SIZE ( 6 )
#define NAS_SID_NID_STR_MAX_SIZE     ( NAS_SID_NID_ELEMENT_MAX_SIZE * 20 + 1 )
#define NAS_MIN_S_STR_MAX_SIZE       ( 11 )
#define NAS_NEIGHBOR_LIST_MAX_SIZE   ( 64 )
#define NAS_PRL_VERSION_MAX_SIZE     ( 7 )
#define NAS_CID_ASCII_MAX_LEN        ( 9 )
#define NAS_MDN_STR_MAX_SIZE         ( MDN_MAX_LEN_V01 + 1)

typedef struct
{
  char *cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_MAX ];
  char mob_dir_number[ NAS_MDN_STR_MAX_SIZE ];
  char home_sid[ NAS_SID_NID_STR_MAX_SIZE ];
  char home_nid[ NAS_SID_NID_STR_MAX_SIZE ];
  char min_s[ NAS_IMSI_MIN1_LEN_V01 + NAS_IMSI_MIN2_LEN_V01 + 1 ];
  char prl_version[ NAS_PRL_VERSION_MAX_SIZE ];
} qcril_nas_cdma_subscription_type;

typedef struct
{
    RIL_NeighboringCell *neighbor_cell_list[NAS_NEIGHBOR_LIST_MAX_SIZE];
    RIL_NeighboringCell neighbor_cell[NAS_NEIGHBOR_LIST_MAX_SIZE];
    char cid[ NAS_NEIGHBOR_LIST_MAX_SIZE ][ NAS_CID_ASCII_MAX_LEN ];
} qcril_nas_neighboring_cell_type;

enum
{
  NAS_DMS_DEVICE_ID_IMEI,
  NAS_DMS_DEVICE_ID_IMEISV,
  NAS_DMS_DEVICE_ID_ESN,
  NAS_DMS_DEVICE_ID_MEID,
  NAS_DMS_DEVICE_ID_MAX
};

#define NAS_DMS_IMEI_MAX_STR_SIZE         (17)
#define NAS_DMS_IMEISV_MAX_STR_SIZE         (3)
#define NAS_DMS_ESN_MAX_STR_SIZE          (9)
#define NAS_DMS_MEID_MAX_STR_SIZE         (15)

typedef struct
{
  char *device_identity[ NAS_DMS_DEVICE_ID_MAX ];
  char imei[ NAS_DMS_IMEI_MAX_STR_SIZE ];
  char imeisv[ NAS_DMS_IMEISV_MAX_STR_SIZE ];
  char esn[ NAS_DMS_ESN_MAX_STR_SIZE ];
  char meid[ NAS_DMS_MEID_MAX_STR_SIZE ];
} qcril_nas_dms_device_identity_type;

typedef void (*qcril_qmi_cb_func_ptr) ( RIL_Errno resp_res );

typedef struct
{
    qcril_provision_info_type provision_info;
    int                       repost_event_id;
} qcril_nas_dsds_activate_repost_params;

typedef struct
{
    int is_reject_case;
    int reject_cause;
    int is_managed_roaming;
} qcril_qmi_nas_srv_status_convertion_extra_results_type;

#define NAS_SYS_INFO_IS_EMPTY                           ( (uint32_t) 0 )
#define NAS_SYS_INFO_IS_3GPP                            ( (uint32_t) 1 << 0 )
#define NAS_SYS_INFO_IS_DATA                            ( (uint32_t) 1 << 1 )
#define NAS_SYS_INFO_IS_HDR                             ( (uint32_t) 1 << 2 )
#define NAS_SYS_INFO_IS_LTE                             ( (uint32_t) 1 << 3 )

#define NAS_RADIO_POWER_REQUEST_NAME_OFFSET                 ( 1 )
#define NAS_DMS_OP_MODE_START                               ( DMS_OP_MODE_ONLINE_V01 )
#define NAS_DMS_OP_MODE_END                                 ( DMS_OP_MODE_MODE_ONLY_LOW_POWER_V01 )

#define NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_1_1900_IN_MILLI_SEC   (-2208988800000)
#define NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_6_1980_IN_MILLI_SEC   (315964800000)

#define NAS_SET_BIT( flag_variable, value)              flag_variable |= value;
#define NAS_IS_BIT_SET( flag_variable, value)           ((flag_variable & value)? TRUE: FALSE)

typedef struct
{
  nas_3gpp2_srv_status_info_type_v01 * threegpp2_srv_status;
  nas_3gpp_srv_status_info_type_v01 * threegpp_srv_status;
  nas_common_sys_info_type_v01 * common_sys_info;
  nas_cdma_hdr_only_sys_info_type_v01 * cdma_hdr_only_sys_info;
  nas_cdma_only_sys_info_type_v01 * cdma_only_sys_info;
  nas_hdr_only_sys_info_type_v01 * hdr_only_sys_info;
  nas_3gpp_only_sys_info_type_v01 * threegpp_only_sys_info;
  nas_gsm_only_sys_info_type_v01 * gsm_only_sys_info;
  nas_wcdma_only_sys_info_type_v01 * wcdma_only_sys_info;
  nas_tdscdma_only_sys_info_type_v01 * tdscdma_only_sys_info;
  nas_lte_only_sys_info_type_v01 * lte_only_sys_info;
  uint8_t * voice_support_on_lte;
  qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results;
}nas_sys_info_helper_type;

typedef struct
{
    unsigned long     message_id;
    void *            payload;
    int               payload_len;
} qmi_ril_nw_reg_nw_select_passover_params_type;

static const char *qmi_ril_op_name_persist_store_prop_list_long[] =
                                            { QMI_RIL_OP_NAME_NITZ_LONS_0,
                                              QMI_RIL_OP_NAME_NITZ_LONS_1,
                                              QMI_RIL_OP_NAME_NITZ_LONS_2,
                                              QMI_RIL_OP_NAME_NITZ_LONS_3 };

static const char *qmi_ril_op_name_persist_store_prop_list_short[] =
                                             { QMI_RIL_OP_NAME_NITZ_SONS_0,
                                               QMI_RIL_OP_NAME_NITZ_SONS_1,
                                               QMI_RIL_OP_NAME_NITZ_SONS_2,
                                               QMI_RIL_OP_NAME_NITZ_SONS_3 };

#define NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE                      (0xFF)

#define QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD 8
#define QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD 13

#define QCRIL_QMI_NAS_MAX_OPLMN_LIST 2503 // (500 * (3+2)) + 2 + 1

typedef struct {

  uint16_t mcc;
  /**<   A 16-bit integer representation of MCC. Range: 0 to 999.
  */

  uint16_t mnc;
  /**<   A 16-bit integer representation of MNC. Range: 0 to 999.
  */
  boolean mnc_includes_pcs_digit;

  nas_csg_list_cat_enum_v01 csg_list_cat;
  /**<   Closed subscriber group category. Values: \n
       - 0 -- NAS_CSG_LIST_CAT_UNKNOWN -- Unknown CSG list \n
       - 1 -- NAS_CSG_LIST_CAT_ALLOWED -- Allowed CSG list \n
       - 2 -- NAS_CSG_LIST_CAT_OPERATOR -- Operator CSG list
  */

  nas_csg_info_type_v01 csg_info;
  /**<   Closed subscriber group information.
  */
}qcril_qmi_nas_csg_nw_info_type;  /* Type */

typedef struct {

  uint16_t mcc;
  /**<   A 16-bit integer representation of MCC. Range: 0 to 999.
  */

  uint16_t mnc;
  /**<   A 16-bit integer representation of MNC. Range: 0 to 999.
  */

  boolean mnc_includes_pcs_digit;

  uint32_t csg_id;
  /**<   Closed subscriber group identifier.
  */

  int32_t signal_strength;
  /**<   Signal strength information in dBm.
  */
}qcril_qmi_nas_csg_nw_signal_strength_info_type;

typedef struct {
uint16_t mcc;
uint16_t mnc;
boolean mnc_includes_pcs_digit;
uint8_t network_status;
uint8_t plmn_rat_valid;
uint8_t plmn_rat;
}qcril_qmi_nas_nw_scan_info_helper_type;

#define NUM_OF_STRINGS_WITH_LEGACY_RAT                  5
#define NUM_OF_STRINGS_WITH_COMBINED_RAT_OR_NO_RAT      4

typedef struct {

  /* Mandatory */
  /*  Result Code */
  qmi_response_type_v01 resp;
  /**<   Standard response type.
 Standard response type. Contains the following data members:
     - qmi_result_type -- QMI_RESULT_SUCCESS or QMI_RESULT_FAILURE \n
     - qmi_error_type  -- Error code. Possible error code values are described in
                          the error codes section of each message definition.
  */

  /* 0x13 */
  /*  Network Scan Result */
  uint8_t scan_result_tag;  /**< Must be set to true if scan_result is being passed */
  uint16_t scan_result_len;
  uint32_t scan_result;

  /* 0x14+mnc_pcs_bit */
  /*  CSG Information */
  uint8_t csg_info_tag;  /**< Must be set to true if csg_info is being passed */
  uint16_t csg_info_total_len;  /**< Must be set to # of elements in csg_info */
  uint8_t csg_info_no_of_entries;
  qcril_qmi_nas_csg_nw_info_type csg_info[NAS_3GPP_NETWORK_INFO_LIST_MAX_V01];

  /* 0x15+mnc_pcs_bit */
  /*  CSG Signal Strength Information */
  uint8_t csg_sig_info_tag;  /**< Must be set to true if csg_sig_info is being passed */
  uint16_t csg_sig_info_total_len;  /**< Must be set to # of elements in csg_sig_info */
  uint8_t csg_sig_info_no_of_entries;
  qcril_qmi_nas_csg_nw_signal_strength_info_type csg_sig_info[NAS_3GPP_NETWORK_INFO_LIST_MAX_V01];
}qcril_qmi_nas_perform_network_scan_csg_resp_msg;

/* APN info input */
typedef struct
{
    int32   apn_type_len;

    /* null terminated string */
    char   *apn_type;

    int32   apn_name_len;

    /* null terminated string */
    char   *apn_name;

    /* confirms whether apn is removed */
    int32   is_apn_valid;
} qcril_qmi_oem_evt_hook_set_set_apn_info_type;

//===========================================================================

//                     GLOBALS

//===========================================================================

static struct nas_cached_info_type                  nas_cached_info;
static struct nas_dms_cached_info_type              nas_dms_cached_info;
static struct nas_common_runtime_info_type          nas_common_info;

static const char *card_status_name[] = { "UNKNOWN",
                                          "NOT APPLICABLE",
                                          "DOWN",
                                          "UP",
                                          "NOT ACCESSIBLE",
                                          "REFRESH",
                                          "PWR UP FAILED",
                                          "PWR DOWN FAILED",
                                          "ILLEGAL",
                                          "ABSENT" };

static const char *radio_power_request_name[] = { "NONE",
                                                  "BOOTUP_RADIO_POWER_OFF",
                                                  "OTHER" };

static const char *radio_power_cancel_name[] = { "NONE",
                                                 "SSR" };

static const char *radio_power_multiple_rild_sync_name[] = { "UNKNOWN",
                                                    "WAITING",
                                                    "DONE" };

static const char *radio_power_state_name[] = { "NONE",
                                                "INITIALIZED",
                                                "WAITING_FOR_CARD_STATUS",
                                                "SETTING_CARD_STATUS",
                                                "CARD_STATUS_SET",
                                                "SETTING_OP_MODE",
                                                "OP_MODE_SET",
                                                "DONE",
                                                "INITIATING_MULTIPLE_RILD_SYNC",
                                                "WAITING_FOR_MULTIPLE_RILD_SYNC",
                                                "MULTIPLE_RILD_SYNC_DONE"};

static const char *radio_power_command_name[] = { "INITIATE",
                                                  "TRIGGER_MODEM",
                                                  "TRIGGER_CARD",
                                                  "TIMEOUT",
                                                  "COMPLETE" };

static const char *restricted_details_state_name[] = { "NONE",
                                                       "INITIATE_CALCULATION",
                                                       "CALCULATED",
                                                       "REPORT",
                                                       "DONE",
                                                       "DONE_WITH_CHANGE"
                                                      };

static const char *radio_power_telephony_request_name[] = { "UNKNOWN",
                                                            "LPM",
                                                            "ONLINE",
                                                            "OFF" };

static const char *dms_op_mode_name[] = { "ONLINE",
                                          "LPM",
                                          "FTM",
                                          "OFFLINE",
                                          "RESETTING",
                                          "SHUTTING_DOWN",
                                          "PERSISTENT_LPM",
                                          "MODE_ONLY_LPM" };

static const char *radio_tech_name[] =  { "UNKNOWN",
                                          "GPRS",
                                          "EDGE",
                                          "UMTS",
                                          "IS95A",
                                          "IS95B",
                                          "1xRTT",
                                          "EVDO_0",
                                          "EVDO_A",
                                          "HSDPA",
                                          "HSUPA",
                                          "HSPA",
                                          "EVDO_B",
                                          "EHRPD",
                                          "LTE",
                                          "HSPAP",
                                          "GSM",
                                          "TDSCDMA",
                                          "IWLAN",
                                          "INVALID" };

static const char *pref_data_tech_name[] =  { "INVALID",
                                              "UNKNOWN",
                                              "CDMA",
                                              "EVDO",
                                              "GSM",
                                              "UMTS",
                                              "EHRPD",
                                              "LTE",
                                              "TDSCDMA",
                                              "MAX"};


static const qcril_arb_pref_data_tech_e_type qmi_ril_data_reg_tech_priorities[ QCRIL_ARB_PREF_DATA_TECH_MAX ] = { QCRIL_ARB_PREF_DATA_TECH_LTE,
                                                                                                                  QCRIL_ARB_PREF_DATA_TECH_EHRPD,
                                                                                                                  QCRIL_ARB_PREF_DATA_TECH_EVDO,
                                                                                                                  QCRIL_ARB_PREF_DATA_TECH_UMTS,
                                                                                                                  QCRIL_ARB_PREF_DATA_TECH_TDSCDMA,
                                                                                                                  QCRIL_ARB_PREF_DATA_TECH_CDMA,
                                                                                                                  QCRIL_ARB_PREF_DATA_TECH_GSM
                                                                                                                 };

typedef struct
{
  timer_t timer_id;
  qcril_instance_id_e_type instance_id;
  boolean timer_started;
  oem_hook_ftm_subscription_source_e_type subs_type;
}qcril_qmi_nas_get_engineer_mode_info_timer_type;

static qcril_qmi_nas_get_engineer_mode_info_timer_type qcril_qmi_nas_get_engineer_mode_info_timer;

//===========================================================================

//                                FUNCTIONS

//===========================================================================

//INLINE functions
static inline int qcril_qmi_nas_is_atel_rat_3gpp(RIL_RadioTechnology atel_rat);
static inline int qcril_qmi_nas_is_atel_rat_3gpp2(RIL_RadioTechnology atel_rat);
static inline RIL_RadioTechnology process_3gpp_radio_technology(RIL_RadioTechnology reported_radio_technology, uint16_t mode_pref);
static inline RIL_RadioTechnology process_3gpp2_radio_technology(RIL_RadioTechnology reported_radio_technology,uint16_t mode_pref);

static inline int qcril_qmi_nas_is_3gpp2_roaming(uint8_t reg_state_valid,
                                                 int reg_state,
                                                 uint8_t reg_tech_valid,
                                                 int reg_tech);


static int qcril_qmi_nas_event_report_ind_conv_qmi2ril(nas_event_report_ind_msg_v01* qmi_msg, int * network_state_updated, int * data_nw_state_updated);
static int qcril_qmi_nas_is_using_radio_if(uint8_t radio_if);
static int qcril_qmi_nas_is_using_rte(qmi_ril_nw_reg_rte_type rte, qmi_ril_nw_reg_rte_kind_type rte_kind);
static int qcril_qmi_nas_sig_info_ind_conv_qmi2ril(nas_sig_info_ind_msg_v01* qmi_msg);
static int qcril_qmi_nas_err_rate_ind_conv_qmi2ril(nas_err_rate_ind_msg_v01* qmi_msg);
static int qcril_qmi_nas_serving_system_ind_conv_qmi2ril(nas_serving_system_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated,
                                                  int * radio_tech_changed,
                                                  int * data_nw_state_changed
                                                );

static int qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril(nas_system_selection_preference_ind_msg_v01 * qmi_msg,
                                                  int * emergency_mode_entered,
                                                  int * emergency_mode_left
                                                );

static int qcril_qmi_nas_operator_name_data_ind_conv_qmi2ril(nas_operator_name_data_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated
                                                );

static int qcril_qmi_nas_current_plmn_name_ind_conv_qmi2ril(nas_current_plmn_name_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated
                                                );

static void qcril_qmi_nas_network_time_ind_conv_qmi2ril(nas_network_time_ind_msg_v01* ind_msg,
                                                        char *nitz_time_msg,
                                                        int *nitz_updated
                                                        );

static void qcril_qmi_nas_rtre_config_ind_conv_qmi2ril(nas_rtre_cfg_ind_msg_v01* ind_msg,
                                                        RIL_CdmaSubscriptionSource *sub_source,
                                                        int *sub_source_updated
                                                        );

static int qcril_qmi_nas_dms_event_report_qmi2ril(dms_event_report_ind_msg_v01 * qmi_msg,
                                                  int * radio_state_updated
                                                );


static int qcril_qmi_nas_signal_strength_con_conv_cache2ril(RIL_SignalStrength* ril_msg);
static void qcril_qmi_nas_set_subscription_source_generic
(
  const qcril_request_params_type *const params_ptr,
  int spc_present,
  qcril_request_return_type *const ret_ptr // Output parameter
);

/*static void qcril_qmi_nas_empty_command_cb
(
  qmi_client_type              user_handle,
  unsigned long                message_id,
  void                         *resp_c_struct,
  int                          resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
); */

static void qcril_qmi_nas_perform_network_scan_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
);

static void qcril_qmi_nas_get_neighboring_cells_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
);

static void qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
);

RIL_Errno qcril_qmi_nas_parse_csg_scan_oem_req(uint8 *oem_hook_data,nas_perform_network_scan_req_msg_v01 *filled_data,uint8 oem_data_len );

RIL_Errno qcril_qmi_nas_parse_csg_sys_selection_req(uint8 *oem_hook_data,nas_set_system_selection_preference_req_msg_v01 *filled_data,uint8 oem_data_len );

static void qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler(nas_system_selection_preference_ind_msg_v01* qmi_ind);

static int qcril_qmi_nas_util_calculate_neighbor_cell_rssi(int cell_value);
static void qcril_qmi_util_initiate_network_selection_check(const qcril_request_params_type *const params_ptr, int is_automatic, int mcc, int mnc, int move_on,int pcs_digit_present, RIL_RadioTechnology rat);
static RIL_Errno qcril_qmi_util_initiate_network_selection(const qcril_request_params_type *const params_ptr, int is_automatic, int mcc, int mnc, int move_on, int pcs_digit_present, RIL_RadioTechnology rat);
static void qcril_qmi_nas_restore_modem_pref();

static void qcril_qmi_nas_set_nw_selection_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
);

RIL_Errno qcril_qmi_util_enable_networking_indications( int enable, int force_update );

static void qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch
(
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_card_status_e_type card_status
);

static void qcril_qmi_nas_fill_up_operator_name( int is_current_nw,
                                                 char * mcc_str,
                                                 char * mnc_str,
                                                 char * mcc_mnc_str_ref,
                                                 char *long_ons_ptr,
                                                 size_t long_ons_ptr_size,
                                                 char *short_ons_ptr,
                                                 size_t short_ons_ptr_size
                                               );

static int qcril_qmi_nas_fill_up_3gpp2_operator_name( char * mcc_str,
                                                      char * mnc_str,
                                                      uint16_t sid,
                                                      uint16_t nid,
                                                      char *long_ons_ptr,
                                                      size_t long_ons_ptr_size,
                                                      char *short_ons_ptr,
                                                      size_t short_ons_ptr_size
                                                    );
static void qcril_qmi_nas_get_plmn_name_from_modem
(
  char *mcc_str,
  char *mnc_str,
  char *short_eons,
  char *long_eons,
  boolean use_static_table_only,
  boolean is_always_send_plmn_name,
  int  is_nw_scan,
  nas_radio_if_enum_v01 plmn_rat,
  uint8_t csg_id_valid,
  uint32_t csg_id
);

static void qcril_qmi_nas_dump_sign_strength_report(RIL_SignalStrength* ril_signal_strength);

static void qcril_qmi_nas_dms_update_common_modem_state();

static void qcril_qmi_voice_technology_updated();

static int qcril_qmi_nas_dms_card_status_reported();

static void qcril_qmi_nas_dms_update_multisim_config_property();

static int qcril_qmi_nas_is_in_service_of_technology(int technology);

static RIL_Errno qcril_qmi_nas_fetch_serving_system_info();

static qcril_subs_mode_pref qcril_qmi_nas_conv_nas_mode_pref_to_qcril(uint8_t info_valid,
                                                               uint16_t qmi_nas_mode_pref,
                                                               RIL_SelectUiccSub* master_request_ref );

static void qcril_qmi_nas_dsds_dual_standby_pref_ind_handler( nas_dual_standby_pref_ind_msg_v01* ind_msg );
static void qcril_qmi_nas_subscription_info_ind_handler( nas_subscription_info_ind_msg_v01* ind_msg );
static void qcril_qmi_nas_dsds_subscription_info_ind_handle_helper( nas_subscription_info_ind_msg_v01* ind_msg );

RIL_Errno qcril_qmi_nas_send_data_subscription_request();
static void qcril_qmi_nas_dsds_fillini_default_standby_pref(nas_standby_pref_enum_v01 standby_pref, nas_set_dual_standby_pref_req_msg_v01* req_msg);
static RIL_Errno qcril_qmi_nas_dsds_util_request_set_subscription_mode( nas_standby_pref_enum_v01 *standby_pref,
                                                                 nas_subs_type_enum_v01 * data_subs,
                                                                 nas_subs_type_enum_v01 *priority_subs,
                                                                 nas_subs_type_enum_v01 *voice_subs,
                                                                 qcril_qmi_cb_func_ptr  standby_pref_res_cb );

static void qcril_qmi_dsds_set_pref_ril_req_cb ( RIL_Errno resp_res );
static void qcril_qmi_nas_drop_nw_info_cache(void);
static RIL_Errno qcril_qmi_nas_dms_handle_modem_operating_mode(dms_operating_mode_enum_v01 requested_operating_mode,int * is_operating_mode_change_needed);
static RIL_Errno qcril_qmi_nas_dms_handle_card_status(qcril_evt_e_type uim_evt);
static void qcril_qmi_nas_radio_power_transaction_handler( int requested_telephony_power_state );

static int qcril_qmi_nas_is_considered_registered
(
    qmi_ril_nw_reg_rte_type *registered_rte
);

static RIL_Errno qcril_qmi_nas_fetch_signal_strength_observations(void);
static RIL_Errno qcril_qmi_nas_propagate_known_signal_strength_ind(void);
static void qcril_qmi_nas_initiate_propagate_known_signal_strength_ind(void);
static void qcril_qmi_nas_send_known_signal_strength(void);
static void qcril_qmi_nas_nitz_persistent_cache_update(void);
static IxErrnoType qcril_qmi_nas_persist_entry_update(char const * op_name_to_save, const char ** prop_name_prefix, int prop_name_prefix_domain_size, int prop_name_suffix );
static RIL_Errno qcril_qmi_nas_fetch_sys_info();
RIL_Errno qcril_qmi_nas_get_cell_location_data_sync( nas_get_cell_location_info_resp_msg_v01 *get_cell_location_info_resp, uint64_t *timestamp );
static void qcril_qmi_nas_queue_cell_info_poll();
void qcril_qmi_nas_cell_location_update_timer_cl( qmi_ril_cell_location_period_action action);

static int qcril_qmi_nas_is_ignore_nas_srv_domain(nas_service_status_enum_type_v01 nas_srv_status,
                                                  uint8_t srv_domain_valid,
                                                  nas_service_domain_enum_type_v01 srv_domain,
                                                  uint8_t *is_voice_supported_on_lte);
static void qcril_qmi_nas_start_srv_domain_camped_timer();
static void qcril_qmi_nas_cancel_srv_domain_camped_timer();
static void qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb(void * params);

static int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status( uint32_t nas_sys_info_flag, nas_sys_info_helper_type * nas_sys_info_helper );
static void qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info( int is_data,
                                                                     int * res,
                                                                     nas_reg_reject_info_type_v01 * reg_reject_info,
                                                                     qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results );
static int qcril_qmi_nas_sys_info_ind_conv_qmi2ril( nas_sys_info_ind_msg_v01 * qmi_msg,
                                            int * network_state_updated,
                                            int * radio_tech_changed,
                                            int * data_nw_state_changed
                                                );
static IxErrnoType qcril_qmi_nas_update_presist_nitz_cache_shadow(char * op_name_long, char * op_name_short, char * op_mcc_str, char * op_mnc_str);
static void qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow(void);
static void qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow(void);
static IxErrnoType qcril_qmi_nas_persist_entry_fetch_to_shadow(char * op_name_to_read, size_t op_name_to_read_size, const char ** prop_name_prefix, int prop_name_prefix_domain_size, int prop_name_suffix );
static int qcril_qmi_nas_nitz_persistent_cache_is_shadow_available(void);
static void qcril_qmi_nas_update_voice_rte(void);
static void qcril_qmi_nas_update_data_rte(void);
static void qcril_qmi_nas_update_ims_rte(void);
static void qcril_qmi_sys_info_roll_details(int * rte_reg_status,
                                            int is_data,
                                            qcril_qmi_nas_srv_status_convertion_extra_results_type* extra_results_vector_param);
static int qcril_qmi_nas_util_determine_cdma_rev(nas_cdma_only_sys_info_type_v01 * cdma_details_info);
static int qcril_qmi_nas_util_determine_hdr_rev(nas_hdr_only_sys_info_type_v01 * hdr_details_info);
static int qcril_qmi_util_determine_cdma_rev_direct( uint8_t p_rev );
static void qcril_qmi_nas_query_cur_power_state(int * op_mode_valid, dms_operating_mode_enum_v01 * op_mode);
static RIL_Errno qcril_qmi_nas_set_nw_select_state(qmi_ril_nas_nw_select_state_e_type new_state);
static qmi_ril_nas_nw_select_state_e_type qcril_qmi_nas_get_nw_select_state(void);
static void qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb
        (
          qmi_client_type                user_handle,
          unsigned int                   message_id,
          void                          *ind_buf,
          unsigned int                   ind_buf_len,
          void                          *ind_cb_data
        );
static void qcril_qmi_nas_nw_select_timeout_handler();
static void qcril_qmi_nas_nw_select_timeout_cb(void * params);
static void qcril_qmi_nas_nw_select_limited_timeout_cb(void * params);
static int qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(nas_common_network_id_type_v01 * reported_plmn);
static void qcril_qmi_nas_select_nw_conclusion_check(void);
static void qcril_qmi_nas_nw_select_total_cleanup(void);
void qcril_qmi_nas_initial_attach_timeout_handler(void *param);
qmi_ril_nas_init_apn_attch_state_e_type qcril_qmi_nas_get_init_attch_state();
static int qcril_qmi_nas_find_current_mcc_mnc
(
    char * mcc_str_ptr,
    char * mnc_str_ptr,
    int is_full_service_required,
    nas_radio_if_enum_v01 *plmn_rat
);

static void qcril_qmi_nas_evaluate_sglte_current_eons_rte();
static int qcril_qmi_nas_is_radio_if_plmn_available(uint8_t radio_if);
static void qmi_ril_nwr_update_reg_rej_from_sys_info(void);
static void qmi_ril_nwr_update_reg_rej_legacy(void);
static void qmi_ril_nwr_util_log_mccmnc_str(char * ctx, char *mcc_or_mnc_arr);
static int qmi_ril_nwr_conv_reg_reject_cause_voice(uint8_t org_cause, uint8_t radio_if);
static int qmi_ril_nwr_conv_reg_reject_cause_data(uint8_t org_cause, uint8_t radio_if);
static int qmi_ril_nwr_conv_reg_reject_cause_lte(uint8_t org_cause);
static int qmi_ril_nwr_is_mcc_or_mnc_empty(char * mcc_or_mnc_str);

static void qcril_qmi_nas_retranslate_cs_ps_bar_info_handler(void * param);
static void qcril_qmi_nas_managed_roaming_ind_handler(int * reg_report);
static void qcril_qmi_nas_fill_up_restricted_state_details(nas_gw_sys_info3_type_v01 * cs_gw_sys_info3,
                                                           nas_gw_sys_info3_type_v01 * ps_gw_sys_info3,
                                                           int * restricted_state_details);
static void qcril_qmi_nas_wave_voice_data_status();
static void qcril_qmi_nas_dms_op_state_update_handler(dms_operating_mode_enum_v01 new_op_state);
static RIL_Errno qcril_qmi_nas_radio_power_helper(RIL_Token params_token, int params_event_id,char * radio_req_val, qcril_instance_id_e_type  cur_instance);
static void qcril_qmi_nas_initiate_radio_power_process(void);
static IxErrnoType qcril_qmi_nas_radio_power_process_condition_wait_helper();
static void qmi_ril_process_oem_hook_shutdown(void * param);
static void qcril_qmi_nas_log_radio_power_process_state(int requested_telephony_power_state,qmi_ril_dms_radio_pwr_state_e_type cur_state);
static RIL_Errno qcril_qmi_nas_radio_power_handle_card_transition( int requested_telephony_power_state );
static RIL_Errno qcril_qmi_nas_radio_power_handle_modem_transition( int requested_telephony_power_state );
static void qcril_qmi_nas_card_status_translater(qcril_timed_callback_handler_params_type * handler_params);
static int qcril_qmi_nas_is_mcc_mnc_wildcard_entry(char *mcc, char *mnc);
static void qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper(char *mcc, char *mnc);
static void qcril_qmi_nas_fillup_mcc_mnc_helper(char *src_arr, char *dest_str);
static RIL_Errno qcril_qmi_nas_dms_fetch_cur_prl_version(uint16_t * prl_version);
static void qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed(void);
static void qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp();
static int qcril_qmi_nas_is_mcc_mnc_info_available();
static RIL_Errno qcril_qmi_nas_fetch_system_info_helper();
static nas_service_status_enum_type_v01 qcril_qmi_util_retrieve_srv_status(nas_sys_info_helper_type * nas_sys_info_helper, int is_3gpp);
static uint8 qcril_qmi_nas_is_voip_enabled();
static RIL_Errno qcril_qmi_nas_embms_fetch_embms_status();
static void qcril_qmi_nas_embms_txn_enable_act( qmi_ril_embms_op_enable_transaction_command_e_type command, RIL_Errno status, void* extra );
static void qcril_qmi_nas_embms_set_enable_timeout_handler_handler(void * param);
static void qcril_qmi_nas_embms_set_enable_cmd_cb
                                                    (
                                                      qmi_client_type              user_handle,
                                                      unsigned int                 message_id,
                                                      void                         *resp_c_struct,
                                                      unsigned int                 resp_c_struct_len,
                                                      void                         *resp_cb_data,
                                                      qmi_client_error_type        transp_err
                                                    );
static void qcril_qmi_nas_embms_embms_status_ind_handler(nas_embms_status_ind_msg_v01* status_ind);
static void qcril_qmi_nas_embms_embms_status_ind_handler_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_enable_data_con_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_txn_disable_act( qmi_ril_embms_op_disable_transaction_command_e_type command, RIL_Errno status, void* extra );
static void qcril_qmi_nas_embms_set_disable_cmd_cb
                                                    (
                                                      qmi_client_type              user_handle,
                                                      unsigned int                 message_id,
                                                      void                        *resp_c_struct,
                                                      unsigned int                 resp_c_struct_len,
                                                      void                        *resp_cb_data,
                                                      qmi_client_error_type        transp_err
                                                    );
static void qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_disable_data_ind_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void  qcril_qmi_nas_embms_set_disable_timeout_handler_handler(void * param);
static void qcril_qmi_nas_embms_enable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params);
static void qcril_qmi_nas_embms_disable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params);


static RIL_RadioTechnology qcril_qmi_get_voice_radio_technology();
static RIL_RadioTechnology qcril_qmi_convert_rte_to_radio_technology(qmi_ril_nw_reg_rte_type rte);
static int qcril_qmi_nas_fetch_mode_pref(mode_pref_mask_type_v01 *mode_pref);


static void qcril_qmi_dms_set_simo_cs_ps_property(dms_simul_voice_and_data_capability_mask_v01 simul_cap);
static void qcril_qmi_nas_set_eons_enabled_property(int is_centralized_eons_supported);

static void qcril_qmi_dms_save_prl_info(int prl_version_is_set, uint16_t prl_version);
static void qcril_qmi_nas_force_network_search();
static int qmi_ril_nwr_map_roam_status_from_qmi_to_android( nas_roam_status_enum_type_v01 qmi_roam_status );
static int qcril_qmi_nas_is_apm_enabled();
static void qcril_qmi_nas_update_radio_power_request_info();
static int qcril_qmi_nas_is_bootup_radio_power_off_request();
static void qcril_qmi_nas_handle_multiple_rild_radio_power_sync(int requested_telephony_power_state);
static void qcril_qmi_nas_multiple_rild_radio_power_timeout_cb(void * param);

static void qcril_qmi_nas_evaluate_voice_rte_propagation();
static void qcril_qmi_nas_data_control_cb (qcril_data_hndl_t         hndl,
                                           void                     *user_data,
                                           qcril_data_net_evt_t      evt,
                                           qcril_data_evt_payload_t *payload );
static void qcril_qmi_nas_data_control_register_for_call_activity();

static void qcril_qmi_nas_data_control_deregister_for_call_activity();

static void qcril_qmi_nas_report_eutra_status(nas_eutra_cell_status_enum_type_v01 * eutra_status);
static void qcril_qmi_nas_dms_handle_prl_change_helper();

static void qmi_ril_nwreg_rte_change_propagation_expired_handler(void * param);

static void qmi_ril_nw_reg_snapshot_dump_log( qmi_ril_nw_reg_rte_snapshot_type* snapshot );
static void qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler(void * param);
static void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler(void * param);
static void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler(void * param);
static void qmi_ril_nw_reg_update_sys_info_cache_from_ind( nas_sys_info_ind_msg_v01 * qmi_msg );
static void qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
static int qcril_qmi_nas_util_check_request_need(qcril_arb_pref_data_tech_e_type pref_data_tech, qmi_ril_nw_reg_rte_type drte);
static int qcril_qmi_nas_util_check_roaming_status(qcril_arb_pref_data_tech_e_type pref_data_tech, int * data_reg_status, int *confident_response );
static void qmi_ril_nw_reg_update_serving_system_cache_from_ind( nas_serving_system_ind_msg_v01 * qmi_msg );
static void qcril_qmi_nas_check_retrieve_centralized_eons_support_status();
static int qcril_qmi_nas_is_centralized_eons_supported();
static int qcril_qmi_util_prefer_spn_over_plmn_name(int is_spn_present, int is_plmn_name_present, int is_nw_scan);
static void qcril_qmi_util_handle_centralized_short_long_eons(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, int is_nw_scan, nas_radio_if_enum_v01 plmn_rat, uint8_t csg_id_valid, uint32_t csg_id);
static int qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, qcril_qmi_nw_scan_resp_helper_type * unique_network_scan_plmns_table, int no_of_unique_network_scan_plmns);
static void qcril_qmi_util_convert_3gpp2_mnc_to_ascii_mnc( char *mnc_3gpp2, uint8_t imsi_11_12);
static int qcril_qmi_ril_domestic_service_is_power_save_enabled();
static void qmi_ril_nw_reg_redo_reg_report(void * param);
static void qmi_ril_nw_reg_redo_data_reg_report(void * param);
static qmi_ril_nw_reg_rte_type qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(qcril_arb_pref_data_tech_e_type pref_data_tech);
static void qmi_ril_nw_reg_refresh_cache_main_thrd(void * param);
static int qcril_qmi_nas_is_data_nw_state_updated(nas_sys_info_ind_msg_v01 * qmi_msg);
static void qmi_ril_nw_reg_extend_pref_data_tech_cl( qcril_arb_pref_data_type * pref_data, int * is_extrapolation, int * extrapolation_is_roaming );
static void qcril_qmi_nas_restricted_state_handle_event( qmi_ril_nas_restricted_details_event_e_type event );
static void qcril_qmi_nas_calculate_restricted_details(int * restricted_details);
static void qcril_qmi_nas_report_restricted_details(int restricted_details);
static void qcril_qmi_nas_retranslate_cs_ps_bar_info_handler(void * param);

static void qmi_ril_nwr_reg_reject_init(void);
static void qmi_ril_nwr_reg_reject_tmr_expiry(qcril_timed_callback_handler_params_type * handler_params);
static void qmi_ril_nwr_reg_reject_post_refresher(qcril_timed_callback_handler_params_type * handler_params);
static void qmi_ril_nwr_reg_reject_handle_event_cl( qmi_ril_nw_reg_rte_kind_type rte_kind, qmi_ril_nw_reg_rte_type rte, qmi_ril_reg_reject_perception_event_e_type evt );
static void qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl( void );
static void qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl( void );
static void qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search_as_applicable_ncl( void );

static void qcril_qmi_nas_rf_band_info_ind_handler(nas_rf_band_info_ind_msg_v01* rf_band_info_ind);
static void qcril_qmi_nas_set_builtin_plmn_list_ind_handler(nas_set_builtin_plmn_list_ind_msg_v01 * plmn_list_ind);
static void qcril_qmi_nas_coex_control_process_rf_band_info
(
    qcril_coex_rf_band_info_type rf_band_info[QCRIL_COEX_RD_BAND_INFO_LENGTH],
    int                          rf_band_info_len
);

static int qmi_ril_nwreg_spawn_snapshot_timer_cl( int is_maintanance );

static void qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired(void * param);

static qmi_ril_embms_coverage_state_e_type qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(
        nas_lte_rrc_embms_coverage_status_enum_v01 qmi_embms_coverage);


static void qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(uint8_t prev_lte_embms_coverage_valid,
                    nas_lte_rrc_embms_coverage_status_enum_v01 prev_lte_embms_coverage);
static void qcril_qmi_nas_embms_send_cell_info_changed_if_needed(boolean prev_lte_sys_info_valid, const nas_lte_sys_info_type_v01* prev_lte_sys_info);
static void qcril_qmi_nas_embms_send_e911_state_changed_if_needed
(
    uint8_t new_mode_valid,
    uint8_t new_mode
);

static void qmi_ril_nw_reg_data_roaming_tmr_expired(void * param);

static void qmi_ril_nwreg_perform_dsds_specific_early_init();

void qcril_qmi_nas_get_subscription_info();
int qcril_qmi_dms_construct_modem_cap_response(uint8_t * resp_byte_stream);
void qcril_qmi_nas_send_unsol_modem_capability();
uint32_t qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();

static void qcril_qmi_nas_process_custom_emergency_numbers();
static void* qcril_qmi_nas_process_custom_emergency_numbers_helper(qmi_ril_custom_emergency_numbers_source_type source, int *number_of_tuples);
static void qcril_qmi_nas_cleanup_custom_emergency_numbers();
static int qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers
(
    char *number,
    char *mcc,
    qmi_ril_custom_emergency_numbers_source_type source
);

int qcril_qmi_nas_update_ril_ecclist(char *emergency_numbers);
static int qcril_qmi_nas_retrieve_number_of_tuples(char *emergency_list);
static char* qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value(char *property_prefix);
static void qcril_qmi_nas_cleanup_custom_emergency_numbers_helper(void * emergency_numbers, int is_cleanup_table, int *number_of_tuples);
static void qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc();
static void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card();
static void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw();

static int qcril_qmi_nas_retrieve_scan_network_type(nas_network_type_mask_type_v01 *scan_network_type);
static void qcril_qmi_nas_wait_for_pbm_ind_timeout_cb(void * params);
static void qcril_qmi_nas_eme_call_end_recently_timeout_cb(void * params);

static void qmi_ril_report_data_connection_information(void * param);
static int qmi_ril_retrieve_data_connection_information_from_data_call_list(int *nof_data_calls, qcril_qmi_nas_dc_rt_info_helper_type **data_call_real_time_info_list);

static void qcril_qmi_nas_fetch_sib16_network_time();
static void qcril_qmi_nas_process_sib16_network_time
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
);
static void qcril_qmi_nas_process_sib16_network_time_for_ats_utc
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
);
static void qcril_qmi_nas_process_sib16_network_time_for_ats_modem(uint64_t abs_time);

static void qcril_qmi_nas_sib16_network_time_ind_hdlr(const nas_lte_sib16_network_time_ind_msg_v01* decoded_payload);

static void qcril_qmi_nas_get_field_test_mode_info_for_cdma( struct cdma_ftm_data *cdma_data);
static void qcril_qmi_nas_get_field_test_mode_info_for_gsm( struct gsm_ftm_data *gsm_data);
static void qcril_qmi_nas_get_field_test_mode_info_for_wcdma( struct wcdma_ftm_data *wcdma_data);

static uint64_t qcril_qmi_nas_convert_julian_time_to_abs_time(uint16_t year, uint8_t month, uint8_t day,
                                                              uint8_t hour, uint8_t minute, uint8_t second, uint16_t milli_second);
void qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(uint8_t prev_lte_sib16_coverage_valid,
                                                       uint8_t prev_lte_sib16_coverage,
                                                       uint8_t curr_lte_sib16_coverage_valid,
                                                       uint8_t curr_lte_sib16_coverage);

void qcril_qmi_modem_power_process_regular_shutdown();

static void qcril_qmi_nas_data_update_mtu_size_if_needed(uint8_t prev_reported_state_valid,
                                                         int prev_reported_state,
                                                         uint8_t prev_reported_tech_valid,
                                                         int prev_reported_tech);

static void qcril_qmi_nas_perform_incremental_network_scan_ind_handler
(
    nas_perform_incremental_network_scan_ind_msg_v01 * nw_scan_ind
);

static void qcril_qmi_nas_get_serv_cell_sib_ind_handler
(
    nas_get_serv_cell_sib_ind_msg_v01 * serv_cell_sib_ind
);

static void qcril_qmi_nas_check_initial_attach_state
(
    uint8_t srv_domain_pref_valid,
    nas_srv_domain_pref_enum_type_v01 srv_domain_pref
);

static qmi_ril_nw_reg_rte_type qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name_info
(
    qmi_ril_nw_reg_rte_type  registered_rtes[QMI_RIL_RTE_LAST]
);

RIL_Errno qcril_qmi_nas_embms_parse_embms_plmn
(
   qcril_binary_data_type bin_data,
   int max_plmn_len,
   int *plmn_len,
   embms_plmn_type_v01 plmn[]
);

//===========================================================================
// qcril_qmi_nas_init
//===========================================================================
void qcril_qmi_nas_dms_commmon_pre_init()
{
    QCRIL_LOG_FUNC_ENTRY();
    pthread_mutexattr_init( &nas_common_info.cache_lock_mtx_atr );
    pthread_mutexattr_settype(&nas_common_info.cache_lock_mtx_atr, PTHREAD_MUTEX_RECURSIVE);

    pthread_mutex_init( &nas_common_info.cache_lock_mutex, &nas_common_info.cache_lock_mtx_atr );

    pthread_mutexattr_init( &nas_common_info.nw_sel_lock_mtx_atr );
    pthread_mutexattr_setpshared( &nas_common_info.nw_sel_lock_mtx_atr, PTHREAD_PROCESS_SHARED );

    pthread_mutex_init( &nas_common_info.nw_sel_lock_mutex, &nas_common_info.nw_sel_lock_mtx_atr );

    nas_cached_info.embms_ssr_in_progress = FALSE;

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_dms_commmon_post_init
//===========================================================================
void qcril_qmi_nas_dms_commmon_post_init()
{
    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_data_control_register_for_call_activity();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_dms_commmon_post_init

//===========================================================================
// qcril_qmi_nas_dms_commost_post_cleanup
//===========================================================================
void qcril_qmi_nas_dms_commost_post_cleanup()
{
    pthread_mutex_destroy( &nas_common_info.radio_pwr_mutex );
    pthread_mutexattr_destroy( &nas_common_info.radio_pwr_mutex_atr );
    pthread_cond_destroy( &nas_common_info.radio_pwr_cond_var );

    pthread_mutex_destroy( &nas_common_info.cache_lock_mutex );
    pthread_mutexattr_destroy( &nas_common_info.cache_lock_mtx_atr );

    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_update_iccid

===========================================================================*/
/*!
    @brief
    Function that reads the ICCID from the SIM Card

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_update_iccid
(
  int slot
)
{
  RIL_Errno rc;
  dms_uim_get_iccid_resp_msg_v01      get_iccid_resp;

  QCRIL_LOG_DEBUG("%s", __FUNCTION__);
  memset( &get_iccid_resp, 0, sizeof(get_iccid_resp) );
  rc = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                  QMI_DMS_UIM_GET_ICCID_REQ_V01,
                                                  NULL,
                                                  NAS_NIL,
                                                  &get_iccid_resp,
                                                  sizeof(get_iccid_resp),
                                                  QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

  if ((rc == RIL_E_SUCCESS) && (get_iccid_resp.resp.result == QMI_RESULT_SUCCESS_V01))
  {
    strlcpy(nas_common_info.card_info[slot].iccid, get_iccid_resp.uim_id, QMI_DMS_UIM_ID_MAX_V01 + 1);
    nas_common_info.card_info[slot].iccid_len = strlen(get_iccid_resp.uim_id);
  }
  else
  {
    QCRIL_LOG_ERROR("Error reading iccid for slot %d", slot);
  }
} /* qcril_qmi_nas_update_iccid */

//===========================================================================
// qcril_qmi_nas_init
//===========================================================================
void qcril_qmi_nas_init()
{
    int temp_len;
    unsigned long ret_val;
    uint64_t ret_value;
    char property_name[ 40 ];
    char args[ PROPERTY_VALUE_MAX ];
    char *end_ptr;

    int                         op_mode_valid;
    dms_operating_mode_enum_v01 op_mode;

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_query_cur_power_state( &op_mode, &op_mode_valid ); // need to have current oprt mode prior to qcril_qmi_util_enable_networking_indications() call

    NAS_CACHE_LOCK();
#ifdef QMI_RIL_UTF
    nas_common_info.is_screen_off = FALSE;
#endif
    nas_common_info.ct_operator_name = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_OPERATOR_PROP );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      nas_common_info.ct_operator_name = !strncmp( args, QCRIL_CT_OPERATOR_NAME, strlen( QCRIL_CT_OPERATOR_NAME ));
    }
    else
    {
      QCRIL_LOG_ERROR( "QCRIL_OPERATOR_NAME is %s,  property_name is %s. Failed to get operator name\n", QCRIL_OPERATOR_PROP, property_name );
    }
    QCRIL_LOG_DEBUG( "CT Operator name =%d", nas_common_info.ct_operator_name);

    nas_common_info.apm_sim_not_pwdn = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_APM_SIM_NOT_PWDN );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert APM_SIM_NOT_PWDN %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved APM_SIM_NOT_PWDN %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.apm_sim_not_pwdn = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "APM_SIM_NOT_PWDN=%d", nas_common_info.apm_sim_not_pwdn);

    nas_common_info.add_power_save_enabled = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ADD_POWER_SAVE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert ADD_POWER_SAVE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved ADD_POWER_SAVE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.add_power_save_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_INFO( "ADD_POWER_SAVE=%d", nas_common_info.add_power_save_enabled);

    nas_common_info.force_nw_search = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_FORCE_NW_SEARCH );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert FORCE_NW_SEARCH %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved FORCE_NW_SEARCH %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.force_nw_search = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "FORCE_NW_SEARCH=%d", nas_common_info.force_nw_search);

    nas_common_info.voice_support_on_lte       = NAS_NIL;
    nas_common_info.voice_support_on_lte_valid = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_VOICE_SUPPORT_ON_LTE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert VOICE_SUPPORT_ON_LTE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved VOICE_SUPPORT_ON_LTE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.voice_support_on_lte       = ( uint8 ) ret_val;
        nas_common_info.voice_support_on_lte_valid = TRUE;
      }
    }
    QCRIL_LOG_DEBUG( "VOICE_SUPPORT_ON_LTE=%d", nas_common_info.voice_support_on_lte);

    nas_common_info.always_report_restricted_state = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ALWAYS_REPORT_RESTRICTED_STATE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert QCRIL_ALWAYS_REPORT_RESTRICTED_STATE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved QCRIL_ALWAYS_REPORT_RESTRICTED_STATE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.always_report_restricted_state = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "QCRIL_ALWAYS_REPORT_RESTRICTED_STATE=%d", nas_common_info.always_report_restricted_state);

    nas_common_info.registered_sys_serv_ind = FALSE;

    nas_common_info.fill_eons = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_FILL_EONS );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert FILL_EONS %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved FILL_EONS %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.fill_eons = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "FILL_EONS=%d", nas_common_info.fill_eons);

    nas_common_info.limit_sys_info_logic_change = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_LIMIT_SYS_INFO );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert limit_sys_info %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid value %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.limit_sys_info_logic_change = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "limit_sys_info=%d", nas_common_info.limit_sys_info_logic_change);

    nas_common_info.no_wait_for_card = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_NO_WAIT_FOR_CARD );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert NO_WAIT_FOR_CARD %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved NO_WAIT_FOR_CARD %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.no_wait_for_card = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "NO_WAIT_FOR_CARD=%d", nas_common_info.no_wait_for_card);

    nas_common_info.data_snapshot_timer_value       = NAS_NIL;
    nas_common_info.data_snapshot_timer_value_valid = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SNAPSHOT_TIMER_VALUE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert SNAPSHOT_TIMER %s", args );
      }
      else
      {
        nas_common_info.data_snapshot_timer_value = ( uint8 ) ret_val;
        nas_common_info.data_snapshot_timer_value_valid = TRUE;
      }
    }
    QCRIL_LOG_DEBUG( "SNAPSHOT_TIMER=%d", nas_common_info.data_snapshot_timer_value);

    nas_common_info.data_snapshot_feature_enabled = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SNAPSHOT_FEATURE_ENABLED );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert SNAPSHOT_FEATURE_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved SNAPSHOT_FEATURE_ENABLED %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.data_snapshot_feature_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "SNAPSHOT_FEATURE_ENABLED=%d", nas_common_info.data_snapshot_feature_enabled);

    nas_common_info.data_dormancy_no_toggle = NAS_NIL;
    nas_common_info.data_limited_sys_ind_toggle = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_DATA_DORMANCY_NO_TOGGLE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert DATA_DORMANCY_NO_TOGGLE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved DATA_DORMANCY_NO_TOGGLE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.data_dormancy_no_toggle = ( uint8 ) ret_val;
        nas_common_info.data_limited_sys_ind_toggle = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "DATA_DORMANCY_NO_TOGGLE=%d, DATA_LIMITED_SYS_IND_TOGGLE=%d",
                     nas_common_info.data_dormancy_no_toggle, nas_common_info.data_limited_sys_ind_toggle);

    nas_common_info.use_se_table_only = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_USE_SE_TABLE_ONLY );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert USE_SE_TABLE_ONLY %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved USE_SE_TABLE_ONLY %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.use_se_table_only = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "USE_SE_TABLE_ONLY=%d", nas_common_info.use_se_table_only);

    nas_common_info.get_mode_pref_from_nv_10 = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_GET_MODE_PREF_FROM_NV_10 );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert GET_MODE_PREF_FROM_NV_10 %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved GET_MODE_PREF_FROM_NV_10 %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.get_mode_pref_from_nv_10 = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "GET_MODE_PREF_FROM_NV_10=%d", nas_common_info.get_mode_pref_from_nv_10);


    nas_common_info.custom_emergency_numbers_enabled = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_ENABLED );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert CUSTOM_EMERGENCY_NUMBERS_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CUSTOM_EMERGENCY_NUMBERS_ENABLED %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.custom_emergency_numbers_enabled = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CUSTOM_EMERGENCY_NUMBERS_ENABLED=%d", nas_common_info.custom_emergency_numbers_enabled );

    nas_common_info.eri_64_home = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_ERI_64_HOME );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert ERI_64_HOME %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved ERI_64_HOME %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.eri_64_home = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "ERI_64_HOME=%d", nas_common_info.eri_64_home);

    nas_common_info.prefer_spn_over_plmn_name = QMI_RIL_NAS_DO_NOT_PREFER_SPN;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_PREFER_SPN_OVER_PLMN_NAME );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert PREFER_SPN_OVER_PLMN_NAME %s", args );
      }
      else if ( ret_val >= QMI_RIL_NAS_PREFER_MAX_VALUE )
      {
        QCRIL_LOG_ERROR( "Invalid saved PREFER_SPN_OVER_PLMN_NAME %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.prefer_spn_over_plmn_name = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "PREFER_SPN_OVER_PLMN_NAME=%d", nas_common_info.prefer_spn_over_plmn_name );

    nas_common_info.always_send_plmn_name = FALSE;
    qmi_ril_get_property_value_from_boolean( QMI_RIL_ALWAYS_SEND_PLMN_NAME,
                                             (boolean *)&nas_common_info.always_send_plmn_name,
                                             FALSE );
    QCRIL_LOG_DEBUG( "ALWAYS SEND PLMN NAME=%d", nas_common_info.always_send_plmn_name);


    nas_common_info.process_duplicate_nw_scan_names = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_PROCESS_DUPLICATE_NW_SCAN_NAMES );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert PROCESS_DUPLICATE_NW_SCAN_NAMES %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved PROCESS_DUPLICATE_NW_SCAN_NAMES %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.process_duplicate_nw_scan_names = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "PROCESS_DUPLICATE_NW_SCAN_NAMES=%d", nas_common_info.process_duplicate_nw_scan_names );

    nas_common_info.sglte_eons_is_domain_cs = TRUE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SGLTE_EONS_PREF_DOMAIN_PROPERTY );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      if(!strcmp(args, "ps"))
      {
        nas_common_info.sglte_eons_is_domain_cs = FALSE;
      }
      nas_common_info.sglte_eons_is_set = TRUE;
    }
    QCRIL_LOG_DEBUG( "SGLTE_EONS_PREF_DOMAIN_PROPERTY=%d", nas_common_info.sglte_eons_is_domain_cs );

    nas_common_info.sglte_eons_is_roam_enabled = TRUE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SGLTE_EONS_PREF_ROAMING_PROPERTY );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      if(!strcmp(args, "false"))
      {
          nas_common_info.sglte_eons_is_roam_enabled = FALSE;
      }
      nas_common_info.sglte_eons_is_set = TRUE;
    }

    QCRIL_LOG_DEBUG( "SGLTE_EONS_PREF_ROAMING_PROPERTY=%d", nas_common_info.sglte_eons_is_roam_enabled );

    nas_common_info.prov_emer_call_in_lpm = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_PROVISION_EMERGENCY_CALL_IN_LPM );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert PROVISION_EMERGENCY_CALL_IN_LPM %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved PROVISION_EMERGENCY_CALL_IN_LPM %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.prov_emer_call_in_lpm = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "PROVISION_EMERGENCY_CALL_IN_LPM=%d", nas_common_info.prov_emer_call_in_lpm );

    nas_common_info.relay_oprt_change = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_RELAY_OPRT_CHANGE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
          QCRIL_LOG_ERROR( "Fail to convert RELAY_OPRT_CHANGE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved RELAY_OPRT_CHANGE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.relay_oprt_change = ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "RELAY_OPRT_CHANGE=%d", nas_common_info.relay_oprt_change );

    nas_common_info.consider_lte_ltd_srv_vrte_update = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CONSIDER_LTE_LTD_SRV_VRTE_UPDATE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert CONSIDER_LTE_LTD_SRV_VRTE_UPDATE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CONSIDER_LTE_LTD_SRV_VRTE_UPDATE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.consider_lte_ltd_srv_vrte_update = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CONSIDER_LTE_LTD_SRV_VRTE_UPDATE=%d", nas_common_info.consider_lte_ltd_srv_vrte_update);

    nas_common_info.consider_3gpp_ltd_srv_drte_update = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.consider_3gpp_ltd_srv_drte_update = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "CONSIDER_3GPP_LTD_SRV_DRTE_UPDATE=%d", nas_common_info.consider_3gpp_ltd_srv_drte_update);

    nas_common_info.do_not_consider_managed_roam = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_DO_NOT_CONSIDER_MANAGED_ROAM );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert DO_NOT_CONSIDER_MANAGED_ROAM %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved DO_NOT_CONSIDER_MANAGED_ROAM %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.do_not_consider_managed_roam = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "DO_NOT_CONSIDER_MANAGED_ROAM=%d", nas_common_info.do_not_consider_managed_roam);

    nas_common_info.wait_for_pbm_ind = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_WAIT_FOR_PBM_IND );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert WAIT_FOR_PBM_IND %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved WAIT_FOR_PBM_IND %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.wait_for_pbm_ind = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "WAIT_FOR_PBM_IND=%d", nas_common_info.wait_for_pbm_ind);

    nas_common_info.wait_for_pbm_ind_timer = QMI_RIL_WAIT_FOR_PBM_IND_TIMER_DEFAULT; //default timer value is 90 seconds
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_WAIT_FOR_PBM_IND_TIMER );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert WAIT_FOR_PBM_IND_TIMER %s", args );
      }
      else
      {
        nas_common_info.wait_for_pbm_ind_timer = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "WAIT_FOR_PBM_IND_TIMER=%d", nas_common_info.wait_for_pbm_ind_timer);

    nas_common_info.sib16_support = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_SIB16_SUPPORT );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert SIB16_SUPPORT %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved SIB16_SUPPORT %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.sib16_support = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "SIB16_SUPPORT=%d", nas_common_info.sib16_support);

    nas_common_info.permanent_lte_band_pref = NAS_NIL;
    nas_common_info.permanent_lte_band_pref_valid = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_FULL_LTE_BAND_PREF);
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_value = strtoull( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_value == ULLONG_MAX) )
      {
        QCRIL_LOG_ERROR( "Fail to convert lte_full_band_pref %s", args );
      }
      else
      {
        nas_common_info.permanent_lte_band_pref = ret_value;
        nas_common_info.permanent_lte_band_pref_valid = TRUE;
      }
    }
    QCRIL_LOG_DEBUG( "valid:%d lte_full_band_pref=%llx",
        nas_common_info.permanent_lte_band_pref_valid, nas_common_info.permanent_lte_band_pref);

    qmi_ril_get_property_value_from_integer(QCRIL_RESTORE_MODE_PREF_SUPPORT,
                                            &nas_common_info.is_restore_prev_mode_pref,
                                            NAS_NIL);
    QCRIL_LOG_DEBUG( "RESTORE_MODE_PREF_SUPPORT = %d",
                     nas_common_info.is_restore_prev_mode_pref);

    nas_common_info.location_updates_enabled        = TRUE;

    nas_cached_info.is_registered_on_ims = FALSE;

    nas_cached_info.voice_rte                       = QMI_RIL_RTE_NONE;
    nas_cached_info.data_rte                        = QMI_RIL_RTE_NONE;
    nas_cached_info.ims_rte                         = QMI_RIL_RTE_NONE;

    nas_common_info.unsol_cell_info_rate = INT_MAX;
    nas_common_info.unsol_cell_info_current_rate = nas_common_info.unsol_cell_info_rate;
    nas_common_info.cell_info_poll_timer_id = 0;
    nas_common_info.cell_info_poll_timer_id_valid = FALSE;

    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_CELL_INFO_RATE_SWEEP_LIMIT );
    property_get( property_name, args, "10000" );

    if ((strlen(args) > 0))
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Failed to convert CELL_INFO_RATE_SWEEP_LIMIT %s", args );
      }
      else if ( ret_val & 0x80000000 )
      {
        QCRIL_LOG_ERROR( "Invalid value for CELL_INFO_RATE_SWEEP_LIMIT: %s", args);
      }
      else
      {
        nas_common_info.unsol_cell_info_rate_sweep_limit = (int)ret_val;
        QCRIL_LOG_INFO("Cell Info Sweep limit: %d",
                nas_common_info.unsol_cell_info_rate_sweep_limit);
      }
    }

    nas_cached_info.voice_rte_confidence_tag        = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.data_rte_confidence_tag         = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.ims_rte_confidence_tag          = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.voice_roam_status_reported      = FALSE;

    nas_cached_info.data_reg_report_expiry          = NAS_NIL;
    nas_cached_info.extrapolation_ban_expiry        = NAS_NIL;

    nas_cached_info.init_attch_timeout_watch        = NAS_NIL;

    nas_common_info.data_dormancy_ind_enabled               = FALSE;
    nas_cached_info.common_indications_is_subscribed        = TRUE;     // because of subsequent qcril_qmi_util_enable_networking_indications() call

    memset( &nas_common_info.card_info, 0, QMI_UIM_MAX_CARD_COUNT * sizeof( qcril_qmi_nas_dms_card_info_type ) );

    nas_common_info.dfr_mode_pref_set_until_online = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_DFR_MODE_PREF_SET_UNTIL_ONLINE );


    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert DFR_MODE_PREF_SET_UNTIL_ONLINE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved DFR_MODE_PREF_SET_UNTIL_ONLINE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.dfr_mode_pref_set_until_online = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "DFR_MODE_PREF_SET_UNTIL_ONLINE=%d", nas_common_info.dfr_mode_pref_set_until_online);

    // check if rat tlv can be used for network selection
    qcril_db_query_properties_table(QCRIL_IS_RAT_TLV_SUPPORTED,args);
    nas_common_info.is_rat_tlv_supported = atoi(args) ? TRUE : FALSE;

    nas_common_info.is_reg_denied_on_rej_cause = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_REG_DENIED_ON_REJ_CAUSE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert REG_DENIED_ON_REJ_CAUSE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved REG_DENIED_ON_REJ_CAUSE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.is_reg_denied_on_rej_cause = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_DEBUG( "REG_DENIED_ON_REJ_CAUSE=%d", nas_common_info.is_reg_denied_on_rej_cause);

    nas_common_info.manual_nw_reject_cause_counter_enabled = FALSE;
    qmi_ril_get_property_value_from_integer(QMI_RIL_MANUAL_NW_REJECT_COUNTER_ENABLE,
                                            &nas_common_info.manual_nw_reject_cause_counter_enabled,
                                            NAS_NIL);

    QCRIL_LOG_DEBUG("MANUAL_NW_REJECT_COUNTER_ENABLE=%d",
                     nas_common_info.manual_nw_reject_cause_counter_enabled);

    qmi_ril_get_property_value_from_integer(QMI_RIL_IGNORE_SRV_DOMAIN_CAMPED_TIMER,
                                            &nas_common_info.ignore_srv_domain_camped_timer,
                                            NAS_NIL);

    QCRIL_LOG_DEBUG("IGNORE_SRV_DOMAIN_CAMPED_TIMER=%d",
                     nas_common_info.ignore_srv_domain_camped_timer);
    nas_common_info.ignore_srv_domain_camped_timer_id_valid = FALSE;
    nas_common_info.ignore_srv_domain_camped_timer_id = NAS_NIL;
    nas_common_info.prev_srv_domain_valid = FALSE;
    nas_common_info.prev_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;


    qcril_db_query_properties_table(QCRIL_IS_RIL_VRTE_LEARNING_ENABLED,
                                    args);

    temp_len = strlen(args);
    if (temp_len > 0)
    {
        nas_common_info.is_ril_vrte_learning_enabled = atoi(args) ? TRUE : FALSE;
    }
    else
    {
        nas_common_info.is_ril_vrte_learning_enabled = TRUE;
    }

    QCRIL_LOG_DEBUG("is_ril_vrte_learning_enabled = %d",
                     nas_common_info.is_ril_vrte_learning_enabled);

    nas_common_info.csg_info_available = NAS_NIL;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_CSG_INFO_AVAILABLE );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert QCRIL_CSG_INFO_AVAILABLE %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved QCRIL_CSG_INFO_AVAILABLE %ld, use default", ret_val );
      }
      else
      {
        nas_common_info.csg_info_available = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_INFO( "QCRIL_CSG_INFO_AVAILABLE=%d", nas_common_info.csg_info_available);

    qmi_ril_get_property_value_from_integer(QMI_RIL_1X_ROAM_MTU_SIZE,
                                            &nas_common_info.roam_mtu_size_1x,
                                            NAS_NIL);

    qcril_qmi_nas_populate_sig_config_delta_info();

    nas_cached_info.deferred_mode_pref_set_valid         = FALSE;
    nas_cached_info.deferred_mode_pref_set_android_param = NAS_NIL;

    nas_cached_info.deferred_acq_order_valid = FALSE;
    nas_cached_info.deferred_acq_order_len   = 0;
    nas_cached_info.deferred_acq_order_map   = 0;
    memset(nas_cached_info.deferred_acq_order, 0, sizeof(nas_cached_info.deferred_acq_order));

    nas_dms_cached_info.card_shutdown_initiated     = FALSE;

    nas_cached_info.data_reg_roaming_status_latest          = NAS_NIL;
    nas_cached_info.data_reg_roaming_status_latest_val      = FALSE;
    nas_cached_info.data_reg_roaming_status_latest_expiry   = NAS_NIL;

    nas_cached_info.embms_enabled = FALSE;
    nas_cached_info.embms_enable_success_sent_to_atel = FALSE;
    nas_cached_info.embms_cell_id_sent_after_enabled = FALSE;
    nas_cached_info.embms_coverage_sent_after_enabled = FALSE;

    nas_cached_info.is_indication_received = FALSE;
    if( NAS_ZERO != nas_cached_info.sys_sel_pref_tmr )
    {
        qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.sys_sel_pref_tmr);
        nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
    }

    nas_cached_info.designated_number_added_for_designated_country_status = QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NONE;
    *nas_cached_info.mcc_from_imsi_cache = NAS_NIL;

    qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow();
    qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow();
    qcril_qmi_nas_initiate_radio_power_process();
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_set_reported_voice_radio_tech(RADIO_TECH_IS95A);

    qmi_ril_nwr_reg_reject_init();

    qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_NOT_ACTIVE );

    qcril_qmi_fetch_system_selection_preference();

    qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed();

    qcril_qmi_util_enable_networking_indications( TRUE, FALSE );
    qcril_qmi_nas_check_retrieve_centralized_eons_support_status();

    if( TRUE == nas_common_info.custom_emergency_numbers_enabled )
    {
        qcril_qmi_nas_process_custom_emergency_numbers();
    }

    qcril_qmi_nas_fetch_sib16_network_time();

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                   NULL,
                   QMI_RIL_ZERO,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp, NULL, NULL );
    qcril_qmi_nas_update_sim_mcc_mnc(FALSE, NULL, NULL);

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_init

void qcril_qmi_nas_multi_sim_init()
{
  int res = RIL_E_SUCCESS;
  QCRIL_LOG_FUNC_ENTRY();

  res = qcril_qmi_nas_get_device_capability(TRUE, TRUE);

  NAS_CACHE_LOCK();
  nas_common_info.dsds.valid = FALSE;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_get_subscription_info()
{
  nas_get_subscription_info_resp_msg_v01 qmi_response;
  qmi_client_error_type qmi_transport_error;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_response, 0, sizeof(qmi_response));
  qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_SUBSCRIPTION_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp );
  QCRIL_LOG_INFO( ".. transport error %d, ril_error %d", (int)qmi_transport_error, (int)ril_req_res );
  NAS_CACHE_LOCK();
  if ( RIL_E_SUCCESS == ril_req_res )
  {
    if ( qmi_response.voice_system_id_valid )
    {
      QCRIL_LOG_INFO("VSID %d", qmi_response.voice_system_id);
#ifndef QMI_RIL_UTF
      if(qmi_response.voice_system_id)
      {
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_system_id, qmi_response.voice_system_id );
        qcril_am_set_vsid(QCRIL_AM_VS_VOICE, qmi_response.voice_system_id);
      }
#endif
    }

    if ( qmi_response.lte_voice_system_id_valid )
    {
        QCRIL_LOG_DEBUG ("LTE Voice System ID %x\n", qmi_response.lte_voice_system_id);
#ifndef QMI_RIL_UTF
        if ( qmi_response.lte_voice_system_id )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS, qmi_response.lte_voice_system_id);
        }
#endif
    }

    if ( qmi_response.wlan_voice_system_id_valid )
    {
        QCRIL_LOG_DEBUG ("WLAN Voice System ID %x\n", qmi_response.wlan_voice_system_id);
#ifndef QMI_RIL_UTF
        if ( qmi_response.wlan_voice_system_id )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS_WLAN, qmi_response.wlan_voice_system_id);
        }
#endif
    }

    if ( qmi_ril_is_multi_sim_feature_supported() && qmi_response.is_priority_subs_valid )
    {
      QCRIL_LOG_INFO("is_priority_subs %d", qmi_response.is_priority_subs);
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_priority_subs, qmi_response.is_priority_subs );
    }
    if ( qmi_ril_is_multi_sim_feature_supported() && qmi_response.is_active_valid )
    {
      QCRIL_LOG_INFO("is_active %d", qmi_response.is_active);
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_active, qmi_response.is_active );
    }
  }
  NAS_CACHE_UNLOCK();
  QCRIL_LOG_FUNC_RETURN();
}

uint8_t qcril_qmi_nas_get_max_subscriptions()
{
    uint8_t max_subs;

    NAS_CACHE_LOCK();
    max_subs = nas_dms_cached_info.max_subscriptions;
    NAS_CACHE_UNLOCK();

    return max_subs;
}

RIL_Errno qcril_qmi_nas_get_device_capability(int need_msim_capability, int need_sub_capability)
{
  dms_get_device_cap_resp_msg_v01 qmi_dev_cap_response;
  qmi_client_error_type qmi_transport_error;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  int instance_id = qmi_ril_get_process_instance_id();
  uint8_t modem_stack_id = (uint8_t) qcril_qmi_nas_get_modem_stack_id();

  memset( &qmi_dev_cap_response, 0, sizeof( qmi_dev_cap_response ) );
  qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_DEVICE_CAP_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_dev_cap_response,
                                                       sizeof( qmi_dev_cap_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_dev_cap_response.resp);
  QCRIL_LOG_INFO( "[MSIM] requested device caps %d, %d", (int)qmi_transport_error, (int)ril_req_res );

  if( RIL_E_SUCCESS == ril_req_res )
  {
      if ( ( instance_id == QCRIL_DEFAULT_INSTANCE_ID ) && ( need_msim_capability == TRUE ) && ( qmi_dev_cap_response.multisim_capability_valid == TRUE ) )
      {
        QCRIL_LOG_INFO(" max_subscriptions %d ", (int) qmi_dev_cap_response.multisim_capability.max_subscriptions);
        NAS_CACHE_LOCK();
        nas_dms_cached_info.max_subscriptions = qmi_dev_cap_response.multisim_capability.max_subscriptions;
        if ( qmi_dev_cap_response.multisim_capability.subscription_config_list_len > 0 )
        {
          QCRIL_LOG_INFO(" max_subscriptions_active %d ", (int) qmi_dev_cap_response.multisim_capability.subscription_config_list[0].max_active );
          // Currently max_active will be uniform for all config in config list.
          // So, pick first config type.
          nas_dms_cached_info.max_subscriptions_active = qmi_dev_cap_response.multisim_capability.subscription_config_list[0].max_active;
          qcril_qmi_nas_dms_update_multisim_config_property();
        }
        NAS_CACHE_UNLOCK();
      }
      if ( ( need_sub_capability == TRUE ) &&
           ( qmi_dev_cap_response.multisim_capability.subscription_config_list_len > 0 &&
             qmi_dev_cap_response.multisim_capability.subscription_config_list[0].subscription_list_len > modem_stack_id ) )
      {
        QCRIL_LOG_DEBUG("[MSIM] Stack capability %x", qmi_dev_cap_response.multisim_capability.subscription_config_list[0].subscription_list[modem_stack_id]);
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.current_sub_capability, qmi_dev_cap_response.multisim_capability.subscription_config_list[0].subscription_list[modem_stack_id] );
        NAS_CACHE_UNLOCK();
      }
      if ( ( need_sub_capability == TRUE ) && ( qmi_dev_cap_response.subs_voice_data_capability_valid == TRUE ) )
      {
        NAS_CACHE_LOCK();
        QCRIL_LOG_DEBUG("[MSIM] Current sub voice data capability %d ", (int) qmi_dev_cap_response.subs_voice_data_capability[modem_stack_id].subs_voice_data_capability);
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.subs_voice_data_capability, qmi_dev_cap_response.subs_voice_data_capability[modem_stack_id].subs_voice_data_capability );
        NAS_CACHE_UNLOCK();
      }
      if ((need_sub_capability == TRUE) &&
           (qmi_dev_cap_response.max_active_data_subscriptions_valid == TRUE))
      {
        QCRIL_LOG_DEBUG("[MSIM] Max Active Data : %d", qmi_dev_cap_response.max_active_data_subscriptions);
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_dms_cached_info.max_active_data_subs,
                                       qmi_dev_cap_response.max_active_data_subscriptions);
        NAS_CACHE_UNLOCK();
      }
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_req_res);
  return ril_req_res;
}

void qcril_qmi_nas_update_modem_stack_id(uint8_t stack_id)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    nas_common_info.dsds.modem_stack_id = stack_id;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_DEBUG("[MSIM] Modem stack id %d", (int) nas_common_info.dsds.modem_stack_id);
}

qcril_modem_stack_id_e_type qcril_qmi_nas_get_modem_stack_id()
{
    QCRIL_LOG_FUNC_RETURN_WITH_RET(nas_common_info.dsds.modem_stack_id);
    return nas_common_info.dsds.modem_stack_id;
}

//===========================================================================
// qmi_ril_nwreg_perform_dsds_specific_early_init
//===========================================================================
void qmi_ril_nwreg_perform_dsds_specific_early_init()
{
    dms_bind_subscription_req_msg_v01   dms_bind_request;
    dms_bind_subscription_resp_msg_v01  dms_bind_resp;
    RIL_Errno                           bind_res;
    qcril_instance_id_e_type            cur_proc_instance;


    if ( qmi_ril_is_multi_sim_feature_supported() )
    {
        cur_proc_instance = qmi_ril_get_process_instance_id();
        QCRIL_LOG_INFO( ".. nwreg DSDS specific early init on instance %d", (int) cur_proc_instance );

        memset( &dms_bind_request, 0, sizeof( dms_bind_request ) );

        switch ( cur_proc_instance )
        {
            case QCRIL_THIRD_INSTANCE_ID:
                dms_bind_request.bind_subs = DMS_TERTIARY_SUBS_V01;
                break;

            case QCRIL_SECOND_INSTANCE_ID:
                dms_bind_request.bind_subs = DMS_SECONDARY_SUBS_V01;
                break;

            case QCRIL_DEFAULT_INSTANCE_ID:     // fallthrough
            default:
                dms_bind_request.bind_subs = DMS_PRIMARY_SUBS_V01;
                break;
        }


        bind_res =  qcril_qmi_client_send_msg_sync_ex( QCRIL_QMI_CLIENT_DMS,
                                                   QMI_DMS_BIND_SUBSCRIPTION_REQ_V01,
                                                   (void*)&dms_bind_request,
                                                   sizeof( dms_bind_request ),
                                                   (void*) &dms_bind_resp,
                                                   sizeof( dms_bind_resp ),
                                                   QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                                    );
        QCRIL_LOG_INFO( " ..dms bind to % d res %d", (int)dms_bind_request.bind_subs , (int) bind_res );
    }
} // qmi_ril_nwreg_perform_dsds_specific_early_init
//===========================================================================
// qcril_qmi_nas_get_mode_pref_from_nv_10
//===========================================================================
boolean qcril_qmi_nas_get_mode_pref_from_nv_10()
{
    return nas_common_info.get_mode_pref_from_nv_10;
} // qcril_qmi_nas_get_mode_pref_from_nv_10

//===========================================================================
// qcril_qmi_nas_is_sglte3
//===========================================================================
int qcril_qmi_nas_is_sglte3()
{
    return nas_common_info.sglte_eons_is_set;
} // qcril_qmi_nas_is_sglte3

//===========================================================================
// qcril_qmi_nas_start_wait_for_pbm_ind_timer
//===========================================================================
void qcril_qmi_nas_start_wait_for_pbm_ind_timer()
{
   struct timeval wait_for_pbm_ind_timeout;

   QCRIL_LOG_FUNC_ENTRY();

   wait_for_pbm_ind_timeout.tv_sec = nas_common_info.wait_for_pbm_ind_timer;
   wait_for_pbm_ind_timeout.tv_usec = NAS_NIL;

   NAS_CACHE_LOCK();
   if( nas_common_info.wait_for_pbm_ind && !nas_common_info.wait_for_pbm_ind_timer_id_valid) //persist.radio.wait_for_pbm is set to "1" and timer is NOT currently running
   {
       qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
                                   qcril_qmi_nas_wait_for_pbm_ind_timeout_cb,
                                   &wait_for_pbm_ind_timeout, &nas_common_info.wait_for_pbm_ind_timer_id);
       nas_common_info.wait_for_pbm_ind_timer_id_valid = TRUE;
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer started");
   }
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_start_wait_for_pbm_ind_timer

//===========================================================================
// qcril_qmi_nas_cancel_wait_for_pbm_ind_timer
//===========================================================================
void qcril_qmi_nas_cancel_wait_for_pbm_ind_timer()
{
   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();
   if( nas_common_info.wait_for_pbm_ind && nas_common_info.wait_for_pbm_ind_timer_id_valid) //persist.radio.wait_for_pbm is set to "1" and timer is currently running
   {
       qcril_cancel_timed_callback((void *)(uintptr_t)nas_common_info.wait_for_pbm_ind_timer_id);
       nas_common_info.wait_for_pbm_ind_timer_id_valid = FALSE;
       nas_common_info.wait_for_pbm_ind_timer_id = NAS_NIL;
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer cancelled");
   }
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_cancel_wait_for_pbm_ind_timer

//===========================================================================
// qcril_qmi_nas_wait_for_pbm_ind_timeout_cb
//===========================================================================
void qcril_qmi_nas_wait_for_pbm_ind_timeout_cb(void * params)
{
   int action_needed;
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(params);

   action_needed = FALSE;

   NAS_CACHE_LOCK();
   if( nas_common_info.wait_for_pbm_ind ) //Ideally this function is called only when nas_common_info.wait_for_pbm_ind is "1"
   {
       QCRIL_LOG_INFO("wait_for_pbm_ind_timer timed out, operating mode %d, is screen off %d", nas_dms_cached_info.operating_mode, nas_common_info.is_screen_off);
       nas_common_info.wait_for_pbm_ind_timer_id_valid = FALSE;
       nas_common_info.wait_for_pbm_ind_timer_id = NAS_NIL;

       //As the window for keeping the PBM indications enabled
       //has passed, We would need to disable the PBM indications now
       //If the modem is in LPM or the Screen is OFF to save power
       if( DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode || TRUE == nas_common_info.is_screen_off )
       {
           action_needed = TRUE;
       }
   }
   NAS_CACHE_UNLOCK();

   if( action_needed )
   {
       qcril_qmi_pbm_enable_emergency_number_indications( FALSE );
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_wait_for_pbm_ind_timeout_cb

//===========================================================================
// qcril_qmi_nas_check_retrieve_centralized_eons_support_status
//===========================================================================
void qcril_qmi_nas_check_retrieve_centralized_eons_support_status()
{
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_transport_error;
    nas_get_centralized_eons_support_status_resp_msg_v01 qmi_response;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_response, 0, sizeof(qmi_response));
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_CENTRALIZED_EONS_SUPPORT_STATUS_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp );
    QCRIL_LOG_INFO( ".. transport error %d, ril_error %d", (int)qmi_transport_error, (int)ril_req_res );

    NAS_CACHE_LOCK();
    if ( RIL_E_SUCCESS == ril_req_res )
    {
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.centralized_eons_supported, qmi_response.centralized_eons_supported );
        QCRIL_LOG_INFO("centralized eons supported %d",qmi_response.centralized_eons_supported);
        if( TRUE == qmi_response.centralized_eons_supported_valid && TRUE == qmi_response.centralized_eons_supported )
        {
            qcril_qmi_nas_set_eons_enabled_property(TRUE);
        }
        else
        {
            qcril_qmi_nas_set_eons_enabled_property(FALSE);
        }
    }
    else
    {
        NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.centralized_eons_supported );
        QCRIL_LOG_INFO("Invalidating centralized eons cache");
        qcril_qmi_nas_set_eons_enabled_property(FALSE);
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_check_retrieve_centralized_eons_support_status

//===========================================================================
// qcril_qmi_nas_retrieve_rf_band_info
//===========================================================================
void qcril_qmi_nas_retrieve_rf_band_info()
{
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_transport_error;
    nas_get_rf_band_info_resp_msg_v01 qmi_response;
    uint32_t iter_i = 0;
    qcril_coex_rf_band_info_type  rf_band_info_arr[QCRIL_COEX_RD_BAND_INFO_LENGTH] = {{0}};
    qcril_coex_rf_band_info_type *rf_band_info_ptr = NULL;
    int                           rf_band_info_len = 0;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_response, 0, sizeof(qmi_response));
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_RF_BAND_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp );
    QCRIL_LOG_INFO( ".. transport error %d, ril_error %d", (int)qmi_transport_error, (int)ril_req_res );

    if ( RIL_E_SUCCESS == ril_req_res )
    {
      for( iter_i = 0; iter_i < qmi_response.rf_band_info_list_len; iter_i++ )
      {
        if  (( NAS_RADIO_IF_GSM_V01 == qmi_response.rf_band_info_list[iter_i].radio_if ) &&
             ( rf_band_info_len < QCRIL_COEX_RD_BAND_INFO_LENGTH))
        {
          rf_band_info_ptr = &rf_band_info_arr[rf_band_info_len];
          rf_band_info_len++;
          rf_band_info_ptr->rf_band_info = &qmi_response.rf_band_info_list[iter_i];
          rf_band_info_ptr->rat          = NAS_RADIO_IF_GSM_V01;
          QCRIL_LOG_INFO("rf band info list contains GSM");
        }

        if  (( NAS_RADIO_IF_LTE_V01 == qmi_response.rf_band_info_list[iter_i].radio_if ) &&
             ( rf_band_info_len < QCRIL_COEX_RD_BAND_INFO_LENGTH))
        {
          rf_band_info_ptr = &rf_band_info_arr[rf_band_info_len];
          rf_band_info_len++;
          rf_band_info_ptr->rf_band_info = &qmi_response.rf_band_info_list[iter_i];
          rf_band_info_ptr->rat          = NAS_RADIO_IF_LTE_V01;
          QCRIL_LOG_INFO("rf band info list contains LTE");
        }
      }

      qcril_qmi_nas_coex_control_process_rf_band_info(rf_band_info_arr, rf_band_info_len);
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_retrieve_rf_band_info

//===========================================================================
// qcril_qmi_nas_rf_band_info_ind_handler
//===========================================================================
void qcril_qmi_nas_rf_band_info_ind_handler(nas_rf_band_info_ind_msg_v01* rf_band_info_ind)
{
  QCRIL_LOG_FUNC_ENTRY();

  if( rf_band_info_ind )
  {
    qcril_qmi_nas_retrieve_rf_band_info();
  }
  else
  {
    QCRIL_LOG_FATAL("Null Pointer");
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_rf_band_info_ind_handler

//===========================================================================
// qcril_qmi_nas_coex_control_process_rf_band_info
//===========================================================================
void qcril_qmi_nas_coex_control_process_rf_band_info
(
    qcril_coex_rf_band_info_type rf_band_info[QCRIL_COEX_RD_BAND_INFO_LENGTH],
    int                          rf_band_info_len
)
{

    QCRIL_LOG_FUNC_ENTRY();
    if( rf_band_info && rf_band_info_len )
    {
        qcril_qmi_coex_process_rf_band_info(rf_band_info, rf_band_info_len);
    }
    else
    {
        QCRIL_LOG_FATAL("Null Pointer");
    }

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_coex_control_process_rf_band_info

//===========================================================================
// qcril_qmi_nas_is_centralized_eons_supported
//===========================================================================
int qcril_qmi_nas_is_centralized_eons_supported()
{
  int ret = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.centralized_eons_supported) )
  {
    ret = nas_cached_info.centralized_eons_supported;
  }
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} //qcril_qmi_nas_is_centralized_eons_supported

//===========================================================================
// qcril_qmi_dms_fusion_csfb_init
//===========================================================================
static void qcril_qmi_dms_fusion_csfb_init()
{
    QCRIL_LOG_FUNC_ENTRY();

    // empty

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_dms_fusion_csfb_init

//===========================================================================
// qcril_qmi_dms_get_device_caps
//===========================================================================
void qcril_qmi_dms_get_device_caps()
{
    QCRIL_LOG_FUNC_ENTRY();

    dms_get_device_cap_resp_msg_v01 qmi_response;
    RIL_Errno ril_err;
    qmi_client_error_type qmi_transport_error;

    memset( &qmi_response, 0, sizeof( qmi_response ) );
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_DEVICE_CAP_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);
    QCRIL_LOG_INFO( "requested device caps %d, %d", (int)qmi_transport_error, (int)ril_err );

    if( RIL_E_SUCCESS == ril_err )
    {
        NAS_CACHE_LOCK();
        if( TRUE == qmi_response.simul_voice_and_data_capability_valid )
        {
            QCRIL_LOG_INFO( "simul_voice_and_data_capability is valid %d",
                  (int)qmi_response.simul_voice_and_data_capability );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.simul_voice_and_data_capability,
                  qmi_response.simul_voice_and_data_capability );
        }
        // Check if device_capabilities TLV is valid. For older targets like
        // SVLTE2 this will be valid and voice_support_capability TLV will not be
        // present.
        else
        {
            QCRIL_LOG_INFO( "simul_voice_and_data_capability not valid, %d",
                  (int)qmi_response.device_capabilities.data_service_capability );
            if (qmi_response.device_capabilities.data_service_capability ==
                  DMS_DATA_CAP_SIMUL_CS_AND_PS_V01)
            {
               nas_cached_info.simul_voice_and_data_capability_valid = TRUE;
               nas_cached_info.simul_voice_and_data_capability =
                  QMI_DMS_MASK_SVLTE_CAPABLE_V01 | QMI_DMS_MASK_SVDO_CAPABLE_V01;
            }
            else
            {
               nas_cached_info.simul_voice_and_data_capability_valid = FALSE;
               nas_cached_info.simul_voice_and_data_capability = NAS_NIL;
            }
        }
        qcril_qmi_dms_set_simo_cs_ps_property( nas_cached_info.simul_voice_and_data_capability );

        if( (TRUE == qmi_response.subs_device_feature_mode_valid) &&
            (qcril_qmi_nas_get_modem_stack_id() < qmi_response.subs_device_feature_mode_len) )
        {
            nas_cached_info.subs_device_feature_mode_valid = TRUE;
            nas_cached_info.subs_device_feature_mode = qmi_response.subs_device_feature_mode[qcril_qmi_nas_get_modem_stack_id()];
        }
        NAS_CACHE_UNLOCK();
    }
    else
    {
        QCRIL_LOG_ESSENTIAL( "Fail to retrieve device capabilities" );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET( ril_err );
} // qcril_qmi_dms_get_device_caps

//===========================================================================
// qcril_qmi_is_srlte_supported
//===========================================================================
int qcril_qmi_is_srlte_supported()
{
    int ret = FALSE;

    NAS_CACHE_LOCK();
    if( TRUE == nas_cached_info.subs_device_feature_mode_valid )
    {
        ret = (nas_cached_info.subs_device_feature_mode == DMS_DEVICE_SUBS_FEATURE_MODE_SRLTE_V01);
    }
    NAS_CACHE_UNLOCK();

    return ret;
} // qcril_qmi_is_srlte_supported

//===========================================================================
// qcril_qmi_dms_set_simo_cs_ps_property
//===========================================================================
void qcril_qmi_dms_set_simo_cs_ps_property(dms_simul_voice_and_data_capability_mask_v01 simul_cap)
{
    QCRIL_LOG_FUNC_ENTRY();

    char args[ PROPERTY_VALUE_MAX ];

    QCRIL_LOG_INFO( "simul cap %ld", simul_cap );

    if( QMI_DMS_MASK_SVLTE_CAPABLE_V01 & simul_cap )    //checking svlte
    {
        strlcpy(args,"true",sizeof(args));
    }
    else
    {
        strlcpy(args,"false",sizeof(args));
    }
    QCRIL_LOG_INFO("Setting %s property to %s", QMI_RIL_SIMO_CS_PS_SVLTE, args);
    if ( property_set( QMI_RIL_SIMO_CS_PS_SVLTE, args ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_SIMO_CS_PS_SVLTE );
    }

    if( QMI_DMS_MASK_SVDO_CAPABLE_V01 & simul_cap )    //checking svdo
    {
        strlcpy(args,"true",sizeof(args));
    }
    else
    {
        strlcpy(args,"false",sizeof(args));
    }
    QCRIL_LOG_INFO("Setting %s property to %s", QMI_RIL_SIMO_CS_PS_SVDO, args);
    if ( property_set( QMI_RIL_SIMO_CS_PS_SVDO, args ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_SIMO_CS_PS_SVDO );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_dms_set_simo_cs_ps_property

//===========================================================================
// qcril_qmi_nas_retrieve_sv_capability
//===========================================================================
dms_simul_voice_and_data_capability_mask_v01 qcril_qmi_nas_retrieve_sv_capability()
{
    dms_simul_voice_and_data_capability_mask_v01 sv_capability = NAS_NIL;;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ) )
    {
        sv_capability = nas_cached_info.simul_voice_and_data_capability;
    }
    NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN_WITH_RET(sv_capability);
   return sv_capability;
} //qcril_qmi_nas_retrieve_sv_capability

//===========================================================================
// qcril_qmi_nas_set_eons_enabled_property
//===========================================================================
void qcril_qmi_nas_set_eons_enabled_property(int is_centralized_eons_supported)
{
    QCRIL_LOG_FUNC_ENTRY();

    char args[ PROPERTY_VALUE_MAX ];

    QCRIL_LOG_INFO( "is_centralized_eons_supported %d", is_centralized_eons_supported );
    if( FALSE == is_centralized_eons_supported )
    {
        strlcpy(args,"true",sizeof(args));
    }
    else
    {
        strlcpy(args,"false",sizeof(args));
    }

    QCRIL_LOG_INFO("Setting %s property to %s", QMI_RIL_TELEPHONY_EONS_SUPPORTED, args);
    if ( property_set( QMI_RIL_TELEPHONY_EONS_SUPPORTED, args ) != E_SUCCESS )
    {
      QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_TELEPHONY_EONS_SUPPORTED );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_eons_enabled_property

//===========================================================================
// qcril_qmi_dms_init
//===========================================================================
void qcril_qmi_dms_init()
{
    dms_set_event_report_req_msg_v01 qmi_request;
    dms_set_event_report_resp_msg_v01 qmi_response;

    RIL_Errno ril_err;
    qmi_client_error_type qmi_transport_error;

    memset( &qmi_request, 0, sizeof( qmi_request ) );

    qmi_request.report_oprt_mode_state_valid = TRUE;
    qmi_request.report_oprt_mode_state = NAS_REQ_REPORT;

    qmi_request.report_prl_init_valid = TRUE;
    qmi_request.report_prl_init = NAS_REQ_REPORT;

    if ( qmi_ril_is_multi_sim_feature_supported() )
    {
      qmi_request.report_device_multisim_info_valid = TRUE;
      qmi_request.report_device_multisim_info = NAS_REQ_REPORT;
    }

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_SET_EVENT_REPORT_REQ_V01,
                                                       (void*) &qmi_request,
                                                       sizeof( qmi_request ),
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);

    if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_FUSION_CSFB) )
    {  // Fusion specific init
        qcril_qmi_dms_fusion_csfb_init();
    }

    qcril_qmi_dms_get_device_caps();


    QCRIL_LOG_INFO( "requested dms indication reports %d, %d", (int)qmi_transport_error, (int)ril_err );
} // qcril_qmi_dms_init


//===========================================================================
// qcril_qmi_nas_empty_command_cb
//===========================================================================
/*
void qcril_qmi_nas_empty_command_cb
(
  qmi_client_type              user_handle,
  unsigned long                message_id,
  void                         *resp_c_struct,
  int                          resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    RIL_Errno ril_err;

    QCRIL_LOG_INFO( "qcril_qmi_nas_empty_command_cb empty action, message %d", message_id );

    user_handle = user_handle;
    resp_cb_data = resp_cb_data;
    resp_c_struct_len = resp_c_struct_len;


    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(transp_err, (qmi_response_type_v01*)resp_c_struct);
    QCRIL_LOG_INFO( "qcril_qmi_nas_empty_command_cb got request completion info %d, %d", (int)transp_err, (int)ril_err );

    // do nothing
} // qcril_qmi_nas_empty_command_cb
*/

//===========================================================================
// qcril_qmi_data_nas_control_get_current_calls_number
//
// returns number of existing data calls in case of SUCCESS
// otherwise QCRIL_DATA_FAILURE (-1)
//===========================================================================
int qcril_qmi_data_nas_control_get_current_calls_number(qcril_data_active_call_info_t *call_list)
{
    qcril_data_hndl_t handle;
    int ret;
    int number_of_calls = QCRIL_DATA_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    handle = nas_common_info.nas_data_control_handle;
    NAS_CACHE_UNLOCK();

    if( NAS_NIL != handle )
    {
        ret = qcril_data_get_active_calls(handle, (unsigned int*) &number_of_calls, call_list);
        if( QCRIL_DATA_SUCCESS != ret )
        {
            number_of_calls = QCRIL_DATA_FAILURE;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(number_of_calls);
    return number_of_calls;
} //qcril_qmi_data_nas_control_get_current_calls_number

//===========================================================================
// qcril_qmi_nas_data_control_cb
//===========================================================================
void qcril_qmi_nas_data_control_cb (qcril_data_hndl_t         hndl,
                                    void                     *user_data,
                                    qcril_data_net_evt_t      evt,
                                    qcril_data_evt_payload_t *payload )
{
    int initiate_report = FALSE;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(hndl);
    QCRIL_NOTUSED(user_data);
    QCRIL_NOTUSED(payload);

    QCRIL_LOG_INFO( ".. %d", (int)evt );

    switch ( evt )
    {
        case QCRIL_DATA_EVT_CALL_RELEASED:
            qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler,
                                        NULL,  // immediate
                                        NULL );
            qcril_qmi_nas_control_signal_nas_on_current_calls_change();
            initiate_report = TRUE;
            break;

        case QCRIL_DATA_EVT_CALL_CONNECTED:
            qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler,
                                        NULL,  // immediate
                                        NULL );
            initiate_report = TRUE;
            break;

        case QCRIL_DATA_EVT_CALL_PHYSLINK_UP:
        case QCRIL_DATA_EVT_CALL_PHYSLINK_DOWN:
            initiate_report = TRUE;
            break;

        default: // nothing
            break;
    }

    if( TRUE == initiate_report )
    {
        qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qmi_ril_report_data_connection_information,
                                    NULL,  // immediate
                                    NULL );

        if( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_APQ) ||
            QCRIL_IS_DSDA_COEX_ENABLED() )
        {
            qcril_qmi_coex_initiate_report_lte_info_to_riva(QCRIL_QMI_COEX_INITIATE_FOR_DATA_CHECK);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_data_control_cb

//===========================================================================
// qmi_ril_retrieve_data_connection_information_from_data_call_list
//
// Populates nof_data_calls with number of existing data calls
// Allocates array of length nof_data_calls for data_call_real_time_info_list
// Caller would need to free the memory
//
// returns TRUE if retrieval was successful, FALSE otherwise
//===========================================================================
int qmi_ril_retrieve_data_connection_information_from_data_call_list(int *nof_data_calls, qcril_qmi_nas_dc_rt_info_helper_type **qcril_qmi_nas_dc_rt_info_helper_ptr)
{
    int                             iter_i;
    int                             ret_code;
    qcril_data_active_call_info_t   *data_call_list;
    qcril_qmi_nas_dc_rt_info_helper_type *qcril_qmi_nas_dc_rt_info_helper_holder;

    QCRIL_LOG_FUNC_ENTRY();

    iter_i = 0;
    ret_code = FALSE;
    data_call_list = NULL;
    qcril_qmi_nas_dc_rt_info_helper_holder = NULL;

    if( nof_data_calls && qcril_qmi_nas_dc_rt_info_helper_ptr )
    {
        *nof_data_calls = NAS_NIL;
        *qcril_qmi_nas_dc_rt_info_helper_ptr = NULL;

        data_call_list = qcril_malloc(sizeof( *data_call_list ) * QCRIL_DATA_MAX_CALL_RECORDS);
        if(data_call_list)
        {
            memset(data_call_list, 0, (sizeof( *data_call_list ) * QCRIL_DATA_MAX_CALL_RECORDS));

            *nof_data_calls = qcril_qmi_data_nas_control_get_current_calls_number(data_call_list);

            if( *nof_data_calls > NAS_NIL )
            {
                qcril_qmi_nas_dc_rt_info_helper_holder = (qcril_qmi_nas_dc_rt_info_helper_type*) qcril_malloc(sizeof(*qcril_qmi_nas_dc_rt_info_helper_holder));
                if( qcril_qmi_nas_dc_rt_info_helper_holder )
                {
                    memset(qcril_qmi_nas_dc_rt_info_helper_holder, 0, sizeof(*qcril_qmi_nas_dc_rt_info_helper_holder));
                    for( iter_i = 0; iter_i < *nof_data_calls; iter_i++ )
                    {
                        /*
                        qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i].call_id = data_call_list[iter_i].call_id;
                        qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i].radioTech = data_call_list[iter_i].radioTech;
                        switch( data_call_list[iter_i].active )
                        {
                            case CALL_INACTIVE:
                                qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i].powerState = RIL_DC_POWER_STATE_INACTIVE;
                                break;

                            case CALL_ACTIVE_PHYSLINK_DOWN:
                                qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i].powerState = RIL_DC_POWER_STATE_DORMANT;
                                break;

                            case CALL_ACTIVE_PHYSLINK_UP:
                                qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i].powerState = RIL_DC_POWER_STATE_NOT_DORMANT;
                                break;

                            default:
                                qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i].powerState = RIL_DC_POWER_STATE_UNKNOWN;
                                break;
                        }
                        qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list_ptr[iter_i] = &qcril_qmi_nas_dc_rt_info_helper_holder->data_call_real_time_info_list[iter_i];
                        */
                    }
                    *qcril_qmi_nas_dc_rt_info_helper_ptr = qcril_qmi_nas_dc_rt_info_helper_holder;
                    ret_code = TRUE;
                }
                else
                {
                    QCRIL_LOG_FATAL("Unable to allocate memory for qcril_qmi_nas_dc_rt_info_helper_holder");
                }
            }
            else if( *nof_data_calls == NAS_NIL )
            {
                ret_code = TRUE;
            }
            else
            {
                QCRIL_LOG_FATAL("Unable to retrieve data_call_list information");
            }

            qcril_free( data_call_list );
        }
        else
        {
            QCRIL_LOG_FATAL("Unable to allocate memory for data_call_list");
        }
    }
    else
    {
        QCRIL_LOG_FATAL("NULL parameter(s) passed");
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret_code);
    return ret_code;
} //qmi_ril_retrieve_data_connection_information_from_data_call_list

//===========================================================================
// qmi_ril_report_data_connection_information
//===========================================================================
void qmi_ril_report_data_connection_information(void * param)
{
    qcril_unsol_resp_params_type    unsol_resp_params;
    int                             report;
    int                             nof_data_calls;
    qcril_qmi_nas_dc_rt_info_helper_type *qcril_qmi_nas_dc_rt_info_helper;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    report = FALSE;
    nof_data_calls = NAS_NIL;
    qcril_qmi_nas_dc_rt_info_helper = NULL;

    /*
    report = qmi_ril_retrieve_data_connection_information_from_data_call_list(&nof_data_calls, &qcril_qmi_nas_dc_rt_info_helper);
    */

    if( report )
    {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_DC_RT_INFO_CHANGED, &unsol_resp_params );
        if( qcril_qmi_nas_dc_rt_info_helper )
        {
            unsol_resp_params.resp_pkt    = (void*) &qcril_qmi_nas_dc_rt_info_helper->data_call_real_time_info_list_ptr;
            unsol_resp_params.resp_len    = nof_data_calls * sizeof( RIL_DcRtInfo* );
        }
        qcril_send_unsol_response( &unsol_resp_params );
    }

    if( qcril_qmi_nas_dc_rt_info_helper )
    {
        qcril_free(qcril_qmi_nas_dc_rt_info_helper);
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_report_data_connection_information

//===========================================================================
//RIL_REQUEST_GET_DC_RT_INFO
//===========================================================================
void qcril_qmi_nas_request_get_dc_rt_info
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    qcril_request_resp_params_type        resp;
    RIL_Errno                             ril_req_res;
    int                                   nof_data_calls;
    qcril_qmi_nas_dc_rt_info_helper_type *qcril_qmi_nas_dc_rt_info_helper;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = RIL_E_GENERIC_FAILURE;
    nof_data_calls = NAS_NIL;
    qcril_qmi_nas_dc_rt_info_helper = NULL;

    /*
    if( qmi_ril_retrieve_data_connection_information_from_data_call_list(&nof_data_calls, &qcril_qmi_nas_dc_rt_info_helper) )
    {
        ril_req_res = RIL_E_SUCCESS;
    }
    */

    // ** respond
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    if( qcril_qmi_nas_dc_rt_info_helper && RIL_E_SUCCESS == ril_req_res )
    {
        resp.resp_pkt    = (void*) &qcril_qmi_nas_dc_rt_info_helper->data_call_real_time_info_list_ptr;
        resp.resp_len    = nof_data_calls * sizeof( RIL_DcRtInfo* );
    }
    qcril_send_request_response( &resp );
    QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);

    if( qcril_qmi_nas_dc_rt_info_helper )
    {
        qcril_free(qcril_qmi_nas_dc_rt_info_helper);
    }

    QCRIL_LOG_FUNC_RETURN();
}


//===========================================================================
// qcril_qmi_nas_data_control_register_for_call_activity
//===========================================================================
void qcril_qmi_nas_data_control_register_for_call_activity()
{
    qcril_data_hndl_t handle;

    QCRIL_LOG_FUNC_ENTRY();

    handle = qcril_data_client_register(qcril_qmi_nas_data_control_cb, NULL );

    if( QCRIL_DATA_CLIENT_HNDL_INVALID == handle )
    {
        QCRIL_LOG_INFO("Registration for data call activity unsuccessful");
        handle = NAS_NIL;
    }
    else
    {
        QCRIL_LOG_INFO("Registration for data call activity successful, handle %d",handle);
    }

    NAS_CACHE_LOCK();
    nas_common_info.nas_data_control_handle = handle;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_data_control_register_for_call_activity

//===========================================================================
// qcril_qmi_nas_data_control_deregister_for_call_activity
//===========================================================================
void qcril_qmi_nas_data_control_deregister_for_call_activity()
{
    qcril_data_hndl_t handle;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    handle = nas_common_info.nas_data_control_handle;
    nas_common_info.nas_data_control_handle = NAS_NIL;
    NAS_CACHE_UNLOCK();

    if( NAS_NIL != handle )
    {
        qcril_data_client_release(handle);
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_data_control_deregister_for_call_activity


//===========================================================================
// qcril_qmi_nas_data_update_mtu_size_if_needed
//===========================================================================
void qcril_qmi_nas_data_update_mtu_size_if_needed(uint8_t prev_reported_state_valid,
                                                  int prev_reported_state,
                                                  uint8_t prev_reported_tech_valid,
                                                  int prev_reported_tech)
{
    uint8_t curr_reported_state_valid;
    int curr_reported_state;
    uint8_t curr_reported_tech_valid;
    int curr_reported_tech;
    int is_prev_3gpp2_roaming;
    int is_curr_3gpp2_roaming;

    QCRIL_LOG_FUNC_ENTRY();

    curr_reported_state_valid = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.reported_data_reg_status);
    curr_reported_state = nas_cached_info.reported_data_reg_status;
    curr_reported_tech_valid = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.reported_data_technology);
    curr_reported_tech = nas_cached_info.reported_data_technology;
    is_prev_3gpp2_roaming = FALSE;
    is_curr_3gpp2_roaming = FALSE;

    QCRIL_LOG_INFO("mtu size for 3gpp2 roaming %d",nas_common_info.roam_mtu_size_1x);
    QCRIL_LOG_INFO("prev reg state valid %d, value %d, reg tech valid %d, value %d",
                   prev_reported_state_valid,
                   prev_reported_state,
                   prev_reported_tech_valid,
                   prev_reported_tech);
    QCRIL_LOG_INFO("curr reg state valid %d, value %d, reg tech valid %d, value %d",
                   curr_reported_state_valid,
                   curr_reported_state,
                   curr_reported_tech_valid,
                   curr_reported_tech);

    if(NAS_NIL != nas_common_info.roam_mtu_size_1x)
    {
        is_prev_3gpp2_roaming = qcril_qmi_nas_is_3gpp2_roaming(prev_reported_state_valid,
                                                               prev_reported_state,
                                                               prev_reported_tech_valid,
                                                               prev_reported_tech);

        is_curr_3gpp2_roaming = qcril_qmi_nas_is_3gpp2_roaming(curr_reported_state_valid,
                                                               curr_reported_state,
                                                               curr_reported_tech_valid,
                                                               curr_reported_tech);

        if((is_prev_3gpp2_roaming != is_curr_3gpp2_roaming) &&
           ((TRUE == is_prev_3gpp2_roaming) || (TRUE == is_curr_3gpp2_roaming))
           )
        {
#ifndef QMI_RIL_UTF
            if(TRUE == is_curr_3gpp2_roaming)
            {
                QCRIL_LOG_INFO("mtu size being changed to %d",nas_common_info.roam_mtu_size_1x);
                qcril_data_update_mtu(nas_common_info.roam_mtu_size_1x);
            }
            else
            {
                QCRIL_LOG_INFO("mtu size being changed to default value");
                qcril_data_update_mtu(NAS_ZERO);
            }
#endif
        }
        else
        {
            QCRIL_LOG_INFO("mtu size unchanged");
        }
    }
} //qcril_qmi_nas_data_update_mtu_size_if_needed



//===========================================================================
// DMS unsolicited event handler
//===========================================================================

void qcril_qmi_dms_unsolicited_indication_cb
(
  qmi_client_type                user_handle,
  unsigned int                   message_id,
  void                          *ind_buf,
  unsigned int                   ind_buf_len,
  void                          *ind_cb_data
)
{
  qmi_ind_callback_type qmi_callback;

  QCRIL_LOG_FUNC_ENTRY();

  qmi_callback.data_buf = qcril_malloc(ind_buf_len);

  if( qmi_callback.data_buf )
  {
    qmi_callback.user_handle = user_handle;
    qmi_callback.msg_id = message_id;
    memcpy(qmi_callback.data_buf,ind_buf,ind_buf_len);
    qmi_callback.data_buf_len = ind_buf_len;
    qmi_callback.cb_data = ind_cb_data;

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_DMS_HANDLE_INDICATIONS,
                   (void*) &qmi_callback,
                   sizeof(qmi_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
  }
  else
  {
    QCRIL_LOG_FATAL("malloc failed");
  }

  QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_dms_unsolicited_indication_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_dms_unsolicited_indication_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_DMS_HANDLE_INDICATIONS

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_dms_unsolicited_indication_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   void * decoded_payload = NULL;
   qmi_client_error_type qmi_err;
   uint32_t decoded_payload_len;
   int result = 0;

   qcril_unsol_resp_params_type unsol_resp_params;

   struct nas_evt_post_info_type evt_post_info[MAX_NOF_NAS_EVT_POST_REC];
   int idx;
   uint16_t prl_version;

   qmi_ind_callback_type * qmi_callback = (qmi_ind_callback_type*) params_ptr->data;

   QCRIL_NOTUSED(ret_ptr);
   memset(&evt_post_info, 0, sizeof(evt_post_info));

   do {

      if(! qmi_callback )
      {
         QCRIL_LOG_ERROR("qmi_callback is NULL");
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      QCRIL_LOG_INFO("invoked msg 0x%x", (int) qmi_callback->msg_id);

      qmi_err = qmi_idl_get_message_c_struct_len( dms_get_service_object_v01(),
                                                  QMI_IDL_INDICATION,
                                                  qmi_callback->msg_id,
                                                  &decoded_payload_len);
      if ( qmi_err != QMI_NO_ERR )
      {
         QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      if( !decoded_payload_len )
      {
         // ok, this is a null payload - don't need to process it.
      }
      else
      {
         // process the payload

         decoded_payload = qcril_malloc( decoded_payload_len );
         if (! decoded_payload )
         {
            QCRIL_LOG_ERROR("Failed to alloc memory for decoded payload");
            QCRIL_ASSERT(0); // this is a noop in release build
            break;
         }
         memset( decoded_payload, 0, decoded_payload_len );

         qmi_err = qmi_client_message_decode(
                       qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                       QMI_IDL_INDICATION,
                       qmi_callback->msg_id,
                       qmi_callback->data_buf,
                       qmi_callback->data_buf_len,
                       decoded_payload,
                       (int)decoded_payload_len );

         if (qmi_err != QMI_NO_ERR)
         {
            QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
            QCRIL_ASSERT(0); // this is a noop in release build
            qcril_free(decoded_payload);
            break;
         }

         switch ( qmi_callback->msg_id )
         {
            case QMI_DMS_EVENT_REPORT_IND_V01:

               result = qcril_qmi_nas_dms_event_report_qmi2ril(
                               (dms_event_report_ind_msg_v01*) decoded_payload,
                               &evt_post_info[0].engaged );

               if ( (E_SUCCESS == result) && evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED;
               }
               break;

            default:
               QCRIL_LOG_ERROR("Unknown DSM unsol message 0x%x", (int) qmi_callback->msg_id);
               QCRIL_ASSERT(0); // this is a noop in release build
               break;
         }

         qcril_free( decoded_payload );
      }

      // submit events
      for ( idx = 0; idx < MAX_NOF_NAS_EVT_POST_REC; idx++ )
      {
         if (! evt_post_info[idx].engaged )
         {
            // No response necessary for this rec
            continue;
         }

         // send a response
         if ( RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED == evt_post_info[idx].ril_evt )
         {
            qcril_qmi_nas_initiate_radio_state_changed_ind();
         }
         else
         {
            qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                              evt_post_info[idx].ril_evt, &unsol_resp_params );
            unsol_resp_params.resp_pkt = evt_post_info[idx].ril_evt_payload;
            unsol_resp_params.resp_len = evt_post_info[idx].ril_evt_payload_len;
            qcril_send_unsol_response( &unsol_resp_params );
            QCRIL_LOG_INFO("posted RIL indication %d", (int) evt_post_info[idx].ril_evt );
         }
      }

   } while(0);

   if( qmi_callback && qmi_callback->data_buf )
   {
     qcril_free(qmi_callback->data_buf);
   }
}// qcril_qmi_dms_unsolicited_indication_cb_helper

//===========================================================================
// NAS unsolicited event handler
//===========================================================================

void qcril_qmi_nas_unsolicited_indication_cb
(
  qmi_client_type                user_handle,
  unsigned int                   message_id,
  void                          *ind_buf,
  unsigned int                   ind_buf_len,
  void                          *ind_cb_data
)
{
  qmi_ind_callback_type qmi_callback;

  QCRIL_LOG_FUNC_ENTRY();

  qmi_callback.data_buf = qcril_malloc(ind_buf_len);

  if( qmi_callback.data_buf )
  {
    qmi_callback.user_handle = user_handle;
    qmi_callback.msg_id = message_id;
    memcpy(qmi_callback.data_buf,ind_buf,ind_buf_len);
    qmi_callback.data_buf_len = ind_buf_len;
    qmi_callback.cb_data = ind_cb_data;

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_NAS_HANDLE_INDICATIONS,
                   (void*) &qmi_callback,
                   sizeof(qmi_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
  }
  else
  {
    QCRIL_LOG_FATAL("malloc failed");
  }

  QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_nas_unsolicited_indication_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_unsolicited_indication_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_NAS_HANDLE_INDICATIONS

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_unsolicited_indication_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   void * decoded_payload = NULL;
   qmi_client_error_type qmi_err;
   uint32_t decoded_payload_len;

   qcril_unsol_resp_params_type unsol_resp_params;
   struct nas_evt_post_info_type evt_post_info[MAX_NOF_NAS_EVT_POST_REC];
   int idx;
   char ril_nitz_time[NAS_NITZ_STR_BUF_MAX];
   RIL_CdmaSubscriptionSource sub_source;

   int is_pre_registered = FALSE;
   int is_post_registered = FALSE;
   int restricted_details;
   int result = 0;
   int is_now_registered;
   int emergency_callback_mode_state;

   QCRIL_NOTUSED(ret_ptr);
   qmi_ind_callback_type * qmi_callback = (qmi_ind_callback_type*) params_ptr->data;

   do {

      if(! qmi_callback )
      {
         QCRIL_LOG_ERROR("qmi_callback is NULL");
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      QCRIL_LOG_INFO("invoked msg 0x%x", (int) qmi_callback->msg_id);

      NAS_CACHE_LOCK();
      is_pre_registered = qcril_qmi_nas_is_considered_registered(NULL);
      NAS_CACHE_UNLOCK();

      qmi_err = qmi_idl_get_message_c_struct_len( nas_get_service_object_v01(),
                                                  QMI_IDL_INDICATION,
                                                  qmi_callback->msg_id,
                                                  &decoded_payload_len );
      if ( qmi_err != QMI_NO_ERR )
      {
         QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
         QCRIL_ASSERT(0); // this is a noop in release build
         break;
      }

      if(! decoded_payload_len )
      {
         // NULL payload
         switch ( qmi_callback->msg_id )
         {
            case QMI_NAS_MANAGED_ROAMING_IND_MSG_V01:
               qcril_qmi_nas_managed_roaming_ind_handler( &evt_post_info[0].engaged );
               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }
               break;

            case QMI_NAS_DDTM_IND_MSG_V01:
            case QMI_NAS_CSP_PLMN_MODE_BIT_IND_MSG_V01:
               // no handling
               break;

            default:
               QCRIL_LOG_ERROR("Unknown message or missing payload");
               QCRIL_ASSERT(0); // this is a noop in release build
               break;
         }
      }
      else
      {
         // Non-null payload

         decoded_payload = qcril_malloc( decoded_payload_len );
         if( !decoded_payload )
         {
            QCRIL_LOG_ERROR("Failed to alloc memory");
            QCRIL_ASSERT(0); // this is a noop in release build
            break;
         }
         memset( decoded_payload, 0, decoded_payload_len );

         qmi_err = qmi_client_message_decode(
                      qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                      QMI_IDL_INDICATION,
                      qmi_callback->msg_id,
                      qmi_callback->data_buf,
                      qmi_callback->data_buf_len,
                      decoded_payload,
                      (int)decoded_payload_len);

         memset( &evt_post_info, 0, sizeof( evt_post_info ) );

         // Handle messages w/payload required
         switch ( qmi_callback->msg_id )
         {
            case QMI_NAS_EVENT_REPORT_IND_MSG_V01:
               result = qcril_qmi_nas_event_report_ind_conv_qmi2ril(
                               (nas_event_report_ind_msg_v01*) decoded_payload,
                               &evt_post_info[0].engaged,
                               &evt_post_info[1].engaged );
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed event_report_ind_conv_qmi2ril w/%d",
                                  result);
                  break;
               }

               NAS_CACHE_LOCK();
               is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
               NAS_CACHE_UNLOCK();

               if ( is_now_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }
               else if ( evt_post_info[1].engaged )
               {
                  evt_post_info[1].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }

               break;

            case QMI_NAS_SIG_INFO_IND_MSG_V01:
               result = qcril_qmi_nas_sig_info_ind_conv_qmi2ril(
                                 (nas_sig_info_ind_msg_v01*) decoded_payload);
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed sig_info_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               NAS_CACHE_LOCK();
               is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
               NAS_CACHE_UNLOCK();

               if ( is_now_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

            case QMI_NAS_ERR_RATE_IND_MSG_V01:
               result = qcril_qmi_nas_err_rate_ind_conv_qmi2ril(
                                 (nas_err_rate_ind_msg_v01*) decoded_payload);
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed err_rate_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               NAS_CACHE_LOCK();
               is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
               NAS_CACHE_UNLOCK();

               if ( is_now_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

            case QMI_NAS_SERVING_SYSTEM_IND_MSG_V01:
               result = qcril_qmi_nas_serving_system_ind_conv_qmi2ril(
                             (nas_serving_system_ind_msg_v01*) decoded_payload,
                             &evt_post_info[0].engaged,
                             &evt_post_info[1].engaged,
                             &evt_post_info[2].engaged
                             );
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed serving_system_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               if (! (evt_post_info[0].engaged || evt_post_info[1].engaged
                     || evt_post_info[2].engaged) )
               {
                  // Nothing engaged
                  break;
               }

               NAS_CACHE_LOCK();
               is_post_registered = qcril_qmi_nas_is_considered_registered(NULL);
               NAS_CACHE_UNLOCK();

               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }
               else if ( evt_post_info[2].engaged )
               {
                  evt_post_info[2].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }

               if ( evt_post_info[1].engaged )
               {
                  evt_post_info[1].ril_evt = RIL_UNSOL_VOICE_RADIO_TECH_CHANGED;
               }
               if ( ( is_post_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update ) && !is_pre_registered )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

            case QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01:
               result = qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril(
                   (nas_system_selection_preference_ind_msg_v01*) decoded_payload,
                   &evt_post_info[0].engaged,
                   &evt_post_info[1].engaged );
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed system_selection_preference_ind_conv_qmi2ril w/%d", result);
                  break;
               }

               if ( ! (evt_post_info[0].engaged || evt_post_info[1].engaged) )
               {
                  // nothing engaged, ignore
                  break;
               }

               if ( evt_post_info[0].engaged )
               {
                   emergency_callback_mode_state = (int) qmi_ril_nwr_get_eme_cbm();
                   QCRIL_LOG_INFO(".. EME CB set event, however relying on"
                                  " manual setting of eme cb, cur_mode %d",
                                   emergency_callback_mode_state);

                   qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      QCRIL_DATA_ON_STACK,
                                      QCRIL_EVT_QMI_RIL_NAS_EMERGENCY_MODE_ON,
                                      NULL,
                                      NAS_NIL,
                                      (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
               }
               if ( evt_post_info[1].engaged )
               {
                  qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      QCRIL_DATA_ON_STACK,
                                      QCRIL_EVT_QMI_RIL_NAS_EMERGENCY_MODE_OFF,
                                      NULL,
                                      NAS_NIL,
                                      (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
               }

               qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler((nas_system_selection_preference_ind_msg_v01*) decoded_payload);
               break;

            case QMI_NAS_DDTM_IND_MSG_V01:
               // no handling
               break;

            case QMI_NAS_SYS_INFO_IND_MSG_V01:
               restricted_details = RIL_RESTRICTED_STATE_NONE;
               result = qcril_qmi_nas_sys_info_ind_conv_qmi2ril(
                                  (nas_sys_info_ind_msg_v01 *) decoded_payload,
                                  &evt_post_info[0].engaged,
                                  &evt_post_info[2].engaged,
                                  &evt_post_info[1].engaged);
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed sys_info_ind_conv_qmi2ril w/%d",
                                   result);
                  break;
               }

               if ( !(evt_post_info[0].engaged || evt_post_info[1].engaged
                     || evt_post_info[2].engaged) )
               {
                  // Nothing engaged
                  break;
               }

               NAS_CACHE_LOCK();
               is_post_registered = qcril_qmi_nas_is_considered_registered(NULL);
               NAS_CACHE_UNLOCK();

               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }
               else if ( evt_post_info[1].engaged )
               {
                  evt_post_info[1].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }

               if ( evt_post_info[2].engaged )
               {
                  evt_post_info[2].ril_evt = RIL_UNSOL_VOICE_RADIO_TECH_CHANGED;
               }
               if ( ( is_post_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update ) && !is_pre_registered )
               {
                  qcril_qmi_nas_send_known_signal_strength();
               }
               break;

            case QMI_NAS_OPERATOR_NAME_DATA_IND_MSG_V01:
               result = qcril_qmi_nas_operator_name_data_ind_conv_qmi2ril(
                         (nas_operator_name_data_ind_msg_v01*) decoded_payload,
                         &evt_post_info[0].engaged );
               if ( result != E_SUCCESS ) {
                  QCRIL_LOG_ERROR("Failed operator_name_data_ind_conv_qmi2ril w/%d", result);
                  break;
               }
               if (evt_post_info[0].engaged && !qmi_ril_is_qmi_sys_info_available())
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
                  is_post_registered = qcril_qmi_nas_is_considered_registered(NULL);
                  if (( is_post_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update ) && !is_pre_registered )
                  {
                     qcril_qmi_nas_send_known_signal_strength();
                  }
               }
               break;

             case QMI_NAS_CURRENT_PLMN_NAME_IND_V01:
                result = qcril_qmi_nas_current_plmn_name_ind_conv_qmi2ril(
                          (nas_current_plmn_name_ind_msg_v01*) decoded_payload,
                          &evt_post_info[0].engaged );
                if ( result != E_SUCCESS ) {
                   QCRIL_LOG_ERROR("Failed current_plmn_name_ind_conv_qmi2ril w/%d", result);
                   break;
                }
                if (evt_post_info[0].engaged)
                {
                   evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
                   is_post_registered = qcril_qmi_nas_is_considered_registered(NULL);
                   if ( ( is_post_registered || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update ) && !is_pre_registered )
                   {
                      qcril_qmi_nas_send_known_signal_strength();
                   }
                }
                break;

            case QMI_NAS_CSP_PLMN_MODE_BIT_IND_MSG_V01:
               // no handling
               break;

            case QMI_NAS_DUAL_STANDBY_PREF_IND_MSG_V01:
               qcril_qmi_nas_dsds_dual_standby_pref_ind_handler( (nas_dual_standby_pref_ind_msg_v01*) decoded_payload );
               break;

            case QMI_NAS_SUBSCRIPTION_INFO_IND_MSG_V01:
               qcril_qmi_nas_subscription_info_ind_handler( (nas_subscription_info_ind_msg_v01*) decoded_payload );
               break;

            case QMI_NAS_NETWORK_TIME_IND_MSG_V01:
               qcril_qmi_nas_network_time_ind_conv_qmi2ril(
                               (nas_network_time_ind_msg_v01*) decoded_payload,
                               ril_nitz_time, &evt_post_info[0].engaged);
               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_NITZ_TIME_RECEIVED;
                  evt_post_info[0].ril_evt_payload = ril_nitz_time;
                  evt_post_info[0].ril_evt_payload_len = strlen(ril_nitz_time) + 1;
               }
               break;

            case QMI_NAS_LTE_SIB16_NETWORK_TIME_IND_V01:
               qcril_qmi_nas_sib16_network_time_ind_hdlr((nas_lte_sib16_network_time_ind_msg_v01*) decoded_payload);
               break;

            case QMI_NAS_RTRE_CONFIG_IND_V01:
               qcril_qmi_nas_rtre_config_ind_conv_qmi2ril(
                               (nas_rtre_cfg_ind_msg_v01*) decoded_payload,
                               &sub_source, &evt_post_info[0].engaged);
               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED;
                  evt_post_info[0].ril_evt_payload = &sub_source;
                  evt_post_info[0].ril_evt_payload_len = sizeof(sub_source);
               }
               break;

            case QMI_NAS_MANAGED_ROAMING_IND_MSG_V01:
               qcril_qmi_nas_managed_roaming_ind_handler( &evt_post_info[0].engaged );
               if ( evt_post_info[0].engaged )
               {
                  evt_post_info[0].ril_evt = RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED;
               }
               break;

            case QMI_NAS_EMBMS_STATUS_IND_V01:
               qcril_qmi_nas_embms_embms_status_ind_handler( (nas_embms_status_ind_msg_v01*)decoded_payload );
               break;

           case QMI_NAS_RF_BAND_INFO_IND_V01:
              qcril_qmi_nas_rf_band_info_ind_handler( (nas_rf_band_info_ind_msg_v01*)decoded_payload );
              break;

            case QMI_NAS_SET_BUILTIN_PLMN_LIST_IND_MSG_V01:
              qcril_qmi_nas_set_builtin_plmn_list_ind_handler( (nas_set_builtin_plmn_list_ind_msg_v01*)decoded_payload );
            break;

            case QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_IND_MSG_V01:
              qcril_qmi_nas_perform_incremental_network_scan_ind_handler( (nas_perform_incremental_network_scan_ind_msg_v01*)decoded_payload );
              break;

           case QMI_NAS_GET_SERV_CELL_SIB_IND_MSG_V01:
              qcril_qmi_nas_get_serv_cell_sib_ind_handler((nas_get_serv_cell_sib_ind_msg_v01*)decoded_payload);
              break;

            default:
               break;
         } // end_switch

         qcril_free( decoded_payload );

      } // end_else process event w/payload

      // submit events
      QCRIL_LOG_INFO(".. operational state %d",
                      (int) qmi_ril_get_operational_status() );

      if ( qmi_ril_get_operational_status() != QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED &&
           QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag )
      {
         /* Allow RIL_UNSOL_VOICE_RADIO_TECH_CHANGED in restricted state.
         ** This is required when device is in limited service (3gpp)/service(3gpp2)
         ** to propogate RIL_UNSOL_VOICE_RADIO_TECH_CHANGED to telephony. */
         for ( idx = 0; idx < MAX_NOF_NAS_EVT_POST_REC; idx++ )
         {
            if ( evt_post_info[idx].engaged && (evt_post_info[idx].ril_evt != NAS_NIL) )
            {
                if ( RIL_UNSOL_VOICE_RADIO_TECH_CHANGED == evt_post_info[idx].ril_evt )
                {
                    qcril_qmi_nas_initiate_voice_rte_change_propagation();
                }
            }
         }

        QCRIL_LOG_INFO("Restricted state! Exiting.. ");
        break;
      }

      // post events
      for ( idx = 0; idx < MAX_NOF_NAS_EVT_POST_REC; idx++ )
      {
         if ( evt_post_info[idx].engaged && (evt_post_info[idx].ril_evt != NAS_NIL) )
         {   // we got something to say

             if ( RIL_UNSOL_VOICE_RADIO_TECH_CHANGED != evt_post_info[idx].ril_evt )
             {
                qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                  evt_post_info[idx].ril_evt, &unsol_resp_params );
                unsol_resp_params.resp_pkt = evt_post_info[idx].ril_evt_payload;
                unsol_resp_params.resp_len = evt_post_info[idx].ril_evt_payload_len;
                qcril_send_unsol_response( &unsol_resp_params );

                QCRIL_LOG_INFO("posted RIL indication %d",
                                (int) evt_post_info[idx].ril_evt );
             }
             else
             {
                qcril_qmi_nas_initiate_voice_rte_change_propagation();
             }
         }
      } // end_for

   } while(0);

   if( qmi_callback && qmi_callback->data_buf )
   {
     qcril_free(qmi_callback->data_buf);
   }

   QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_unsolicited_indication_cb_helper

//===========================================================================
//qcril_qmi_dms_save_prl_info
//===========================================================================
void qcril_qmi_dms_save_prl_info(int prl_version_is_set, uint16_t prl_version)
{
    QCRIL_LOG_INFO("prl_version_is_set %d, prl_version %d",prl_version_is_set,prl_version);

    NAS_CACHE_LOCK();
    nas_cached_info.prl_version_is_set = prl_version_is_set;
    nas_cached_info.prl_version = prl_version;

    if( TRUE == prl_version_is_set && TRUE == qcril_qmi_voice_is_emergency_call_pending())
    {
        qcril_qmi_voice_set_emergency_call_pending(FALSE);
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_VOICE_EMERGENCY_CALL_PENDING,
                       NULL,
                       NAS_NIL,
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
}// qcril_qmi_dms_save_prl_info

//===========================================================================
//qcril_qmi_dms_is_prl_info_available
//===========================================================================
int qcril_qmi_dms_is_prl_info_available(uint16_t * prl_version)
{
    int ret;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    ret = nas_cached_info.prl_version_is_set;
    if( TRUE == nas_cached_info.prl_version_is_set && NULL != prl_version )
    {
        *prl_version = nas_cached_info.prl_version;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}// qcril_qmi_dms_is_prl_info_available

//===========================================================================
//dms evt report update
//===========================================================================
int qcril_qmi_nas_dms_event_report_qmi2ril(dms_event_report_ind_msg_v01 * qmi_msg,
                                                  int * radio_state_updated
                                                )
{
  int common_modem_state_update   = FALSE;
  int operating_state_update      = FALSE;
  int follow_up_deferred_mode_set = FALSE;
  uint8_t modem_stack_id = (uint8_t) qcril_qmi_nas_get_modem_stack_id();

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_INFO("oprt %d / %d", qmi_msg->operating_mode_valid, qmi_msg->operating_mode );
  QCRIL_LOG_INFO("prl_init %d / %d", qmi_msg->prl_init_valid, qmi_msg->prl_init );

  if ( qmi_msg )
  {
    if (qmi_msg->multisim_capability_valid == TRUE )
    {
        QCRIL_LOG_INFO(" max_subscriptions %d ", (int) qmi_msg->multisim_capability.max_subscriptions);
        NAS_CACHE_LOCK();
        nas_dms_cached_info.max_subscriptions = qmi_msg->multisim_capability.max_subscriptions;
        if ( qmi_msg->multisim_capability.subscription_config_list_len > 0 )
        {
          QCRIL_LOG_INFO(" max_subscriptions_active %d ", (int) qmi_msg->multisim_capability.subscription_config_list[0].max_active );
          // Currently max_active will be uniform for all config in config list.
          // So, pick first config type.
          nas_dms_cached_info.max_subscriptions_active = qmi_msg->multisim_capability.subscription_config_list[0].max_active;
          if ( qmi_ril_get_process_instance_id() == QCRIL_DEFAULT_INSTANCE_ID )
          {
            qcril_qmi_nas_dms_update_multisim_config_property();
          }
        }
        NAS_CACHE_UNLOCK();
    }

    if ( qmi_msg->max_active_data_subscriptions_valid == TRUE )
    {
        QCRIL_LOG_DEBUG("[MSIM] Max Active Data : %d", qmi_msg->max_active_data_subscriptions);
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_dms_cached_info.max_active_data_subs,
                                       qmi_msg->max_active_data_subscriptions);
        NAS_CACHE_UNLOCK();
        // Unsol modem capability shall be sent only for change in max data subscription.
        if ( nas_dms_cached_info.max_active_data_subs != qmi_msg->max_active_data_subscriptions )
        {
            qcril_qmi_nas_send_unsol_modem_capability();
        }
    }
    // Handle sub/stack capability for msim
    if ( qmi_msg->subs_voice_data_capability_valid == TRUE )
    {
        NAS_CACHE_LOCK();
        QCRIL_LOG_DEBUG("[MSIM] Current sub voice data capability %d ", (int) qmi_msg->subs_voice_data_capability[modem_stack_id].subs_voice_data_capability);
        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.subs_voice_data_capability, qmi_msg->subs_voice_data_capability[modem_stack_id].subs_voice_data_capability );
        NAS_CACHE_UNLOCK();
    }

    if ( qmi_msg->operating_mode_valid )
    {
        NAS_CACHE_LOCK();
        NAS_CACHE_STORE_TINY_ENTRY( nas_dms_cached_info.operating_mode, qmi_msg->operating_mode );
        if ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode && nas_cached_info.deferred_mode_pref_set_valid )
        {
            follow_up_deferred_mode_set = TRUE;
        }
        NAS_CACHE_UNLOCK();

        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_COMMON_IND_SUBSCRIBE_CONSIDER_ACTION,
                       NULL,
                       NAS_NIL,
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

        if( qmi_msg->operating_mode == DMS_VAL_FACTORY_TEST_MODE )
        {
            common_modem_state_update = TRUE;
            operating_state_update = TRUE;
        }
        else
        {
            qcril_qmi_nas_dms_op_state_update_handler(qmi_msg->operating_mode);
        }

        if ( DMS_OP_MODE_ONLINE_V01 == qmi_msg->operating_mode )
        {
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                           QCRIL_DEFAULT_MODEM_ID,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_RIL_POST_OPRT_ONLINE_ACTION,
                           NULL,
                           NAS_NIL,
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        }
    }

    if ( qmi_msg->prl_init_valid && qmi_msg->prl_init )
    { // initiate recheck if PRL ver has changed or not
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_CHECK_PRL_VER_CHANGE,
                       NULL,
                       NAS_NIL,
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
  }

    NAS_CACHE_LOCK();

    if ( common_modem_state_update )
    {
        qcril_qmi_nas_dms_update_common_modem_state();
    }

    NAS_CACHE_UNLOCK();

    *radio_state_updated = operating_state_update;

    if ( follow_up_deferred_mode_set )
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_ENFORCE_DEFERRED_MODE_PREF_SET,
                       NULL,
                       NAS_NIL,
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }

    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
}

//===========================================================================
//qcril_qmi_nas_dms_fetch_cur_prl_version
//===========================================================================
RIL_Errno qcril_qmi_nas_dms_fetch_cur_prl_version(uint16_t * prl_version)
{
    qmi_client_error_type qmi_client_error;
    dms_get_current_prl_info_resp_msg_v01  qmi_current_prl_info_response;

    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    memset(&qmi_current_prl_info_response, 0, sizeof(qmi_current_prl_info_response) );

    if ( prl_version )
    {
        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                         QMI_DMS_GET_CURRENT_PRL_INFO_REQ_V01,
                                                         NULL, // no request payload for QMI_DMS_GET_CURRENT_PRL_INFO_REQ_V01
                                                         NAS_NIL,
                                                         (void*) &qmi_current_prl_info_response,
                                                         sizeof( qmi_current_prl_info_response ),
                                                         QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_current_prl_info_response.resp );
        if ( RIL_E_SUCCESS == res )
        {
            if( TRUE == qmi_current_prl_info_response.prl_version_valid )
            {
              *prl_version = qmi_current_prl_info_response.prl_version;
              QCRIL_LOG_INFO( ".. Current prl_version  %d", (int) qmi_current_prl_info_response.prl_version );
            }
            else
            {
              QCRIL_LOG_INFO("Current PRL info unavailable" );
              res = RIL_E_GENERIC_FAILURE;
            }
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res );
    return res;
}

//===========================================================================
//qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed
//===========================================================================
void qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed(void)
{
    int is_set;

    is_set = qcril_qmi_dms_is_prl_info_available(NULL);

    QCRIL_LOG_INFO("is_set: %d", (int) is_set );
    if ( !is_set )
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_PRL_VER_FETCH_ATTEMPT,
                       NULL,
                       NAS_NIL,
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }

} // qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed

//===========================================================================
// QCRIL_EVT_QMI_RIL_PRL_VER_FETCH_ATTEMPT
//===========================================================================
void qcril_qmi_nas_dms_handle_fetch_prl_request
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_NOTUSED( params_ptr );
    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_dms_handle_prl_change_helper();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_handle_fetch_prl_request

//===========================================================================
// QCRIL_EVT_QMI_RIL_CHECK_PRL_VER_CHANGE
//===========================================================================
void qcril_qmi_nas_dms_handle_check_prl_ver_change
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  QCRIL_NOTUSED( params_ptr );
  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_nas_dms_handle_prl_change_helper();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_handle_fetch_prl_request

//===========================================================================
// qcril_qmi_nas_dms_handle_prl_change_helper
//===========================================================================
void qcril_qmi_nas_dms_handle_prl_change_helper()
{
  uint16_t    prl_version;
  RIL_Errno   res;

  uint16_t    previous_prl_version;
  int         previous_prl_version_was_set;

  int                          prl_payload;
  qcril_unsol_resp_params_type unsol_resp;


  QCRIL_LOG_FUNC_ENTRY();

  res = qcril_qmi_nas_dms_fetch_cur_prl_version( &prl_version );
  if ( RIL_E_SUCCESS == res )
  {
      previous_prl_version_was_set = qcril_qmi_dms_is_prl_info_available(&previous_prl_version);
      qcril_qmi_dms_save_prl_info(TRUE, prl_version);

      QCRIL_LOG_INFO( "prl ver prev %d, ver cur %d, was set %d ", (int) previous_prl_version, (int)prl_version, previous_prl_version_was_set  );

      if ( FALSE == previous_prl_version_was_set || previous_prl_version != prl_version )
      {
            qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                             (int) RIL_UNSOL_CDMA_PRL_CHANGED,
                                             &unsol_resp );
            prl_payload         = prl_version;
            unsol_resp.resp_pkt = (void *) &prl_payload;
            unsol_resp.resp_len = sizeof( prl_payload );
            qcril_send_unsol_response( &unsol_resp );
      }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_handle_prl_change_helper


//===========================================================================
//qcril_qmi_nas_dms_op_state_update_handler
//===========================================================================
void qcril_qmi_nas_dms_op_state_update_handler(dms_operating_mode_enum_v01 new_op_state)
{
    RIL_Errno   res = RIL_E_GENERIC_FAILURE;

    qcril_reqlist_public_type             qcril_req_info;
    errno_enum_type                       found_qcril_request;
    qcril_request_resp_params_type        resp;
    qcril_instance_id_e_type  cur_instance;
    int operating_mode_match;

    QCRIL_LOG_FUNC_ENTRY();

    operating_mode_match = FALSE;

    if( new_op_state >= NAS_DMS_OP_MODE_START && new_op_state <= NAS_DMS_OP_MODE_END)
    {
        QCRIL_LOG_ESSENTIAL("reported op mode %s", dms_op_mode_name[new_op_state]);
    }

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  QCRIL_EVT_QMI_REQUEST_POWER_RADIO,
                                  &qcril_req_info );

    QCRIL_LOG_INFO("found qcril request %d", (int) found_qcril_request);

    if( E_SUCCESS == found_qcril_request )
    {
        if( qcril_req_info.sub.nas.required_operating_mode >= NAS_DMS_OP_MODE_START && qcril_req_info.sub.nas.required_operating_mode <= NAS_DMS_OP_MODE_END)
        {
            QCRIL_LOG_ESSENTIAL("expected op mode %s", dms_op_mode_name[qcril_req_info.sub.nas.required_operating_mode]);
        }

        if( qcril_req_info.sub.nas.required_operating_mode == new_op_state )
        {
            operating_mode_match = TRUE;
            RADIO_POWER_LOCK();
            if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM == nas_common_info.radio_pwr_signal_cond )
            {
                RADIO_POWER_SIGNAL();
                nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            }
            RADIO_POWER_UNLOCK();
        }
    }
    else
    {
        if( nas_common_info.prov_emer_call_in_lpm )
        {
            RADIO_POWER_LOCK();
            QCRIL_LOG_INFO("current state %d", nas_common_info.radio_pwr_prov_emer_call_lpm_state);
            if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE == nas_common_info.radio_pwr_prov_emer_call_lpm_state )
            {
                if( nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode >= NAS_DMS_OP_MODE_START && nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode <= NAS_DMS_OP_MODE_END)
                {
                    QCRIL_LOG_ESSENTIAL("expected op mode %s", dms_op_mode_name[nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode]);
                }
                if( nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode == new_op_state)
                {
                    operating_mode_match = TRUE;
                    nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE;
                    if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM == nas_common_info.radio_pwr_signal_cond )
                    {
                        RADIO_POWER_SIGNAL();
                        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                    }
                }
            }
            RADIO_POWER_UNLOCK();
        }
        if( nas_common_info.relay_oprt_change )
        {
            qcril_qmi_nas_initiate_radio_state_changed_ind();
        }
    }

    if( FALSE == operating_mode_match )
    {
        QCRIL_LOG_INFO("reported op mode does not match with expected op mode");
    }

    if( DMS_OP_MODE_ONLINE_V01 != new_op_state )
    {
        qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
        qcril_qmi_arb_reset_pref_data_snapshot();
        qcril_qmi_drop_sig_info_cache();
        NAS_CACHE_LOCK();
        qcril_qmi_nas_update_data_rte();
        qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
        NAS_CACHE_UNLOCK();

        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_dms_op_state_update_handler

typedef struct
{
  uint16                      sid;
  uint16                      nid;
  uint16                      mnc;
  uint16                      mcc;
} sdprl_sid_nid_pair_type;

//===========================================================================
//QCRIL_EVT_HOOK_CDMA_GET_AVOIDANCE_LIST
//===========================================================================
void qcril_qmi_nas_get_cdma_avoid_system_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    int i = 0;
    qmi_client_error_type qmi_client_error;
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_request_resp_params_type resp;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    int result_array[NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01*4+1];
    sdprl_sid_nid_pair_type temp[NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01];
    nas_get_cdma_avoid_system_list_resp_msg_v01 cdma_get_avoid_info_list_resp;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    do
    {
        if( NULL == params_ptr )
            break;

        instance_id = params_ptr->instance_id;
        if( instance_id >= QCRIL_MAX_INSTANCE_ID )
            break;

        modem_id = params_ptr->modem_id;
        if( modem_id >= QCRIL_MAX_MODEM_ID )
            break;

        memset(result_array, 0, sizeof(result_array));
        memset(temp, 0, sizeof(temp));
        memset(&cdma_get_avoid_info_list_resp, 0, sizeof(cdma_get_avoid_info_list_resp));
        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS),
                                                     QMI_NAS_GET_CDMA_AVOID_SYSTEM_LIST_REQ_MSG_V01,
                                                     NULL,
                                                     QMI_RIL_ZERO,
                                                     (void*) &cdma_get_avoid_info_list_resp,
                                                     sizeof( cdma_get_avoid_info_list_resp ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

        QCRIL_LOG_INFO("qmi_client_error=%d",qmi_client_error);
        if (qmi_client_error != QMI_NO_ERR)
        {
            qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
            qcril_send_request_response( &resp );
            break;
        }

        QCRIL_LOG_INFO("nam1_systems_valid=%d",cdma_get_avoid_info_list_resp.nam1_systems_valid);
        if( TRUE == cdma_get_avoid_info_list_resp.nam1_systems_valid )
        {
            QCRIL_LOG_INFO("nam1_systems_len=%d",cdma_get_avoid_info_list_resp.nam1_systems_len);
            ril_req_res = RIL_E_SUCCESS;
            memcpy(temp, cdma_get_avoid_info_list_resp.nam1_systems, sizeof(temp));
            result_array[0] = cdma_get_avoid_info_list_resp.nam1_systems_len;
            for (i = 0; i < NAS_MAX_CDMA_SYSTEMS_AVOIDED_V01; i++)
            {
                result_array[i*4+1] = temp[i].sid;
                result_array[i*4+2] = temp[i].nid;
                result_array[i*4+3] = temp[i].mnc;
                result_array[i*4+4] = temp[i].mcc;
            }
        }

        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );

        resp.resp_pkt = (void *) result_array;
        resp.resp_len = sizeof( result_array);
        qcril_send_request_response( &resp );
    }while(FALSE);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_get_cdma_avoid_system_list

/*==========================================================================
  QCRIL_EVT_HOOK_CDMA_AVOID_CUR_NWK
===========================================================================
  FUNCTION: qcril_qmi_nas_cdma_avoid_system
=========================================================================*/
void qcril_qmi_nas_cdma_avoid_system
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;

  nas_cdma_avoid_system_req_msg_v01 cdma_avoid_info;
  nas_cdma_avoid_system_resp_msg_v01 qmi_response;
  qcril_request_resp_params_type resp;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_transport_error;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    memset(&cdma_avoid_info, 0, sizeof(cdma_avoid_info));
    memset(&qmi_response, 0, sizeof(qmi_response));

    if( NULL == params_ptr )
      break;

    instance_id = params_ptr->instance_id;
    if( instance_id >= QCRIL_MAX_INSTANCE_ID )
      break;

    modem_id = params_ptr->modem_id;
    if( modem_id >= QCRIL_MAX_MODEM_ID )
      break;

    QCRIL_NOTUSED( ret_ptr );

    cdma_avoid_info.avoid_type = NAS_AVOID_SYS_IDLE_V01;

    QCRIL_LOG_INFO("Avoid Type:%d",cdma_avoid_info.avoid_type);

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_CDMA_AVOID_SYSTEM_REQ_MSG_V01,
                                                    &cdma_avoid_info,
                                                    sizeof(cdma_avoid_info),
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

    QCRIL_LOG_INFO("%s  qmi_transport_error:%d","AVOID CDMA SYSTEM ",qmi_transport_error);
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_transport_error, &qmi_response.resp );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_cdma_avoid_system

/*==========================================================================
  QCRIL_EVT_HOOK_CDMA_CLEAR_AVOIDANCE_LIST
===========================================================================
  FUNCTION: qcril_qmi_nas_cdma_clear_avoid_list
=========================================================================*/
void qcril_qmi_nas_cdma_clear_avoid_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;

  nas_cdma_avoid_system_req_msg_v01 cdma_avoid_info;
  nas_cdma_avoid_system_resp_msg_v01 qmi_response;
  qcril_request_resp_params_type resp;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_transport_error;

  QCRIL_LOG_FUNC_ENTRY();
  do
  {
    memset(&cdma_avoid_info, 0, sizeof(cdma_avoid_info));
    memset(&qmi_response, 0, sizeof(qmi_response));

    if( NULL == params_ptr )
      break;

    instance_id = params_ptr->instance_id;
    if( instance_id >= QCRIL_MAX_INSTANCE_ID )
      break;

    modem_id = params_ptr->modem_id;
    if( modem_id >= QCRIL_MAX_MODEM_ID )
      break;

    QCRIL_NOTUSED( ret_ptr );

    cdma_avoid_info.avoid_type = NAS_AVOID_SYS_CLR_LIST_V01;
    QCRIL_LOG_INFO("Clear Avoid Type:%d",cdma_avoid_info.avoid_type);

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_CDMA_AVOID_SYSTEM_REQ_MSG_V01,
                                                    &cdma_avoid_info,
                                                    sizeof(cdma_avoid_info),
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

    QCRIL_LOG_INFO("%s  qmi_transport_error:%d","CLEAR AVOID CDMA LIST ",qmi_transport_error);
    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_transport_error, &qmi_response.resp );
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
    qcril_send_request_response( &resp );
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_cdma_clear_avoid_list

//===========================================================================
//QCRIL_EVT_HOOK_SET_BUILTIN_PLMN_LIST
//===========================================================================
void qcril_qmi_nas_set_builtin_plmn_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  nas_set_builtin_plmn_list_req_msg_v01 req_msg;
  uint8 set_builtin_plmn_req[QCRIL_QMI_NAS_MAX_OPLMN_LIST];
  uint16 no_of_oplmn = 0;
  RIL_Errno result = RIL_E_SUCCESS;
  qmi_client_error_type qmi_client_error;
  nas_set_builtin_plmn_list_resp_msg_v01  qmi_response;
  qcril_request_resp_params_type resp;
  qcril_reqlist_public_type qcril_req_info_ptr;
  int oem_data_len = 0, i, j=0;
  nas_set_builtin_plmn_list_ind_msg_v01 plmn_list_ind;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  do
  {

    if( NULL ==  params_ptr->data || 0 == params_ptr->datalen )
    {
      result = RIL_E_GENERIC_FAILURE;
      break;
    }

    oem_data_len = params_ptr->datalen;
    QCRIL_LOG_DEBUG ("oem_data_len = %d",oem_data_len);
    memset(&req_msg,0,sizeof(nas_set_builtin_plmn_list_req_msg_v01));
    memset(&set_builtin_plmn_req,0,oem_data_len);
    memcpy(&set_builtin_plmn_req, (void*)params_ptr->data, oem_data_len);
    memcpy(&no_of_oplmn, (void *)&set_builtin_plmn_req[0], sizeof(uint16));

    QCRIL_LOG_DEBUG ("No. of OPLMN = %d", no_of_oplmn);

    if (no_of_oplmn > 0)
    {
      req_msg.oplmn_list_valid = TRUE;
      req_msg.oplmn_list.list_id = (intptr_t)params_ptr->t;
      // total_list_entries may vary only when we send multiple oplmn lists.
      // Currently Android will send only max 500 entries.
      req_msg.oplmn_list.total_list_entries = no_of_oplmn;
      req_msg.oplmn_list.oplmn_len = no_of_oplmn;
    }
    else
    {
      result = RIL_E_GENERIC_FAILURE;
      break;
    }

    for ( i = 0; i < oem_data_len; )
    {
      if (j < no_of_oplmn)
      {
        memcpy (&req_msg.oplmn_list.oplmn[j].plmn, (void *)&set_builtin_plmn_req[i + 2], 3);
        memcpy (&req_msg.oplmn_list.oplmn[j].access_tech, (void *)&set_builtin_plmn_req[i + 5], 2);
        j++;
      }
      i = i + 5;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                 QCRIL_EVT_HOOK_SET_BUILTIN_PLMN_LIST,
                                 NULL,
                                 &qcril_req_info_ptr );
    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) == E_SUCCESS )
    {
      memset(&qmi_response,0,sizeof(qmi_response));
      qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                               QMI_NAS_SET_BUILTIN_PLMN_LIST_REQ_MSG_V01,
                                               &req_msg,
                                               NAS_ZERO,
                                               (void*) &qmi_response,
                                               sizeof( qmi_response ),
                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

      result = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;

      if ( RIL_E_SUCCESS == result )
      {
        if (qmi_response.resp.result != QMI_RESULT_SUCCESS_V01)
        {
          QCRIL_LOG_ERROR("Set Built-in PLMN request,QMI Result = %d,error=%d\n", qmi_response.resp.result,qmi_response.resp.error);
          result =  RIL_E_GENERIC_FAILURE;
        }
        else
        {
          QCRIL_LOG_DEBUG("Waiting for Set Buil-in PLMN indication from QMI-NAS..");
        }
      }
      else
      {
        result =  RIL_E_GENERIC_FAILURE;
      }
    }
    else
    {
      result =  RIL_E_GENERIC_FAILURE;
    }
  } while (FALSE);

  if (result == RIL_E_GENERIC_FAILURE)
  {
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           result,
                                           &resp );
    qcril_send_request_response( &resp );
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_builtin_plmn_list

void qcril_qmi_nas_set_builtin_plmn_list_ind_handler
(
nas_set_builtin_plmn_list_ind_msg_v01* plmn_list_ind
)
{
  qcril_reqlist_public_type qcril_req_info;
  errno_enum_type           found_qcril_request;
  RIL_Errno result = RIL_E_SUCCESS;
  qcril_request_resp_params_type resp;

  QCRIL_LOG_FUNC_ENTRY();

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_HOOK_SET_BUILTIN_PLMN_LIST,
                                                      &qcril_req_info );

  if ( E_SUCCESS == found_qcril_request )
  {
    if ( plmn_list_ind && plmn_list_ind->error != QMI_ERR_NONE_V01 )
    {
      result = RIL_E_GENERIC_FAILURE;
    }
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                   qcril_req_info.t,
                                                   qcril_req_info.request,
                                                   result,
                                                   &resp );
    qcril_send_request_response( &resp );
  }
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_set_builtin_plmn_list_ind_handler

//===========================================================================
//qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp
//===========================================================================
void qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp()
{
    char* sw_version_property = "ro.build.display.id";
    qmi_client_error_type qmi_transport_error;
    dms_set_ap_sw_version_req_msg_v01 device_sw_ver_info;
    dms_set_ap_sw_version_resp_msg_v01 qmi_response;
    char args[ PROPERTY_VALUE_MAX ];

    QCRIL_LOG_FUNC_ENTRY();

    memset(args,0,sizeof(args));
    memset(&device_sw_ver_info,0,sizeof(device_sw_ver_info));
    memset(&qmi_response,0,sizeof(qmi_response));
    property_get(sw_version_property,args,"123456");
    strlcpy( device_sw_ver_info.ap_sw_version, args, QMI_DMS_SW_VERSION_MAX_V01 );
    QCRIL_LOG_INFO( "length of SW Version string %d", strlen(device_sw_ver_info.ap_sw_version));
    QCRIL_LOG_INFO( "size of SW Version string %d", sizeof(device_sw_ver_info.ap_sw_version));

    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                    QMI_DMS_SET_AP_SW_VERSION_REQ_V01,
                                                    &device_sw_ver_info,
                                                    sizeof(device_sw_ver_info),
                                                    &qmi_response,
                                                    sizeof(qmi_response),
                                                    QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

    QCRIL_LOG_INFO( "QMI_DMS_SET_AP_SW_VERSION_REQ_V01 transport error code %d", qmi_transport_error);
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_send_ap_sw_ver_info_to_mp

//===========================================================================
//operator name data ind
//===========================================================================
int qcril_qmi_nas_operator_name_data_ind_conv_qmi2ril(nas_operator_name_data_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated
                                                )
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    *network_state_updated = qmi_msg->service_provider_name_valid   ||
                             qmi_msg->operator_plmn_list_valid      ||
                             qmi_msg->plmn_network_name_valid       ||
                             qmi_msg->plmn_name_valid               ||
                             qmi_msg->nitz_information_valid;

    NAS_CACHE_STORE_ENTRY( nas_cached_info.service_provider_name,  qmi_msg->service_provider_name );
    NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.operator_plmn_list, qmi_msg->operator_plmn_list );
    NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.plmn_network_name,  qmi_msg->plmn_network_name );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.plmn_name,  qmi_msg->plmn_name );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.nitz_information,  qmi_msg->nitz_information );

    QCRIL_LOG_INFO( "service_provider_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.service_provider_name ) );
    QCRIL_LOG_INFO( "operator_plmn_list cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.operator_plmn_list ) );
    QCRIL_LOG_INFO( "plmn_network_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_network_name ) );
    QCRIL_LOG_INFO( "plmn_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_name ) );
    QCRIL_LOG_INFO( "nitz_information cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) );

    qcril_qmi_nas_nitz_persistent_cache_update();

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
}

//===========================================================================
//current plmn name ind
//===========================================================================
int qcril_qmi_nas_current_plmn_name_ind_conv_qmi2ril(nas_current_plmn_name_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated
                                               )
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    *network_state_updated = qmi_msg->plmn_id_valid     ||
                             qmi_msg->short_name_valid  ||
                             qmi_msg->long_name_valid;

    NAS_CACHE_STORE_ENTRY( nas_cached_info.plmn_id,  qmi_msg->plmn_id );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.spn,  qmi_msg->spn );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.short_name,  qmi_msg->short_name );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.long_name,  qmi_msg->long_name );

    QCRIL_LOG_INFO( "plmn_id cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id ) );
    QCRIL_LOG_INFO( "spn cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn ) );
    QCRIL_LOG_INFO( "short_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) );
    QCRIL_LOG_INFO( "long_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) );

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
}


//===========================================================================
//qcril_qmi_nas_persist_entry_update
//===========================================================================
IxErrnoType qcril_qmi_nas_persist_entry_update(char const * op_name_to_save, const char ** prop_name_prefix, int prop_name_prefix_domain_size, int prop_name_suffix )
{
    IxErrnoType res = E_FAILURE;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];

    int op_name_len;
    int idx;
    int written_len;
    int remaining_len;
    int write_chunk_len;

    char const * op_name_cur_ptr;
    const char ** prop_name_orefix_cur_ptr;


    QCRIL_LOG_INFO("op_name_to_save: %s", op_name_to_save);

    if( NULL != op_name_to_save )
    {
        op_name_len = strlen( op_name_to_save );
        written_len = 0;
        op_name_cur_ptr = op_name_to_save;
        prop_name_orefix_cur_ptr = prop_name_prefix;
        res = E_SUCCESS;

        for ( idx = 0 ; idx < prop_name_prefix_domain_size ; idx++ )
        {
            *property_value = 0;
            remaining_len = op_name_len - written_len;
            if ( remaining_len > 0 )
            {
              if ( remaining_len >= (PROPERTY_VALUE_MAX-1) )
              {
                write_chunk_len = PROPERTY_VALUE_MAX - 1;
              }
              else
              {
                write_chunk_len = remaining_len;
              }

              memcpy( property_value, op_name_cur_ptr, write_chunk_len );
              property_value[ write_chunk_len ] = '\0';
              op_name_cur_ptr += write_chunk_len;
              written_len += write_chunk_len;
            }

            snprintf( property_name, sizeof(property_name), "%s%d", *prop_name_orefix_cur_ptr, prop_name_suffix );

            res = property_set( property_name, property_value );

            QCRIL_LOG_INFO(".. iter - # %d, name %s, val %s, res %d", idx, property_name, property_value, (int) res );

            prop_name_orefix_cur_ptr++;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);

    return res;
} // qcril_qmi_nas_persist_entry_update
//===========================================================================
//qcril_qmi_nas_nitz_persistent_cache_update
//===========================================================================
void qcril_qmi_nas_nitz_persistent_cache_update(void)
{
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    char nitz_str_long_buf[512];
    char nitz_str_short_buf[512];
    int moniker;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE],mnc_str[NAS_MCC_MNC_MAX_SIZE];

    IxErrnoType prop_req_err;


    QCRIL_LOG_FUNC_ENTRY();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) && qcril_qmi_nas_find_current_mcc_mnc(mcc_str,mnc_str,TRUE, NULL) )
    {
        moniker = (int)qmi_ril_get_process_instance_id();
        QCRIL_LOG_INFO( ".. updating store for %d", moniker );

        prop_req_err = E_FAILURE;

        do
        {
            // nitz str - long - prepare
            *nitz_str_long_buf = 0;
            qcril_qmi_util_decode_operator_name(nitz_str_long_buf,
                                                NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                nas_cached_info.nitz_information->coding_scheme,
                                                nas_cached_info.nitz_information->long_name,
                                                nas_cached_info.nitz_information->long_name_len);
            QCRIL_LOG_INFO("..nitz long %s", nitz_str_long_buf);

            // nitz str - short - prepare
            *nitz_str_short_buf = 0;
            qcril_qmi_util_decode_operator_name(nitz_str_short_buf,
                                                NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                nas_cached_info.nitz_information->coding_scheme,
                                                nas_cached_info.nitz_information->short_name,
                                                nas_cached_info.nitz_information->short_name_len);
            QCRIL_LOG_INFO("..nitz short %s", nitz_str_short_buf);

            if ( (*nitz_str_long_buf && *nitz_str_short_buf)  || ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_ICS ) && ( *nitz_str_long_buf || *nitz_str_short_buf ) ) )
            { // either both long + short valid, or at least one valid for ICS
                prop_req_err = qcril_qmi_nas_persist_entry_update( nitz_str_long_buf,
                                                                   qmi_ril_op_name_persist_store_prop_list_long,
                                                                   QCRIL_ARR_SIZE(qmi_ril_op_name_persist_store_prop_list_long),
                                                                   moniker );
                if ( E_SUCCESS != prop_req_err )
                    break;

                prop_req_err = qcril_qmi_nas_persist_entry_update( nitz_str_short_buf,
                                                                   qmi_ril_op_name_persist_store_prop_list_short,
                                                                   QCRIL_ARR_SIZE(qmi_ril_op_name_persist_store_prop_list_short),
                                                                   moniker );
                if ( E_SUCCESS != prop_req_err )
                    break;
            }
            else
            {
                QCRIL_LOG_INFO("..no NITZ info to operate with on given feature set" );
                break;
            }

            // mcc mnc context
            snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_OP_NAME_NITZ_PLMN, moniker );
            snprintf( property_value, sizeof(property_value), "%s %s", mcc_str, mnc_str );
            prop_req_err = property_set( property_name, property_value );

            QCRIL_LOG_INFO( ".. plmn inf %s - %s, %d", property_name, property_value, (int) prop_req_err );

            if ( E_SUCCESS != prop_req_err )
                break;


        } while (FALSE);

        QCRIL_LOG_INFO("..overall push through status %d", (int) prop_req_err);

        if ( E_SUCCESS == prop_req_err )
        { // updated dyncmic cache as well
            prop_req_err = qcril_qmi_nas_update_presist_nitz_cache_shadow( nitz_str_long_buf,
                                                                           nitz_str_short_buf,
                                                                           mcc_str,
                                                                           mnc_str );
        }
    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nitz_persistent_cache_update

//===========================================================================
//qcril_qmi_nas_update_presist_nitz_cache_shadow
//===========================================================================
IxErrnoType qcril_qmi_nas_update_presist_nitz_cache_shadow(char * op_name_long, char * op_name_short, char * op_mcc_str, char * op_mnc_str)
{
    IxErrnoType res = E_SUCCESS;
    char * persist_store_name_long = NULL;
    char * persist_store_name_short = NULL;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO( ".. long %s, short %s, mcc %s, mnc %s", op_name_long, op_name_short, op_mcc_str, op_mnc_str  );

    do
    {
        persist_store_name_long = qcril_malloc( strlen(op_name_long) + 1 );
        if ( persist_store_name_long )
        {
            strlcpy(persist_store_name_long, op_name_long, strlen(op_name_long) + 1);
        }
        else
        {
            res = E_FAILURE;
            break;
        }

        persist_store_name_short = qcril_malloc( strlen(op_name_short) + 1 );
        if ( persist_store_name_short )
        {
            strlcpy(persist_store_name_short, op_name_short, strlen(op_name_short) + 1);
        }
        else
        {
            res = E_FAILURE;
            break;
        }

    } while ( FALSE );

    if ( E_SUCCESS == res )
    {
        if ( nas_cached_info.persistent_cached_nitz_op_name_long )
        {
            qcril_free( nas_cached_info.persistent_cached_nitz_op_name_long );
            nas_cached_info.persistent_cached_nitz_op_name_long = NULL;
        }
        nas_cached_info.persistent_cached_nitz_op_name_long = persist_store_name_long;

        if ( nas_cached_info.persistent_cached_nitz_op_name_short )
        {
            qcril_free( nas_cached_info.persistent_cached_nitz_op_name_short );
            nas_cached_info.persistent_cached_nitz_op_name_short = NULL;
        }
        nas_cached_info.persistent_cached_nitz_op_name_short = persist_store_name_short;

        strlcpy(nas_cached_info.persistent_cached_mobile_country_code,op_mcc_str,sizeof(nas_cached_info.persistent_cached_mobile_country_code));
        strlcpy(nas_cached_info.persistent_cached_mobile_network_code,op_mnc_str,sizeof(nas_cached_info.persistent_cached_mobile_network_code));
    }
    else
    {
        if ( persist_store_name_long )
        {
            qcril_free( persist_store_name_long );
        }
        if ( persist_store_name_short )
        {
            qcril_free( persist_store_name_short );
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);

    return res;
} // qcril_qmi_nas_update_presist_nitz_cache_shadow

//===========================================================================
//qcril_qmi_nas_persist_entry_fetch_to_shadow
//===========================================================================
IxErrnoType qcril_qmi_nas_persist_entry_fetch_to_shadow(char * op_name_to_read, size_t op_name_to_read_size, const char ** prop_name_prefix, int prop_name_prefix_domain_size, int prop_name_suffix )
{
    IxErrnoType res;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];

    int idx;

    const char ** prop_name_orefix_cur_ptr;


    QCRIL_LOG_FUNC_ENTRY();

    prop_name_orefix_cur_ptr = prop_name_prefix;
    res = E_SUCCESS;
    *op_name_to_read = 0;

    for ( idx = 0 ; idx < prop_name_prefix_domain_size && E_SUCCESS == res; idx++ )
    {
        snprintf( property_name, sizeof(property_name), "%s%d", *prop_name_orefix_cur_ptr, prop_name_suffix );
        *property_value = 0;
        property_get( property_name, property_value, "" );
        QCRIL_LOG_INFO(".. prop get iter %d prop %s", idx, property_value );
        if ( E_SUCCESS == res )
        {
            strlcat(op_name_to_read, property_value, op_name_to_read_size);
        }
        prop_name_orefix_cur_ptr++;
    }

    QCRIL_LOG_INFO("res: %d, op_name_to_read: %s", (int)res, op_name_to_read);

    return res;
} // qcril_qmi_nas_persist_entry_fetch_to_shadow

//===========================================================================
//qcril_qmi_nas_nitz_persistent_cache_is_shadow_available
//===========================================================================
int qcril_qmi_nas_nitz_persistent_cache_is_shadow_available(void)
{
    int res = FALSE;
    int long_valid;
    int short_valid;

    long_valid  = ( NULL != nas_cached_info.persistent_cached_nitz_op_name_long && NAS_ZERO != *nas_cached_info.persistent_cached_nitz_op_name_long );
    short_valid = ( NULL != nas_cached_info.persistent_cached_nitz_op_name_short && NAS_ZERO != *nas_cached_info.persistent_cached_nitz_op_name_short );
    if ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_ICS ) )
    {
        res = long_valid || short_valid;
    }
    else
    {
        res = long_valid && short_valid;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_nitz_persistent_cache_is_shadow_available
//===========================================================================
//qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow
//===========================================================================
void qcril_qmi_nas_nitz_persistent_cache_fetch_to_shadow(void)
{
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;
    IxErrnoType prop_req_err;
    char nitz_long_buf[512];
    char nitz_short_buf[512];

    char fetched_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char fetched_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    int sscanf_res;

    QCRIL_LOG_INFO("persistent_cached_nitz_op_name_long: %p, persistent_cached_nitz_op_name_short: %p",
                    nas_cached_info.persistent_cached_nitz_op_name_long,
                    nas_cached_info.persistent_cached_nitz_op_name_short);

    if ( NULL == nas_cached_info.persistent_cached_nitz_op_name_long || NULL == nas_cached_info.persistent_cached_nitz_op_name_short )
    {

        moniker = (int)qmi_ril_get_process_instance_id();
        prop_req_err = E_SUCCESS;

        QCRIL_LOG_INFO( ".. load from prop - %d", (int) moniker );

        do
        {
            // mcc mnc context
            snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_OP_NAME_NITZ_PLMN, moniker );
            prop_req_err = property_get( property_name, property_value, "" );
            QCRIL_LOG_INFO( ".. master mccmnc prop get %d, %s - %s", (int) prop_req_err, property_name, property_value );
            if ( !*property_value )
            {
                prop_req_err = E_FAILURE;
                break;
            }

            memset(fetched_mcc_str,0,sizeof(fetched_mcc_str));
            memset(fetched_mnc_str,0,sizeof(fetched_mnc_str));
            // TBD: use macro pasting so we can use macro here for width as well
            sscanf_res = sscanf(property_value, "%4s %4s", fetched_mcc_str, fetched_mnc_str );
            QCRIL_LOG_INFO( ".. mcc mnc fetch %s-%s, %d", fetched_mcc_str, fetched_mnc_str, sscanf_res );
            if ( sscanf_res != 2 )
            {
                prop_req_err = E_FAILURE;
                break;
            }

            // name long
            prop_req_err = qcril_qmi_nas_persist_entry_fetch_to_shadow( nitz_long_buf,
                                                               sizeof(nitz_long_buf),
                                                               qmi_ril_op_name_persist_store_prop_list_long,
                                                               QCRIL_ARR_SIZE(qmi_ril_op_name_persist_store_prop_list_long),
                                                               moniker  );
            if ( E_SUCCESS != prop_req_err )
                break;

            // name short
            prop_req_err = qcril_qmi_nas_persist_entry_fetch_to_shadow( nitz_short_buf,
                                                               sizeof(nitz_short_buf),
                                                               qmi_ril_op_name_persist_store_prop_list_short,
                                                               QCRIL_ARR_SIZE(qmi_ril_op_name_persist_store_prop_list_short),
                                                               moniker  );
            if ( E_SUCCESS != prop_req_err )
                break;
        } while (FALSE);

        QCRIL_LOG_INFO( ".. prop fetch res %d", (int) prop_req_err );
        if ( E_SUCCESS == prop_req_err  )
        {
            QCRIL_LOG_INFO( ".. long, short fetch %s, %s", nitz_long_buf, nitz_short_buf );
            qcril_qmi_nas_update_presist_nitz_cache_shadow( nitz_long_buf, nitz_short_buf, fetched_mcc_str, fetched_mnc_str );
        }

    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nitz_persistent_cache_fetch_to_dyna_cache

//===========================================================================
//qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow
//===========================================================================
void qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow(void)
{
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;
    IxErrnoType prop_req_err;
    int sscanf_res;
    char tune_away_buf[512];
    char priority_paging_buf[512];
    char *end_ptr;
    unsigned long ret_val;
    QCRIL_LOG_INFO( "dsds_is_tune_away = %d, priority_paging = %d, dsds_is_lte_tune_away = %d",
                     nas_common_info.dsds.is_tune_away, nas_common_info.dsds.paging_priority,
                     nas_common_info.dsds.is_lte_tune_away);

    moniker = (int)qmi_ril_get_process_instance_id();
    prop_req_err = E_SUCCESS;

    QCRIL_LOG_INFO( ".. load from prop - %d", (int) moniker );

    // tune away
    snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_TUNE_AWAY, moniker );
    prop_req_err = property_get( property_name, property_value, "" );
    QCRIL_LOG_INFO( ".. master tuneaway prop get %d, %s - %s", (int) prop_req_err, property_name, property_value );
    nas_common_info.dsds.is_tune_away = NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;

    if ( *property_value )
    {
        ret_val = strtoul( property_value, &end_ptr, 0 );
        if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
        {
          QCRIL_LOG_ERROR( "Fail to convert tune away property values %s", property_value );
        }
        else if ( TRUE != ret_val && FALSE != ret_val )
        {
          QCRIL_LOG_ERROR( "Invalid saved tune away %ld", ret_val );
        }
        else
        {
          nas_common_info.dsds.is_tune_away = ( boolean ) ret_val;
        }
    }
    QCRIL_LOG_INFO( "..  tuneaway value after reading from property %d", (int) nas_common_info.dsds.is_tune_away );

    // priority paging
    snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_PAGING_PRIORITY, moniker );
    prop_req_err = property_get( property_name, property_value, "" );
    QCRIL_LOG_INFO( ".. master priority paging prop get %d, %s - %s", (int) prop_req_err, property_name, property_value );

    nas_common_info.dsds.paging_priority= NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;
    if ( *property_value )
    {
        ret_val = strtoul( property_value, &end_ptr, 0 );
        if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
        {
          QCRIL_LOG_ERROR( "RID %d Fail to convert paging priorty %s", property_value );
        }
        else if ( ( ret_val > NAS_SECONDARY_SUBSCRIPTION_V01 ) || ( ret_val > NAS_PRIMARY_SUBSCRIPTION_V01 ) )
        {
          QCRIL_LOG_ERROR( "RID %d Invalid saved paging priority %ld", ret_val );
        }
        else
        {
          nas_common_info.dsds.paging_priority = ( RIL_SubscriptionType ) ret_val;
        }
    }
    QCRIL_LOG_INFO( "..  paging priority value after reading from property %d", (int) nas_common_info.dsds.paging_priority );

    // lte tune away
    snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_LTE_TUNE_AWAY, moniker );
    qmi_ril_get_property_value_from_integer(property_name,
                                            &nas_common_info.dsds.is_lte_tune_away,
                                            NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE);

    QCRIL_LOG_INFO( "..  lte tuneaway value after reading from property %d", (int) nas_common_info.dsds.is_lte_tune_away );

    nas_common_info.dsds.default_voice_sub= NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;

    nas_common_info.dsds.default_data_sub= NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE;

    nas_common_info.dsds.modem_stack_id = moniker;

    nas_common_info.dsds.is_default_data_set = FALSE;

} // qcril_qmi_nas_dsds_persistent_cache_fetch_to_shadow

//===========================================================================
//qcril_qmi_fetch_system_selection_preference
//===========================================================================
RIL_Errno qcril_qmi_fetch_system_selection_preference(void)
{

    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

    nas_get_system_selection_preference_resp_msg_v01 * qmi_response = NULL;

    qmi_response = qcril_malloc( sizeof( *qmi_response ) );
    if ( qmi_response )
    {

        ril_req_res = qcril_qmi_client_send_msg_sync_ex(  QCRIL_QMI_CLIENT_NAS ,
                                                           QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                           NULL,
                                                           NAS_NIL,  // empty request payload
                                                           (void*) qmi_response,
                                                           sizeof( *qmi_response ),
                                                           QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );


        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.emergency_mode, qmi_response->emergency_mode );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.mode_pref, qmi_response->mode_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.band_pref, qmi_response->band_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prl_pref, qmi_response->prl_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_pref, qmi_response->roam_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.net_sel_pref, qmi_response->net_sel_pref );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gw_acq_order_pref, qmi_response->gw_acq_order_pref );
            NAS_CACHE_STORE_ENTRY_ARR ( nas_cached_info.acq_order, qmi_response->acq_order );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_disable_cause, qmi_response->lte_disable_cause );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.rat_disabled_mask, qmi_response->rat_disabled_mask );

            // If srv_domain_pref is invalid, it means no domain/no srv. Reset the cache.
            if ( qmi_response->srv_domain_pref_valid )
            {
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.srv_domain_pref, qmi_response->srv_domain_pref );
            }
            else
            {
                NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.srv_domain_pref );
            }

            NAS_CACHE_UNLOCK();
        }

        qcril_free( qmi_response );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_fetch_system_selection_preference
//===========================================================================
//qcril_qmi_nas_get_nw_selection_mode
//===========================================================================
RIL_Errno qcril_qmi_nas_get_nw_selection_mode(nas_net_sel_pref_enum_v01 * mode)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    if ( mode )
    {
        if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.net_sel_pref) )
        {
            *mode = nas_cached_info.net_sel_pref;
            QCRIL_LOG_INFO("returning pref %d ", (int) *mode);
            res = RIL_E_SUCCESS;
        }
    }

    return res;
} // qcril_qmi_nas_get_nw_selection_mode
//===========================================================================
//selection preference ind
//===========================================================================
int qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril(nas_system_selection_preference_ind_msg_v01 * qmi_msg,
                                                  int * emergency_mode_entered,
                                                  int * emergency_mode_left
                                                )
{
    qcril_reqlist_public_type                   qcril_req_info;
    errno_enum_type                             found_qcril_request;
    qcril_request_resp_params_type        resp;
    int is_mode_pref_change = FALSE;
    qmi_ril_nas_init_apn_attch_state_e_type cur_attch_state = qcril_qmi_nas_get_init_attch_state();

    is_mode_pref_change = qmi_msg->mode_pref_valid?( nas_cached_info.mode_pref_valid != qmi_msg->mode_pref_valid ):FALSE;
    if( (FALSE == is_mode_pref_change) && qmi_msg->mode_pref_valid )
    {
        is_mode_pref_change = ( nas_cached_info.mode_pref != qmi_msg->mode_pref )? TRUE:FALSE;
    }

    qcril_qmi_nas_embms_send_e911_state_changed_if_needed(qmi_msg->emergency_mode_valid,
            qmi_msg->emergency_mode);

    if ( qmi_msg->emergency_mode_valid )
    {
        *emergency_mode_entered = (qmi_msg->emergency_mode == NAS_CMN_EMERGENCY_MODE_ON) ? TRUE : FALSE;
        *emergency_mode_left    = (qmi_msg->emergency_mode == NAS_CMN_EMERGENCY_MODE_OFF) ? TRUE : FALSE;
    }

    NAS_CACHE_LOCK();
    if ( qmi_msg->mode_pref_valid )
    {
        nas_cached_info.is_indication_received = TRUE;
        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  QCRIL_EVT_QMI_REQUEST_SET_SYS_SEL_PREF,
                                  &qcril_req_info );

        if( E_SUCCESS == found_qcril_request )
        {
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                            qcril_req_info.t,
                                            qcril_req_info.request,
                                            RIL_E_SUCCESS ,
                                            &resp );

            qcril_send_request_response( &resp );
            QCRIL_LOG_INFO( "..Got Entry QCRIL_EVT_QMI_REQUEST_SET_SYS_SEL_PREF in list. Sent response ");
            if( NAS_ZERO != nas_cached_info.sys_sel_pref_tmr )
            {
                qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.sys_sel_pref_tmr);
                nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
            }
        }
    }

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.emergency_mode, qmi_msg->emergency_mode );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.mode_pref, qmi_msg->mode_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.band_pref, qmi_msg->band_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prl_pref, qmi_msg->prl_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_pref, qmi_msg->roam_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_band_pref, qmi_msg->lte_band_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.net_sel_pref, qmi_msg->net_sel_pref );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gw_acq_order_pref, qmi_msg->gw_acq_order_pref );
    NAS_CACHE_STORE_ENTRY_ARR ( nas_cached_info.acq_order, qmi_msg->acq_order );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_disable_cause, qmi_msg->lte_disable_cause );
    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.rat_disabled_mask,
                               qmi_msg->rat_disabled_mask);

    // If srv_domain_pref is invalid, it means no domain/no srv. Reset the cache.
    if ( qmi_msg->srv_domain_pref_valid )
    {
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.srv_domain_pref, qmi_msg->srv_domain_pref );
    }
    else
    {
      NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.srv_domain_pref );
    }

    QCRIL_LOG_INFO( ".. new lte band pref valid %d, value %llx", (int)qmi_msg->lte_band_pref_valid, qmi_msg->lte_band_pref);
    QCRIL_LOG_INFO( ".. new mode pref valid %d, value %d", (int)qmi_msg->mode_pref_valid, (int) qmi_msg->mode_pref );
    QCRIL_LOG_INFO( ".. new net sel pref valid %d, value %d", (int)qmi_msg->net_sel_pref_valid, (int) qmi_msg->net_sel_pref );
    QCRIL_LOG_INFO( ".. new emergency mode valid %d, value %d", (int)qmi_msg->emergency_mode_valid, (int) qmi_msg->emergency_mode );
    QCRIL_LOG_INFO( ".. new prl pref valid %d, value %d", (int)qmi_msg->prl_pref_valid, (int) qmi_msg->prl_pref );
    QCRIL_LOG_INFO( ".. new gw acq order valid %d, value %d", (int)qmi_msg->gw_acq_order_pref_valid, (int) qmi_msg->gw_acq_order_pref );
    QCRIL_LOG_INFO( ".. new srv domain pref valid %d, value %d", (int)qmi_msg->srv_domain_pref_valid, (int) qmi_msg->srv_domain_pref);
    QCRIL_LOG_INFO( ".. new acq order pref valid %d, len %d", (int)qmi_msg->acq_order_valid, (int) qmi_msg->acq_order_len );
    QCRIL_LOG_INFO( ".. new lte disable cause valid %d, value %d", (int)qmi_msg->lte_disable_cause_valid, (int) qmi_msg->lte_disable_cause );
    QCRIL_LOG_INFO( ".. new rat disables mask valid %d, value %d",
                    (int)qmi_msg->rat_disabled_mask_valid,
                    (int)qmi_msg->rat_disabled_mask);

    NAS_CACHE_UNLOCK();

    if ((cur_attch_state == QMI_RIL_NAS_INIT_APN_ATTCH_DETACH) ||
        (cur_attch_state == QMI_RIL_NAS_INIT_APN_ATTCH_ATTACH))
    {
      qcril_qmi_nas_check_initial_attach_state(qmi_msg->srv_domain_pref_valid, qmi_msg->srv_domain_pref);
    }
    else if ((cur_attch_state == QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_DETACH) ||
             (cur_attch_state == QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ATTACH) ||
             (cur_attch_state == QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_WAIT_FOR_RAT_EXP))
    {
      qcril_qmi_nas_check_ps_attach_status();
    }

    if ( TRUE == is_mode_pref_change )
    {
        qcril_qmi_nas_initiate_voice_rte_change_propagation();
    }

    return E_SUCCESS;
} // qcril_qmi_nas_system_selection_preference_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_fill_sys_info_details
//===========================================================================
int qcril_qmi_nas_fill_sys_info_details(nas_sys_info_helper_type * sys_info_helper,
                                        nas_service_status_enum_type_v01 * service_status)
{
    int res = E_SUCCESS;
    switch ( nas_cached_info.voice_rte )
    {
      case QMI_RIL_RTE_1x:
      QCRIL_LOG_INFO( " .. cur rte- CDMA" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
      {
        *service_status = nas_cached_info.cdma_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
      {
        sys_info_helper->common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
        sys_info_helper->cdma_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
      }
      break;

      case QMI_RIL_RTE_GSM:
      QCRIL_LOG_INFO( " .. cur rte- GSM" );
      if ( NAS_CACHE_IS_ENTRY_VALID ( nas_cached_info.gsm_srv_status_info ) )
      {
        *service_status = nas_cached_info.gsm_srv_status_info->srv_status;
        sys_info_helper->threegpp_srv_status  = nas_cached_info.gsm_srv_status_info;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
      {
        sys_info_helper->common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
        sys_info_helper->threegpp_only_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
      }
      break;

      case QMI_RIL_RTE_WCDMA:
      QCRIL_LOG_INFO( " .. cur rte- WCDMA" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
      {
        sys_info_helper->threegpp_srv_status  = nas_cached_info.wcdma_srv_status_info;
        *service_status = nas_cached_info.wcdma_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
      {
        sys_info_helper->common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
        sys_info_helper->threegpp_only_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
      }
      break;

      case QMI_RIL_RTE_TDSCDMA:
      QCRIL_LOG_INFO( " .. cur rte- TDSCDMA" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
      {
          sys_info_helper->threegpp_srv_status  = nas_cached_info.tdscdma_srv_status_info;
          *service_status = nas_cached_info.tdscdma_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
      {
        sys_info_helper->common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
        sys_info_helper->threegpp_only_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
      }
      break;

      case QMI_RIL_RTE_SUB_LTE:
      QCRIL_LOG_INFO( " .. cur rte- LTE" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
      {
        sys_info_helper->threegpp_srv_status  = nas_cached_info.lte_srv_status_info;
        *service_status = nas_cached_info.lte_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
      {
        sys_info_helper->common_sys_info  = &nas_cached_info.lte_sys_info->common_sys_info;
        sys_info_helper->threegpp_only_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
        sys_info_helper->lte_only_sys_info = &nas_cached_info.lte_sys_info->lte_specific_sys_info;
      }
      break;

      case QMI_RIL_RTE_SUB_DO:
      QCRIL_LOG_INFO( " .. cur rte- EVDO" );
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
      {
        *service_status = nas_cached_info.hdr_srv_status_info->srv_status;
      }
      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
      {
        sys_info_helper->common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
        sys_info_helper->cdma_hdr_only_sys_info = &nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info;
        sys_info_helper->hdr_only_sys_info = &nas_cached_info.hdr_sys_info->hdr_specific_sys_info;
      }
      break;

      default:
      QCRIL_LOG_INFO( " .. cur rte- UNKNOWN" );
      res = E_FAILURE;
      break;
    }
    return res;
}

//===========================================================================
//qcril_qmi_nas_fetch_lte_voice_status
//===========================================================================
void qcril_qmi_nas_fetch_lte_voice_status ( uint8_t *lte_voice_status_valid, nas_lte_voice_status_enum_type_v01 *lte_voice_status )
{
    *lte_voice_status = nas_cached_info.lte_voice_status;
    *lte_voice_status_valid = nas_cached_info.lte_voice_status_valid;
}

//===========================================================================
//qcril_qmi_nas_fetch_lte_sms_status
//===========================================================================
void qcril_qmi_nas_fetch_lte_sms_status ( uint8_t *lte_sms_status_valid, nas_sms_status_enum_type_v01 *lte_sms_status )
{
    NAS_CACHE_LOCK();
    *lte_sms_status = nas_cached_info.lte_sms_status;
    *lte_sms_status_valid = nas_cached_info.lte_sms_status_valid;
    NAS_CACHE_UNLOCK();
}

//===========================================================================
//qcril_qmi_nas_lte_voice_status_compare
//===========================================================================
int qcril_qmi_nas_lte_voice_status_compare( uint8_t prev_lte_voice_status_valid, nas_lte_voice_status_enum_type_v01 prev_lte_voice_status )
{
    int status = FALSE;

    status = ( nas_cached_info.lte_voice_status_valid != prev_lte_voice_status_valid )? TRUE:FALSE;

    if( ( FALSE == status ) && nas_cached_info.lte_voice_status_valid )
    {
        status = ( nas_cached_info.lte_voice_status != prev_lte_voice_status )? TRUE:FALSE;
    }

    return status;

}

//===========================================================================
//qcril_qmi_nas_lte_sms_status_compare
//===========================================================================
int qcril_qmi_nas_lte_sms_status_compare( uint8_t prev_lte_sms_status_valid, nas_sms_status_enum_type_v01 prev_lte_sms_status )
{
    int status = FALSE;

    status = ( nas_cached_info.lte_sms_status_valid != prev_lte_sms_status_valid )? TRUE:FALSE;

    if( ( FALSE == status ) && nas_cached_info.lte_sms_status_valid )
    {
        status = ( nas_cached_info.lte_sms_status != prev_lte_sms_status )? TRUE:FALSE;
    }

    return status;
}

//===========================================================================
//qcril_qmi_nas_sys_info_ind_conv_qmi2ril
//===========================================================================
int qcril_qmi_nas_sys_info_ind_conv_qmi2ril(nas_sys_info_ind_msg_v01 * qmi_msg,
                                            int * network_state_updated,
                                            int * radio_tech_changed,
                                            int * data_nw_state_changed
                                                )
{
  qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
  qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
  int                              any_rte_change;
  uint64_t current_time;
  uint8_t                          prev_lte_embms_coverage_valid;
  uint8_t                          prev_lte_embms_coverage;
  uint8_t                          prev_embms_coverage_status_valid;
  nas_lte_rrc_embms_coverage_status_enum_v01  prev_embms_coverage_status;
  uint8_t                          prev_lte_sys_info_valid;
  nas_lte_sys_info_type_v01        prev_lte_sys_info;
  nas_service_status_enum_type_v01  old_service_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
  nas_service_status_enum_type_v01  new_service_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
  nas_sys_info_helper_type prev_sys_info_helper;
  nas_sys_info_helper_type cur_sys_info_helper;
  int limit_sys_info = nas_common_info.limit_sys_info_logic_change; // Default value is 0
  int res = E_SUCCESS;

  uint8_t old_mcc_mnc_valid;
  char old_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char old_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  uint8_t new_mcc_mnc_valid;
  char new_mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char new_mnc_str[NAS_MCC_MNC_MAX_SIZE];

  nas_sms_status_enum_type_v01 prev_lte_sms_status;
  uint8_t prev_lte_sms_status_valid;

  nas_lte_voice_status_enum_type_v01 prev_lte_voice_status;
  uint8_t prev_lte_voice_status_valid;

  RIL_Errno location_data_res;

  qcril_arb_pref_data_type pref_data;
  int extrapolation_is_under;
  int extrapolation_is_roaming;

  QCRIL_LOG_FUNC_ENTRY();

  if ( qmi_ril_is_qmi_sys_info_available() )
  {
    NAS_CACHE_LOCK();
    qcril_qmi_nas_fetch_lte_voice_status( &prev_lte_voice_status_valid, &prev_lte_voice_status );
    qcril_qmi_nas_fetch_lte_sms_status( &prev_lte_sms_status_valid, &prev_lte_sms_status);

    prev_lte_embms_coverage_valid = nas_cached_info.lte_embms_coverage_valid;
    prev_lte_embms_coverage = nas_cached_info.lte_embms_coverage;
    prev_embms_coverage_status_valid = nas_cached_info.embms_coverage_status_valid;
    prev_embms_coverage_status = nas_cached_info.embms_coverage_status;

    prev_lte_sys_info_valid = nas_cached_info.lte_sys_info_valid;
    if (prev_lte_sys_info_valid)
    {
      if (nas_cached_info.lte_sys_info)
      {
        memcpy(&prev_lte_sys_info, nas_cached_info.lte_sys_info, sizeof(prev_lte_sys_info));
      }
      else
      {
        QCRIL_LOG_DEBUG("nas_cached_info.lte_sys_info_valid is true but nas_cached_info.lte_sys_info is NULL");
        prev_lte_sys_info_valid = FALSE;
      }
    }

    old_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(old_mcc_str, old_mnc_str, TRUE, NULL);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_DEBUG( "limit_sys_info=%d", limit_sys_info);


    qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
    qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );

    NAS_CACHE_LOCK();

    if ( INT_MAX != nas_common_info.unsol_cell_info_rate )
    {
      qcril_qmi_nas_cell_location_update_timer_cl(QCRIL_CELL_LOCATION_RESET_PERIOD);
      current_time = ril_nano_time();
      if ( (nas_cached_info.cell_location_info_time +
           nas_common_info.unsol_cell_info_current_rate * 1000000) <= current_time)
      {
        qcril_qmi_nas_queue_cell_info_poll();
      }
    }

    // Set network_state_updated initialized to FALSE if limit_sys_info prop is set
    if ( limit_sys_info == TRUE )
    {
      *network_state_updated = FALSE;
    }
    else
    {

      *network_state_updated = TRUE;
    }

    *data_nw_state_changed = qcril_qmi_nas_is_data_nw_state_updated( qmi_msg );

    QCRIL_LOG_DEBUG("... network_state_updated = %d, data_nw_state_changed = %d", *network_state_updated, *data_nw_state_changed);

    // Store the current nas cache info to compare against updated sys info
    if ( limit_sys_info == TRUE )
    {
      memset(&prev_sys_info_helper,0,sizeof(prev_sys_info_helper));
      res = qcril_qmi_nas_fill_sys_info_details (&prev_sys_info_helper, &old_service_status );
      if ( res == E_FAILURE)
      {
         *network_state_updated = TRUE;
      }
    }
    qmi_ril_nw_reg_update_sys_info_cache_from_ind( qmi_msg );


    if( qmi_msg->wcdma_eutra_status_valid )
    {
        qcril_qmi_nas_report_eutra_status( &qmi_msg->wcdma_eutra_status );
    }

    qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc();

    new_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(new_mcc_str, new_mnc_str, TRUE, NULL);
    if( old_mcc_mnc_valid != new_mcc_mnc_valid || strcmp(old_mcc_str, new_mcc_str) || strcmp(old_mnc_str, new_mnc_str) ) //invalidiating operator name specifics as PLMN has changed
    {
        NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
        NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
        NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
        NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
        NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
        *network_state_updated = TRUE;
        *radio_tech_changed = TRUE;
    }

    NAS_CACHE_UNLOCK();

    qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
    qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
    qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
    any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
    QCRIL_LOG_INFO( "any rte change %d", any_rte_change);

    if(FALSE == (*radio_tech_changed))
    {
        *radio_tech_changed = ( any_rte_change ) ? TRUE : FALSE;
    }

    QCRIL_LOG_INFO( ".. rte changed %d",
                    (int)*radio_tech_changed );

    if( FALSE == ( *radio_tech_changed ) )
    {
        if( qcril_qmi_nas_lte_sms_status_compare( prev_lte_sms_status_valid, prev_lte_sms_status ) ||
            qcril_qmi_nas_lte_voice_status_compare( prev_lte_voice_status_valid, prev_lte_voice_status )
          )
        {
            *radio_tech_changed = TRUE;
        }
    }

    QCRIL_LOG_INFO( ".. after lte voice and sms status rte changed %d", (int)*radio_tech_changed );
    if( TRUE == any_rte_change )
    {
      NAS_CACHE_LOCK();
      qcril_qmi_nas_drop_nw_info_cache();
      qcril_qmi_nas_fetch_sys_info();

      memset(&pref_data, 0, sizeof(pref_data));
      qcril_qmi_get_pref_data_tech(&pref_data);
      qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, &extrapolation_is_under, &extrapolation_is_roaming );
      // Invalidate sig info cache if pref data tech is invalid or not extrapolating
      if ( (!extrapolation_is_under && nas_common_info.is_screen_off) ||
           ( extrapolation_is_under && nas_common_info.is_screen_off && ( nas_cached_info.voice_rte == nas_cached_info.data_rte ) ) )
      {
        qcril_qmi_drop_sig_info_cache();
      }

      NAS_CACHE_UNLOCK();

      *network_state_updated = TRUE; //voice and data network state need to be updated as there is a change in rte
      *data_nw_state_changed = TRUE;
    }

    NAS_CACHE_LOCK();
    qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(prev_embms_coverage_status_valid, prev_embms_coverage_status);
    qcril_qmi_nas_embms_send_cell_info_changed_if_needed(prev_lte_sys_info_valid, &prev_lte_sys_info);
  }


  QCRIL_LOG_DEBUG("...... network_state_updated = %d, data_nw_state_changed = %d", *network_state_updated, *data_nw_state_changed);

  // In case RTE is not changed check for change in other sys info fields
  if ( ( limit_sys_info == TRUE ) && (! ( *network_state_updated  || *data_nw_state_changed ) ) )
  {
    memset(&cur_sys_info_helper,0,sizeof(cur_sys_info_helper));
    res = qcril_qmi_nas_fill_sys_info_details (&cur_sys_info_helper, &new_service_status );
    if ( res == E_FAILURE)
    {
       *network_state_updated = TRUE;
    }

    // Basic srv status related checks common to 3gpp and 3gpp2
    if ( !*network_state_updated && ( NULL != prev_sys_info_helper.common_sys_info ) &&
         ( NULL != cur_sys_info_helper.common_sys_info ) )
    {
      *network_state_updated = old_service_status != new_service_status ||
                               ( ( prev_sys_info_helper.common_sys_info->srv_domain_valid && cur_sys_info_helper.common_sys_info->srv_domain_valid ) &&
                                  prev_sys_info_helper.common_sys_info->srv_domain != cur_sys_info_helper.common_sys_info->srv_domain ) ||
                               ( ( prev_sys_info_helper.common_sys_info->srv_capability_valid && cur_sys_info_helper.common_sys_info->srv_capability_valid ) &&
                                  prev_sys_info_helper.common_sys_info->srv_capability != cur_sys_info_helper.common_sys_info->srv_capability ) ||
                               ( ( prev_sys_info_helper.common_sys_info->roam_status_valid && cur_sys_info_helper.common_sys_info->roam_status_valid ) &&
                                  prev_sys_info_helper.common_sys_info->roam_status != cur_sys_info_helper.common_sys_info->roam_status );
      QCRIL_LOG_INFO( "old_service_status %d, new_service_status %d prev srv domain %d cur srv domain %d prev srv capability %d cur srv capability %d prev roam status %d cur roam status %d", old_service_status, new_service_status, prev_sys_info_helper.common_sys_info->srv_domain, cur_sys_info_helper.common_sys_info->srv_domain, prev_sys_info_helper.common_sys_info->srv_capability, cur_sys_info_helper.common_sys_info->srv_capability, prev_sys_info_helper.common_sys_info->roam_status, cur_sys_info_helper.common_sys_info->roam_status);
    }

    // 3gpp checks
    if ( (!*network_state_updated) &&
         ( ( nas_cached_info.voice_rte == QMI_RIL_RTE_GSM ) ||
           ( nas_cached_info.voice_rte == QMI_RIL_RTE_WCDMA ) ||
           ( nas_cached_info.voice_rte == QMI_RIL_RTE_TDSCDMA ) ||
           ( nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_LTE ) ) &&
         ( NULL != prev_sys_info_helper.threegpp_only_sys_info ) &&
         ( NULL != cur_sys_info_helper.threegpp_only_sys_info ) &&
         ( NULL != prev_sys_info_helper.threegpp_srv_status ) &&
         ( NULL != cur_sys_info_helper.threegpp_srv_status ) )
    {
      QCRIL_LOG_INFO( " .. 3gpp check");
      *network_state_updated = ( ( prev_sys_info_helper.threegpp_only_sys_info->reg_reject_info_valid && cur_sys_info_helper.threegpp_only_sys_info->reg_reject_info_valid ) &&
                                 (( prev_sys_info_helper.threegpp_only_sys_info->reg_reject_info.reject_srv_domain != cur_sys_info_helper.threegpp_only_sys_info->reg_reject_info.reject_srv_domain ) ||
                                 ( prev_sys_info_helper.threegpp_only_sys_info->reg_reject_info.rej_cause != cur_sys_info_helper.threegpp_only_sys_info->reg_reject_info.rej_cause )) ) ||
                                 prev_sys_info_helper.threegpp_srv_status->true_srv_status != cur_sys_info_helper.threegpp_srv_status->true_srv_status ||
                               ( nas_common_info.location_updates_enabled &&
                                  ( ( ( prev_sys_info_helper.threegpp_only_sys_info->lac_valid && cur_sys_info_helper.threegpp_only_sys_info->lac_valid ) &&
                                    ( prev_sys_info_helper.threegpp_only_sys_info->lac != cur_sys_info_helper.threegpp_only_sys_info->lac )) ||
                                    (( prev_sys_info_helper.threegpp_only_sys_info->cell_id_valid && cur_sys_info_helper.threegpp_only_sys_info->cell_id_valid ) &&
                                    ( prev_sys_info_helper.threegpp_only_sys_info->cell_id != cur_sys_info_helper.threegpp_only_sys_info->cell_id )) ) );
     QCRIL_LOG_INFO( "prev lac %u cur lac %u prev cid %d cur cid %d", prev_sys_info_helper.threegpp_only_sys_info->lac, cur_sys_info_helper.threegpp_only_sys_info->lac, prev_sys_info_helper.threegpp_only_sys_info->cell_id, cur_sys_info_helper.threegpp_only_sys_info->cell_id );

     // Check for TAC change if rte is LTE
     if ( !*network_state_updated && nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_LTE && ( NULL != prev_sys_info_helper.lte_only_sys_info) &&
          ( NULL != cur_sys_info_helper.lte_only_sys_info) )
     {
       *network_state_updated = ( nas_common_info.location_updates_enabled &&
                                ( ( prev_sys_info_helper.lte_only_sys_info->tac_valid && cur_sys_info_helper.lte_only_sys_info->tac_valid ) &&
                                  ( prev_sys_info_helper.lte_only_sys_info->tac != cur_sys_info_helper.lte_only_sys_info->tac ) ) );
     }
   }
   // Check for location update for CDMA
   else if ( !*network_state_updated && nas_cached_info.voice_rte == QMI_RIL_RTE_1x &&
              ( NULL != prev_sys_info_helper.cdma_only_sys_info) && ( NULL != cur_sys_info_helper.cdma_only_sys_info) )
   {
     QCRIL_LOG_INFO( " .. 1x check");
     *network_state_updated =  ( nas_common_info.location_updates_enabled &&
                               ( ( prev_sys_info_helper.cdma_only_sys_info->bs_info_valid && cur_sys_info_helper.cdma_only_sys_info->bs_info_valid ) &&
                                 (( prev_sys_info_helper.cdma_only_sys_info->bs_info.base_id != cur_sys_info_helper.cdma_only_sys_info->bs_info.base_id ) ||
                                 ( prev_sys_info_helper.cdma_only_sys_info->bs_info.base_lat != cur_sys_info_helper.cdma_only_sys_info->bs_info.base_lat ) ||
                                 ( prev_sys_info_helper.cdma_only_sys_info->bs_info.base_long != cur_sys_info_helper.cdma_only_sys_info->bs_info.base_long )) ) );
     QCRIL_LOG_INFO( "prev base_id %u cur base_id %u", prev_sys_info_helper.cdma_only_sys_info->bs_info.base_id, cur_sys_info_helper.cdma_only_sys_info->bs_info.base_id );
   }
   // HDR fields
   else if ( !*network_state_updated && nas_cached_info.voice_rte == QMI_RIL_RTE_SUB_DO &&
             ( NULL != prev_sys_info_helper.hdr_only_sys_info) && ( NULL != cur_sys_info_helper.hdr_only_sys_info) )
   {
     QCRIL_LOG_INFO( " .. hdr check");
     *network_state_updated = ( ( prev_sys_info_helper.hdr_only_sys_info->hdr_personality_valid && cur_sys_info_helper.hdr_only_sys_info->hdr_personality_valid ) ||
                                 prev_sys_info_helper.hdr_only_sys_info->hdr_personality != cur_sys_info_helper.hdr_only_sys_info->hdr_personality ) ||
                              ( ( prev_sys_info_helper.hdr_only_sys_info->hdr_active_prot_valid && cur_sys_info_helper.hdr_only_sys_info->hdr_active_prot_valid ) ||
                                prev_sys_info_helper.hdr_only_sys_info->hdr_active_prot != cur_sys_info_helper.hdr_only_sys_info->hdr_active_prot );
      QCRIL_LOG_INFO( "prev hdr_personality %d cur hdr_personality %d", prev_sys_info_helper.hdr_only_sys_info->hdr_personality, cur_sys_info_helper.hdr_only_sys_info->hdr_personality );
   }
 }

  QCRIL_LOG_DEBUG("......... network_state_updated = %d, data_nw_state_changed = %d", *network_state_updated, *data_nw_state_changed);

  QCRIL_LOG_FUNC_RETURN();

  return E_SUCCESS;
} // qcril_qmi_nas_sys_info_ind_conv_qmi2ril

//===========================================================================
//qmi_ril_nw_reg_update_sys_info_cache_from_ind
//===========================================================================
void qmi_ril_nw_reg_update_sys_info_cache_from_ind( nas_sys_info_ind_msg_v01 * qmi_msg )
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_srv_status_info, qmi_msg->cdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_srv_status_info, qmi_msg->hdr_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_srv_status_info, qmi_msg->gsm_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_srv_status_info, qmi_msg->wcdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_srv_status_info, qmi_msg->tdscdma_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_srv_status_info, qmi_msg->lte_srv_status_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info, qmi_msg->cdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info, qmi_msg->hdr_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info, qmi_msg->gsm_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info, qmi_msg->wcdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_sys_info, qmi_msg->tdscdma_sys_info );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info, qmi_msg->lte_sys_info );

    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info2, qmi_msg->cdma_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info2, qmi_msg->hdr_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info2, qmi_msg->gsm_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info2, qmi_msg->wcdma_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info2, qmi_msg->lte_sys_info2 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info3, qmi_msg->gsm_sys_info3 );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info3, qmi_msg->wcdma_sys_info3  );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_cell_status, qmi_msg->lte_cell_status  );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_support_on_lte, qmi_msg->voice_support_on_lte );

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_embms_coverage, qmi_msg->lte_embms_coverage );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.embms_coverage_status, qmi_msg->embms_coverage_status );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sim_rej_info, qmi_msg->sim_rej_info );

    nas_cached_info.is_considered_registered_cached_result_valid = FALSE;
    nas_cached_info.is_in_service_of_technology_cache_result_valid = FALSE;

    NAS_CACHE_STORE_ENTRY(nas_cached_info.wcdma_csg_info, qmi_msg->wcdma_csg_info );

    NAS_CACHE_STORE_ENTRY(nas_cached_info.lte_csg_info, qmi_msg->lte_csg_info );

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_voice_status,qmi_msg->lte_voice_status);

    NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sms_status,qmi_msg->lte_sms_status);

    qcril_qmi_nas_update_voice_rte();
    qcril_qmi_nas_update_data_rte();
    qcril_qmi_nas_update_ims_rte();
    qcril_qmi_voice_technology_updated();
    qmi_ril_nwr_update_reg_rej_from_sys_info();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_update_sys_info_cache_from_ind

//===========================================================================
//qcril_qmi_nas_is_data_nw_state_updated
//===========================================================================
int qcril_qmi_nas_is_data_nw_state_updated(nas_sys_info_ind_msg_v01 * qmi_msg)
{
  int res = FALSE;
  qcril_arb_pref_data_type pref_data;

  nas_3gpp_only_sys_info_type_v01 *cache_threegpp_specific_sys_info, *ind_threegpp_specific_sys_info;
  nas_common_sys_info_type_v01 *cache_common_sys_info, *ind_common_sys_info;
  nas_lte_only_sys_info_type_v01 *cache_lte_specific_sys_info, *ind_lte_specific_sys_info;


  QCRIL_LOG_FUNC_ENTRY();

  cache_threegpp_specific_sys_info = NULL;
  ind_threegpp_specific_sys_info = NULL;
  cache_lte_specific_sys_info = NULL;
  ind_lte_specific_sys_info = NULL;
  cache_common_sys_info = NULL;
  ind_common_sys_info = NULL;

  if( qmi_msg )
  {
    memset(&pref_data, 0, sizeof(pref_data));
    qcril_qmi_get_pref_data_tech(&pref_data);

    if( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech &&
        QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data.pref_data_tech &&
        TRUE == pref_data.is_current )
    {
        QCRIL_LOG_INFO("CnE module available with current status - Valid pref data tech %d", pref_data.pref_data_tech);

        switch ( pref_data.pref_data_tech )
        {
            case QCRIL_ARB_PREF_DATA_TECH_GSM:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
                }
                if( qmi_msg->gsm_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->gsm_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->gsm_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
                }
                if( qmi_msg->wcdma_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->wcdma_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->wcdma_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
                }
                if( qmi_msg->tdscdma_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->tdscdma_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->tdscdma_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_LTE:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                {
                    cache_threegpp_specific_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                    cache_common_sys_info = &nas_cached_info.lte_sys_info->common_sys_info;
                    cache_lte_specific_sys_info = &nas_cached_info.lte_sys_info->lte_specific_sys_info;
                }
                if( qmi_msg->lte_sys_info_valid )
                {
                    ind_threegpp_specific_sys_info = &qmi_msg->lte_sys_info.threegpp_specific_sys_info;
                    ind_common_sys_info = &qmi_msg->lte_sys_info.common_sys_info;
                    ind_lte_specific_sys_info = &qmi_msg->lte_sys_info.lte_specific_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
                {
                    cache_common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
                }
                if( qmi_msg->cdma_sys_info_valid )
                {
                    ind_common_sys_info = &qmi_msg->cdma_sys_info.common_sys_info;
                }
                break;

            case QCRIL_ARB_PREF_DATA_TECH_EVDO:
            case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                {
                    cache_common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
                }
                if( qmi_msg->hdr_sys_info_valid )
                {
                    ind_common_sys_info = &qmi_msg->hdr_sys_info.common_sys_info;
                }
                break;


            default:
                // nothing
                break;
        }

        if( FALSE == res && cache_common_sys_info && ind_common_sys_info )
        {
          if( cache_common_sys_info->roam_status_valid == ind_common_sys_info->roam_status_valid &&
              cache_common_sys_info->roam_status == ind_common_sys_info->roam_status )
          {
            res = FALSE;
          }
          else
          {
            res = TRUE;
          }
        }
        else if( cache_common_sys_info != ind_common_sys_info )
        {
          res = TRUE;
        }

        if( FALSE == res && cache_threegpp_specific_sys_info && ind_threegpp_specific_sys_info )
        {
          if( cache_threegpp_specific_sys_info->cell_id_valid == ind_threegpp_specific_sys_info->cell_id_valid &&
              cache_threegpp_specific_sys_info->cell_id == ind_threegpp_specific_sys_info->cell_id &&
              cache_threegpp_specific_sys_info->lac_valid == ind_threegpp_specific_sys_info->lac_valid &&
              cache_threegpp_specific_sys_info->lac == ind_threegpp_specific_sys_info->lac )
          {
            res = FALSE;
          }
          else
          {
            res = TRUE;
          }
        }
        else if( cache_threegpp_specific_sys_info != ind_threegpp_specific_sys_info )
        {
          res = TRUE;
        }


        if( FALSE == res && cache_lte_specific_sys_info && ind_lte_specific_sys_info )
        {
          if( cache_lte_specific_sys_info->tac_valid == ind_lte_specific_sys_info->tac_valid &&
              cache_lte_specific_sys_info->tac == ind_lte_specific_sys_info->tac )
          {
            res = FALSE;
          }
          else
          {
            res = TRUE;
          }
        }
        else if( cache_lte_specific_sys_info != ind_lte_specific_sys_info )
        {
          res = TRUE;
        }
    }
    else
    {
      res = TRUE;
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} //qcril_qmi_nas_is_data_nw_state_updated

//===========================================================================
//qcril_qmi_nas_report_eutra_status
//===========================================================================
void qcril_qmi_nas_report_eutra_status(nas_eutra_cell_status_enum_type_v01 * eutra_status)
{
    char payload;

    QCRIL_LOG_FUNC_ENTRY();

    if( eutra_status )
    {
        QCRIL_LOG_INFO("eutra status %d", *eutra_status);
        payload = (char) *eutra_status;
        qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_EUTRA_STATUS, &payload, sizeof(payload));
    }
    else
    {
        QCRIL_LOG_INFO("eutra status unspecified");
    }

    QCRIL_LOG_FUNC_RETURN();
}  // qcril_qmi_nas_report_eutra_status
//===========================================================================
// qcril_qmi_nas_calculate_restricted_details
//===========================================================================
void qcril_qmi_nas_calculate_restricted_details(int * restricted_details)
{
    nas_gw_sys_info3_type_v01 * cs_restriction_related_sys_info3;
    nas_gw_sys_info3_type_v01 * ps_restriction_related_sys_info3;
    nas_gw_sys_info3_type_v01 lte_restricted_details;
    nas_gw_sys_info3_type_v01 tdscdma_restricted_details;


    QCRIL_LOG_FUNC_ENTRY();

    if( restricted_details )
    {
      cs_restriction_related_sys_info3 = NULL;
      ps_restriction_related_sys_info3 = NULL;
      memset(&lte_restricted_details, 0, sizeof(lte_restricted_details));
      memset(&tdscdma_restricted_details, 0, sizeof(tdscdma_restricted_details));

      if ( !qmi_ril_is_qmi_sys_info_available() )
      {
          QCRIL_LOG_INFO("radio_if_gsm %d, radio_if_wcdma %d",(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM)),(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS)));
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.call_barring_status )&&
               (qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM) ||
               qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS) ||
                TRUE == nas_common_info.always_report_restricted_state) )
          {
              cs_restriction_related_sys_info3 = nas_cached_info.call_barring_status;
              ps_restriction_related_sys_info3 = nas_cached_info.call_barring_status;
          }
      }
      else
      {
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
             cs_restriction_related_sys_info3 = nas_cached_info.wcdma_sys_info3;
          }
          else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              if( nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.cs_bar_status_valid )
              {
                  tdscdma_restricted_details.cs_bar_status = nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.cs_bar_status;
                  cs_restriction_related_sys_info3 = &tdscdma_restricted_details;
              }
          }
          else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              cs_restriction_related_sys_info3 = nas_cached_info.gsm_sys_info3;
          }
          else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              lte_restricted_details.cs_bar_status = nas_cached_info.lte_cell_status;
              cs_restriction_related_sys_info3 = &lte_restricted_details;
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              lte_restricted_details.ps_bar_status = nas_cached_info.lte_cell_status;
              ps_restriction_related_sys_info3 = &lte_restricted_details;
          }
          else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              ps_restriction_related_sys_info3 = nas_cached_info.wcdma_sys_info3;
          }
          else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              if( nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.ps_bar_status_valid )
              {
                  tdscdma_restricted_details.ps_bar_status = nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info.ps_bar_status;
                  ps_restriction_related_sys_info3 = &tdscdma_restricted_details;
              }
          }
          else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 ) &&
               (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_DATA) || TRUE == nas_common_info.always_report_restricted_state)
              )
          {
              ps_restriction_related_sys_info3 = nas_cached_info.gsm_sys_info3;
          }
      }

      qcril_qmi_nas_fill_up_restricted_state_details( cs_restriction_related_sys_info3, ps_restriction_related_sys_info3, restricted_details );
    }
    else
    {
      QCRIL_LOG_FATAL("Null Pointer");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_calculate_restricted_details

//===========================================================================
// qcril_qmi_nas_report_restricted_details
//===========================================================================
void qcril_qmi_nas_report_restricted_details(int restricted_details)
{
    qcril_unsol_resp_params_type unsol_resp_params;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_FATAL(".. reporting %d", restricted_details);

    qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESTRICTED_STATE_CHANGED, &unsol_resp_params );
    unsol_resp_params.resp_pkt    = &restricted_details;
    unsol_resp_params.resp_len    = sizeof( restricted_details );
    qcril_send_unsol_response( &unsol_resp_params );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_report_restricted_details

//===========================================================================
//qcril_qmi_nas_restricted_state_handle_event
//===========================================================================
void qcril_qmi_nas_restricted_state_handle_event( qmi_ril_nas_restricted_details_event_e_type event )
{
    int                                                     fresh_details;
    qmi_ril_nas_restricted_details_state_e_type             new_state;
    int                                                     state_changed;

    QCRIL_LOG_FUNC_ENTRY();

    state_changed = FALSE;
    new_state     = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE;

    QCRIL_LOG_INFO( "event %d under state %d, cached details %d", (int)event, (int)nas_cached_info.restricted_details_state, (int)nas_cached_info.cached_restricted_details );

    switch ( event )
    {
        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_RESET:
            new_state                                 = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE;
            state_changed                             = TRUE;
            nas_cached_info.cached_restricted_details = NAS_NIL;
            break;

        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE:
            fresh_details = NAS_NIL;
            qcril_qmi_nas_calculate_restricted_details( &fresh_details );
            if ( fresh_details != nas_cached_info.cached_restricted_details )
            {
                nas_cached_info.cached_restricted_details = fresh_details;
                qcril_qmi_nas_report_restricted_details( nas_cached_info.cached_restricted_details );

                switch ( nas_cached_info.restricted_details_state )
                {
                    case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING:
                        // no change
                        break;

                    case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE:
                        new_state     = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING;
                        state_changed = TRUE;
                        break;

                    default:
                        // nothing
                        break;
                }
            }
            break;

        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_REPOST:
            switch ( nas_cached_info.restricted_details_state )
            {
                case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING:
                    qcril_setup_timed_callback(
                                              QCRIL_DEFAULT_INSTANCE_ID,
                                              QCRIL_DEFAULT_MODEM_ID,
                                              qcril_qmi_nas_retranslate_cs_ps_bar_info_handler,
                                              NULL,   // immediate
                                              NULL
                                              );
                    break;

                default:
                    break;
            }
            break;
            break;

        case QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHANGE_REPOST:
            switch ( nas_cached_info.restricted_details_state )
            {
                case QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_IN_CHANGE_REPOST_PENDING:
                    qcril_qmi_nas_report_restricted_details( nas_cached_info.cached_restricted_details );

                    new_state                                 = QMI_RIL_NAS_RESTRICTED_DETAILS_STATE_NONE;
                    state_changed                             = TRUE;
                    break;

                default:
                    break;
            }
            break;

        default: // nothing
            break;
    }

    if ( state_changed )
    {
        nas_cached_info.restricted_details_state = new_state;
        QCRIL_LOG_INFO( "state changed to %d", (int)nas_cached_info.restricted_details_state );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_restricted_state_handle_event

//===========================================================================
//qcril_qmi_nas_fill_up_restricted_state_details
//===========================================================================
void qcril_qmi_nas_fill_up_restricted_state_details(nas_gw_sys_info3_type_v01 * cs_gw_sys_info3,
                                                    nas_gw_sys_info3_type_v01 * ps_gw_sys_info3,
                                                    int * restricted_state_details)
{
    int restricted_state_details_local;

    restricted_state_details_local = NAS_NIL;
    if ( NULL != cs_gw_sys_info3 )
    {
        QCRIL_LOG_INFO(  "cs_bar_status %d", (int)cs_gw_sys_info3->cs_bar_status );
        switch ( cs_gw_sys_info3->cs_bar_status )
        {
            case NAS_CELL_ACCESS_NORMAL_ONLY_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_CS_EMERGENCY;
                break;

            case NAS_CELL_ACCESS_EMERGENCY_ONLY_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_CS_NORMAL;
                break;

            case NAS_CELL_ACCESS_NO_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_CS_ALL;
                break;

            case NAS_CELL_ACCESS_ALL_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_NONE;
                break;

            case NAS_CELL_ACCESS_UNKNOWN_V01:
            default: // nothing
                break;
        }
    }

    if ( NULL != ps_gw_sys_info3 )
    {
        QCRIL_LOG_INFO(  "ps_bar_status %d", (int)ps_gw_sys_info3->ps_bar_status );
        switch ( ps_gw_sys_info3->ps_bar_status )
        {
            case NAS_CELL_ACCESS_EMERGENCY_ONLY_V01:    // fallthrough
            case NAS_CELL_ACCESS_NO_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_PS_ALL;
                break;

            case NAS_CELL_ACCESS_NORMAL_ONLY_V01:       // fallthrough
            case NAS_CELL_ACCESS_ALL_CALLS_V01:
                restricted_state_details_local |= RIL_RESTRICTED_STATE_NONE;
                break;

            case NAS_CELL_ACCESS_UNKNOWN_V01:
            default: // nothing
                break;
        }

    }

    QCRIL_LOG_INFO(  " .. restricted_state_details_local %d", (int)restricted_state_details_local );
    *restricted_state_details = restricted_state_details_local;
} // qcril_qmi_nas_fill_up_restricted_state_details


//===========================================================================
//qcril_qmi_nas_serving_system_ind_conv_qmi2ril
//===========================================================================
int qcril_qmi_nas_serving_system_ind_conv_qmi2ril(nas_serving_system_ind_msg_v01 * qmi_msg,
                                                  int * network_state_updated,
                                                  int * radio_tech_changed,
                                                  int * data_nw_state_changed
                                                )
{
    QCRIL_LOG_FUNC_ENTRY();

    int changed;
    int is_card_status_reported = qcril_qmi_nas_dms_card_status_reported();
    int fundamental_techjnology_or_reg_change = FALSE;

    if ( !qmi_ril_is_qmi_sys_info_available() )
    {
        NAS_CACHE_LOCK();

        // check if radio tech changed
        changed      = is_card_status_reported &&
                                 (
                                   !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system )
                                   ||
                                   ( nas_cached_info.serving_system->selected_network != qmi_msg->serving_system.selected_network )
                                 );
        *radio_tech_changed = changed && (NAS_SELECTED_NETWORK_UNKNOWN_V01 != qmi_msg->serving_system.selected_network) ;
        fundamental_techjnology_or_reg_change = changed;

        // check if network_state_updated
        if ( !*radio_tech_changed && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.serving_system) )
        {
            changed = (nas_cached_info.serving_system->registration_state != qmi_msg->serving_system.registration_state) ||
                      (nas_cached_info.serving_system->cs_attach_state != qmi_msg->serving_system.cs_attach_state) ||
                      (nas_cached_info.serving_system->ps_attach_state != qmi_msg->serving_system.ps_attach_state) ||
                      (    (nas_cached_info.serving_system->radio_if_len != qmi_msg->serving_system.radio_if_len)
                        || ((qmi_msg->serving_system.registration_state ==  NAS_VAL_REGISTERED) && (qmi_msg->serving_system.radio_if_len > NAS_ZERO)
                            && (nas_cached_info.serving_system->radio_if[NAS_ZERO] != qmi_msg->serving_system.radio_if[NAS_ZERO] ) )
                      )
                      ;
            if ( !fundamental_techjnology_or_reg_change && changed )
            {
                fundamental_techjnology_or_reg_change = TRUE;
            }

            if( !changed && qmi_msg->data_capabilities_valid)
            {
                changed = TRUE; // QMI NAS will only send data caps if those changed
            }
            if ( !changed && nas_common_info.location_updates_enabled )
            {
                switch ( nas_cached_info.serving_system->selected_network )
                {
                    case NAS_VAL_RADIO_TECH_3GPP2:

                        if  (
                              ( qmi_msg->cdma_system_id_valid &&
                                 (!NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id ) ||
                                   (nas_cached_info.cdma_system_id->sid != qmi_msg->cdma_system_id.sid || nas_cached_info.cdma_system_id->nid != qmi_msg->cdma_system_id.nid )
                                 )
                               )
                              ||
                              (  qmi_msg->cdma_base_station_info_valid &&
                                ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_base_station_info ) ||
                                  ( nas_cached_info.cdma_base_station_info->base_id   != qmi_msg->cdma_base_station_info.base_id    ||
                                    nas_cached_info.cdma_base_station_info->base_lat  != qmi_msg->cdma_base_station_info.base_lat   ||
                                    nas_cached_info.cdma_base_station_info->base_long != qmi_msg->cdma_base_station_info.base_long
                                  )
                                )
                              )
                          ||
                          (
                           (qmi_msg->detailed_service_info_valid && !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info )) ||
                           (!qmi_msg->detailed_service_info_valid && NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info )) ||
                           (
                             (qmi_msg->detailed_service_info_valid && NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info )) &&
                             (qmi_msg->detailed_service_info.hdr_srv_status != nas_cached_info.detailed_service_info->hdr_srv_status)
                           )
                          )
                          ||
                          (
                           (qmi_msg->hdr_personality_valid && !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_personality )) ||
                           (!qmi_msg->hdr_personality_valid && NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_personality )) ||
                           (
                            (qmi_msg->hdr_personality_valid && NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_personality )) &&
                             (qmi_msg->hdr_personality != nas_cached_info.hdr_personality )
                           )

                          )
                        )

                    {
                        changed = TRUE;
                        fundamental_techjnology_or_reg_change = TRUE;
                    }
                    break;

                    case NAS_VAL_RADIO_TECH_3GPP:
                        if( (qmi_msg->cell_id_valid && (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cell_id) || (nas_cached_info.cell_id != qmi_msg->cell_id)))
                            || (qmi_msg->lac_valid &&  (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lac) || (nas_cached_info.lac != qmi_msg->lac)))
                            || (qmi_msg->tac_valid &&  (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tac) || (nas_cached_info.tac != qmi_msg->tac)))
                            )
                        {
                            changed = TRUE;
                            fundamental_techjnology_or_reg_change = TRUE;
                        }
                        break;

                    default:
                        changed = TRUE;
                        break;
                }
            }
        }
        else
        {
            changed = TRUE;
        }
        *network_state_updated  = changed;
        // check if data nw state changed
        *data_nw_state_changed  = changed;

        // see if cache may be regarded valid overall
        QCRIL_LOG_INFO( ".. fundamental change %d",(int) fundamental_techjnology_or_reg_change );
        if ( fundamental_techjnology_or_reg_change )
        {
            qcril_qmi_nas_drop_nw_info_cache();
        }

        qmi_ril_nw_reg_update_serving_system_cache_from_ind( qmi_msg );

        qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );

        NAS_CACHE_UNLOCK();

    }
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_serving_system_ind_conv_qmi2ril

//===========================================================================
//qmi_ril_nw_reg_update_serving_system_cache_from_ind
//===========================================================================
void qmi_ril_nw_reg_update_serving_system_cache_from_ind( nas_serving_system_ind_msg_v01 * qmi_msg )
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_STORE_ENTRY_VALID_VAL( nas_cached_info.serving_system, qmi_msg->serving_system );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roaming_indicator, qmi_msg->roaming_indicator );
    NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.data_capabilities, qmi_msg->data_capabilities );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.current_plmn, qmi_msg->current_plmn );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_system_id, qmi_msg->cdma_system_id );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_base_station_info, qmi_msg->cdma_base_station_info );
    NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.roaming_indicator_list, qmi_msg->roaming_indicator_list );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.def_roam_ind, qmi_msg->def_roam_ind );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.nas_3gpp_time_zone, qmi_msg->nas_3gpp_time_zone);
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.p_rev_in_use, qmi_msg->p_rev_in_use );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.ccs, qmi_msg->ccs );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lac, qmi_msg->lac );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cell_id, qmi_msg->cell_id );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prl_ind, qmi_msg->prl_ind );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.detailed_service_info, qmi_msg->detailed_service_info );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cdma_system_id_ext, qmi_msg->cdma_system_id_ext );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.hdr_personality, qmi_msg->hdr_personality );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.tac, qmi_msg->tac );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.call_barring_status, qmi_msg->call_barring_status );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.umts_psc, qmi_msg->umts_psc );
    NAS_CACHE_STORE_ENTRY( nas_cached_info.mnc_includes_pcs_digit, qmi_msg->mnc_includes_pcs_digit );
    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.hs_call_status, qmi_msg->hs_call_status );


    if ( NAS_VAL_REGISTERED == qmi_msg->serving_system.registration_state )
    {
        NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.registration_reject_reason );
    }

    qcril_qmi_voice_technology_updated();
    qmi_ril_nwr_update_reg_rej_legacy();

    QCRIL_LOG_INFO( "serving_system cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) );
    QCRIL_LOG_INFO( "roaming_indicator cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator ) );
    QCRIL_LOG_INFO( "data_capabilities cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ) );
    QCRIL_LOG_INFO( "current_plmn cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.current_plmn ) );
    QCRIL_LOG_INFO( "mnc_includes_pcs_digit cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mnc_includes_pcs_digit ) );
    QCRIL_LOG_INFO( "hs_call_status cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hs_call_status ) );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_update_serving_system_cache_from_ind

//===========================================================================
//event report and signal strength ind
//===========================================================================
int qcril_qmi_nas_event_report_ind_conv_qmi2ril(nas_event_report_ind_msg_v01* qmi_msg, int * network_state_updated, int * data_nw_state_updated)
{
    int cs_reg_rej;
    int ps_reg_rej;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if (qmi_msg)
        {
        if ( qmi_msg->signal_strength_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.signal_strength_list );
        }

        // dbm
        if ( qmi_msg->rssi_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.rssi );
        }

        // error rate
        if ( qmi_msg->error_rate_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.error_rate );
        }


        // ecio
        if ( qmi_msg->ecio_valid )
        {
            NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.ecio );
        }

        // ** update cache
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.io, qmi_msg->io );
        NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sinr, qmi_msg->sinr );
        NAS_CACHE_STORE_ENTRY( nas_cached_info.rsrq , qmi_msg->rsrq );

        NAS_CACHE_STORE_ENTRY( nas_cached_info.registration_reject_reason , qmi_msg->registration_reject_reason );
        QCRIL_LOG_INFO( ".. reg reject valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason ) );
        if ( qmi_msg->registration_reject_reason_valid &&
             nas_cached_info.registration_reject_reason &&
             NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason )
           )
        {
            QCRIL_LOG_INFO( ".. evt_rep reg reject cause %d", (int)nas_cached_info.registration_reject_reason->reject_cause );
            QCRIL_LOG_INFO( ".. evt_rep reg reject dmn %d", (int)nas_cached_info.registration_reject_reason->service_domain );
            switch (nas_cached_info.registration_reject_reason->service_domain)
            {
                case NAS_CIRCUIT_SWITCHED_V01:
                    cs_reg_rej = TRUE;
                    ps_reg_rej = FALSE;
                    break;

                case NAS_PACKET_SWITCHED_V01:
                    cs_reg_rej = FALSE;
                    ps_reg_rej = TRUE;
                    break;

                case NAS_CIRCUIT_AND_PACKET_SWITCHED_V01:
                    cs_reg_rej = TRUE;
                    ps_reg_rej = TRUE;
                    break;

                default:
                    // no action
                    cs_reg_rej = FALSE;
                    ps_reg_rej = FALSE;
                    break;
            }

                if ( cs_reg_rej )
                {
                *network_state_updated = TRUE;

                if ( qmi_ril_is_qmi_sys_info_available() )
                {
                  // workaround for sys_info not delivering reg reject, using QMI_RIL_RTE_WCDMA but any 3gpp rte would do
                  if ( !nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected )
                  {
                      QCRIL_LOG_INFO( ".. applying cs reg rej workaround, cause %d", (int)nas_cached_info.registration_reject_reason->reject_cause );
                      qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                      nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_reject_cause           = nas_cached_info.registration_reject_reason->reject_cause;
                      nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected_assumed       = TRUE;
                  }
                }
            }
                if ( ps_reg_rej )
                {
                *data_nw_state_updated = TRUE;
                }
            if ( (cs_reg_rej || ps_reg_rej) && !qmi_ril_is_qmi_sys_info_available() )
            {
              qmi_ril_nwr_update_reg_rej_legacy();
            }
        }

        NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.rf_band_info_list , qmi_msg->rf_band_info_list );
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_event_report_ind_conv_qmi2ril

//===========================================================================
//handling sig info ind
//===========================================================================
int qcril_qmi_nas_sig_info_ind_conv_qmi2ril(nas_sig_info_ind_msg_v01* qmi_msg)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if (qmi_msg)
    {
      NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sig_info, qmi_msg->cdma_sig_info );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sig_info, qmi_msg->hdr_sig_info );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gsm_sig_info, qmi_msg->gsm_sig_info );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sig_info, qmi_msg->wcdma_sig_info );
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.rscp, qmi_msg->rscp );
      NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sig_info, qmi_msg->lte_sig_info );
    }

    QCRIL_LOG_INFO("validity sign info GSM %d, WCDMA %d, TDSCDMA %d, 1x %d, HRPD %d, LTE %d",
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info)
                       );

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_sig_info_ind_conv_qmi2ril

//===========================================================================
//handling err rate ind
//===========================================================================
int qcril_qmi_nas_err_rate_ind_conv_qmi2ril(nas_err_rate_ind_msg_v01* qmi_msg)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    if (qmi_msg)
    {
        //gsm
        if( qmi_msg->gsm_bit_err_rate_valid )
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.gsm_bit_err_rate );
        }

        // wcdma
        if ( qmi_msg->wcdma_block_err_rate_valid )
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.wcdma_block_err_rate );
        }

        // tdscdma
        if ( qmi_msg->tdscdma_block_err_rate_valid )
        {
            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.tdscdma_block_err_rate );
        }
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();

    return E_SUCCESS;
} // qcril_qmi_nas_err_rate_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_dump_sign_strength_report
//===========================================================================
void qcril_qmi_nas_dump_sign_strength_report(RIL_SignalStrength* ril_signal_strength)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( "..GW");
    QCRIL_LOG_INFO( ".. signalStrength %d, bitErrorRate %d", ril_signal_strength->GW_SignalStrength.signalStrength,
                                                             ril_signal_strength->GW_SignalStrength.bitErrorRate );

    QCRIL_LOG_INFO( "..TDSCDMA");
#ifndef QMI_RIL_UTF
    QCRIL_LOG_INFO( ".. signalStrength %d", ril_signal_strength->TD_SCDMA_SignalStrength.rscp );
#endif

    QCRIL_LOG_INFO( "..CDMA");
    QCRIL_LOG_INFO( ".. dbm %d, ecio %d ", ril_signal_strength->CDMA_SignalStrength.dbm,
                                                             ril_signal_strength->CDMA_SignalStrength.ecio );

    QCRIL_LOG_INFO( "..EVDO");
    QCRIL_LOG_INFO( ".. dbm %d, ecio %d, signalNoiseRatio %d", ril_signal_strength->EVDO_SignalStrength.dbm,
                                                             ril_signal_strength->EVDO_SignalStrength.ecio,
                                                             ril_signal_strength->EVDO_SignalStrength.signalNoiseRatio );

    QCRIL_LOG_INFO( "..LTE");
    QCRIL_LOG_INFO( ".. signalStrength %d, rsrp %d, rsrq %d, rsnnr %d", ril_signal_strength->LTE_SignalStrength.signalStrength,
                                                              ril_signal_strength->LTE_SignalStrength.rsrp,
                                                              ril_signal_strength->LTE_SignalStrength.rsrq,
                                                              ril_signal_strength->LTE_SignalStrength.rssnr );

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//signal strength
//===========================================================================
int qcril_qmi_nas_signal_strength_con_conv_cache2ril(RIL_SignalStrength* ril_msg)
{

    uint16_t idx;

    if (ril_msg)
    {
        memset( ril_msg, 0, sizeof( *ril_msg ) );

        ril_msg->GW_SignalStrength.signalStrength   = NAS_SIGNAL_STRENGTH_UNK_GW;
        ril_msg->LTE_SignalStrength.signalStrength  = NAS_SIGNAL_STRENGTH_UNK_GW;
        ril_msg->CDMA_SignalStrength.dbm            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->EVDO_SignalStrength.dbm            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->CDMA_SignalStrength.ecio            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->EVDO_SignalStrength.ecio            = NAS_SIGNAL_STRENGTH_UNK;
        ril_msg->EVDO_SignalStrength.signalNoiseRatio = NAS_SIGNAL_STRENGTH_UNK;

        ril_msg->LTE_SignalStrength.rsrp    = INT_MAX;
        ril_msg->LTE_SignalStrength.rsrq    = INT_MAX;
        ril_msg->LTE_SignalStrength.rssnr   = INT_MAX;
        ril_msg->LTE_SignalStrength.cqi     = INT_MAX;

#if (RIL_VERSION >= 9)
        ril_msg->LTE_SignalStrength.timingAdvance = INT_MAX;
#endif

#ifndef QMI_RIL_UTF
        ril_msg->TD_SCDMA_SignalStrength.rscp = INT_MAX;
#endif

        // ??? ril_msg->CDMA_SignalStrength.signalNoiseRatio

        if(!qmi_ril_is_qmi_sys_info_available())
        {
                // signal strength
                if ( nas_cached_info.signal_strength_list_valid )
                {
                    for ( idx = 0; idx < nas_cached_info.signal_strength_list_len; idx++ )
                    {
                        switch (nas_cached_info.signal_strength_list->arr[idx].radio_if)
                        {
                            case NAS_RADIO_IF_GSM:
                            case NAS_RADIO_IF_UMTS:
                                ril_msg->GW_SignalStrength.signalStrength = nas_cached_info.signal_strength_list->arr[idx].sig_strength; // 1:1
                                break;

                            case NAS_RADIO_IF_LTE:
                                ril_msg->LTE_SignalStrength.signalStrength = nas_cached_info.signal_strength_list->arr[idx].sig_strength; // 1:1
                                break;

                            default:  // skip
                                break;
                        }
                    }
                }

                // dbm
                if ( nas_cached_info.rssi_valid )
                {
                    for ( idx = 0; idx < nas_cached_info.rssi_len; idx++ )
                    {
                        switch (nas_cached_info.rssi->arr[idx].radio_if)
                        {
                            case NAS_RADIO_IF_CDMA2000:
                                ril_msg->CDMA_SignalStrength.dbm = nas_cached_info.rssi->arr[idx].rssi; // 1:1, no need to multiply by -1 as qmi values are already positive
                                break;

                            case NAS_RADIO_IF_CDMA2000_HRPD:
                                ril_msg->EVDO_SignalStrength.dbm = nas_cached_info.rssi->arr[idx].rssi; // 1:1, no need to multiply by -1 as qmi values are already positive
                                break;

                            case NAS_RADIO_IF_GSM:
                            case NAS_RADIO_IF_UMTS:
                                qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.rssi->arr[idx].rssi),&ril_msg->GW_SignalStrength.signalStrength);
                                break;

                            case NAS_RADIO_IF_LTE:
                                qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.rssi->arr[idx].rssi),&ril_msg->LTE_SignalStrength.signalStrength);
                                break;

                            default:  // skip
                                break;
                        }
                     }
                }

                // error rate
                if ( nas_cached_info.error_rate_valid )
                {
                    for ( idx = 0; idx < nas_cached_info.error_rate_len; idx++ )
                    {
                        switch (nas_cached_info.error_rate->arr[idx].radio_if)
                        {
                            case NAS_RADIO_IF_GSM:
                            case NAS_RADIO_IF_UMTS:
                                ril_msg->GW_SignalStrength.bitErrorRate = nas_cached_info.error_rate->arr[idx].error_rate; // 1:1
                                break;

                            default:  // skip
                                break;
                        }
                     }
                }

                // signal noice
                if (nas_cached_info.sinr_valid)
                {
                    ril_msg->EVDO_SignalStrength.signalNoiseRatio = nas_cached_info.sinr; // 1:1 mapping
                }


                // ecio
                if ( nas_cached_info.ecio_valid )
                {
                    for ( idx = 0; idx < nas_cached_info.ecio_len; idx++ )
                    {
                        switch (nas_cached_info.ecio->arr[idx].radio_if)
                        {
                            case NAS_RADIO_IF_CDMA2000:
                                ril_msg->CDMA_SignalStrength.ecio = nas_cached_info.ecio->arr[idx].ecio * 5; // (.5 * qmi_msg *10)
                                break;

                            case NAS_RADIO_IF_CDMA2000_HRPD:
                                ril_msg->EVDO_SignalStrength.ecio = nas_cached_info.ecio->arr[idx].ecio * 5; // (.5 * qmi_msg *10)
                                break;

                            default:  // skip
                                break;
                        }
                     }
                }




                // rsrq
                if (nas_cached_info.rsrq_valid)
                {
                    ril_msg->LTE_SignalStrength.rsrq = nas_cached_info.rsrq->rsrq; // 1:1
                }

                qcril_qmi_nas_dump_sign_strength_report( ril_msg );
        }
        else
        {
                //TODO Initialization of bit err rate
                if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM))
                {
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info) )
                    {
                        qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.gsm_sig_info * -1),&ril_msg->GW_SignalStrength.signalStrength);
                    }
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_bit_err_rate) )
                    {
                        //TODO translating QMI NAS value to Telephony value
                    }
                }

                if( NAS_SIGNAL_STRENGTH_UNK_GW == ril_msg->GW_SignalStrength.signalStrength &&
                    qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS)){
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info) )
                    {
                        qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.wcdma_sig_info->rssi * -1),&ril_msg->GW_SignalStrength.signalStrength);
                    }
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_block_err_rate) )
                    {
                        //TODO translating QMI NAS value to Telephony value
                    }
                }

                if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA))
                {
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp) )
                    {
#ifndef QMI_RIL_UTF
                        ril_msg->TD_SCDMA_SignalStrength.rscp = nas_cached_info.rscp * -1;
#endif
                    }
                }

                if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000))
                {
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info) )
                    {
                        ril_msg->CDMA_SignalStrength.dbm = nas_cached_info.cdma_sig_info->rssi * -1;
                        ril_msg->CDMA_SignalStrength.ecio = nas_cached_info.cdma_sig_info->ecio * 5;
                    }
                }

                if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000_HRPD))
                {
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info) )
                    {
                        ril_msg->EVDO_SignalStrength.dbm = nas_cached_info.hdr_sig_info->common_sig_str.rssi * -1;
                        ril_msg->EVDO_SignalStrength.ecio = nas_cached_info.hdr_sig_info->common_sig_str.ecio * 5;
                        ril_msg->EVDO_SignalStrength.signalNoiseRatio = nas_cached_info.hdr_sig_info->sinr;
                    }
                }

                if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE))
                {
                    if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info) )
                    {
                        qcril_cm_util_rssi_to_gw_signal_strength((nas_cached_info.lte_sig_info->rssi * -1),&ril_msg->LTE_SignalStrength.signalStrength);
                        ril_msg->LTE_SignalStrength.rssnr = nas_cached_info.lte_sig_info->snr;
                        ril_msg->LTE_SignalStrength.rsrp = nas_cached_info.lte_sig_info->rsrp * -1;
                        ril_msg->LTE_SignalStrength.rsrq = nas_cached_info.lte_sig_info->rsrq * -1;
                    }
                }
                qcril_qmi_nas_dump_sign_strength_report( ril_msg );
        }
    }

    return E_SUCCESS;
}

//===========================================================================
// RIL_REQUEST_SIGNAL_STRENGTH
//===========================================================================
void qcril_qmi_nas_request_signal_strength
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  RIL_SignalStrength ril_response_payload;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  int   is_registered;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();
  // let's see if any info needs to be fetched
  NAS_CACHE_LOCK();
  memset( &ril_response_payload, 0, sizeof( ril_response_payload ) );

  NAS_CACHE_LOCK();
  is_registered = qcril_qmi_nas_is_considered_registered(NULL);
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO(".. is registered %d", (int) is_registered);

  if ( is_registered  || TRUE == nas_common_info.consider_3gpp_ltd_srv_drte_update )
  {
      ril_req_res = qcril_qmi_nas_fetch_signal_strength_observations();

      QCRIL_LOG_INFO(".. subfetch sig strength info %d", (int) ril_req_res);
      if ( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();
          ril_req_res = ( E_SUCCESS == qcril_qmi_nas_signal_strength_con_conv_cache2ril( &ril_response_payload ) ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
          NAS_CACHE_UNLOCK();
      }
  }
  else
  {  // no registered
      ril_req_res = RIL_E_SUCCESS; // we will retun 0 data
  }

  NAS_CACHE_UNLOCK();
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_LOG_INFO( "responsed with payload");
      resp.resp_pkt = (void *) &ril_response_payload;
      resp.resp_len = sizeof( ril_response_payload );
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);
} // qcril_qmi_nas_request_signal_strength
//===========================================================================
// qcril_qmi_nas_initiate_propagate_known_signal_strength_ind
//===========================================================================
void qcril_qmi_nas_initiate_propagate_known_signal_strength_ind(void)
{
    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_NAS_SIG_STRENGTH_UPDATE,
                   NULL,
                   NAS_NIL,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
} // qcril_qmi_nas_initiate_propagate_known_signal_strength_ind
//===========================================================================
// QCRIL_EVT_QMI_NAS_SIG_STRENGTH_UPDATE
//===========================================================================
void qcril_qmi_trigger_propagate_known_signal_strength_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(params_ptr);
    QCRIL_NOTUSED(ret_ptr);
    qcril_qmi_nas_propagate_known_signal_strength_ind();
}
//===========================================================================
// qcril_qmi_nas_propagate_known_signal_strength_ind
//===========================================================================
RIL_Errno qcril_qmi_nas_propagate_known_signal_strength_ind(void)
{
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    RIL_SignalStrength ril_response_payload;
    qcril_unsol_resp_params_type unsol_resp_params;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &ril_response_payload, 0, sizeof(ril_response_payload) );
    ril_req_res = qcril_qmi_nas_fetch_signal_strength_observations();
    QCRIL_LOG_INFO(".. subfetch sig strength info %d", (int) ril_req_res);
    if ( RIL_E_SUCCESS == ril_req_res )
    {
        NAS_CACHE_LOCK();
        ril_req_res = ( E_SUCCESS == qcril_qmi_nas_signal_strength_con_conv_cache2ril( &ril_response_payload ) ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
        NAS_CACHE_UNLOCK();
        QCRIL_LOG_INFO(".. conf res %d", (int) ril_req_res);
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_SIGNAL_STRENGTH, &unsol_resp_params );
            unsol_resp_params.resp_pkt    = &ril_response_payload;
            unsol_resp_params.resp_len    = sizeof( ril_response_payload );
            qcril_send_unsol_response( &unsol_resp_params );
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);
    return ril_req_res;
} // qcril_qmi_nas_propagate_known_signal_strength_ind
//===========================================================================
// qcril_qmi_nas_fetch_signal_strength_observations
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_signal_strength_observations(void)
{
    uint16_t           qmi_request_mask = NAS_NIL;
    int           qmi_request_need_sig_info = 0, qmi_request_need_err_rate = 0;

    nas_get_signal_strength_req_msg_v01 qmi_request;
    nas_get_signal_strength_resp_msg_v01 * qmi_response = NULL;

    nas_get_sig_info_resp_msg_v01 qmi_response_sig_info;
    nas_get_err_rate_resp_msg_v01 qmi_response_err_rate;

    qmi_client_error_type qmi_client_error;

    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_FUNC_ENTRY();

    if( !qmi_ril_is_qmi_sys_info_available() )
    {
    NAS_CACHE_LOCK();
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.signal_strength_list ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_MANDATORY_FLD;
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.rssi ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_RSSI;
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.ecio ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_ECIO;
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.sinr ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_SINR;
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.io ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_IO;
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.error_rate ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_ERROR_RATE;
    qmi_request_mask |= NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.rsrq ) ? NAS_NIL : NAS_REQ_MASK_SIG_STRENGTH_RSRQ;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("..req mask %d", (int)qmi_request_mask);

    if ( NAS_NIL != qmi_request_mask )
    {
        QCRIL_LOG_INFO("entered IF %d",qmi_request_mask);
        memset( &qmi_request, 0, sizeof( qmi_request ) );
        qmi_request.request_mask_valid    = TRUE;
        qmi_request.request_mask          = qmi_request_mask & NAS_REQ_MASK_SIG_STRENGTH_VALID_MASK;

        QCRIL_LOG_INFO("entered RIL_REQ_RES qmi_request.request__mask = %d",qmi_request.request_mask);
        qmi_response = qcril_malloc( sizeof( *qmi_response ) );
        if ( qmi_response )
        {
            QCRIL_LOG_INFO("entered IF QMI RESPONSE %d",qmi_request_mask);
            qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                               QMI_NAS_GET_SIGNAL_STRENGTH_REQ_MSG_V01,
                                                               (void*) &qmi_request,
                                                               sizeof( qmi_request ),
                                                               (void*) qmi_response,
                                                               sizeof( *qmi_response ),
                                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

            ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );
            if ( RIL_E_SUCCESS == ril_req_res )
            {
                QCRIL_LOG_INFO("entered IF UTIL_RES = SUCCESS %d",qmi_request_mask);

                NAS_CACHE_LOCK();
                NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.signal_strength_list, qmi_response->signal_strength_list );
                NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.rssi, qmi_response->rssi );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.io, qmi_response->io );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sinr, qmi_response->sinr );
                NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.error_rate, qmi_response->error_rate );
                NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.ecio, qmi_response->ecio );
                NAS_CACHE_STORE_ENTRY( nas_cached_info.rsrq, qmi_response->rsrq );
                NAS_CACHE_UNLOCK();
            }
            qcril_free( qmi_response );
        }
    }
    }
    else
    {
        NAS_CACHE_LOCK();

        QCRIL_LOG_INFO("validity sign info GSM %d, WCDMA %d, TDSCDMA %d, 1x %d, HRPD %d, LTE %d",
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info),
                       (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info)
                       );

        QCRIL_LOG_INFO("validity err rate GSM %d, WCDMA %d, TDSCDMA %d",
                       (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_bit_err_rate),
                       (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_block_err_rate),
                       (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_block_err_rate)
                       );

        qmi_request_need_sig_info = FALSE;
        qmi_request_need_err_rate = FALSE;
        if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM) )
        {
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sig_info) )
            {
                qmi_request_need_sig_info = TRUE;
            }
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_bit_err_rate) )
            {
                qmi_request_need_err_rate = TRUE;
            }
        }

        if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS) )
        {
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sig_info) )
            {
                qmi_request_need_sig_info = TRUE;
            }
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_block_err_rate) )
            {
                qmi_request_need_err_rate = TRUE;
            }
        }

        if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA) )
        {
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rscp) )
            {
                qmi_request_need_sig_info = TRUE;
            }
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_block_err_rate) )
            {
                qmi_request_need_err_rate = TRUE;
            }
        }

        if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000) )
        {
            if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_sig_info) )
            {
                qmi_request_need_sig_info = TRUE;
            }
        }

        if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000_HRPD) )
        {
            if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_sig_info))
            {
                qmi_request_need_sig_info = TRUE;
            }
        }

        if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE) )
        {
            if(!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sig_info) )
            {
                qmi_request_need_sig_info = TRUE;
            }
        }

        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("..qmi_request_need_sig_info-%d, qmi_request_need_err_rate-%d", qmi_request_need_sig_info,qmi_request_need_err_rate);

        if ( qmi_request_need_sig_info )
        {
            memset( &qmi_response_sig_info, 0, sizeof( qmi_response_sig_info ) );
            qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                               QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
                                                               NULL,
                                                               NAS_NIL,
                                                               &qmi_response_sig_info,
                                                               sizeof( qmi_response_sig_info ),
                                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

            ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response_sig_info.resp );
            if ( RIL_E_SUCCESS == ril_req_res )
            {
                NAS_CACHE_LOCK();
                NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sig_info, qmi_response_sig_info.cdma_sig_info );
                NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sig_info, qmi_response_sig_info.hdr_sig_info );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gsm_sig_info, qmi_response_sig_info.gsm_sig_info );
                NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sig_info, qmi_response_sig_info.wcdma_sig_info );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.rscp, qmi_response_sig_info.rscp );
                NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sig_info, qmi_response_sig_info.lte_sig_info );
                NAS_CACHE_UNLOCK();
            }
            QCRIL_LOG_INFO("..sign info fetch res %d, %d, %d", (int) ril_req_res, (int) qmi_client_error, (int)qmi_response_sig_info.resp.error );
        }

        if ( (RIL_E_SUCCESS == ril_req_res) && qmi_request_need_err_rate )
        {
            memset( &qmi_response_err_rate, 0, sizeof( qmi_response_err_rate ) );
            qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                               QMI_NAS_GET_ERR_RATE_REQ_MSG_V01,
                                                               NULL,
                                                               NAS_NIL,
                                                               &qmi_response_err_rate,
                                                               sizeof( qmi_response_err_rate ),
                                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

            ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response_err_rate.resp );
            if ( RIL_E_SUCCESS == ril_req_res )
            {
                NAS_CACHE_LOCK();
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.gsm_bit_err_rate, qmi_response_err_rate.gsm_bit_err_rate );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.wcdma_block_err_rate, qmi_response_err_rate.wcdma_block_err_rate );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.tdscdma_block_err_rate, qmi_response_err_rate.tdscdma_block_err_rate );
                NAS_CACHE_UNLOCK();
            }
            QCRIL_LOG_INFO("..err rate fetch res %d, %d, %d", (int) ril_req_res, (int) qmi_client_error, (int)qmi_response_err_rate.resp.error );
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_fetch_signal_strength_observations

//===========================================================================^M
// qcril_qmi_nas_send_known_signal_strength
//===========================================================================
static void qcril_qmi_nas_send_known_signal_strength(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    RIL_SignalStrength ril_signal_strength;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;
    qcril_unsol_resp_params_type unsol_resp_params;

    memset( &ril_signal_strength, 0, sizeof(ril_signal_strength) );

    ril_req_res = qcril_qmi_nas_fetch_signal_strength_observations();

    QCRIL_LOG_INFO(".. Fetch sig strength info %d", (int) ril_req_res);
    if ( RIL_E_SUCCESS == ril_req_res )
    {
      NAS_CACHE_LOCK();
      ril_req_res = qcril_qmi_nas_signal_strength_con_conv_cache2ril( &ril_signal_strength );
      NAS_CACHE_UNLOCK();

      if ( RIL_E_SUCCESS == ril_req_res )
      {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_SIGNAL_STRENGTH, &unsol_resp_params );
        unsol_resp_params.resp_pkt    = &ril_signal_strength;
        unsol_resp_params.resp_len    = sizeof( ril_signal_strength );
        qcril_send_unsol_response( &unsol_resp_params );
      }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_send_known_signal_strength

//===========================================================================
// qcril_qmi_nas_get_cell_location_data_sync
//===========================================================================
RIL_Errno qcril_qmi_nas_get_cell_location_data_sync
(
    nas_get_cell_location_info_resp_msg_v01 *get_cell_location_info_resp,
    uint64_t *timestamp
)
{
    qmi_client_error_type qmi_client_error = QMI_ERR_INTERNAL_V01;
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

    if ( NULL != get_cell_location_info_resp )
    {
        memset (get_cell_location_info_resp, 0, sizeof( *get_cell_location_info_resp));

        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                          QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                          NULL,
                                                          NAS_NIL,
                                                          (void *) get_cell_location_info_resp,
                                                          sizeof( *get_cell_location_info_resp ),
                                                          QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

        if (timestamp)
        {
          *timestamp = ril_nano_time();
        }
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &get_cell_location_info_resp->resp );
    }

    return ril_req_res;
}

//===========================================================================
// qcril_qmi_nas_fetch_sys_info
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_sys_info()
{
    qmi_client_error_type qmi_client_error;
    uint8_t prev_lte_embms_coverage_valid;
    uint8_t prev_lte_embms_coverage;
    uint8_t prev_lte_embms_coverage_status_valid;
    nas_lte_rrc_embms_coverage_status_enum_v01 prev_lte_embms_coverage_status;
    uint8_t                          prev_lte_sys_info_valid;
    nas_lte_sys_info_type_v01        prev_lte_sys_info;

    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    RIL_Errno   location_data_res;

    nas_get_sys_info_resp_msg_v01 * qmi_response = NULL;

    uint8_t old_mcc_mnc_valid;
    char old_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char old_mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint8_t new_mcc_mnc_valid;
    char new_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char new_mnc_str[NAS_MCC_MNC_MAX_SIZE];

    qmi_response = qcril_malloc( sizeof( *qmi_response ) );
    if ( qmi_response )
    {

        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                           NULL,
                                                           NAS_NIL,  // empty request payload
                                                           (void*) qmi_response,
                                                           sizeof( *qmi_response ),
                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );


        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();

            old_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(old_mcc_str, old_mnc_str, TRUE, NULL);

            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_srv_status_info, qmi_response->cdma_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_srv_status_info, qmi_response->hdr_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_srv_status_info, qmi_response->gsm_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_srv_status_info, qmi_response->wcdma_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_srv_status_info, qmi_response->tdscdma_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_srv_status_info, qmi_response->lte_srv_status_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info, qmi_response->cdma_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info, qmi_response->hdr_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info, qmi_response->gsm_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info, qmi_response->wcdma_sys_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.tdscdma_sys_info, qmi_response->tdscdma_sys_info );

            prev_lte_sys_info_valid = nas_cached_info.lte_sys_info_valid;
            if (prev_lte_sys_info_valid)
            {
               if (nas_cached_info.lte_sys_info)
               {
                  memcpy(&prev_lte_sys_info, nas_cached_info.lte_sys_info, sizeof(prev_lte_sys_info));
               }
               else
               {
                  QCRIL_LOG_DEBUG("nas_cached_info.lte_sys_info_valid is true but nas_cached_info.lte_sys_info is NULL");
                  prev_lte_sys_info_valid = FALSE;
               }
            }
            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info, qmi_response->lte_sys_info );

            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_sys_info2, qmi_response->cdma_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.hdr_sys_info2, qmi_response->hdr_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info2, qmi_response->gsm_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info2, qmi_response->wcdma_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.lte_sys_info2, qmi_response->lte_sys_info2 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.gsm_sys_info3, qmi_response->gsm_sys_info3 );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.wcdma_sys_info3, qmi_response->wcdma_sys_info3 );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_cell_status, qmi_response->lte_cell_status );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_support_on_lte, qmi_response->voice_support_on_lte );

            prev_lte_embms_coverage_valid = nas_cached_info.lte_embms_coverage_valid;
            prev_lte_embms_coverage = nas_cached_info.lte_embms_coverage;
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_embms_coverage, qmi_response->lte_embms_coverage );

            prev_lte_embms_coverage_status_valid = nas_cached_info.embms_coverage_status_valid;
            prev_lte_embms_coverage_status = nas_cached_info.embms_coverage_status;
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.embms_coverage_status, qmi_response->embms_coverage_status );

            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.sim_rej_info, qmi_response->sim_rej_info );

            nas_cached_info.is_considered_registered_cached_result_valid = FALSE;
            nas_cached_info.is_in_service_of_technology_cache_result_valid = FALSE;

            NAS_CACHE_STORE_ENTRY(nas_cached_info.wcdma_csg_info, qmi_response->wcdma_csg_info );

            NAS_CACHE_STORE_ENTRY(nas_cached_info.lte_csg_info, qmi_response->lte_csg_info );

            qcril_qmi_nas_update_voice_rte();
            qcril_qmi_nas_update_data_rte();
            qcril_qmi_nas_update_ims_rte();
            qcril_qmi_voice_technology_updated();
            qmi_ril_nwr_update_reg_rej_from_sys_info();

            new_mcc_mnc_valid = qcril_qmi_nas_find_current_mcc_mnc(new_mcc_str, new_mnc_str, TRUE, NULL);
            if( old_mcc_mnc_valid != new_mcc_mnc_valid || strcmp(old_mcc_str, new_mcc_str) || strcmp(old_mnc_str, new_mnc_str) )  //invalidiating operator name specifics as PLMN has changed
            {
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
                NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
            }

            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_voice_status,qmi_response->lte_voice_status);

            NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sms_status,qmi_response->lte_sms_status);

            NAS_CACHE_UNLOCK();

            qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(
                    prev_lte_embms_coverage_status_valid,
                    prev_lte_embms_coverage_status);
            qcril_qmi_nas_embms_send_cell_info_changed_if_needed(prev_lte_sys_info_valid, &prev_lte_sys_info);
        }

        qcril_free( qmi_response );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_fetch_sys_info
//===========================================================================
// qcril_qmi_nas_fetch_serving_system_info
//===========================================================================
RIL_Errno qcril_qmi_nas_fetch_serving_system_info()
{
    qmi_client_error_type qmi_client_error;

    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

    nas_get_serving_system_resp_msg_v01 * qmi_response = NULL;

    qmi_response = qcril_malloc( sizeof( *qmi_response ) );
    if ( qmi_response )
    {

        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_GET_SERVING_SYSTEM_REQ_MSG_V01,
                                                           NULL,
                                                           NAS_NIL,  // empty request payload
                                                           (void*) qmi_response,
                                                           sizeof( *qmi_response ),
                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );


        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();

            NAS_CACHE_STORE_ENTRY_VALID_VAL( nas_cached_info.serving_system, qmi_response->serving_system );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_base_station_info, qmi_response->cdma_base_station_info );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.cdma_system_id, qmi_response->cdma_system_id );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roaming_indicator, qmi_response->roaming_indicator );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lac, qmi_response->lac );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cell_id, qmi_response->cell_id );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.ccs, qmi_response->ccs );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prl_ind, qmi_response->prl_ind );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.detailed_service_info, qmi_response->detailed_service_info );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cdma_system_id_ext, qmi_response->cdma_system_id_ext );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.hdr_personality, qmi_response->hdr_personality );
            NAS_CACHE_STORE_ENTRY_ARR( nas_cached_info.data_capabilities, qmi_response->data_capabilities );

            NAS_CACHE_STORE_ENTRY( nas_cached_info.current_plmn,  qmi_response->current_plmn );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.p_rev_in_use, qmi_response->p_rev_in_use );

            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.tac, qmi_response->tac );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.call_barring_status, qmi_response->call_barring_status );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.umts_psc, qmi_response->umts_psc );
            NAS_CACHE_STORE_ENTRY( nas_cached_info.mnc_includes_pcs_digit, qmi_response->mnc_includes_pcs_digit );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.hs_call_status, qmi_response->hs_call_status );
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.def_roam_ind, qmi_response->def_roam_ind );

            if ( NAS_VAL_REGISTERED == qmi_response->serving_system.registration_state )
            {
                NAS_CACHE_INVALIDATE_ENTRY( nas_cached_info.registration_reject_reason );
            }

            qcril_qmi_voice_technology_updated();
            qmi_ril_nwr_update_reg_rej_legacy();

            ril_req_res = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;

            NAS_CACHE_UNLOCK();
        }

        qcril_free( qmi_response );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_fetch_serving_system_info

//===========================================================================
// RIL_REQUEST_REGISTRATION_STATE
//===========================================================================
void qcril_qmi_nas_request_registration_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_request_resp_params_type resp;

  qcril_qmi_nas_registration_state_resp_helper_type ril_resp_helper;

  int           qmi_request_need1;

  qmi_ril_nw_reg_rte_type           vrte;
  qmi_ril_nw_reg_rte_type           irte;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int         ril_resp_no_elements = NAS_NIL;

  int idx;
  int cnt;

  int   val_int;

  int in_service;

  int reg_state = 0;

  int assume_emergency_calls_possible;

  nas_service_status_enum_type_v01  sys_info_common_service_status;
  RIL_RadioTechnology               voice_rte;
  int                               is_rte_3gpp;
  int                               is_rte_lte;
  nas_sys_info_helper_type sys_info_helper;

  uint8_t                            temp_radio_if;
  uint32                             log_mask = 0;

  int                                is_ics;

  int                                must_rerender_reg_report;
  int                                in_transfer_cs_reg_reject;

  qmi_ril_nas_restricted_details_state_e_type
                                     restricted_details_state;

  int                                post_adjustment_val;

  int                                ccs_is_present;

  int                                cdma_ccs_supported;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  is_rte_lte = FALSE;
  cdma_ccs_supported = FALSE;
  must_rerender_reg_report  = FALSE;
  in_transfer_cs_reg_reject = FALSE;

  // ** response holder init
  memset( &ril_resp_helper, 0, sizeof( ril_resp_helper ) );

  ril_resp_helper.registration_info_array[0] = ril_resp_helper.registration_state;
  ril_resp_helper.registration_info_array[1] = ril_resp_helper.lac;
  ril_resp_helper.registration_info_array[2] = ril_resp_helper.cid;
  ril_resp_helper.registration_info_array[3] = ril_resp_helper.radio_tech;
  ril_resp_helper.registration_info_array[4] = ril_resp_helper.base_id;
  ril_resp_helper.registration_info_array[5] = ril_resp_helper.base_latitude;
  ril_resp_helper.registration_info_array[6] = ril_resp_helper.base_longitude;
  ril_resp_helper.registration_info_array[7] = ril_resp_helper.ccs;
  ril_resp_helper.registration_info_array[8] = ril_resp_helper.sid;
  ril_resp_helper.registration_info_array[9] = ril_resp_helper.nid;
  ril_resp_helper.registration_info_array[10] = ril_resp_helper.roam_status;
  ril_resp_helper.registration_info_array[11] = ril_resp_helper.prl_ind;
  ril_resp_helper.registration_info_array[12] = ril_resp_helper.def_roam_ind;
  ril_resp_helper.registration_info_array[13] = ril_resp_helper.reg_reject_cause;
  ril_resp_helper.registration_info_array[14] = ril_resp_helper.primary_scrambling_code;

  is_ics = qmi_ril_is_feature_supported(  QMI_RIL_FEATURE_ICS );
  QCRIL_LOG_INFO( ".. is ICS %d", (int) is_ics );

  qmi_ril_suppress_android_unsol_resp(RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED);
  qmi_ril_suppress_android_unsol_resp(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED);
  NAS_CACHE_LOCK();

  if ( !qmi_ril_is_qmi_sys_info_available() )
  { // legacy version
      // ** update cache if necessary
      NAS_CACHE_LOCK();
      qmi_request_need1 = ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) &&
                            NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info ) &&
                            NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator )
                             ) ? FALSE : TRUE;

      if (  qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01) )
      {
          qmi_request_need1 |= (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cell_id ) &&
                               NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lac )) ? FALSE : TRUE;

      }

      if (  qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP2_V01) )
      {
          qmi_request_need1 |= (
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.def_roam_ind ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_base_station_info ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.ccs ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.prl_ind ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_personality ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.umts_psc )
                                )
                                ? FALSE : TRUE;

      }
      NAS_CACHE_UNLOCK();

      QCRIL_LOG_INFO("cache subrequest need %d", (int) qmi_request_need1);
      if ( qmi_request_need1 )
      {
          ril_req_res = qcril_qmi_nas_fetch_serving_system_info();
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
      }

      // ** update cache if necessary - sys info part
      if ( RIL_E_SUCCESS == ril_req_res )
      {
          qcril_qmi_nas_fetch_serving_system_info(); // will be extended
      }


      // ** form answer
      if ( RIL_E_SUCCESS == ril_req_res )
      {

          QCRIL_LOG_INFO( "forming response");

          NAS_CACHE_LOCK();

          // * registartion state
          val_int = 4; // unknown
          in_service = FALSE;

          QCRIL_LOG_INFO( ".. detaled service info valid %d", (int)NAS_CACHE_IS_ENTRY_VALID_ARR( nas_cached_info.detailed_service_info ));

          if ( NAS_CACHE_IS_ENTRY_VALID_ARR( nas_cached_info.detailed_service_info ) )
          {
              QCRIL_LOG_INFO( ".. detaled service info srv_status %d", nas_cached_info.detailed_service_info->srv_status );
              switch ( nas_cached_info.detailed_service_info->srv_status )
              {
                  case NAS_VAL_LIMITED_SERVICE:
                  case NAS_VAL_LIMITED_REGIONAL_SERVICE:
                      assume_emergency_calls_possible = TRUE;
                      break;

                  default:
                      assume_emergency_calls_possible = FALSE;
                  break;
              }
          }
          else
          {
              assume_emergency_calls_possible = FALSE;
          }

          QCRIL_LOG_INFO( ".. serving system valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) )
          {
            QCRIL_LOG_INFO( ".. registration state %d, cs attach state %d",
                            (int) nas_cached_info.serving_system->registration_state,
                            (int) nas_cached_info.serving_system->cs_attach_state );
          }
          QCRIL_LOG_INFO( ".. roaming indicator valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator ) );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator ) )
          {
              QCRIL_LOG_INFO( ".. roaming indicator %d", (int) nas_cached_info.roaming_indicator );
          }
          QCRIL_LOG_INFO( ".. registration reject valid %d", (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.registration_reject_reason)  );
          if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.registration_reject_reason)  )
          {
              QCRIL_LOG_INFO( ".. registration reject service domain %d", (int) nas_cached_info.registration_reject_reason->service_domain );
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) )
          {
            switch ( nas_cached_info.serving_system->registration_state  )
            {
                case NAS_VAL_REGISTERED:
                    if ( nas_cached_info.serving_system->cs_attach_state == NAS_VAL_CS_ATTACH_ATTACHED )
                    {
                        if ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator )  ||
                             ( NAS_VAL_ROAMING_HOME == nas_cached_info.roaming_indicator ||
                               ( NAS_VAL_ROAMING_HOME_EX_64 == nas_cached_info.roaming_indicator && nas_common_info.eri_64_home )
                             )
                           )
                        {
                            val_int = 1;
                        }
                        else
                        {
                            val_int = 5;
                        }
                        in_service = TRUE;
                    }
                    else
                    {
                        val_int = 2;
                    }
                    break;

                case NAS_VAL_NOT_REGISTERED:
                case NAS_VAL_NOT_REGISTERED_SEARCHING:
                    val_int = assume_emergency_calls_possible ? 12 : 2; // not registered, searching
                    if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.registration_reject_reason) )
                    {
                        switch ( nas_cached_info.registration_reject_reason->service_domain )
                        {
                            case NAS_CIRCUIT_SWITCHED_V01:
                            case NAS_CIRCUIT_AND_PACKET_SWITCHED_V01:
                                val_int = assume_emergency_calls_possible ? 13 : 3; // Registration denied
                                break;

                            default:
                                // skip
                                break;
                        }
                    }
                    break;

                case NAS_VAL_REGISTRATION_DENIED:
                    val_int = assume_emergency_calls_possible ? 13 : 3; // Registration denied
                    break;

                case NAS_VAL_REGISTRATION_UNKNOWN:
                    val_int = assume_emergency_calls_possible ? 14 : 4; // Unknown
                    if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.registration_reject_reason) )
                    {
                        switch ( nas_cached_info.registration_reject_reason->service_domain )
                        {
                            case NAS_CIRCUIT_SWITCHED_V01:
                            case NAS_CIRCUIT_AND_PACKET_SWITCHED_V01:
                                val_int = assume_emergency_calls_possible ? 13 : 3; // Registration denied
                                break;

                            default:
                                // skip
                                break;
                        }
                    }
                    break;

                default:
                    val_int = 4; // Unknown
                    break;
            }
          }
          else
          { // unknown
            val_int                  = RIL_VAL_REG_UNKNOWN;
            in_service               = FALSE;
          }
          // adjustment reg reject legacy
          QCRIL_LOG_INFO("pre - cur reg state %d", (int) val_int);
          switch ( val_int )
          {
              case RIL_VAL_REG_REGISTERED_HOME_NET:
              case RIL_VAL_REG_REGISTERED_ROAMING:
                if ( nas_cached_info.reg_reject_legacy.cs_rejected && !nas_cached_info.reg_reject_legacy.cs_reject_cause_relayed )
                {
                  val_int = RIL_VAL_REG_REGISTRATION_DENIED;
                  must_rerender_reg_report = TRUE;
                }
                break;

              case RIL_VAL_REG_UNKNOWN:                         // fallthough
              case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:        // fallthough
              case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:    // fallthough
              case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                  if ( nas_cached_info.reg_reject_legacy.cs_rejected )
                  {
                    switch ( val_int )
                    {
                      case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                        post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                        break;

                      default:
                        post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED;
                        break;
                    }
                    val_int = post_adjustment_val;
                  }
                  QCRIL_LOG_INFO(".. adjusting for reg reject %d, status %d", (int) nas_cached_info.reg_reject_legacy.cs_rejected, val_int );
                  break;

              default:
                  break;
          }


          snprintf( ril_resp_helper.registration_state, sizeof(ril_resp_helper.registration_state), "%d", val_int );
          reg_state = val_int;
          QCRIL_LOG_INFO("cur reg state %d", (int) val_int);

          if ( in_service )
          {
              // *lac
              if ( qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01) )
              {
                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", nas_cached_info.lac );
              }
              // *cid
              if ( qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01) )
              {
                  if ( nas_cached_info.cell_id > (uint32_t)0x7FFFFFFF )
                  {
                      snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", (uint32_t) 0x7FFFFFFF );
                  }
                  else
                  {
                      snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", nas_cached_info.cell_id );
                  }
              }
              // *radio technology
              val_int = NAS_NIL;
              if (nas_cached_info.serving_system->radio_if_len > 0)
              {
                  switch ( nas_cached_info.serving_system->radio_if[NAS_NIL] )
                  {
                      case NAS_RADIO_IF_CDMA2000:
                          QCRIL_LOG_INFO(".. cdma p_rev valid %d", (int)NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.p_rev_in_use ) );
                          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.p_rev_in_use ) )
                          {
                              QCRIL_LOG_INFO(".. cdma p_rev %d", (int)nas_cached_info.p_rev_in_use );
                              val_int = qcril_qmi_util_determine_cdma_rev_direct( nas_cached_info.p_rev_in_use );
                          }
                          else
                          {
                              val_int = RADIO_TECH_IS95A;
                          }
                          break;

                      case NAS_RADIO_IF_CDMA2000_HRPD:
                          val_int = RADIO_TECH_EVDO_0;
                          break;

                    case NAS_RADIO_IF_GSM:
                          if ( is_ics )
                          {
                            val_int = RADIO_TECH_GSM;
                          }
                          else
                          {
                            val_int = RADIO_TECH_GPRS;
                          }
                          break;

                      case NAS_RADIO_IF_UMTS:
                          val_int = RADIO_TECH_UMTS;
                          break;

                      case NAS_RADIO_IF_LTE:
                          val_int = RADIO_TECH_LTE;
                          break;

                      default:
                          break;
                  }
              }
              snprintf( ril_resp_helper.radio_tech, sizeof(ril_resp_helper.radio_tech), "%d", val_int );

              // *base_id, base_latitude, base_longitude, sid, nid, roaming status, def roam indicator
              if ( qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP2_V01)  )
              {
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_base_station_info ) )
                  {
                      snprintf( ril_resp_helper.base_id, sizeof(ril_resp_helper.base_id), "%d", (int) nas_cached_info.cdma_base_station_info->base_id );

                      snprintf( ril_resp_helper.base_latitude, sizeof(ril_resp_helper.base_latitude), "%ld", (long int)nas_cached_info.cdma_base_station_info->base_lat );

                      snprintf( ril_resp_helper.base_longitude, sizeof(ril_resp_helper.base_longitude), "%ld", (long int)nas_cached_info.cdma_base_station_info->base_long );
                  }

                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.ccs ) )
                  {
                      snprintf( ril_resp_helper.ccs, sizeof(ril_resp_helper.ccs), "%d", nas_cached_info.ccs );
                  }
              }

          }
          else
          {  // technology
              snprintf( ril_resp_helper.radio_tech, sizeof(ril_resp_helper.radio_tech), "%d", NAS_NIL );
          }

          //report roaming related fields If valid due to voice or data service through RIL_REQUEST_REGISTRATION_STATE response
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id ) )
          {
              snprintf( ril_resp_helper.sid, sizeof(ril_resp_helper.sid), "%d", (int) nas_cached_info.cdma_system_id->sid );

              snprintf( ril_resp_helper.nid, sizeof(ril_resp_helper.nid), "%d", (int) nas_cached_info.cdma_system_id->nid );
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator ) )
          {
              snprintf( ril_resp_helper.roam_status, sizeof(ril_resp_helper.roam_status), "%d", nas_cached_info.roaming_indicator );
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.prl_ind ) )
          {
              snprintf( ril_resp_helper.prl_ind, sizeof(ril_resp_helper.prl_ind), "%d", nas_cached_info.prl_ind );
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.def_roam_ind ) )
          {
              snprintf( ril_resp_helper.def_roam_ind, sizeof(ril_resp_helper.def_roam_ind), "%d", nas_cached_info.def_roam_ind );
          }



          // * registration reject reason
          switch ( reg_state )
          {
              case RIL_VAL_REG_REGISTRATION_DENIED:
              case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                  if (! nas_cached_info.reg_reject_legacy.cs_rejected )
                  {
                      val_int = NAS_NIL;
                      break;
                  }
                  if ((nas_cached_info.reg_reject_legacy.cs_rejected_managed_roaming)
                   && (nas_cached_info.reg_reject_legacy.cs_reject_cause_relayed == TRUE ))
                  {
                      val_int = NAS_NIL;
                      break;
                  }
                  temp_radio_if = (nas_cached_info.serving_system->radio_if_len > 0)?
                                   nas_cached_info.serving_system->radio_if[NAS_NIL]: NAS_RADIO_IF_NO_SVC_V01;
                  val_int = qmi_ril_nwr_conv_reg_reject_cause_voice(nas_cached_info.reg_reject_legacy.cs_reject_cause, temp_radio_if);
                  qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED );
                  break;

              default:
                  val_int = NAS_NIL;
                  break;
          }
          snprintf( ril_resp_helper.reg_reject_cause, sizeof(ril_resp_helper.reg_reject_cause), "%d", val_int );

          // * Primary Scrambling Code
          val_int = 0; // Android wants "generic case"
          if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.umts_psc ) )
          {
              val_int = nas_cached_info.umts_psc;
          }
          snprintf( ril_resp_helper.primary_scrambling_code, sizeof(ril_resp_helper.primary_scrambling_code), "%x", val_int );

          // reset display for managed roaming
          if ( nas_cached_info.reg_reject_legacy.cs_rejected &&
               nas_cached_info.reg_reject_legacy.cs_rejected_managed_roaming &&
               nas_cached_info.reg_reject_legacy.cs_reject_cause_relayed
             )
          {
              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED );
          }

          // done
          NAS_CACHE_UNLOCK();
      }

  }
  else
  { // sys info version

      NAS_CACHE_LOCK();

      vrte = nas_cached_info.voice_rte;
      irte = nas_cached_info.ims_rte;

      if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
      {
          qmi_request_need1 = FALSE; // response for IMS is entirely simulated
      }
      else
      {
          switch ( nas_cached_info.voice_rte )
          {
              case QMI_RIL_RTE_1x:
                  qmi_request_need1 =
                      (
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info )
                      ) ? FALSE : TRUE;
                  break;

              case QMI_RIL_RTE_GSM:
                  qmi_request_need1 =
                      (
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 )
                      ) ? FALSE : TRUE;
                  break;

              case QMI_RIL_RTE_WCDMA:
                  qmi_request_need1 =
                      (
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 )
                      ) ? FALSE : TRUE;
                  break;

              case QMI_RIL_RTE_TDSCDMA:
                  qmi_request_need1 =
                      (
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info )
                      ) ? FALSE : TRUE;
                  break;

              case QMI_RIL_RTE_SUB_LTE:
                  qmi_request_need1 =
                      (
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte )
                      ) ? FALSE : TRUE;
                  break;

              case QMI_RIL_RTE_SUB_DO:
                  qmi_request_need1 =
                      (
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) &&
                      NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info )
                      ) ? FALSE : TRUE;
                  break;

              default:
                  qmi_request_need1 = TRUE; // if vrte unknown, refresh
                  break;
          }
      }
      NAS_CACHE_UNLOCK();

      QCRIL_LOG_INFO(".. request need %d, vrte %d, irte %d", (int) qmi_request_need1, (int) vrte, (int) irte );
      if ( qmi_request_need1 )
      {
          ril_req_res = qcril_qmi_nas_fetch_sys_info();
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
      }

      if ( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();

          QCRIL_LOG_INFO(" ... cdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... hdr_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) );
          QCRIL_LOG_INFO(" ... gsm_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) );
          QCRIL_LOG_INFO(" ... wcdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... tdscdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... lte_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) );
          QCRIL_LOG_INFO(" ... cdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) );
          QCRIL_LOG_INFO(" ... hdr_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) );
          QCRIL_LOG_INFO(" ... gsm_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) );
          QCRIL_LOG_INFO(" ... wcdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) );
          QCRIL_LOG_INFO(" ... tdscdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) );
          QCRIL_LOG_INFO(" ... lte_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) );
          QCRIL_LOG_INFO(" ... voice_support_on_lte val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) );

          // first run - full service check
          QCRIL_LOG_INFO(" ... nas_cached_info.voice_rte %d", (int) nas_cached_info.voice_rte );
          sys_info_common_service_status= NAS_SYS_SRV_STATUS_NO_SRV_V01;
          memset(&sys_info_helper,0,sizeof(sys_info_helper));


          QCRIL_LOG_INFO(" ... nas_cached_info.ims_rte %d", (int) nas_cached_info.ims_rte );
          if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
          {
              voice_rte   = RADIO_TECH_UMTS;
              is_rte_3gpp = FALSE;
          }
          else
          {
              switch ( nas_cached_info.voice_rte )
              {
                  case QMI_RIL_RTE_1x:
                      QCRIL_LOG_INFO( " .. prep CDMA" );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
                      {
                          sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
                          sys_info_common_service_status = nas_cached_info.cdma_srv_status_info->srv_status;
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
                      {
                          sys_info_helper.common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
                          sys_info_helper.cdma_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
                          sys_info_helper.cdma_hdr_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_hdr_only_sys_info;
                      }
                      voice_rte                      = qcril_qmi_nas_util_determine_cdma_rev( sys_info_helper.cdma_only_sys_info );
                      is_rte_3gpp                    = FALSE;  \
                      val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_EMPTY,
                                                                                            &sys_info_helper);

                      break;

                  case QMI_RIL_RTE_GSM:
                      QCRIL_LOG_INFO( " .. prep GSM" );
                      if ( NAS_CACHE_IS_ENTRY_VALID ( nas_cached_info.gsm_srv_status_info ) )
                      {
                          sys_info_helper.threegpp_srv_status  = nas_cached_info.gsm_srv_status_info;
                          sys_info_common_service_status = nas_cached_info.gsm_srv_status_info->srv_status;
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                      {
                          sys_info_helper.common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
                          sys_info_helper.threegpp_only_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                      }

                      if ( is_ics )
                      {
                        voice_rte = RADIO_TECH_GSM;
                      }
                      else
                      {
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                             nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid &&
                             NAS_SYS_EGPRS_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp )
                        {
                            voice_rte = RADIO_TECH_EDGE; // edge
                        }
                        else
                        {
                            voice_rte = RADIO_TECH_GPRS; // conclude  -  gprs
                        }
                      }

                      is_rte_3gpp                    = TRUE;
                      val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                            &sys_info_helper);
                      break;

                  case QMI_RIL_RTE_WCDMA:
                      QCRIL_LOG_INFO( " .. prep WCDMA" );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
                      {
                          sys_info_helper.threegpp_srv_status  = nas_cached_info.wcdma_srv_status_info;
                          sys_info_common_service_status = nas_cached_info.wcdma_srv_status_info->srv_status;
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                      {
                          sys_info_helper.common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
                          sys_info_helper.threegpp_only_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                          sys_info_helper.wcdma_only_sys_info = &nas_cached_info.wcdma_sys_info->wcdma_specific_sys_info;
                      }
                      voice_rte                      = RADIO_TECH_UMTS;
                      is_rte_3gpp                    = TRUE;
                      val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                            &sys_info_helper);
                      break;

                  case QMI_RIL_RTE_TDSCDMA:
                      QCRIL_LOG_INFO( " .. prep TDSCDMA" );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
                      {
                          sys_info_helper.threegpp_srv_status  = nas_cached_info.tdscdma_srv_status_info;
                          sys_info_common_service_status = nas_cached_info.tdscdma_srv_status_info->srv_status;
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                      {
                          sys_info_helper.common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
                          sys_info_helper.threegpp_only_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                          sys_info_helper.tdscdma_only_sys_info = &nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info;
                      }
                      voice_rte                      = RADIO_TECH_TD_SCDMA;
                      is_rte_3gpp                    = TRUE;
                      val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                            &sys_info_helper);
                      break;


                  case QMI_RIL_RTE_SUB_LTE:
                      QCRIL_LOG_INFO( " .. prep LTE" );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
                      {
                          sys_info_helper.threegpp_srv_status  = nas_cached_info.lte_srv_status_info;
                          sys_info_common_service_status = nas_cached_info.lte_srv_status_info->srv_status;
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                      {
                          sys_info_helper.common_sys_info  = &nas_cached_info.lte_sys_info->common_sys_info;
                          sys_info_helper.threegpp_only_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                      }
                      voice_rte                      = RADIO_TECH_LTE;
                      is_rte_3gpp                    = TRUE;
                      is_rte_lte                     = TRUE;
                      if( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.voice_support_on_lte) )
                      {
                          sys_info_helper.voice_support_on_lte = &nas_cached_info.voice_support_on_lte;
                      }
                      val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                                            &sys_info_helper);
                      break;

                  case QMI_RIL_RTE_SUB_DO:
                      QCRIL_LOG_INFO( " .. prep EVDO" );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
                      {
                          sys_info_helper.threegpp2_srv_status  = nas_cached_info.hdr_srv_status_info;
                          sys_info_common_service_status = nas_cached_info.hdr_srv_status_info->srv_status;
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                      {
                          sys_info_helper.common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
                          sys_info_helper.cdma_hdr_only_sys_info = &nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info;
                          sys_info_helper.hdr_only_sys_info = &nas_cached_info.hdr_sys_info->hdr_specific_sys_info;
                      }
                      voice_rte                      = RADIO_TECH_UNKNOWN;
                      is_rte_3gpp                    = FALSE;
                      val_int = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_HDR,
                                                                                            &sys_info_helper);
                      break;

                  default:
                      val_int                        = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                      voice_rte                      = RADIO_TECH_UNKNOWN;
                      is_rte_3gpp                    = TRUE;
                      break;
              }
          }
          QCRIL_LOG_INFO(" ... so far ss, vrte %d, %d", (int) nas_cached_info.voice_rte, (int) voice_rte );

          // * registartion state
          if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
          {
              val_int = RIL_VAL_REG_REGISTERED_HOME_NET;
          }
          else
          {
              // reg reject adjust
              switch ( val_int )
              {
                  case RIL_VAL_REG_REGISTERED_HOME_NET:
                  case RIL_VAL_REG_REGISTERED_ROAMING:
                    if ( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected &&
                         !nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause_relayed )
                    {
                        val_int                   = RIL_VAL_REG_REGISTRATION_DENIED;
                        must_rerender_reg_report  = TRUE;
                        in_transfer_cs_reg_reject = TRUE;
                    }
                    break;

                  case RIL_VAL_REG_UNKNOWN:                         // fallthough
                  case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:        // fallthough
                  case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:    // fallthough
                  case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                      if ( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected )
                      {
                        switch ( val_int )
                        {
                          case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                            if ( ( QMI_NAS_REJ_CAUSE_PLMN_NOT_ALLOWED    == nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause ||
                                 QMI_NAS_REJ_CAUSE_NO_SUITABLE_CELL_LA == nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause
                                 ) && ( TRUE == nas_common_info.is_reg_denied_on_rej_cause ) ) //Has to set the property for QMI RIL to report RIL_VAL_REG_REGISTRATION_DENIED when reject cause is QMI_NAS_REJ_CAUSE_PLMN_NOT_ALLOWED or QMI_NAS_REJ_CAUSE_NO_SUITABLE_CELL_LA
                            {
                              post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED;
                            }
                            else
                            {
                              post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                            }
                            break;

                          default:
                            post_adjustment_val = RIL_VAL_REG_REGISTRATION_DENIED;
                            break;
                        }
                        val_int = post_adjustment_val;
                      }
                      QCRIL_LOG_INFO(".. adjusting for reg reject %d, status %d", (int) nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected, val_int );
                      break;

                  default:
                      break;
              }
          }

          // set
          snprintf( ril_resp_helper.registration_state, sizeof(ril_resp_helper.registration_state), "%d", val_int );
          reg_state = val_int;
          QCRIL_LOG_INFO("cur reg state %d", (int) val_int);
          if (val_int == 1) {
              log_mask |= 0x01; // in service
          } else if (val_int == 5) {
              log_mask |= 0x01; // in service
              log_mask |= 0x02; // roaming
          }


          // is in service
          if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
          {
              in_service = TRUE;
          }
          else
          {
              if ( (NAS_SYS_SRV_STATUS_SRV_V01 == sys_info_common_service_status && !in_transfer_cs_reg_reject) ||
                   RIL_VAL_REG_REGISTERED_HOME_NET == val_int ||
                   RIL_VAL_REG_REGISTERED_ROAMING == val_int )
              {
                  in_service = TRUE;
              }
              else
              {
                  in_service = FALSE;
              }
          }
          QCRIL_LOG_INFO(" ... so far in_service %d", (int) in_service );

          if ( in_service )
          {
              if ( QMI_RIL_RTE_NONE == nas_cached_info.ims_rte )
              {
                  // *lac
                  if ( is_rte_3gpp )
                  {
                      if( NULL != sys_info_helper.threegpp_only_sys_info && sys_info_helper.threegpp_only_sys_info->lac_valid )
                      {
                          snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", (uint) sys_info_helper.threegpp_only_sys_info->lac );
                      }

                      if( is_rte_lte )
                      {
                          QCRIL_LOG_INFO("... lte details valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) );
                          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                          {
                              QCRIL_LOG_INFO("... tac valid %d, tac %d", (int) nas_cached_info.lte_sys_info->lte_specific_sys_info.tac_valid, (int) nas_cached_info.lte_sys_info->lte_specific_sys_info.tac  );
                              if ( nas_cached_info.lte_sys_info->lte_specific_sys_info.tac_valid )
                              {
                                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", (uint) nas_cached_info.lte_sys_info->lte_specific_sys_info.tac );
                              }
                          }
                      }
                  }
                  // *cid
                  if ( is_rte_3gpp && NULL != sys_info_helper.threegpp_only_sys_info && sys_info_helper.threegpp_only_sys_info->cell_id_valid )
                  {
                      if ( sys_info_helper.threegpp_only_sys_info->cell_id > (uint32_t)0x7FFFFFFF )
                      {
                          snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", (uint32_t) 0x7FFFFFFF );
                      }
                      else
                      {
                          snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", (uint) sys_info_helper.threegpp_only_sys_info->cell_id );
                      }
                  }
              }
              // *radio technology
              snprintf( ril_resp_helper.radio_tech, sizeof(ril_resp_helper.radio_tech), "%d", (int)voice_rte );

              if ( QMI_RIL_RTE_NONE == nas_cached_info.ims_rte )
              {
                  // *base_id, base_latitude, base_longitude, sid, nid, roaming status, def roam indicator
                  if ( !is_rte_3gpp  )
                  {
                      if ( NULL != sys_info_helper.cdma_only_sys_info && sys_info_helper.cdma_only_sys_info->bs_info_valid )
                      {
                          snprintf( ril_resp_helper.base_id, sizeof(ril_resp_helper.base_id), "%d", (int) sys_info_helper.cdma_only_sys_info->bs_info.base_id );

                          snprintf( ril_resp_helper.base_latitude, sizeof(ril_resp_helper.base_latitude), "%ld",
                                    (long int)sys_info_helper.cdma_only_sys_info->bs_info.base_lat );

                          snprintf( ril_resp_helper.base_longitude, sizeof(ril_resp_helper.base_longitude), "%ld",
                                    (long int)sys_info_helper.cdma_only_sys_info->bs_info.base_long );
                      }

                      if ( NULL != sys_info_helper.cdma_only_sys_info && sys_info_helper.cdma_only_sys_info->ccs_supported_valid )
                      {
                          cdma_ccs_supported = sys_info_helper.cdma_only_sys_info->ccs_supported;
                      }

                      if ( NULL != sys_info_helper.cdma_only_sys_info && sys_info_helper.cdma_only_sys_info->cdma_sys_id_valid  )
                      {
                          NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cdma_sys_id, sys_info_helper.cdma_only_sys_info->cdma_sys_id );
                      }
                      else
                      {
                          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
                      }

                      if ( NULL != sys_info_helper.common_sys_info && sys_info_helper.common_sys_info->roam_status_valid )
                      {
                          NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_status, sys_info_helper.common_sys_info->roam_status );
                          nas_cached_info.voice_roam_status_reported = TRUE;
                      }
                      else
                      {
                          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
                      }

                      if ( NULL != sys_info_helper.cdma_hdr_only_sys_info && sys_info_helper.cdma_hdr_only_sys_info->is_sys_prl_match_valid )
                      {
                          NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.is_sys_prl_match, sys_info_helper.cdma_hdr_only_sys_info->is_sys_prl_match );
                      }
                      else
                      {
                          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
                      }

                  }
              }

          }
          else
          {  // technology
              snprintf( ril_resp_helper.radio_tech, sizeof(ril_resp_helper.radio_tech), "%d", (int)RADIO_TECH_UNKNOWN );
          }

          // CCS
          QCRIL_LOG_INFO("ccs_supported %d", cdma_ccs_supported);
          QCRIL_LOG_DEBUG("simul_voice_and_data_capability valid %d, value %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ), nas_cached_info.simul_voice_and_data_capability);
          QCRIL_LOG_DEBUG("reported data technology %d", nas_cached_info.reported_data_technology);

          ccs_is_present = FALSE;
          switch( nas_cached_info.reported_data_technology )
          {
              case RADIO_TECH_LTE:
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ) &&
                      (QMI_DMS_MASK_SVLTE_CAPABLE_V01 & nas_cached_info.simul_voice_and_data_capability) )    //checking svlte
                  {
                      ccs_is_present = TRUE;
                  }
                  break;

              case RADIO_TECH_EVDO_0:
              case RADIO_TECH_EVDO_A:
              case RADIO_TECH_EVDO_B:
              case RADIO_TECH_EHRPD:
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.simul_voice_and_data_capability ) &&
                      (QMI_DMS_MASK_SVDO_CAPABLE_V01 & nas_cached_info.simul_voice_and_data_capability) )    //checking svdo
                  {
                      ccs_is_present = TRUE;
                  }
                  break;

              case RADIO_TECH_IS95A:
              case RADIO_TECH_IS95B:
              case RADIO_TECH_1xRTT:
                  if( TRUE == cdma_ccs_supported )
                  {
                      ccs_is_present = TRUE;
                  }
                  break;

              case RADIO_TECH_GPRS:
              case RADIO_TECH_EDGE:
              case RADIO_TECH_GSM:
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                  {
                      QCRIL_LOG_INFO("dtm_supp_valid, dtm_supp %d, %d",
                                     (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp_valid,
                                     (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp );
                      if ( nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp_valid &&
                           NAS_SYS_DTM_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.dtm_supp )
                      {
                          ccs_is_present = TRUE;
                      }
                  }
                  break;

              case RADIO_TECH_IWLAN:
                  ccs_is_present = TRUE;
                  break;

              default:  //SV is Not Applicable to other technologies
                  break;
          }
          snprintf( ril_resp_helper.ccs, sizeof(ril_resp_helper.ccs), "%d", ccs_is_present );
          nas_cached_info.considered_data_technology_valid = TRUE;
          nas_cached_info.considered_data_technology = nas_cached_info.reported_data_technology;

          //report roaming related fields If valid due to voice or data service through RIL_REQUEST_REGISTRATION_STATE response
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_id ) )
          {
              snprintf( ril_resp_helper.sid, sizeof(ril_resp_helper.sid), "%d", (int) nas_cached_info.cdma_sys_id.sid );
              snprintf( ril_resp_helper.nid, sizeof(ril_resp_helper.nid), "%d", (int) nas_cached_info.cdma_sys_id.nid );
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roam_status ) )
          {
              snprintf( ril_resp_helper.roam_status, sizeof(ril_resp_helper.roam_status), "%d",  qmi_ril_nwr_map_roam_status_from_qmi_to_android ( nas_cached_info.roam_status ) );
          }

          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.is_sys_prl_match ) )
          {
              snprintf( ril_resp_helper.prl_ind, sizeof(ril_resp_helper.prl_ind), "%d", (int)nas_cached_info.is_sys_prl_match );
              if( FALSE == nas_cached_info.is_sys_prl_match && TRUE == NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roam_status ) )
              {
                snprintf( ril_resp_helper.def_roam_ind, sizeof(ril_resp_helper.def_roam_ind), "%d", qmi_ril_nwr_map_roam_status_from_qmi_to_android ( nas_cached_info.roam_status ) );
              }
          }


          // * registration reject reason
          switch ( reg_state )
          {
              case RIL_VAL_REG_REGISTRATION_DENIED:
              case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                  if (! nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected )
                  {
                      val_int = NAS_NIL;
                      break;
                  }
                  if ((nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected_managed_roaming)
                   && (nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause_relayed == TRUE ))
                  {
                      val_int = NAS_NIL;
                      break;
                  }
                  val_int = qmi_ril_nwr_conv_reg_reject_cause_voice( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause,
                                              nas_cached_info.voice_rte );
                  qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, nas_cached_info.voice_rte, QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED );
                  break;

              default:
                  val_int = NAS_NIL;
                  break;
          }
          snprintf( ril_resp_helper.reg_reject_cause, sizeof(ril_resp_helper.reg_reject_cause), "%d", val_int );

          // * Primary Scrambling Code
          if ( NULL != sys_info_helper.wcdma_only_sys_info && sys_info_helper.wcdma_only_sys_info->psc_valid )
          {
              val_int = sys_info_helper.wcdma_only_sys_info->psc;
              snprintf( ril_resp_helper.primary_scrambling_code, sizeof(ril_resp_helper.primary_scrambling_code), "%x", val_int );
          }


          // reset display for managed roaming
          if ( nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected &&
               nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_rejected_managed_roaming &&
               nas_cached_info.reg_reject_sys_info [ nas_cached_info.voice_rte ].cs_reject_cause_relayed
             )
          {
              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, nas_cached_info.voice_rte, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED );
          }

          // follow up transfer reg reject while in service
          QCRIL_LOG_INFO(".. in transfer reg reject %d", (int) in_transfer_cs_reg_reject );
          if ( in_transfer_cs_reg_reject )
          {
            qmi_ril_nwr_update_reg_rej_from_sys_info();
          }

          // done with reg reporting
          NAS_CACHE_UNLOCK();
      }
  }

  NAS_CACHE_UNLOCK();
  // ** respond
  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      for ( cnt = 0; cnt < NAS_REG_STATE_RESP_MAX_ARR_SIZE; cnt++ )
      {
          if ( ril_resp_helper.registration_info_array[cnt] )
          {
              QCRIL_LOG_INFO(".. rg %d - %s", (int) cnt, ril_resp_helper.registration_info_array[cnt]);

              if ( ! *ril_resp_helper.registration_info_array[cnt] )
              {
                  ril_resp_helper.registration_info_array[cnt] = NULL;
              }
          }
      }
      // Simplified logging
      QCRIL_LOG_INFO("RIL VOICE REGISTRATION: %s %s in %s", ((log_mask&0x01)?"Full service":"No service"), ((log_mask&0x02)?"Roaming":"Home"),
                     qcril_qmi_util_retrieve_technology_name((int)voice_rte));

      resp.resp_pkt = (void *) &ril_resp_helper.registration_info_array;
      resp.resp_len = sizeof( ril_resp_helper.registration_info_array );
  }
  qcril_send_request_response( &resp );

  // NOTE: current implementation ensures that all responses are sent back in ONE thread
  // after calling qcril_send_request_response()
  qmi_ril_unsuppress_android_unsol_resp(RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED);
  qmi_ril_unsuppress_android_unsol_resp(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED);

  NAS_CACHE_LOCK();
  qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_REPOST );
  NAS_CACHE_UNLOCK();

  // check need for rerendering report
  if ( must_rerender_reg_report )
  {
    QCRIL_LOG_INFO(".. will rerender voice reg report");

    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                            QCRIL_DEFAULT_MODEM_ID,
                            qmi_ril_nw_reg_redo_reg_report,
                            NULL,  // immediate
                            NULL );
  }

  // done
  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

} // qcril_qmi_nas_request_registration_state

//===========================================================================
// qcril_qmi_nas_retranslate_cs_ps_bar_info_handler
//===========================================================================
void qcril_qmi_nas_retranslate_cs_ps_bar_info_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(param);

    NAS_CACHE_LOCK();
    qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHANGE_REPOST );
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_retranslate_cs_ps_bar_info_handler


//===========================================================================
// qmi_ril_nw_reg_redo_reg_report
//===========================================================================
void qmi_ril_nw_reg_redo_reg_report(void * param)
{
    qcril_unsol_resp_params_type unsol_resp_params;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
    qcril_send_unsol_response( &unsol_resp_params );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_redo_reg_report

//===========================================================================
// qmi_ril_nwr_map_roam_status_from_qmi_to_android
//===========================================================================
int qmi_ril_nwr_map_roam_status_from_qmi_to_android( nas_roam_status_enum_type_v01 qmi_roam_status )
{
    int res;

    switch ( qmi_roam_status ) // ref: 3GPP2 C.R1001-G, Table 8.1-1. Enhanced Roaming Indicator Number Assignments
    {
        case NAS_SYS_ROAM_STATUS_OFF_V01:
            res = 1; // Roaming Indicator Off
            break;

        case NAS_SYS_ROAM_STATUS_ON_V01:
            res = 0; // Roaming Indicator On
            break;

        case NAS_SYS_ROAM_STATUS_BLINK_V01:
            res = 2; // Roaming Indicator Flashing
            break;

        case NAS_SYS_ROAM_STATUS_OUT_OF_NEIGHBORHOOD_V01:
            res = 3; // Out of Neighborhood
            break;

        case NAS_SYS_ROAM_STATUS_OUT_OF_BLDG_V01:
            res = 4; // Out of Building
            break;

        case NAS_SYS_ROAM_STATUS_PREF_SYS_V01:
            res = 5; // Out of Building
            break;

        case NAS_SYS_ROAM_STATUS_AVAIL_SYS_V01:
            res = 6; // Roaming - Available System
            break;

        case NAS_SYS_ROAM_STATUS_ALLIANCE_PARTNER_V01:
            res = 7; // Roaming - Alliance Partner
            break;

        case NAS_SYS_ROAM_STATUS_PREMIUM_PARTNER_V01:
            res = 8; // Roaming - Premium Partner
            break;

        case NAS_SYS_ROAM_STATUS_FULL_SVC_V01:
            res = 9; // Roaming - Full Service Functionality
            break;

        case NAS_SYS_ROAM_STATUS_PARTIAL_SVC_V01:
            res = 10; // Roaming - Partial Service Functionality
            break;

        case NAS_SYS_ROAM_STATUS_BANNER_ON_V01:
            res = 11; // Roaming Banner On
            break;

        case NAS_SYS_ROAM_STATUS_BANNER_OFF_V01:
            res = 12; // Roaming Banner Off
            break;

        default:
            res = (int) qmi_roam_status;
            break;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res);

    return res;
} // qmi_ril_nwr_map_roam_status_from_qmi_to_android

//===========================================================================
// qmi_ril_nwr_conv_reg_reject_cause_voice
//===========================================================================
int qmi_ril_nwr_conv_reg_reject_cause_voice(uint8_t org_cause, uint8_t radio_if)
{
    int res;

    if( (!qmi_ril_is_qmi_sys_info_available() && NAS_RADIO_IF_LTE_V01 == radio_if) ||
        (qmi_ril_is_qmi_sys_info_available() && QMI_RIL_RTE_SUB_LTE == radio_if) )
    {
        res = qmi_ril_nwr_conv_reg_reject_cause_lte( org_cause );
    }
    else
    {
        switch ( org_cause )
        {
            case 255 : // Authentication rejected
            case 2 :   // IMSI unknown in HLR
            case 3 :   // Illegal MS
            case 4 :   // IMSI unknown in VLR
            case 5 :   // IMEI not accepted
            case 6:    // Illegal ME
            case 8:
            case 11:   // PLMN not allowed
            case 12:   // Location Area not allowed
            case 13:   // Roaming not allowed in this location area
            case 15:   // No Suitable Cells in this Location Area
            case 17:   // Network failure
            case 20:   // MAC Failure
            case 21:   // Sync Failure */
            case 22:   // Congestion
            case 23:   // GSM Authentication unacceptable
            case 25:   // Not Authorized for this CSG
            case 32:   // Service option not supported
            case 33:   // Requested service option not subscribed
            case 34:   // Service option temporarily out of order
            case 38:   // Call cannot be identified
            case 95:   // Semantically incorrect message
            case 96:   // Network failure
            case 97:   // Network failure
            case 98:   // Network failure
            case 99:   // Network failure
            case 100:  // Network failure
            case 101:  // Message not compatible with protocol state
            case 111:  // Protocol error, unspecified
                res = (int) org_cause;
                break;

            case RIL_VAL_REG_MANAGED_ROAMING_CAUSE: // managed roaming
                res = (int) RIL_VAL_REG_MANAGED_ROAMING_CAUSE;
                break;

            case 48 ... 63: // Retry upon entry into a new cell
                res = 48;
                break;

            default:   // Unspecified failure
                res = 0;
                break;
        }
    }

    return res;
} // qmi_ril_nwr_conv_reg_reject_cause_voice
//===========================================================================
// qcril_qmi_nas_is_in_service_of_technology
//===========================================================================
int qcril_qmi_nas_is_in_service_of_technology(int technology)
{
    int res = FALSE;
    int idx;
    uint8_t radio_if;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_LOG_INFO( ".. param %d", (int) technology );

    if ( !qmi_ril_is_qmi_sys_info_available() )
    {
        if ( NAS_CACHE_IS_ENTRY_VALID (nas_cached_info.serving_system)  )
        {
            for ( idx = 0; idx < (int)nas_cached_info.serving_system->radio_if_len && !res; idx++ )
            {
                radio_if = nas_cached_info.serving_system->radio_if[idx];
                switch ( technology )
                {
                    case NAS_SELECTED_NETWORK_3GPP_V01:
                        if ( NAS_RADIO_IF_GSM == radio_if || NAS_RADIO_IF_UMTS == radio_if || NAS_RADIO_IF_LTE == radio_if)
                        {
                            res = TRUE;
                        }
                        break;

                    case NAS_SELECTED_NETWORK_3GPP2_V01:
                        if ( NAS_RADIO_IF_CDMA2000 == radio_if || NAS_RADIO_IF_CDMA2000_HRPD == radio_if )
                        {
                            res = TRUE;
                        }
                        break;

                    default:
                        // no action
                        break;
                }
            }
        }
    }
    else
    {
        if ( nas_cached_info.ims_rte )
        {
            res = (NAS_SELECTED_NETWORK_3GPP_V01 == technology) ? TRUE : FALSE;
        }
        else
        {
            QCRIL_LOG_INFO( ".. cache valid %d", (int) nas_cached_info.is_in_service_of_technology_cache_result_valid );

            if ( !nas_cached_info.is_in_service_of_technology_cache_result_valid )
            {
                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] = FALSE;
                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] = FALSE;

                // voice first
                memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
                qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );
                QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
                QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
                QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
                QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
                QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
                QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );
                if (
                    RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_GSM ] ||
                    RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_WCDMA ] ||
                    RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] ||
                    RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ]
                     )
                {
                    nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] = TRUE;
                }
                if (
                    RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_1x ] ||
                    RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_DO ]
                     )
                {
                    nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] = TRUE;
                }
                QCRIL_LOG_INFO( ".. prelim res 3ggp %d, 3gpp2 %d",
                                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ],
                                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] );

                // data if needed
                if ( !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] ||
                     !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ]  )
                {
                    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
                    qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );

                    QCRIL_LOG_INFO( ".. 1x reg data %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
                    QCRIL_LOG_INFO( ".. gsm reg data %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
                    QCRIL_LOG_INFO( ".. wcdma reg data %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
                    QCRIL_LOG_INFO( ".. tdscdma reg data %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
                    QCRIL_LOG_INFO( ".. lte reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
                    QCRIL_LOG_INFO( ".. hdr reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

                    if ( !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ]  &&
                         (
                          RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_GSM ] ||
                          RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_WCDMA ] ||
                          RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] ||
                          RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_LTE ]
                          )
                       )
                    {
                        nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ] = TRUE;
                    }

                    if ( !nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] &&
                         (
                          RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_1x ] ||
                          RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ QMI_RIL_RTE_SUB_DO ]
                         )
                       )
                    {
                        nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] = TRUE;
                    }

                }

                QCRIL_LOG_INFO( ".. final cached res 3ggp %d, 3gpp2 %d",
                                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP_V01 ],
                                nas_cached_info.is_in_service_of_technology_cache_result[ NAS_SELECTED_NETWORK_3GPP2_V01 ] );

                nas_cached_info.is_in_service_of_technology_cache_result_valid = TRUE;
            }
            res = nas_cached_info.is_in_service_of_technology_cache_result[ technology ];
        }

    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) res);
    return res;
} // qcril_qmi_nas_is_in_service_of_technology

//===========================================================================
//qcril_qmi_nas_is_using_rte_helper
//===========================================================================
int qcril_qmi_nas_is_using_rte_helper(qmi_ril_nw_reg_rte_type rte,
                                      qmi_ril_nw_reg_rte_kind_type rte_kind)
{
    int ret;

    QCRIL_LOG_FUNC_ENTRY();

    ret= FALSE;

    NAS_CACHE_LOCK();
    ret = qcril_qmi_nas_is_using_rte(rte, rte_kind);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_using_rte_helper

//===========================================================================
// qcril_qmi_nas_is_using_rte
//===========================================================================
int qcril_qmi_nas_is_using_rte(qmi_ril_nw_reg_rte_type rte, qmi_ril_nw_reg_rte_kind_type rte_kind)
{
    int ret;
    int err;
    qmi_ril_nw_reg_rte_type current_rte;
    qmi_ril_nw_reg_rat_confidence_tag_type current_rte_confidence;

    ret = FALSE;
    err = FALSE;
    current_rte = QMI_RIL_RTE_NONE;
    current_rte_confidence = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;

    switch( rte_kind )
    {
        case QMI_RIL_RTE_KIND_VOICE:
            current_rte            = nas_cached_info.voice_rte;
            current_rte_confidence = nas_cached_info.voice_rte_confidence_tag;
            QCRIL_LOG_INFO("questioned rte %d, voice rte %d confd %d", (int)rte, (int)current_rte, (int)current_rte_confidence);
            break;

        case QMI_RIL_RTE_KIND_DATA:
            current_rte            = nas_cached_info.data_rte;
            current_rte_confidence = nas_cached_info.data_rte_confidence_tag;
            QCRIL_LOG_INFO("questioned rte %d, data rte %d confd %d", (int)rte, (int)current_rte, (int)current_rte_confidence);
            break;

        case QMI_RIL_RTE_KIND_IMS:
            current_rte            = nas_cached_info.ims_rte;
            current_rte_confidence = nas_cached_info.ims_rte_confidence_tag;
            QCRIL_LOG_INFO("questioned rte %d, ims rte %d confd %d", (int)rte, (int)current_rte, (int)current_rte_confidence);
            break;

        default:
            err = TRUE;
            QCRIL_LOG_INFO("invalid rte kind %d", rte_kind);
            break;
    }

    if( FALSE == err )
    {
        if( rte == current_rte && ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == current_rte_confidence || QMI_RIL_RAT_CONFIDENCE_LTD_SVC == current_rte_confidence ) )
        {
            ret = TRUE;
        }
    }

    return ret;
} //qcril_qmi_nas_is_using_rte

//===========================================================================
// qcril_qmi_nas_is_using_radio_if
//===========================================================================
int qcril_qmi_nas_is_using_radio_if(uint8_t radio_if)
{
    int res = FALSE;
    int idx;

    if ( !qmi_ril_is_qmi_sys_info_available() )
    { // legacy
        if ( NAS_CACHE_IS_ENTRY_VALID (nas_cached_info.serving_system)  )
        {
            for ( idx = 0; idx < (int)nas_cached_info.serving_system->radio_if_len && !res; idx++ )
            {
                if ( nas_cached_info.serving_system->radio_if[idx] == radio_if)
                {
                    res = TRUE;
                }
            }
        }
    }
    else
    { // sys info
        QCRIL_LOG_INFO(" isn on tech whereabouts - questioned tech %d", (int)radio_if);

        if ( NAS_RADIO_IF_GSM == radio_if &&
             (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_VOICE) ||
                 qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_DATA)  ||
                 qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_GSM, QMI_RIL_RTE_KIND_IMS)
                                             )
           )
        {
            res = TRUE;
        }
        else if ( NAS_RADIO_IF_UMTS == radio_if &&
                  (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_VOICE) ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_DATA)  ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_WCDMA, QMI_RIL_RTE_KIND_IMS)
                                             )
           )
        {
            res = TRUE;
        }
        else if ( NAS_RADIO_IF_TDSCDMA == radio_if &&
                  (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_VOICE) ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_DATA)  ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_TDSCDMA, QMI_RIL_RTE_KIND_IMS)
                                             )
           )
        {
            res = TRUE;
        }
        else if ( NAS_RADIO_IF_CDMA2000 == radio_if &&
                  (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_VOICE) ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_DATA)
                               )
                )
        {
            res = TRUE;
        }
        else if ( NAS_RADIO_IF_LTE== radio_if &&
                  (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_DATA)  ||
                      qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_IMS)
                                             )
           )
        {
            res = TRUE;
        }
        else if ( NAS_RADIO_IF_CDMA2000_HRPD == radio_if &&
                  (   qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_DO, QMI_RIL_RTE_KIND_DATA) )
                )
        {
            res = TRUE;
        }
        else
        {
            res = FALSE;
        }
    }
    return res;
} // qcril_qmi_nas_is_using_radio_if

//===========================================================================
// qcril_qmi_nas_find_current_mcc_mnc
//===========================================================================
int qcril_qmi_nas_find_current_mcc_mnc
(
    char                  *mcc_str_ptr,
    char                  *mnc_str_ptr,
    int                    is_full_service_required,
    nas_radio_if_enum_v01 *plmn_rat
)
{
    int res = FALSE;
    qmi_ril_nw_reg_rte_type registered_rtes[QMI_RIL_RTE_LAST] = {QMI_RIL_RTE_NONE};
    qmi_ril_nw_reg_rte_type chosen_registered_rte             = QMI_RIL_RTE_NONE;

    if( NULL != mcc_str_ptr && NULL != mnc_str_ptr)
    {
        memset(mcc_str_ptr,0,NAS_MCC_MNC_MAX_SIZE);
        memset(mnc_str_ptr,0,NAS_MCC_MNC_MAX_SIZE);

        if(FALSE == is_full_service_required ||
           qcril_qmi_nas_is_considered_registered(registered_rtes))
        {
            if( !qmi_ril_is_qmi_sys_info_available() )
            {
                if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mnc_includes_pcs_digit ) && qcril_qmi_nas_is_in_service_of_technology(NAS_SELECTED_NETWORK_3GPP_V01) )
                {
                    QCRIL_LOG_INFO("using serving_system_ind");
                    snprintf( mcc_str_ptr, NAS_MCC_MNC_MAX_SIZE, "%03d", nas_cached_info.mnc_includes_pcs_digit->mcc );
                    if ( nas_cached_info.mnc_includes_pcs_digit->mnc > 99 || TRUE == nas_cached_info.mnc_includes_pcs_digit->mnc_includes_pcs_digit )
                    {
                        snprintf( mnc_str_ptr, NAS_MCC_MNC_MAX_SIZE, "%03d", (int) nas_cached_info.mnc_includes_pcs_digit->mnc );
                    }
                    else
                    {
                        snprintf( mnc_str_ptr, NAS_MCC_MNC_MAX_SIZE, "%02d", (int) nas_cached_info.mnc_includes_pcs_digit->mnc );
                    }
                    res = TRUE;
                }
            }
            else
            {
                chosen_registered_rte =
                    qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name_info(registered_rtes);

                QCRIL_LOG_INFO("chosen rte - %d", chosen_registered_rte);

                if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_GSM) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sys_info)
                    && nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id_valid &&
                    (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_GSM) : TRUE))
                {
                    QCRIL_LOG_INFO("using sys_info_ind - GSM");
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                    if (plmn_rat)
                    {
                        *plmn_rat = NAS_RADIO_IF_GSM_V01;
                    }
                    res = TRUE;
                }
                else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_UMTS) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sys_info)
                    && nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id_valid &&
                    (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_WCDMA) : TRUE))
                {
                    QCRIL_LOG_INFO("using sys_info_ind - WCDMA");
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                    if (plmn_rat)
                    {
                        *plmn_rat = NAS_RADIO_IF_UMTS_V01;
                    }
                    res = TRUE;
                }
                else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_TDSCDMA) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_sys_info)
                    && nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id_valid &&
                    (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_TDSCDMA) : TRUE))
                {
                    QCRIL_LOG_INFO("using sys_info_ind - TDSCDMA");
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                    if (plmn_rat)
                    {
                        *plmn_rat = NAS_RADIO_IF_TDSCDMA_V01;
                    }
                    res = TRUE;
                }
                else if(qcril_qmi_nas_is_radio_if_plmn_available(NAS_RADIO_IF_LTE) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sys_info)
                    && nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id_valid &&
                    (is_full_service_required? (chosen_registered_rte == QMI_RIL_RTE_SUB_LTE) : TRUE))
                {
                    QCRIL_LOG_INFO("using sys_info_ind - LTE");
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id.mcc, mcc_str_ptr);
                    qcril_qmi_nas_fillup_mcc_mnc_helper(nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id.mnc, mnc_str_ptr);
                    if (plmn_rat)
                    {
                        *plmn_rat = NAS_RADIO_IF_LTE_V01;
                    }
                    res = TRUE;
                }
            }
        }

        if( TRUE == res )
        {
            QCRIL_LOG_INFO("mcc %s mnc %s",mcc_str_ptr,mnc_str_ptr);
        }
    }
    QCRIL_LOG_INFO("completed with %d",res);

    return res;
} //qcril_qmi_nas_find_current_mcc_mnc

//===========================================================================
// qcril_qmi_nas_fillup_mcc_mnc_helper
//===========================================================================
void qcril_qmi_nas_fillup_mcc_mnc_helper(char *src_arr, char *dest_str)
{
    int iter_i=0,len=0;

    if( NULL != src_arr && NULL != dest_str )
    {
        for( iter_i=0; iter_i<NAS_MCC_MNC_MAX_V01; iter_i++ )
        {
            if( isdigit(src_arr[iter_i]) )
            {
                dest_str[iter_i] = src_arr[iter_i];
                len++;
            }
        }
        dest_str[len] = '\0';
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

} //qcril_qmi_nas_fillup_mcc_mnc_helper

//===========================================================================
// qcril_qmi_nas_is_mcc_mnc_wildcard_entry
//===========================================================================
int qcril_qmi_nas_is_mcc_mnc_wildcard_entry(char *mcc, char *mnc)
{
    int ret = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    if( (NAS_MCC_WILDCARD_ENTRY == mcc[0] && NAS_MCC_MNC_WILDCARD_ENTRY == mcc[1] && NAS_MCC_MNC_WILDCARD_ENTRY == mcc[2]) &&
        (NAS_MNC_WILDCARD_ENTRY == mnc[0] && NAS_MCC_MNC_WILDCARD_ENTRY == mnc[1] && NAS_MCC_MNC_WILDCARD_ENTRY == mnc[2]) )
    {
        ret = TRUE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_mcc_mnc_wildcard_entry

//===========================================================================
// qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper
//===========================================================================
void qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper(char *mcc, char *mnc)
{
    QCRIL_LOG_FUNC_ENTRY();

    strlcpy(mcc,NAS_PLACEHOLDER_MCC_STR,NAS_MCC_MNC_MAX_SIZE);
    strlcpy(mnc,NAS_PLACEHOLDER_MNC_STR,NAS_MCC_MNC_MAX_SIZE);
    QCRIL_LOG_INFO("mcc %s mnc %s", mcc, mnc);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper

//===========================================================================
// qcril_qmi_nas_evaluate_sglte_current_eons_rte
//===========================================================================
void qcril_qmi_nas_evaluate_sglte_current_eons_rte()
{
    qmi_ril_nw_reg_rte_type sglte_current_eons_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rte_type sglte_cs_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rte_type sglte_ps_rte = QMI_RIL_RTE_NONE;
    int is_cs_registered = FALSE;
    int is_cs_roaming = FALSE;
    int is_ps_registered = FALSE;
    int is_ps_roaming = FALSE;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];
    qmi_ril_nw_reg_rte_type idx_rte;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );   //evaluating sglte cs rte
    qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );
    QCRIL_LOG_INFO( ".. gsm cs reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma cs reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma cs reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte cs reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );

    for ( idx_rte = QMI_RIL_RTE_GSM; idx_rte <= QMI_RIL_RTE_SUB_LTE && !is_cs_registered; idx_rte++)
    {
        switch( rte_reg_status[ idx_rte ] )
        {
            case RIL_VAL_REG_REGISTERED_ROAMING: //fallthrough
                is_cs_roaming = TRUE;

            case RIL_VAL_REG_REGISTERED_HOME_NET:
                is_cs_registered = TRUE;
                sglte_cs_rte = idx_rte;
                break;

            default: //no action
                break;
        }
    }

    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) ); //evaluating sglte ps rte
    qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );
    QCRIL_LOG_INFO( ".. gsm ps reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma ps reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma ps reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte ps reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );

    for ( idx_rte = QMI_RIL_RTE_GSM; idx_rte <= QMI_RIL_RTE_SUB_LTE && !is_ps_registered; idx_rte++)
    {
        switch( rte_reg_status[ idx_rte ] )
        {
            case RIL_VAL_REG_REGISTERED_ROAMING: //fallthrough
                is_ps_roaming = TRUE;

            case RIL_VAL_REG_REGISTERED_HOME_NET:
                is_ps_registered = TRUE;
                sglte_ps_rte = idx_rte;
                break;

            default: //no action
                break;
        }
    }

    do
    {
      /* if only one modem is online continue with the same. */
      if (sglte_cs_rte == sglte_ps_rte)
      {
        sglte_current_eons_rte = sglte_cs_rte;
        break;
      }

      /* if only one domain is registered continue with corresponding modem. */
      if (!is_ps_registered && is_cs_registered)
      {
        sglte_current_eons_rte = sglte_cs_rte;
        break;
      }
      else if (!is_cs_registered && is_ps_registered)
      {
        sglte_current_eons_rte = sglte_ps_rte;
        break;
      }
      else if (is_cs_registered && is_ps_registered)
      {
        /* if roaming preference is enabled then continue with the one which is
           roaming */
        if(nas_common_info.sglte_eons_is_roam_enabled)
        {
          if (!is_cs_roaming && is_ps_roaming)
          {
            sglte_current_eons_rte = sglte_ps_rte;
            break;
          }
          else if (!is_ps_roaming && is_cs_roaming)
          {
            sglte_current_eons_rte = sglte_cs_rte;
            break;
          }
        }

        /* if domain preference has been set then continue with the one which is
           cs */
        if(nas_common_info.sglte_eons_is_domain_cs)
        {
          sglte_current_eons_rte = sglte_cs_rte;
          break;
        }
        else
        {
          sglte_current_eons_rte = sglte_ps_rte;
          break;
        }
      }
      else
      {
          QCRIL_LOG_INFO("Not registered on either CS or PS");
          sglte_current_eons_rte = QMI_RIL_RTE_NONE;
      }
    } while (0);

    nas_cached_info.sglte_current_eons_rte = sglte_current_eons_rte;
    QCRIL_LOG_INFO("completed, sglte current eons rte %d", nas_cached_info.sglte_current_eons_rte);
} //qcril_qmi_nas_evaluate_sglte_current_eons_rte

//===========================================================================
// qcril_qmi_nas_is_radio_if_plmn_available
//===========================================================================
int qcril_qmi_nas_is_radio_if_plmn_available(uint8_t radio_if)
{
    int ret = FALSE;

    if( (qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) ||
        qcril_qmi_nas_is_sglte3()) &&
        !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ))
    {
        switch( radio_if )
        {
            case NAS_RADIO_IF_GSM:
                if( QMI_RIL_RTE_GSM == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_UMTS:
                if( QMI_RIL_RTE_WCDMA == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_TDSCDMA:
                if( QMI_RIL_RTE_TDSCDMA == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            case NAS_RADIO_IF_LTE:
                if( QMI_RIL_RTE_SUB_LTE == nas_cached_info.sglte_current_eons_rte )
                {
                    ret = TRUE;
                }
                break;

            default: //no action
                break;
        }
    }
    else
    {
        ret = qcril_qmi_nas_is_using_radio_if(radio_if);
    }

    return ret;
} //qcril_qmi_nas_is_radio_if_plmn_available

//===========================================================================
// qcril_qmi_nas_reset_data_snapshot_cache_and_timer
//===========================================================================
void qcril_qmi_nas_reset_data_snapshot_cache_and_timer()
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    QCRIL_LOG_ESSENTIAL("Resetting snapshot timer");

    if( TRUE == nas_cached_info.data_reg_report_snapshot.valid ) //reset cache
    {
        memset(&nas_cached_info.data_reg_report_snapshot, 0, sizeof(nas_cached_info.data_reg_report_snapshot));
    }
    if ( NAS_NIL != nas_cached_info.data_reg_report_expiry ) //cancel timer
    {
        qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
        nas_cached_info.data_reg_report_expiry = NAS_NIL;
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_reset_data_snapshot_cache_and_timer

//===========================================================================
//qcril_qmi_nas_evaluate_data_rte_on_pref_data_tech_change
//===========================================================================
void qcril_qmi_nas_evaluate_data_rte_on_pref_data_tech_change()
{
  qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
  qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
  int                              any_rte_change;

  QCRIL_LOG_FUNC_ENTRY();

  if ( qmi_ril_is_qmi_sys_info_available() )
  {
    qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
    qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );

    NAS_CACHE_LOCK();
    qcril_qmi_nas_update_data_rte();
    qcril_qmi_voice_technology_updated();
    qmi_ril_nwr_update_reg_rej_from_sys_info();
    qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_send_known_signal_strength();

    qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
    qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
    qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
    any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
    QCRIL_LOG_INFO( "any rte change %d", any_rte_change);
    if( any_rte_change )
    {
      qcril_qmi_nas_initiate_voice_rte_change_propagation();
    }

    if ((qcril_qmi_nas_get_init_attch_state() ==
            QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ATTACH) ||
        (qcril_qmi_nas_get_init_attch_state() ==
            QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH))
    {
      qcril_qmi_nas_check_ps_attach_status();
    }
  }

  QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_evaluate_data_rte_on_pref_data_tech_change

//===========================================================================
// RIL_REQUEST_DATA_REGISTRATION_STATE
//===========================================================================
void qcril_qmi_nas_request_data_registration_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_request_resp_params_type resp;

  qcril_qmi_nas_registration_data_state_resp_helper_type ril_resp_helper;

  int           qmi_request_need1;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int         ril_resp_no_elements = NAS_NIL;

  int idx;
  int cnt;
  uint32_t uidx;
  uint32 log_mask = 0;

  int is_registered = FALSE;

  int   val_int;

  int tech_known;

  int is_under_post_mode_pref_ban;

  nas_data_capabilites_enum_v01 legacy_data_cap;

  qcril_arb_pref_data_type pref_data;
  qcril_arb_pref_data_tech_e_type pref_data_tech_implied;
  qcril_arb_pref_data_tech_e_type data_tech_to_report;
  qcril_arb_pref_data_tech_e_type data_tech_idx;
  qcril_arb_pref_data_tech_e_type data_tech_iter;

  nas_sys_info_helper_type sys_info_helper;
  nas_3gpp_only_sys_info_type_v01* threegpp_sys_info;
  uint32_t                         cell_id;
  nas_cdma_only_sys_info_type_v01* sys_info_cdma;
  nas_common_sys_info_type_v01* common_sys_info;
  nas_cdma_hdr_only_sys_info_type_v01 * cdma_hdr_only_sys_info;

  nas_wcdma_only_sys_info_type_v01* sys_info_wcdma;
  nas_tdscdma_only_sys_info_type_v01* sys_info_tdscdma;


  int tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_MAX ];
  int pref_data_tech_reg_state;

  int do_varations_reg_status;

  int legacy_a_rte;

  qmi_ril_nw_reg_rte_type vrte_mapper;
  uint8_t temp_radio_if;

  uint8_t current_roam_status_valid;
  nas_roam_status_enum_type_v01 current_roam_status;

  qmi_ril_nw_reg_data_reg_snapshot_info_type local_reg_snapshot;

  qcril_unsol_resp_params_type unsol_resp_params;

  int must_rerender_data_reg_report;

  qmi_ril_nw_reg_rte_type drte;

  int spawn_snapshot_timer;

  int extrapolation_is_under;
  int extrapolation_is_roaming;
  int need_reset_roaming_tmr;
  int need_spawn_roaming_tmr;

  const struct timeval roaming_tmr_expiry = { 10 , 0 }; // 10 seconds

  int          data_reg_roaming_confident_resp;
  int          data_reg_roaming_determined;

  nas_hs_support_enum_type_v01 loc_hs_ser = NAS_HS_SUPPORT_ENUM_TYPE_MIN_ENUM_VAL_V01;

  uint8_t prev_reported_state_valid;
  int prev_reported_state;
  uint8_t prev_reported_tech_valid;
  int prev_reported_tech;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  must_rerender_data_reg_report = FALSE;

  extrapolation_is_roaming = FALSE;
  extrapolation_is_under   = FALSE;
  prev_reported_state_valid = FALSE;
  prev_reported_state = RIL_VAL_REG_UNKNOWN;
  prev_reported_tech_valid = FALSE;
  prev_reported_tech = RADIO_TECH_UNKNOWN;


  // ** response holder init
  memset( &ril_resp_helper, 0, sizeof( ril_resp_helper ) );

  ril_resp_helper.registration_info_array[0]  = ril_resp_helper.registration_state;
  ril_resp_helper.registration_info_array[1]  = ril_resp_helper.lac;
  ril_resp_helper.registration_info_array[2]  = ril_resp_helper.cid;
  ril_resp_helper.registration_info_array[3]  = ril_resp_helper.data_radio_tech;
  ril_resp_helper.registration_info_array[4]  = ril_resp_helper.registration_denied_cause;
  ril_resp_helper.registration_info_array[5]  = ril_resp_helper.max_data_call_no;
  ril_resp_helper.registration_info_array[6]  = ril_resp_helper.tac;
  ril_resp_helper.registration_info_array[7]  = ril_resp_helper.phys_cell_id;
  ril_resp_helper.registration_info_array[8]  = ril_resp_helper.eci;
  ril_resp_helper.registration_info_array[9]  = ril_resp_helper.csgid;
  ril_resp_helper.registration_info_array[10] = ril_resp_helper.tadv;

  memset( &local_reg_snapshot, 0, sizeof( local_reg_snapshot ) );

  memset( &pref_data, 0, sizeof(pref_data) );

  qmi_ril_suppress_android_unsol_resp(RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED);
  qmi_ril_suppress_android_unsol_resp(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED);
  NAS_CACHE_LOCK();

  if ( !qmi_ril_is_qmi_sys_info_available() )
  { // classic case - 1 modem
      // ** update cache if necessary
      NAS_CACHE_LOCK();

      qmi_request_need1 = ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) &&
                            NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info ) &&
                            NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ) &&
                            NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator )
                             ) ? FALSE : TRUE;

      if (  qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01) )
      {
          qmi_request_need1 |= (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cell_id ) &&
                               NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lac )) ? FALSE : TRUE;

      }

      if (  qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP2_V01) )
      {
          qmi_request_need1 |= (
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.def_roam_ind ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_base_station_info ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.ccs ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.prl_ind ) &&
                                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_personality )
                                )
                                ? FALSE : TRUE;

      }

      NAS_CACHE_UNLOCK();

      if ( qmi_request_need1 )
      {
          ril_req_res = qcril_qmi_nas_fetch_serving_system_info();
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
      }

      // ** form answer
      if ( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();

          // * registartion state
          val_int = 4; // unknown

          QCRIL_LOG_INFO(" ... serving system valid %d", (int)NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) )
          {
            QCRIL_LOG_INFO(" ... QMI NAS reg_state %d", (int)nas_cached_info.serving_system->registration_state );
            QCRIL_LOG_INFO(" ... ps attach state %d", (int)nas_cached_info.serving_system->ps_attach_state );
          }
          QCRIL_LOG_INFO(" ... cache valid for data_caps %d", (int)NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ));
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ) )
          {
            QCRIL_LOG_INFO(" ... cache valid for data_caps_len %d", (int)nas_cached_info.data_capabilities_len );
          }


          if ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) )
          {
            val_int       = 4; // Unknown
            is_registered = FALSE;
          }
          else if (
               NAS_VAL_REGISTERED == nas_cached_info.serving_system->registration_state &&
               ( ( NAS_VAL_DATA_ATTACH_ATTACHED == nas_cached_info.serving_system->ps_attach_state ) ||
                 (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ) &&
                 nas_cached_info.data_capabilities_len > NAS_ZERO &&
                 NAS_DATA_CAPABILITIES_GSM_V01 == nas_cached_info.data_capabilities->arr[ NAS_ZERO ]
                  && (NAS_VAL_SRV_CAPABILITY_PS_ONLY == nas_cached_info.detailed_service_info->srv_capability
                      || NAS_VAL_SRV_CAPABILITY_CS_AND_PS == nas_cached_info.detailed_service_info->srv_capability )))
               )
          {

              val_int = ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roaming_indicator ) ||
                          ( NAS_VAL_ROAMING_HOME == nas_cached_info.roaming_indicator ||
                            ( NAS_VAL_ROAMING_HOME_EX_64 == nas_cached_info.roaming_indicator && nas_common_info.eri_64_home )
                          )
                        )
                                ? 1  // Registered, home network
                                  :
                                  5; // Registered, roaming
              is_registered = TRUE;
          }
          else
          {
              switch ( nas_cached_info.serving_system->registration_state  )
              {
                  case NAS_VAL_NOT_REGISTERED:
                      val_int = 0; // not registered, not searching
                      break;

                  case NAS_VAL_REGISTERED:
                      val_int = 2; // not registered, searching, not PS attached and not in GSM
                      break;

                  case NAS_VAL_NOT_REGISTERED_SEARCHING:
                      val_int = 2; // not registered, searching
                      break;

                  case NAS_VAL_REGISTRATION_DENIED:
                      val_int = 3; // Registration denied
                      break;

                  case NAS_VAL_REGISTRATION_UNKNOWN:
                      val_int = 4; // Unknown
                      break;

                  default:
                      val_int = 4; // Unknown
                      break;
              }
          }
          QCRIL_LOG_INFO(".. pre  cur reg state %d", (int) val_int);
          // reject adjust
          switch ( val_int )
          {
              case RIL_VAL_REG_REGISTERED_HOME_NET:
              case RIL_VAL_REG_REGISTERED_ROAMING:
                if ( nas_cached_info.reg_reject_legacy.ps_rejected && !nas_cached_info.reg_reject_legacy.ps_reject_cause_relayed )
                {
                  val_int                       = RIL_VAL_REG_REGISTRATION_DENIED;
                  is_registered                 = FALSE;
                  must_rerender_data_reg_report = TRUE;
                }
                break;

              default:
                  if ( nas_cached_info.reg_reject_legacy.ps_rejected )
                  {
                      val_int = RIL_VAL_REG_REGISTRATION_DENIED;
                      is_registered = FALSE;
                  }
                  break;
          }

          snprintf( ril_resp_helper.registration_state, sizeof(ril_resp_helper.registration_state), "%d", val_int );
          QCRIL_LOG_INFO("cur reg state %d", (int) val_int);

          if ( is_registered )
          {
              // *lac
              if ( qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01) )
              {
                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", nas_cached_info.lac );
              }
              // *cid
              if ( qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01) )
              {
                  if ( nas_cached_info.cell_id > (uint32_t)0x7FFFFFFF )
                  {
                      snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", (uint32_t) 0x7FFFFFFF );
                  }
                  else
                  {
                      snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", nas_cached_info.cell_id );
                  }
              }
              // *radio technology
              QCRIL_LOG_INFO(".. data caps %d, %d",
                             (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ),
                             nas_cached_info.data_capabilities_len
                             );
              QCRIL_LOG_INFO(".. detailed info val %d",
                             (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info ) );
              if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info ) )
              {
                  QCRIL_LOG_INFO(".. detailed info srv_cap %d",
                                 nas_cached_info.detailed_service_info->srv_capability  );
              }

              val_int = RADIO_TECH_UNKNOWN;
              tech_known = FALSE;
              if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.data_capabilities ) &&
                       nas_cached_info.data_capabilities_len > NAS_ZERO )
              {
                  tech_known = TRUE;
                  legacy_data_cap = nas_cached_info.data_capabilities->arr[NAS_ZERO];
                  QCRIL_LOG_INFO(".. legacy data cap %d", (int)legacy_data_cap );
                  if ( NAS_DATA_CAPABILITIES_CDMA_V01 == legacy_data_cap && nas_cached_info.data_capabilities_len > 1 )
                  {
                      legacy_data_cap = nas_cached_info.data_capabilities->arr[NAS_ZERO + 1]; // QMI DMS will pass DO details in 2nd element
                  }
                  QCRIL_LOG_INFO(".. final legacy data cap %d", (int)legacy_data_cap );
                  switch (  legacy_data_cap )
                  {

                  case NAS_DATA_CAPABILITIES_GPRS_V01:
                      val_int = RADIO_TECH_GPRS;
                      break;

                  case NAS_DATA_CAPABILITIES_EDGE_V01:
                      val_int = RADIO_TECH_EDGE;
                      break;

                  case NAS_DATA_CAPABILITIES_HSDPA_V01:
                      val_int = RADIO_TECH_HSDPA;
                      break;

                  case NAS_DATA_CAPABILITIES_HSDPA_PLUS_V01:        // fallthrough
                  case NAS_DATA_CAPABILITIES_DC_HSDPA_PLUS_V01:
                      val_int = RADIO_TECH_HSPAP;
                      break;

                  case NAS_DATA_CAPABILITIES_HSUPA_V01:
                      val_int = RADIO_TECH_HSUPA;
                      break;

                  case NAS_DATA_CAPABILITIES_WCDMA_V01:
                      val_int = RADIO_TECH_UMTS;
                      break;

                  case NAS_DATA_CAPABILITIES_CDMA_V01:
                      QCRIL_LOG_INFO(".. cdma p_rev valid %d", (int)NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.p_rev_in_use ) );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.p_rev_in_use ) )
                      {
                          QCRIL_LOG_INFO(".. cdma p_rev %d", (int)nas_cached_info.p_rev_in_use );
                          val_int = qcril_qmi_util_determine_cdma_rev_direct( nas_cached_info.p_rev_in_use );
                      }
                      else
                      {
                          val_int = RADIO_TECH_IS95A;
                      }
                      break;

                  case NAS_DATA_CAPABILITIES_EVDO_REV_O_V01:
                      val_int = RADIO_TECH_EVDO_0;
                      break;

                  case NAS_DATA_CAPABILITIES_EVDO_REV_A_V01:
                      val_int = RADIO_TECH_EVDO_A;
                      break;

                  case NAS_DATA_CAPABILITIES_LTE_V01:
                      val_int = RADIO_TECH_LTE;
                      break;

                  case NAS_DATA_CAPABILITIES_EVDO_REV_B_V01:
                      val_int = RADIO_TECH_EVDO_B;
                      break;

                  case NAS_DATA_CAPABILITIES_GSM_V01: // no country for old men???
                      val_int = RADIO_TECH_UNKNOWN;
                      break;

                  default:
                      if ( NAS_VAL_DATA_TECH_NONE == (int)legacy_data_cap )
                      {
                          val_int = RADIO_TECH_UNKNOWN;
                      }
                      else
                      {
                          val_int = RADIO_TECH_UNKNOWN;
                          tech_known = FALSE;
                      }
                      break;
                  }
              }

              QCRIL_LOG_INFO(" .. hs_call_status valid %d, value %d ", (int)NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hs_call_status), (int)nas_cached_info.hs_call_status);
              if( RADIO_TECH_UMTS == val_int && TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hs_call_status) )
              {
                  switch( nas_cached_info.hs_call_status )
                  {
                      case SYS_HS_IND_HSDPA_SUPP_CELL_V01:
                          val_int = RADIO_TECH_HSDPA;
                          tech_known = TRUE;
                          break;

                      case SYS_HS_IND_HSUPA_SUPP_CELL_V01:
                          val_int = RADIO_TECH_HSUPA;
                          tech_known = TRUE;
                          break;

                      case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL_V01:
                          val_int = RADIO_TECH_HSPA;
                          tech_known = TRUE;
                          break;

                      case SYS_HS_IND_HSDPAPLUS_SUPP_CELL_V01:
                      case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL_V01:
                      case SYS_HS_IND_HSDPAPLUS_64QAM_SUPP_CELL_V01:
                      case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL_V01:
                      case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL_V01:
                      case SYS_HS_IND_HSDPAPLUS_64QAM_HSUPA_SUPP_CELL_V01:
                          val_int = RADIO_TECH_HSPAP;
                          tech_known = TRUE;
                          break;

                      default: //UMTS by default
                          break;
                  }
              }

              // EHRPD adjustment
              QCRIL_LOG_INFO(".. ehrpd adjustment check %d", (int) val_int );
              switch ( val_int )
              {
                  case RADIO_TECH_EVDO_0:   // fall through
                  case RADIO_TECH_EVDO_A:   // fall through
                  case RADIO_TECH_EVDO_B:
                      QCRIL_LOG_INFO(".. detailed_service_info val, nas_cached_info.hdr_personality val  %d, %d",
                                     NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info ),
                                     NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_personality ) );
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.detailed_service_info ) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.hdr_personality) )
                      {
                          QCRIL_LOG_INFO(".. hdr status, hdr_hybrid  %d, %d",
                                         (int) nas_cached_info.detailed_service_info->hdr_srv_status,
                                         (int) nas_cached_info.detailed_service_info->hdr_hybrid );
                          if (

                               (  nas_cached_info.detailed_service_info->hdr_hybrid &&
                                 (NAS_VAL_SERVICE_AVAILABLE == nas_cached_info.detailed_service_info->hdr_srv_status ||
                                  NAS_VAL_POWER_SAVE_OR_DEEP_SLEEP ==  nas_cached_info.detailed_service_info->hdr_srv_status)
                               )
                               ||
                               (  !nas_cached_info.detailed_service_info->hdr_hybrid &&
                                 (NAS_VAL_SERVICE_AVAILABLE == nas_cached_info.detailed_service_info->srv_status ||
                                  NAS_VAL_POWER_SAVE_OR_DEEP_SLEEP ==  nas_cached_info.detailed_service_info->srv_status )
                               )
                            )
                          {
                              QCRIL_LOG_INFO(".. hdr_personality check %d", (int) nas_cached_info.hdr_personality );
                              switch ( nas_cached_info.hdr_personality )
                              {
                                  case NAS_HDR_PERSONALITY_EHRPD_V01:
                                      val_int = RADIO_TECH_EHRPD;
                                      break;

                                  default:
                                      // no change
                                      break;
                              }
                          }
                      }
                      break;

                  default:
                      // no action
                      break;
              }
              // finnally - data rte
              snprintf( ril_resp_helper.data_radio_tech, sizeof(ril_resp_helper.data_radio_tech), "%d", val_int );
              legacy_a_rte = val_int;


              // * tac for LTE
              val_int = NAS_NIL;
              if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tac ) )
              {
                  QCRIL_LOG_INFO("... tac %d", (int) nas_cached_info.tac  );
              }
              if (
                   RADIO_TECH_LTE == legacy_a_rte &&
                   NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tac )
                  )
              {
                  val_int = nas_cached_info.tac;
                  QCRIL_LOG_INFO("... TAC LTE %d", (int) val_int );
                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", val_int );
              }

          }
          else // not registered case
          {
              snprintf( ril_resp_helper.data_radio_tech, sizeof(ril_resp_helper.data_radio_tech), "%d", NAS_NIL );
              NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_technology, NAS_NIL);
          }
          // * registration denied cause
          if ( nas_cached_info.reg_reject_legacy.ps_rejected )
          {
              temp_radio_if = (nas_cached_info.serving_system->radio_if_len > 0)?
                               nas_cached_info.serving_system->radio_if[NAS_NIL]: NAS_RADIO_IF_NO_SVC_V01;
              val_int = qmi_ril_nwr_conv_reg_reject_cause_data( nas_cached_info.reg_reject_legacy.ps_reject_cause, temp_radio_if );
              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED );
          }
          else
          {
              val_int = NAS_NIL;
          }
          snprintf( ril_resp_helper.registration_denied_cause, sizeof(ril_resp_helper.registration_denied_cause), "%d", val_int );

          NAS_CACHE_UNLOCK();
      }

  }
  else
  { // sys info supported

      qcril_qmi_get_pref_data_tech(&pref_data);

      NAS_CACHE_LOCK();
      prev_reported_state_valid = nas_cached_info.reported_data_reg_status_valid;
      prev_reported_state = nas_cached_info.reported_data_reg_status;
      prev_reported_tech_valid = nas_cached_info.reported_data_technology_valid;
      prev_reported_tech = nas_cached_info.reported_data_technology;

      qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, &extrapolation_is_under, &extrapolation_is_roaming );

      drte = nas_cached_info.data_rte;
      qmi_request_need1 = qcril_qmi_nas_util_check_request_need(pref_data.pref_data_tech, drte);

      is_under_post_mode_pref_ban = (NAS_NIL != nas_cached_info.extrapolation_ban_expiry);
      NAS_CACHE_UNLOCK();

      QCRIL_LOG_INFO(".. request need %d, drte %d, pref data tech %s, post mpref ban %d",
                            (int) qmi_request_need1,
                            (int) drte,
                            qcril_qmi_util_retrieve_pref_data_tech_name(pref_data.pref_data_tech),
                            is_under_post_mode_pref_ban );

      if ( qmi_request_need1 )
      {
          ril_req_res = qcril_qmi_nas_fetch_sys_info();
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
      }

      if ( RIL_E_SUCCESS == ril_req_res )
      {

          NAS_CACHE_LOCK();

          QCRIL_LOG_INFO(" ... cdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... hdr_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) );
          QCRIL_LOG_INFO(" ... gsm_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) );
          QCRIL_LOG_INFO(" ... wcdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... tdscdma_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) );
          QCRIL_LOG_INFO(" ... lte_srv_status_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) );
          QCRIL_LOG_INFO(" ... cdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) );
          QCRIL_LOG_INFO(" ... hdr_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) );
          QCRIL_LOG_INFO(" ... gsm_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) );
          QCRIL_LOG_INFO(" ... wcdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) );
          QCRIL_LOG_INFO(" ... tdscdma_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) );
          QCRIL_LOG_INFO(" ... lte_sys_info val %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) );

          memset(&tech_data_reg, 0, sizeof(tech_data_reg) );

          // CDMA
          QCRIL_LOG_INFO( " .. prep CDMA" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_CDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA,
                                                                    &sys_info_helper);
          }

          // DO & EHRPD
          QCRIL_LOG_INFO( " .. prep EVDO" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
              sys_info_helper.hdr_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->hdr_specific_sys_info : NULL;
              do_varations_reg_status = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_HDR,
                                                                    &sys_info_helper);
              QCRIL_LOG_INFO(" ... do/ehrpd detection %d", do_varations_reg_status );
              QCRIL_LOG_INFO(" ... hdr_sys_info valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) );

              switch ( do_varations_reg_status )
              {
                  case RIL_VAL_REG_REGISTERED_HOME_NET:     // fallthrough
                  case RIL_VAL_REG_REGISTERED_ROAMING:
                      if ( sys_info_helper.hdr_only_sys_info )
                      {
                          QCRIL_LOG_INFO(" ... hdr_active valid %d, hdr_personality valid %d", (int)sys_info_helper.hdr_only_sys_info->hdr_active_prot_valid,
                                         (int)sys_info_helper.hdr_only_sys_info->hdr_personality_valid );
                      }
                      if ( sys_info_helper.hdr_only_sys_info && sys_info_helper.hdr_only_sys_info->hdr_personality_valid )
                      {
                          QCRIL_LOG_INFO(" ... hdr_personality %d", (int)sys_info_helper.hdr_only_sys_info->hdr_personality );
                          switch ( sys_info_helper.hdr_only_sys_info->hdr_personality )
                          {
                              case NAS_SYS_PERSONALITY_EHRPD_V01: // EHRPD
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = do_varations_reg_status;
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                                  break;

                              default: // DO
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = do_varations_reg_status;
                                  tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                                  break;
                          }
                      }
                      else
                      { // DO by default
                          tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = do_varations_reg_status;
                          tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                      }
                      break;

                  default:
                      tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EVDO ] = do_varations_reg_status;
                      tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_EHRPD ] = do_varations_reg_status;
                      break;
              }

          }

          // GSM
          QCRIL_LOG_INFO( " .. prep GSM" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP,
                                                                    &sys_info_helper);
          }

          // WCDMA
          QCRIL_LOG_INFO( " .. prep WCDMA" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_UMTS ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP,
                                                                    &sys_info_helper);
          }

          // TDSCDMA
          QCRIL_LOG_INFO( " .. prep TDSCDMA" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP,
                                                                    &sys_info_helper);
          }

          // LTE
          QCRIL_LOG_INFO( " .. prep LTE" );
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
          {
              memset(&sys_info_helper, 0, sizeof(sys_info_helper));
              sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
              sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
              sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
              sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
              tech_data_reg[ QCRIL_ARB_PREF_DATA_TECH_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                    &sys_info_helper);
          }

          // overview
          for ( data_tech_idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; data_tech_idx < QCRIL_ARB_PREF_DATA_TECH_MAX; data_tech_idx++  )
          {
              QCRIL_LOG_INFO(" ... tech %s, reg %d", qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_idx), (int) tech_data_reg[ data_tech_idx ]  );
          }

          // CDMA details
          if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
          {
              sys_info_cdma = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
          }
          else
          {
              sys_info_cdma = NULL;
          }

          QCRIL_LOG_INFO(" ..* tech detection" );
          switch ( pref_data.pref_data_tech )
          {
              case QCRIL_ARB_PREF_DATA_TECH_EVDO:
                  pref_data_tech_implied = QCRIL_ARB_PREF_DATA_TECH_EHRPD;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                  pref_data_tech_implied = QCRIL_ARB_PREF_DATA_TECH_EVDO;
                  break;

              default:
                  pref_data_tech_implied = pref_data.pref_data_tech;
                  break;
          }

          QCRIL_LOG_INFO(" ... data_tech_to_report_implied %s", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech_implied) );

          is_registered = FALSE;
          if (  QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech  )
          {
            QCRIL_LOG_INFO("CnE module available, is current %d, pref data tech %s", (int)pref_data.is_current, qcril_qmi_util_retrieve_pref_data_tech_name(pref_data.pref_data_tech) );
            if( TRUE == pref_data.is_current )
            {
              QCRIL_LOG_INFO("with current status");
              if( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data.pref_data_tech )
              {
                data_tech_to_report = pref_data.pref_data_tech;
                is_registered = TRUE;
                QCRIL_LOG_INFO("data in service on %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));

                // determine roaming status
                need_reset_roaming_tmr = FALSE;
                need_spawn_roaming_tmr = FALSE;

                QCRIL_LOG_INFO("data roam status latest %d / %d under tmr 0x%x, is extrap %d, extrap_roaming %d, a/m nw sel %d",
                               nas_cached_info.data_reg_roaming_status_latest_val,
                               nas_cached_info.data_reg_roaming_status_latest,
                               nas_cached_info.data_reg_roaming_status_latest_expiry,
                               extrapolation_is_under,
                               extrapolation_is_roaming,
                               (int)nas_cached_info.nw_select_state );
                if ( extrapolation_is_under )
                { // extrapolation - reuse what's known
                    pref_data_tech_reg_state = extrapolation_is_roaming ? RIL_VAL_REG_REGISTERED_ROAMING : RIL_VAL_REG_REGISTERED_HOME_NET;
                    need_reset_roaming_tmr = TRUE;
                }
                else
                {
                    data_reg_roaming_determined = FALSE;
                    if ( !( nas_cached_info.data_reg_roaming_status_latest_val &&
                            ( is_under_post_mode_pref_ban || QMI_RIL_NAS_NW_SELECT_NONE != nas_cached_info.nw_select_state )
                          ) || ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.reported_pref_data_technology) &&
                                 ( pref_data.pref_data_tech != nas_cached_info.reported_pref_data_technology ))
                         )
                    { // normal case: not extrapolating and not "right after" mode pref change
                        data_reg_roaming_confident_resp = FALSE;
                        pref_data_tech_reg_state = qcril_qmi_nas_util_check_roaming_status(pref_data.pref_data_tech, tech_data_reg, &data_reg_roaming_confident_resp );

                        if ( data_reg_roaming_confident_resp )
                        {
                           nas_cached_info.data_reg_roaming_status_latest     = pref_data_tech_reg_state;
                           nas_cached_info.data_reg_roaming_status_latest_val = TRUE;
                           data_reg_roaming_determined = TRUE;
                        }
                        else
                        {
                           if ( !nas_cached_info.data_reg_roaming_status_latest_val )
                           { // not matching roaming TLV at this time or roaming never known-set to no roaming
                              pref_data_tech_reg_state    = RIL_VAL_REG_REGISTERED_HOME_NET;
                              data_reg_roaming_determined = TRUE;

                              nas_cached_info.data_reg_roaming_status_latest     = RIL_VAL_REG_REGISTERED_HOME_NET;
                              nas_cached_info.data_reg_roaming_status_latest_val = TRUE;

                           }
                        }

                        need_reset_roaming_tmr = TRUE;
                        need_spawn_roaming_tmr = TRUE;
                    }
                    else
                    { // "right after" mode pref change - apply cached roaming status
                        pref_data_tech_reg_state = nas_cached_info.data_reg_roaming_status_latest;
                        data_reg_roaming_determined = TRUE;
                    }

                    if ( !data_reg_roaming_determined && nas_cached_info.data_reg_roaming_status_latest_val )
                    {
                        pref_data_tech_reg_state = nas_cached_info.data_reg_roaming_status_latest;
                    }
                }
                QCRIL_LOG_INFO("need reset roaming tmr %d, need spawn roaming tmr %d", need_reset_roaming_tmr, need_spawn_roaming_tmr );
                if ( need_reset_roaming_tmr )
                {
                    if ( nas_cached_info.data_reg_roaming_status_latest_expiry )
                    {
                        qcril_cancel_timed_callback( (void*)(uintptr_t)nas_cached_info.data_reg_roaming_status_latest_expiry );
                        nas_cached_info.data_reg_roaming_status_latest_expiry = NAS_NIL;
                    }
                }
              }
            }
          } // if (  QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data.pref_data_tech  )
          else
          {
            QCRIL_LOG_INFO("CnE module UNavailable");
          }

          if( FALSE == is_registered )
          { // determine technology
              QCRIL_LOG_INFO("Using QMI NAS indication info");
              log_mask |= 0x04;
              data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UNKNOWN;

              // what's registered : Only in case of Invalid pref_data_tech (preferred data system indication unavailability)

              if( QCRIL_ARB_PREF_DATA_TECH_INVALID == pref_data.pref_data_tech )
              {
                  for ( idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; idx < QCRIL_ARB_PREF_DATA_TECH_MAX && QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report; idx++ )
                  {
                      data_tech_iter = qmi_ril_data_reg_tech_priorities[ idx ];
                      if ( RIL_VAL_REG_REGISTERED_HOME_NET == tech_data_reg[ data_tech_iter ] || RIL_VAL_REG_REGISTERED_ROAMING == tech_data_reg[ data_tech_iter ] )
                      {
                          data_tech_to_report = data_tech_iter;
                          is_registered = TRUE;
                          QCRIL_LOG_INFO("no CnE, picking %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
                      }
                  }
              }
              // what's reg rejected
              if ( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report )
              {
                  for ( idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; idx < QCRIL_ARB_PREF_DATA_TECH_MAX && QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report; idx++ )
                  {
                      data_tech_iter = qmi_ril_data_reg_tech_priorities[ idx ];
                      switch ( tech_data_reg[ data_tech_iter ] )
                      {
                          case RIL_VAL_REG_REGISTRATION_DENIED:
                          case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                              data_tech_to_report = data_tech_iter;
                              break;

                          default:
                              // skip
                              break;
                      }
                  }
              }
              // what's reg rejected 2
              if ( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report )
              {
                for ( vrte_mapper = QMI_RIL_RTE_NONE;  (vrte_mapper < QMI_RIL_RTE_CAP) && (QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report) ; vrte_mapper++ )
                {
                    if ( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_rejected )
                    {
                        QCRIL_LOG_INFO("... reje reg data adjust to vrte %d", (int) vrte_mapper );

                        switch ( vrte_mapper )
                        {
                            case QMI_RIL_RTE_GSM:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_GSM;
                                break;

                            case QMI_RIL_RTE_WCDMA:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UMTS;
                                break;

                            case QMI_RIL_RTE_TDSCDMA:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_TDSCDMA;
                                break;

                            case QMI_RIL_RTE_SUB_LTE:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_LTE;
                                break;

                            default:
                                data_tech_to_report = QCRIL_ARB_PREF_DATA_TECH_UNKNOWN;
                                break;
                        }
                    }
                }
              }
              // what's in search
              if ( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report )
              {
                  for ( idx = QCRIL_ARB_PREF_DATA_TECH_FIRST; idx < QCRIL_ARB_PREF_DATA_TECH_MAX && QCRIL_ARB_PREF_DATA_TECH_UNKNOWN == data_tech_to_report; idx++ )
                  {
                      data_tech_iter = qmi_ril_data_reg_tech_priorities[ idx ];
                      switch ( tech_data_reg[ data_tech_iter ] )
                      {
                          case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:
                          case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:
                          case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                              data_tech_to_report = data_tech_iter;
                              QCRIL_LOG_INFO("... in search RAT %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
                              break;

                          default:
                              // skip
                              break;
                      }
                  }
              }
              QCRIL_LOG_INFO(" ... matched tech %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));

          // map
          switch ( data_tech_to_report )
          {
              case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                  vrte_mapper = QMI_RIL_RTE_1x;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_EVDO:           // fallthrough
              case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                  vrte_mapper = QMI_RIL_RTE_SUB_DO;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_GSM:
                  vrte_mapper = QMI_RIL_RTE_GSM;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                  vrte_mapper = QMI_RIL_RTE_WCDMA;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                  vrte_mapper = QMI_RIL_RTE_TDSCDMA;
                  break;

              case QCRIL_ARB_PREF_DATA_TECH_LTE:
                  vrte_mapper = QMI_RIL_RTE_SUB_LTE;
                  break;

              default:
                  vrte_mapper = QMI_RIL_RTE_NONE;
                  break;
          }
          QCRIL_LOG_INFO("... vrte_mapper %d", (int) vrte_mapper );

          // reg reject adjust
          QCRIL_LOG_INFO("... pre cur reg state %d", (int) tech_data_reg[ data_tech_to_report ] );
          switch ( tech_data_reg[ data_tech_to_report ] )
          {
              case RIL_VAL_REG_REGISTERED_HOME_NET:
              case RIL_VAL_REG_REGISTERED_ROAMING:
                  // nothing for reg reject
                  break;

              default:
                  if ( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_rejected )
                  {
                      QCRIL_LOG_INFO("... adjusted to reje reg data for data rte %s",qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
                      tech_data_reg [ data_tech_to_report ] = RIL_VAL_REG_REGISTRATION_DENIED;
                  }
                  break;
          }
              pref_data_tech_reg_state = tech_data_reg [ data_tech_to_report ];
       }

          // * response
          QCRIL_LOG_INFO(" ..* response build" );

          local_reg_snapshot.registration_state = pref_data_tech_reg_state;
          NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_reg_status, pref_data_tech_reg_state);
          snprintf( ril_resp_helper.registration_state, sizeof(ril_resp_helper.registration_state), "%d",
                    (int) ( ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV != pref_data_tech_reg_state ) ?
                                                pref_data_tech_reg_state :
                                                RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING )
                  );

          QCRIL_LOG_INFO("... cur reg state %d(%s)", (int) pref_data_tech_reg_state, ril_resp_helper.registration_state );
          if (pref_data_tech_reg_state == 1)
          {
              log_mask |= 0x01; // in service
          }
          else if (pref_data_tech_reg_state == 5)
          {
              log_mask |= 0x01; // in service
              log_mask |= 0x02; // roaming
          }

          if ( is_registered )
          {
              threegpp_sys_info = NULL;
              sys_info_wcdma    = NULL;
              sys_info_tdscdma  = NULL;
              common_sys_info   = NULL;
              cdma_hdr_only_sys_info = NULL;
              switch ( data_tech_to_report )
              {
                  case QCRIL_ARB_PREF_DATA_TECH_GSM:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                      {
                          threegpp_sys_info = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                          common_sys_info = &nas_cached_info.gsm_sys_info->common_sys_info;
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                      {
                          threegpp_sys_info = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                          sys_info_wcdma    = &nas_cached_info.wcdma_sys_info->wcdma_specific_sys_info;
                          common_sys_info = &nas_cached_info.wcdma_sys_info->common_sys_info;
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                      {
                          threegpp_sys_info = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                          sys_info_tdscdma    = &nas_cached_info.tdscdma_sys_info->tdscdma_specific_sys_info;
                          common_sys_info = &nas_cached_info.tdscdma_sys_info->common_sys_info;
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_LTE:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                      {
                          threegpp_sys_info = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                          common_sys_info = &nas_cached_info.lte_sys_info->common_sys_info;
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
                      {
                          common_sys_info = &nas_cached_info.cdma_sys_info->common_sys_info;
                          cdma_hdr_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_hdr_only_sys_info;
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_EVDO:
                  case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                      {
                          common_sys_info = &nas_cached_info.hdr_sys_info->common_sys_info;
                          cdma_hdr_only_sys_info = &nas_cached_info.hdr_sys_info->cdma_hdr_only_sys_info;
                      }
                      break;


                  default:
                      // nothing
                      break;
              }
              // * lac
              if ( NULL != threegpp_sys_info && threegpp_sys_info->lac_valid )
              {
                  local_reg_snapshot.lac_valid = TRUE;
                  local_reg_snapshot.lac = threegpp_sys_info->lac;
                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", (uint) threegpp_sys_info->lac );
                  QCRIL_LOG_INFO("... cur lac %s", ril_resp_helper.lac );
              }

              // * cid
              if ( NULL != threegpp_sys_info && threegpp_sys_info->cell_id_valid )
              {
                  cell_id = threegpp_sys_info->cell_id;
                  if ( cell_id > (uint32_t)0x7FFFFFFF )
                  {
                      local_reg_snapshot.cid_valid = TRUE;
                      local_reg_snapshot.cid = (uint32_t) 0x7FFFFFFF;
                      snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", (uint32_t) 0x7FFFFFFF );
                  }
                  else
                  {
                      local_reg_snapshot.cid_valid = TRUE;
                      local_reg_snapshot.cid = cell_id;
                      snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", cell_id );
                  }

                  QCRIL_LOG_INFO("... cur cid %s", ril_resp_helper.cid );
              }

              if ( NULL != sys_info_cdma && sys_info_cdma->cdma_sys_id_valid )
              {
                  NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.cdma_sys_id, sys_info_cdma->cdma_sys_id );
              }
              else
              {
                  NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
              }


              if ( NULL != common_sys_info && common_sys_info->roam_status_valid )
              {
                  current_roam_status_valid = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.roam_status );
                  current_roam_status = nas_cached_info.roam_status;

                  if ( FALSE == nas_cached_info.voice_roam_status_reported &&
                    (FALSE == current_roam_status_valid || current_roam_status != common_sys_info->roam_status) )
                  {
                      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.roam_status, common_sys_info->roam_status );

                      must_rerender_data_reg_report = TRUE;
                  }
              }
              else
              {
                  NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
              }

              if ( NULL != cdma_hdr_only_sys_info && cdma_hdr_only_sys_info->is_sys_prl_match_valid )
              {
                  NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.is_sys_prl_match, cdma_hdr_only_sys_info->is_sys_prl_match );
              }
              else
              {
                  NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
              }

              // * radio tech
              val_int = RADIO_TECH_UNKNOWN;

              QCRIL_LOG_DEBUG("pref_data.is_current = %d", pref_data.is_current);
              if( (TRUE == pref_data.is_current) )
              {
                  val_int = pref_data.radio_technology;
              }
              else
              {
              switch ( data_tech_to_report )
              {
                  case QCRIL_ARB_PREF_DATA_TECH_CDMA:
                      val_int = qcril_qmi_nas_util_determine_cdma_rev( sys_info_cdma );
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_EVDO:
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
                      {
                          QCRIL_LOG_INFO("... hdr_active_prot_valid %d", (int)nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot_valid );
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) && nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot_valid )
                      {
                          QCRIL_LOG_INFO("... hdr_active_prot %d", (int)nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot  );
                          switch ( nas_cached_info.hdr_sys_info->hdr_specific_sys_info.hdr_active_prot )
                          {
                              case NAS_SYS_ACTIVE_PROT_HDR_REL0_V01:
                                  val_int = RADIO_TECH_EVDO_0;
                                  break;

                              case NAS_SYS_ACTIVE_PROT_HDR_RELA_V01:
                                  val_int = RADIO_TECH_EVDO_A;
                                  break;

                              case NAS_SYS_ACTIVE_PROT_HDR_RELB_V01:
                                  val_int = RADIO_TECH_EVDO_B;
                                  break;

                              case NAS_SYS_ACTIVE_PROT_NONE_V01:
                              default:
                                  break;
                          }
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_GSM:
                      QCRIL_LOG_INFO("... gsm_sys_info valid %d", NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ));
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                      {
                          QCRIL_LOG_INFO("... egprs_supp_valid, egprs_supp %d, %d",
                                         (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid,
                                         (int)nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp );
                      }
                      if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                           nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid &&
                           NAS_SYS_EGPRS_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp )
                      {
                          val_int = RADIO_TECH_EDGE;
                      }
                      else
                      {
                          val_int = RADIO_TECH_GPRS; // safe to assume GPRS as serving_status is "in service" and srv_domain is either cs_ps or ps_only
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_UMTS:
                      val_int = RADIO_TECH_UMTS; // by default
                      QCRIL_LOG_INFO("... sys_info_wcdma %p", sys_info_wcdma);
                      if ( NULL != sys_info_wcdma )
                      {
                          QCRIL_LOG_INFO( "... hs_ind_valid, hs_ind %d, %d", (int)sys_info_wcdma->hs_ind_valid, (int)sys_info_wcdma->hs_ind );
                          QCRIL_LOG_INFO( "... hs_call_status_valid, hs_call_status %d, %d", (int)sys_info_wcdma->hs_call_status_valid, (int)sys_info_wcdma->hs_call_status );
                          if ( sys_info_wcdma->hs_ind_valid && sys_info_wcdma->hs_call_status_valid )
                          {
                            if( sys_info_wcdma->hs_ind > sys_info_wcdma->hs_call_status )
                            {
                              loc_hs_ser = sys_info_wcdma->hs_ind;
                            }
                            else
                            {
                              loc_hs_ser = sys_info_wcdma->hs_call_status;
                            }
                          }
                          else if ( sys_info_wcdma->hs_ind_valid )
                          {
                            loc_hs_ser = sys_info_wcdma->hs_ind;
                          }
                          else if ( sys_info_wcdma->hs_call_status_valid )
                          {
                            loc_hs_ser = sys_info_wcdma->hs_call_status;
                          }

                          switch ( loc_hs_ser )
                          {
                            case SYS_HS_IND_HSDPA_SUPP_CELL_V01:          // fallthrough
                                val_int = RADIO_TECH_HSDPA;
                                break;

                            case SYS_HS_IND_HSUPA_SUPP_CELL_V01:
                                val_int = RADIO_TECH_HSUPA;
                                break;

                            case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL_V01:
                                val_int = RADIO_TECH_HSPA;
                                break;

                            case SYS_HS_IND_HSDPAPLUS_SUPP_CELL_V01:      // fallthrough
                            case SYS_HS_IND_HSDPAPLUS_64QAM_SUPP_CELL_V01:// fallthrough
                            case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL_V01:   // fallthrough
                            case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL_V01:    // fallthrough
                            case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL_V01: // fallthrough
                            case SYS_HS_IND_HSDPAPLUS_64QAM_HSUPA_SUPP_CELL_V01:
                                val_int = RADIO_TECH_HSPAP;
                                break;

                            default:
                                // no change, RADIO_TECH_UMTS by default
                                break;
                          }
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
                      val_int = RADIO_TECH_EHRPD;
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_LTE:
                      val_int = RADIO_TECH_LTE;
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
                      val_int = RADIO_TECH_TD_SCDMA; // by default
                      QCRIL_LOG_INFO("... sys_info_tdscdma %p", sys_info_tdscdma);
                      if ( NULL != sys_info_tdscdma )
                      {
                          QCRIL_LOG_INFO( "... hs_ind_valid, hs_ind %d, %d", (int)sys_info_tdscdma->hs_ind_valid, (int)sys_info_tdscdma->hs_ind );
                          QCRIL_LOG_INFO( "... hs_call_status_valid, hs_call_status %d, %d", (int)sys_info_tdscdma->hs_call_status_valid, (int)sys_info_tdscdma->hs_call_status );
                          if ( sys_info_tdscdma->hs_ind_valid && sys_info_tdscdma->hs_call_status_valid )
                          {
                            if( sys_info_tdscdma->hs_ind > sys_info_tdscdma->hs_call_status )
                            {
                              loc_hs_ser = sys_info_tdscdma->hs_ind;
                            }
                            else
                            {
                              loc_hs_ser = sys_info_tdscdma->hs_call_status;
                            }
                          }
                          else if ( sys_info_tdscdma->hs_ind_valid )
                          {
                            loc_hs_ser = sys_info_tdscdma->hs_ind;
                          }
                          else if ( sys_info_tdscdma->hs_call_status_valid )
                          {
                            loc_hs_ser = sys_info_tdscdma->hs_call_status;
                          }

                          switch ( loc_hs_ser )
                          {
                            case SYS_HS_IND_HSDPA_SUPP_CELL_V01:          // fallthrough
                                val_int = RADIO_TECH_HSDPA;
                                break;

                            case SYS_HS_IND_HSUPA_SUPP_CELL_V01:
                                val_int = RADIO_TECH_HSUPA;
                                break;

                            case SYS_HS_IND_HSDPA_HSUPA_SUPP_CELL_V01:
                                val_int = RADIO_TECH_HSPA;
                                break;

                            case SYS_HS_IND_HSDPAPLUS_SUPP_CELL_V01:      // fallthrough
                            case SYS_HS_IND_HSDPAPLUS_64QAM_SUPP_CELL_V01:// fallthrough
                            case SYS_HS_IND_DC_HSDPAPLUS_SUPP_CELL_V01:   // fallthrough
                            case SYS_HS_IND_HSDPAPLUS_HSUPA_SUPP_CELL_V01:    // fallthrough
                            case SYS_HS_IND_DC_HSDPAPLUS_HSUPA_SUPP_CELL_V01: // fallthrough
                            case SYS_HS_IND_HSDPAPLUS_64QAM_HSUPA_SUPP_CELL_V01:
                                val_int = RADIO_TECH_HSPAP;
                                break;

                            default:
                                // no change, RADIO_TECH_TD_SCDMA by default
                                break;
                          }
                      }
                      break;

                  case QCRIL_ARB_PREF_DATA_TECH_UNKNOWN:    // fallthrough
                  default:
                      val_int = RADIO_TECH_UNKNOWN;
                      break;
              }
              }
              QCRIL_LOG_INFO("... cur tech %d", (int) val_int );
              snprintf( ril_resp_helper.data_radio_tech, sizeof(ril_resp_helper.data_radio_tech), "%d", val_int );
              NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_technology, val_int);
              local_reg_snapshot.data_radio_tech = val_int;


              // * tac for LTE
              if ( !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_PLAIN_ANDROID ) )
              {
                  val_int = NAS_NIL;
                  QCRIL_LOG_INFO("... lte details valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) );
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                  {
                      QCRIL_LOG_INFO("... tac valid %d, tac %d", (int) nas_cached_info.lte_sys_info->lte_specific_sys_info.tac_valid, (int) nas_cached_info.lte_sys_info->lte_specific_sys_info.tac  );
                  }
                  if ( QCRIL_ARB_PREF_DATA_TECH_LTE == data_tech_to_report &&
                       NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                       nas_cached_info.lte_sys_info->lte_specific_sys_info.tac_valid )
                  {
                      val_int = nas_cached_info.lte_sys_info->lte_specific_sys_info.tac;
                      QCRIL_LOG_INFO("... TAC LTE %d", (int) val_int );
                      snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", val_int );
                      local_reg_snapshot.lac_valid = TRUE;
                      local_reg_snapshot.lac = val_int;
                  }
              } // !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_PLAIN_ANDROID ) )

              // * LTE specifics
              if ( QCRIL_ARB_PREF_DATA_TECH_LTE == data_tech_to_report )
              {
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&  nas_cached_info.lte_sys_info->lte_specific_sys_info.tac_valid )
                  {
                      val_int = nas_cached_info.lte_sys_info->lte_specific_sys_info.tac;
                      QCRIL_LOG_INFO("... LTE TAC %d", (int) val_int );
                      snprintf( ril_resp_helper.tac, sizeof(ril_resp_helper.tac), "%d", (int) val_int );
                      local_reg_snapshot.tac_valid = TRUE;
                      local_reg_snapshot.tac = val_int;
                  }
              } // LTE specifics, if ( QCRIL_ARB_PREF_DATA_TECH_LTE == data_tech_to_report) )
          }
          else
          {
          // * reg reject
          if ( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_rejected )
          {
              val_int = qmi_ril_nwr_conv_reg_reject_cause_data( nas_cached_info.reg_reject_sys_info [vrte_mapper].ps_reject_cause, vrte_mapper );
              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, vrte_mapper, QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED );
          }
          else
          {
              val_int = NAS_NIL;
          }
          snprintf( ril_resp_helper.registration_denied_cause, sizeof(ril_resp_helper.registration_denied_cause), "%d", val_int );
          }

          // data reg snapshot work out
          QCRIL_LOG_INFO(".. prestored reg snapshot valid %d while cur reg %d", (int) nas_cached_info.data_reg_report_snapshot.valid, is_registered );

          if ( is_registered )
          { // refer to prestored snapshot on next occasions
              local_reg_snapshot.valid = TRUE;
          }
          else if ( nas_cached_info.data_reg_report_snapshot.valid && nas_common_info.data_snapshot_feature_enabled )
          { // report prestored snapshot vector
              snprintf( ril_resp_helper.registration_state, sizeof(ril_resp_helper.registration_state), "%d", nas_cached_info.data_reg_report_snapshot.registration_state );
              if ( nas_cached_info.data_reg_report_snapshot.lac_valid )
              {
                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", (uint) nas_cached_info.data_reg_report_snapshot.lac );
              }
              else
              {
                  *ril_resp_helper.lac = NAS_NIL;
              }
              if ( nas_cached_info.data_reg_report_snapshot.cid_valid )
              {
                  snprintf( ril_resp_helper.cid, sizeof(ril_resp_helper.cid), "%08x", (uint)nas_cached_info.data_reg_report_snapshot.cid );
              }
              else
              {
                  *ril_resp_helper.cid = NAS_NIL;
              }
              snprintf( ril_resp_helper.data_radio_tech, sizeof(ril_resp_helper.data_radio_tech), "%d", nas_cached_info.data_reg_report_snapshot.data_radio_tech );

              if ( nas_cached_info.data_reg_report_snapshot.tac_valid )
              {
                  snprintf( ril_resp_helper.lac, sizeof(ril_resp_helper.lac), "%04x", (uint) nas_cached_info.data_reg_report_snapshot.tac );
              }
              else
              {
                  *ril_resp_helper.tac = NAS_NIL;
              }

              NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_technology, nas_cached_info.data_reg_report_snapshot.data_radio_tech);
              NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_data_reg_status, nas_cached_info.data_reg_report_snapshot.registration_state);
          }

          if ( !is_registered )
          {
              nas_cached_info.data_reg_roaming_status_latest_val = FALSE;
          }

          QCRIL_LOG_INFO("considered data technology valid %d, value %d", NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.considered_data_technology), nas_cached_info.considered_data_technology);
          QCRIL_LOG_INFO("reported data technology %d", nas_cached_info.reported_data_technology);
          qcril_qmi_nas_data_update_mtu_size_if_needed(prev_reported_state_valid,
                                                       prev_reported_state,
                                                       prev_reported_tech_valid,
                                                       prev_reported_tech);
          NAS_CACHE_UNLOCK();

          // * LTE specifics
          if ( QCRIL_ARB_PREF_DATA_TECH_LTE == data_tech_to_report )
          {
              nas_get_cell_location_info_resp_msg_v01 get_cell_location_info_resp;
              if ( RIL_E_SUCCESS == qcril_qmi_nas_get_cell_location_data_sync(&get_cell_location_info_resp, NULL))
              {
                  if ( get_cell_location_info_resp.lte_intra_valid )
                  {
                      /* Global Cell ID */
                      val_int = get_cell_location_info_resp.lte_intra.global_cell_id;
                      snprintf( ril_resp_helper.eci, sizeof(ril_resp_helper.eci), "%d", (int) val_int );

                      /* Physical Cell ID */
                      val_int = get_cell_location_info_resp.lte_intra.serving_cell_id;
                      snprintf( ril_resp_helper.phys_cell_id, sizeof(ril_resp_helper.phys_cell_id), "%d", (int) val_int);
                  }
              }
          } // LTE specifics, if ( QCRIL_ARB_PREF_DATA_TECH_LTE == data_tech_to_report) )
      }
  }

  // * maximum number of simultaneous Data Calls
  val_int = NAS_REG_DATA_MAX_DATA_CALLS ;
  snprintf( ril_resp_helper.max_data_call_no, sizeof(ril_resp_helper.max_data_call_no), "%d", val_int );

  // save snapshot if applicable
  QCRIL_LOG_INFO("snapshot valid %d", (int) local_reg_snapshot.valid  );
  QCRIL_LOG_INFO("is snapshot feature enabled %d", (int) nas_common_info.data_snapshot_feature_enabled  );
  if ( local_reg_snapshot.valid )
  {
      NAS_CACHE_LOCK();

      if ( !pref_data.is_extrapolation || NAS_NIL == nas_cached_info.data_reg_report_expiry )
      {
          QCRIL_LOG_INFO("launching extrapolation expry tmr" );
          if ( NAS_NIL != nas_cached_info.data_reg_report_expiry )
          {
              QCRIL_LOG_INFO("stopping outdated tmr" );
              qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
              nas_cached_info.data_reg_report_expiry = NAS_NIL;
          }

          if ( qmi_ril_nwreg_spawn_snapshot_timer_cl( FALSE ) )
          {
              nas_cached_info.data_reg_report_snapshot = local_reg_snapshot;
          }

      }
      else
      {
          QCRIL_LOG_INFO("extrapolation expry tmr already oustanding or inapplicable, no recursing" );
      }

      NAS_CACHE_UNLOCK();

  }

  NAS_CACHE_UNLOCK();
  // ** respond
  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {

      for ( cnt = 0; cnt < NAS_REG_DATA_STATE_RESP_MAX_ARR_SIZE; cnt++ )
      {
          if ( ril_resp_helper.registration_info_array[cnt] )
          {
              QCRIL_LOG_INFO(".. rg %d - %s", (int) cnt, ril_resp_helper.registration_info_array[cnt]);

              if ( ! *ril_resp_helper.registration_info_array[cnt] )
              {
                  ril_resp_helper.registration_info_array[cnt] = NULL;
              }
          }
      }

      // Simplified logging
      QCRIL_LOG_INFO("RIL DATA REGISTRATION: %s %s in %s", ((log_mask & 0x01)?"Full service":"No service"), ((log_mask&0x02)?"Roaming":"Home"),
                     qcril_qmi_util_retrieve_pref_data_tech_name(data_tech_to_report));
      QCRIL_LOG_INFO("based on %s", (log_mask&0x04)?"QMI NAS":"QMI WDS");

      resp.resp_pkt = (void *) &ril_resp_helper.registration_info_array;
      resp.resp_len = sizeof( ril_resp_helper.registration_info_array );
  }

  QCRIL_LOG_INFO("reported pref data tech %s", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data.pref_data_tech));
  NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.reported_pref_data_technology, pref_data.pref_data_tech);

  QCRIL_LOG_INFO("complete with %d", (int) ril_req_res  );
  qcril_send_request_response( &resp );

  // NOTE: current implementation ensures that all responses are sent back in ONE thread
  // after calling qcril_send_request_response()
  qmi_ril_unsuppress_android_unsol_resp(RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED);
  qmi_ril_unsuppress_android_unsol_resp(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED);

  if ( must_rerender_data_reg_report )
  {
    QCRIL_LOG_INFO("will arrange rerender data reg report" );

    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                            QCRIL_DEFAULT_MODEM_ID,
                            qmi_ril_nw_reg_redo_data_reg_report,
                            NULL,  // immediate
                            NULL );

  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_request_data_registration_state

//===========================================================================
// qcril_qmi_nas_retrieve_reported_data_technology
//===========================================================================
int qcril_qmi_nas_retrieve_reported_data_technology()
{
    int reported_data_technology;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    reported_data_technology = nas_cached_info.reported_data_technology;
    NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN_WITH_RET(reported_data_technology);
   return reported_data_technology;
} //qcril_qmi_nas_retrieve_reported_data_technology

//===========================================================================
// qmi_ril_nw_reg_data_roaming_tmr_expired
//===========================================================================
void qmi_ril_nw_reg_data_roaming_tmr_expired(void * param)
{
    qcril_modem_restart_con_type outcome;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.data_reg_roaming_status_latest        = NAS_NIL;
    nas_cached_info.data_reg_roaming_status_latest_val    = FALSE;
    nas_cached_info.data_reg_roaming_status_latest_expiry = NAS_NIL;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_roaming_tmr_expired


//===========================================================================
// qmi_ril_nwreg_spawn_snapshot_timer_cl
//===========================================================================
int qmi_ril_nwreg_spawn_snapshot_timer_cl( int is_maintanance )
{
    uint32              snapshot_validity_window_tmr;
    struct timeval      snapshot_validity_window_frame;
    int                 spawn_snapshot_timer;

    if( nas_common_info.data_snapshot_timer_value_valid )
    {
        if ( nas_common_info.data_snapshot_timer_value > NAS_NIL )
        {
            snapshot_validity_window_frame.tv_sec  = nas_common_info.data_snapshot_timer_value;
            snapshot_validity_window_frame.tv_usec = NAS_NIL;
            spawn_snapshot_timer                   = TRUE;
        }
        else
        { // zero effectively disables snapshot timer
            spawn_snapshot_timer = FALSE;
        }
    }
    else
    {
        snapshot_validity_window_frame.tv_sec  = 22; //default value - 22 seconds
        snapshot_validity_window_frame.tv_usec = NAS_NIL;
        spawn_snapshot_timer                   = TRUE;
    }

    if ( spawn_snapshot_timer && is_maintanance )
    { // maintanance mode - not user's setting, not default setting but a large time window
        snapshot_validity_window_frame.tv_sec  = 24 * 60 * 60; // 24 hours
        snapshot_validity_window_frame.tv_usec = NAS_NIL;
    }

    QCRIL_LOG_INFO("snapshot tmr action %d", spawn_snapshot_timer );

    if ( spawn_snapshot_timer )
    {
        qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler,
                                      &snapshot_validity_window_frame,
                                      &snapshot_validity_window_tmr );

        nas_cached_info.data_reg_report_expiry   = snapshot_validity_window_tmr;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET( spawn_snapshot_timer );
    return spawn_snapshot_timer;
} // qmi_ril_nwreg_spawn_snapshot_timer_cl

//===========================================================================
// qmi_ril_nw_reg_data_sys_update_pre_update_action
//===========================================================================
void qmi_ril_nw_reg_data_sys_update_pre_update_action( void )
{
    NAS_CACHE_LOCK();

    QCRIL_LOG_INFO("snapshot tmr 0x%x, snapshot valid %d", nas_cached_info.data_reg_report_expiry, nas_cached_info.data_reg_report_snapshot.valid );
    if ( NAS_NIL != nas_cached_info.data_reg_report_expiry && nas_cached_info.data_reg_report_snapshot.valid )
    {
          qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
          nas_cached_info.data_reg_report_expiry = NAS_NIL;

          (void)qmi_ril_nwreg_spawn_snapshot_timer_cl( FALSE );
    }

    NAS_CACHE_UNLOCK();

} // qmi_ril_nw_reg_data_sys_update_pre_update_action

//===========================================================================
// qmi_ril_nw_reg_extend_pref_data_tech_cl
//===========================================================================
void qmi_ril_nw_reg_extend_pref_data_tech_cl( qcril_arb_pref_data_type * pref_data, int * is_extrapolation, int * extrapolation_is_roaming )
{
  int                       need_reset;
  qcril_card_status_e_type  card_status;
  int                       card_ever_present;
  int                       local_is_extrapolation;
  int                       local_extrapolation_is_roaming;
  uint32_t                  slot = 0;

  QCRIL_LOG_FUNC_ENTRY();

  local_is_extrapolation         = FALSE;
  local_extrapolation_is_roaming = FALSE;

  if ( pref_data )
  {
    need_reset = FALSE;

    slot = qmi_ril_get_sim_slot();
    card_status        = nas_common_info.card_info[slot].status;
    card_ever_present  = nas_common_info.card_info[slot].card_ever_present;

    QCRIL_LOG_INFO( "is extrapolation %d, cache is valid %d, cache rat %d, oprt valid %d, oprt %d, card status %d, card ever present %d, ban %d, mpv %d, mp %d",
                    (int)pref_data->is_extrapolation,
                    (int)nas_cached_info.data_reg_report_snapshot.valid,
                    (int)nas_cached_info.data_reg_report_snapshot.data_radio_tech,
                    NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ),
                    (int)nas_dms_cached_info.operating_mode,
                    (int)card_status,
                    card_ever_present,
                    (int)nas_cached_info.extrapolation_ban_expiry,
                    NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref),
                    (int)nas_cached_info.mode_pref );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) &&
         DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode &&
         RADIO_TECH_IWLAN != pref_data->radio_technology )
    { // reset when not ONLINE
      need_reset = TRUE;
    }
    if ( pref_data->is_extrapolation )
    { // extrapolation behavior

      local_is_extrapolation = TRUE;

      if ( nas_cached_info.data_reg_report_snapshot.valid && RIL_VAL_REG_REGISTERED_ROAMING == nas_cached_info.data_reg_report_snapshot.registration_state )
      {
          local_extrapolation_is_roaming = TRUE;
      }

      // reset if snapshot and expired
      if ( !nas_cached_info.data_reg_report_snapshot.valid || (int)nas_cached_info.data_reg_report_snapshot.data_radio_tech != (int)pref_data->radio_technology )
      {
        need_reset = TRUE;
      }
      // reset if card absent
      if ( card_ever_present && (QCRIL_CARD_STATUS_UP != card_status) )
      {
          need_reset = TRUE;
      }
      // reset if GLW or its subset
      if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) && ( NAS_NIL == ( QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & nas_cached_info.mode_pref ) ) )
      {
          need_reset = TRUE;
      }
      // reset if extrapolation banned
      if ( NAS_NIL != nas_cached_info.extrapolation_ban_expiry )
      {
          need_reset = TRUE;
      }
      // reset if subscription is deactivated
      if (nas_cached_info.dsds_is_active_valid && !nas_cached_info.dsds_is_active)
      {
          need_reset = TRUE;
      }
    }

    QCRIL_LOG_INFO( "need reset %d", need_reset );
    if ( need_reset )
    {
      pref_data->radio_technology = RADIO_TECH_UNKNOWN;
      pref_data->is_current       = FALSE;  // this will force to use QMI NAS info for previously camped CnE RAT

      local_is_extrapolation            = FALSE;
      local_extrapolation_is_roaming    = FALSE;
    }

    QCRIL_LOG_INFO( "RAT %d, is current %d, is_extrapolation %d, is_extrap_roaming %d",
                    (int)pref_data->radio_technology,
                    (int)pref_data->is_current,
                    local_is_extrapolation,
                    local_extrapolation_is_roaming
                     );

    if ( NULL != is_extrapolation )
    {
        *is_extrapolation = local_is_extrapolation;
    }
    if ( NULL != extrapolation_is_roaming )
    {
        *extrapolation_is_roaming = local_extrapolation_is_roaming;
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_extend_pref_data_tech_cl

//===========================================================================
// qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation
//===========================================================================
void qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation_ncl()
{
    const struct timeval ban_timeout = {10 , 0}; // 10 seconds
    uint32 timeout_watch;
    int    timeout_set_res;

    QCRIL_LOG_FUNC_ENTRY();

    timeout_watch = 0;
    NAS_CACHE_LOCK();
    if ( NAS_NIL != nas_cached_info.extrapolation_ban_expiry )
    {
        qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.extrapolation_ban_expiry );
        nas_cached_info.extrapolation_ban_expiry = NAS_NIL;
    }
    NAS_CACHE_UNLOCK();

    timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                  QCRIL_DEFAULT_MODEM_ID,
                                                  qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired,
                                                  &ban_timeout,
                                                  &timeout_watch );
    if ( E_SUCCESS == timeout_set_res && NAS_NIL != timeout_watch )
    {
        NAS_CACHE_LOCK();
        nas_cached_info.extrapolation_ban_expiry = timeout_watch;
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation
//===========================================================================
// qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired
//===========================================================================
void qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired(void * param)
{
    qcril_unsol_resp_params_type unsol_resp_params;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.extrapolation_ban_expiry = NAS_NIL;
    NAS_CACHE_UNLOCK();

    qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
    qcril_send_unsol_response( &unsol_resp_params );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_post_cfg_ban_for_data_reg_extrapolation_expired

//===========================================================================
// qmi_ril_nw_reg_redo_data_reg_report
//===========================================================================
void qmi_ril_nw_reg_redo_data_reg_report(void * param)
{
    qcril_unsol_resp_params_type unsol_resp_params;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
    qcril_send_unsol_response( &unsol_resp_params );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_redo_data_reg_report


//===========================================================================
// qcril_qmi_nas_util_check_request_need
//===========================================================================
int qcril_qmi_nas_util_check_request_need(qcril_arb_pref_data_tech_e_type pref_data_tech, qmi_ril_nw_reg_rte_type drte)
{
  int qmi_request_need;

  QCRIL_LOG_FUNC_ENTRY();

  if( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech )
  {
    switch ( pref_data_tech )
    {
        case QCRIL_ARB_PREF_DATA_TECH_CDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_GSM:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_UMTS:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_LTE:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte )
                ) ? FALSE : TRUE;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_EVDO:
        case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info )
                ) ? FALSE : TRUE;
            break;

        default:
            qmi_request_need = FALSE; // if unknown
            break;
    }
  }
  else
  {
    switch ( drte )
    {
        case QMI_RIL_RTE_1x:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_GSM:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_WCDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info3 )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_TDSCDMA:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_SUB_LTE:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_cell_status ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte )
                ) ? FALSE : TRUE;
            break;

        case QMI_RIL_RTE_SUB_DO:
            qmi_request_need =
                (
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) &&
                NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info )
                ) ? FALSE : TRUE;
            break;

        default:
            qmi_request_need = TRUE; // data rte is unknown, let's refetch QMI NAS info and reevaluate that
            break;
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(qmi_request_need);
  return qmi_request_need;
} //qcril_qmi_nas_util_check_request_need

//===========================================================================
// qcril_qmi_nas_util_check_roaming_status
//===========================================================================
int qcril_qmi_nas_util_check_roaming_status(qcril_arb_pref_data_tech_e_type pref_data_tech, int * data_reg_status, int *confident_response )
{
  int                            res;
  nas_common_sys_info_type_v01 * common_sys_info = NULL;
  int                            local_confident_response;

  QCRIL_LOG_FUNC_ENTRY();

  local_confident_response = FALSE;

  if ( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech &&
       QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data_tech &&
       NULL != data_reg_status &&
       (RIL_VAL_REG_REGISTERED_HOME_NET == data_reg_status [ pref_data_tech ] || RIL_VAL_REG_REGISTERED_ROAMING == data_reg_status [ pref_data_tech ] ) )
  {
    switch ( pref_data_tech )
    {
        case QCRIL_ARB_PREF_DATA_TECH_CDMA:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_GSM:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_UMTS:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_LTE:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
            break;

        case QCRIL_ARB_PREF_DATA_TECH_EVDO:
        case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
            common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
            break;

        default:
            common_sys_info = NULL;
            break;
    }

    if ( NULL != common_sys_info &&
         common_sys_info->roam_status_valid )
    {
        if ( ( NAS_SYS_ROAM_STATUS_OFF_V01 == common_sys_info->roam_status ) ||
             ( ( ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_64 == common_sys_info->roam_status ) ||
                 ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_65 == common_sys_info->roam_status ) ||
                 ( (common_sys_info->roam_status >= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_76 ) &&
                   (common_sys_info->roam_status <= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_83 )
                 ) ) && nas_common_info.eri_64_home )
           )
        {
             res = RIL_VAL_REG_REGISTERED_HOME_NET;
        }
        else
        {
            res = RIL_VAL_REG_REGISTERED_ROAMING;
        }
        local_confident_response = TRUE;
    }
    else
    {
        res = RIL_VAL_REG_REGISTERED_HOME_NET;
    }
  }
  else
  {
    res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
  }

  QCRIL_LOG_INFO( ".. data roam determination confidence %d", local_confident_response );
  if ( NULL != confident_response )
  {
      *confident_response = local_confident_response;
  }
  QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
  return res;
} //qcril_qmi_nas_util_check_roaming_status

//===========================================================================
// qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler
//===========================================================================
void qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler(void * param)
{
    int                             need_update;
    int                             need_keep_guard;
    qcril_unsol_resp_params_type    unsol_resp_params;
    qcril_arb_pref_data_type        pref_data;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    qcril_qmi_get_pref_data_tech( &pref_data );

    NAS_CACHE_LOCK();

    nas_cached_info.data_reg_report_expiry = NAS_NIL;

    need_update         = nas_cached_info.data_reg_report_snapshot.valid && pref_data.is_extrapolation;

    need_keep_guard     = // snapshot is still valid
                          nas_cached_info.data_reg_report_snapshot.valid &&
                         // not extrapolated as if extrapolated we do not extended timer
                         !pref_data.is_extrapolation &&
                         // radio technology is known
                         ( RADIO_TECH_UNKNOWN != pref_data.radio_technology ) &&
                         // not subset of GWL so extrapolation is of use
                         ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) && ( NAS_NIL != ( QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & nas_cached_info.mode_pref ) ) );

    QCRIL_LOG_INFO("is cache still valid %d, pref data tech is extrap %d, need upd %d, need peep guard %d",
                   (int) nas_cached_info.data_reg_report_snapshot.valid,
                   (int) pref_data.is_extrapolation,
                   need_update,
                   need_keep_guard );

    if ( need_keep_guard )
    {
        (void)qmi_ril_nwreg_spawn_snapshot_timer_cl( TRUE );
    }
    else
    {
        nas_cached_info.data_reg_report_snapshot.valid = FALSE;
    }

    NAS_CACHE_UNLOCK();

    if ( need_update )
    {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
        qcril_send_unsol_response( &unsol_resp_params );
        qcril_qmi_drop_sig_info_cache();
        qcril_qmi_nas_send_known_signal_strength();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_reg_snapshot_validity_tmr_expry_handler

//===========================================================================
// qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler
//===========================================================================
void qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler(void * param)
{
    qcril_reqlist_public_type                   qcril_req_info;
    errno_enum_type                             found_qcril_request;
    qcril_request_resp_params_type        resp;
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  QCRIL_EVT_QMI_REQUEST_SET_SYS_SEL_PREF,
                                  &qcril_req_info );

    if ( ( E_SUCCESS == found_qcril_request ) && ( FALSE == nas_cached_info.is_indication_received ) )
    {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         qcril_req_info.t,
                                         qcril_req_info.request,
                                         RIL_E_GENERIC_FAILURE,
                                         &resp );

      qcril_send_request_response( &resp );
    }

    nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
}//qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler

//===========================================================================
// qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler
//===========================================================================
void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler(void * param)
{
    qcril_unsol_resp_params_type    unsol_resp_params;
    int                             nof_data_calls;
    int                             need_invalidate;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    need_invalidate = FALSE;

    nof_data_calls = qcril_qmi_data_nas_control_get_current_calls_number(NULL);
    QCRIL_LOG_INFO("nof data calls %d", (int) nof_data_calls );

    if ( NAS_NIL == nof_data_calls )
    {
        NAS_CACHE_LOCK();
        if ( nas_cached_info.data_reg_report_snapshot.valid )
        {
            if ( NAS_NIL != nas_cached_info.data_reg_report_expiry )
            {
                qcril_cancel_timed_callback( (void*)(uintptr_t) nas_cached_info.data_reg_report_expiry );
                nas_cached_info.data_reg_report_expiry = NAS_NIL;
            }
            nas_cached_info.data_reg_report_snapshot.valid = FALSE;

            need_invalidate = TRUE;
        }
        NAS_CACHE_UNLOCK();
    }

    if ( need_invalidate )
    {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
        qcril_send_unsol_response( &unsol_resp_params );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_disconnect_handler

//===========================================================================
// qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler
//===========================================================================
void qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler(void * param)
{
    qcril_unsol_resp_params_type    unsol_resp_params;
    int                             nof_data_calls;
    int                             need_revalidate;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    need_revalidate = FALSE;

    nof_data_calls = qcril_qmi_data_nas_control_get_current_calls_number(NULL);
    QCRIL_LOG_INFO("nof data calls %d", (int) nof_data_calls );

    if ( nof_data_calls > NAS_NIL )
    {
        NAS_CACHE_LOCK();
        if ( !nas_cached_info.data_reg_report_snapshot.valid )
        {
            need_revalidate = TRUE;
        }
        NAS_CACHE_UNLOCK();
    }

    if ( need_revalidate )
    {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
        qcril_send_unsol_response( &unsol_resp_params );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_reg_snapshot_validate_after_data_call_connect_handler

//===========================================================================
// qcril_qmi_util_retrieve_technology_name
//===========================================================================
const char* qcril_qmi_util_retrieve_technology_name(int technology)
{
  if( technology >= RADIO_TECH_UNKNOWN && technology <= RADIO_TECH_MAX )
  {
    return radio_tech_name[technology];
  }
  else
  {
    return radio_tech_name[RADIO_TECH_MAX + 1];
  }
} //qcril_qmi_util_retrieve_technology_name

//===========================================================================
// qcril_qmi_util_retrieve_pref_data_tech_name
//===========================================================================
const char* qcril_qmi_util_retrieve_pref_data_tech_name(int pref_data_tech)
{
  if( pref_data_tech >= QCRIL_ARB_PREF_DATA_TECH_INVALID && pref_data_tech <= QCRIL_ARB_PREF_DATA_TECH_TDSCDMA )
  {
    return pref_data_tech_name[pref_data_tech + 1];
  }
  else
  {
    return pref_data_tech_name[QCRIL_ARB_PREF_DATA_TECH_MAX + 1];
  }
} //qcril_qmi_util_retrieve_pref_data_tech_name

//===========================================================================
// qmi_ril_nwr_conv_reg_reject_cause_lte
//===========================================================================
int qmi_ril_nwr_conv_reg_reject_cause_lte(uint8_t org_cause)
{
    int res;

    switch( org_cause )
    {
        case 2:   //IMSI unknown in HSS
        case 3:   //Illegal UE
        case 6:   //Illegal ME
        case 9:   //UE identity cannot be derived by the network
        case 10:  //Implicitly detached
        case 5:   //IMEI not accepted
        case 7:   //EPS services not allowed
        case 8:   //EPS services and non-EPS services not allowed
        case 11:  //PLMN not allowed
        case 12:  //Tracking area not allowed
        case 13:  //Roaming not allowed in this tracking area
        case 14:  //EPS services not allowed in this PLMN
        case 15:  //No suitable cells in tracking area
        case 25:  //Not authorized for this CSG
        case 35:  //Requested service option not authorized
        case 40:  //No EPS bearer context activated
        case 16:  //MSC temporarily not reachable
        case 17:  //Network failure
        case 18:  //CS domain not available
        case 19:  //ESM failure
        case 20:  //MAC failure
        case 21:  //Synch failure
        case 22:  //Congestion
        case 23:  //UE security capabilities mismatch
        case 24:  //Security mode rejected, unspecified
        case 26:  //Non-EPS authentication unacceptable
        case 39:  //CS service temporarily not available
        case 95:  //Semantically incorrect message
        case 96:  //Invalid mandatory information
        case 97:  //Message type non-existent or not implemented
        case 98:  //Message type not compatible with protocol state
        case 99:  //Information element non-existent or not implemented
        case 100: //Conditional IE error
        case 101: //Message not compatible with protocol state
        case 111: //Protocol error, unspecified
            res = (int) org_cause;
            break;

        default: // Unspecified failure
            res = 0;
            break;
    }

    return res;
} // qmi_ril_nwr_conv_reg_reject_cause_lte

//===========================================================================
// qmi_ril_nwr_conv_reg_reject_cause_data
//===========================================================================
int qmi_ril_nwr_conv_reg_reject_cause_data(uint8_t org_cause, uint8_t radio_if)
{
    int res;

    if( (!qmi_ril_is_qmi_sys_info_available() && NAS_RADIO_IF_LTE_V01 == radio_if) ||   //checking if radio_if is LTE
        (qmi_ril_is_qmi_sys_info_available() && QMI_RIL_RTE_SUB_LTE == radio_if) )
    {
        res = qmi_ril_nwr_conv_reg_reject_cause_lte( org_cause );
    }
    else
    {
        switch ( org_cause )
        {
          case 2 :  // IMSI Unknown
          case 7 :  // GPRS services not allowed
          case 8 :  // GPRS services and non-GPRS services not allowed
          case 9 :  // MS identity cannot be derived by the network
          case 10:  // Implicitly detached
          case 14:  // GPRS services not allowed in this PLMN
          case 16:  // MSC temporarily not reachable
          case 40:  // No PDP context activated
              res = (int) org_cause;
              break;

          default: // Unspecified failure
              res = 0;
              break;
        }
    }

    return res;
} // qmi_ril_nwr_conv_reg_reject_cause_data


//===========================================================================
// qcril_qmi_nas_util_determine_hdr_rev
//===========================================================================
int qcril_qmi_nas_util_determine_hdr_rev(nas_hdr_only_sys_info_type_v01 * hdr_details_info)
{
    int res = RADIO_TECH_EVDO_0;

    QCRIL_LOG_INFO("hdr_details_info %p", hdr_details_info);
    if ( hdr_details_info )
    {
        QCRIL_LOG_INFO("hdr_personality_valid, hdr_personality %d, %d",
                                 (int) hdr_details_info->hdr_personality_valid,
                                 (int) hdr_details_info->hdr_personality );
        QCRIL_LOG_INFO("hdr_active_prot_valid, hdr_active_prot %d, %d",
                                 (int) hdr_details_info->hdr_active_prot_valid,
                                 (int) hdr_details_info->hdr_active_prot);

        if (( hdr_details_info->hdr_personality_valid ) &&
            (hdr_details_info->hdr_personality == NAS_SYS_PERSONALITY_EHRPD_V01))
        {
            res = RADIO_TECH_EHRPD;
        }
        else if ( hdr_details_info->hdr_active_prot_valid )
        {
            switch (hdr_details_info->hdr_active_prot)
            {
                case NAS_SYS_ACTIVE_PROT_HDR_RELA_V01:
                    res = RADIO_TECH_EVDO_A;
                    break;

                case NAS_SYS_ACTIVE_PROT_HDR_RELB_V01:
                    res = RADIO_TECH_EVDO_B;
                    break;

                default:
                    /* No Action, as default value is already taken care
                       as part of initialization */
                    break;
            }
        }
    }

    return res;
} // qcril_qmi_nas_util_determine_hdr_rev

//===========================================================================
// qcril_qmi_nas_util_determine_cdma_rev
//===========================================================================
int qcril_qmi_nas_util_determine_cdma_rev(nas_cdma_only_sys_info_type_v01 * cdma_details_info)
{
    int res;

    QCRIL_LOG_INFO("cdma_details_info %p", cdma_details_info );
    if ( cdma_details_info )
    {
        QCRIL_LOG_INFO("bs_p_rev_valid, bs_p_rev %d, %d", (int) cdma_details_info->bs_p_rev_valid, (int) cdma_details_info->bs_p_rev  );
        QCRIL_LOG_INFO("p_rev_in_use_valid, p_rev_in_use %d, %d", (int) cdma_details_info->p_rev_in_use_valid, (int) cdma_details_info->p_rev_in_use  );
    }
    if ( cdma_details_info && cdma_details_info->p_rev_in_use_valid )
    {
        res = qcril_qmi_util_determine_cdma_rev_direct( cdma_details_info->p_rev_in_use );
    }
    else
    {
        res = RADIO_TECH_IS95A; // by default
    }

    return res;
} // qcril_qmi_nas_util_determine_cdma_rev
//===========================================================================
// qcril_qmi_util_determine_cdma_rev_direct
//===========================================================================
int qcril_qmi_util_determine_cdma_rev_direct( uint8_t p_rev )
{
    int res;
    if ( p_rev >= 6 )
    {
        res = RADIO_TECH_1xRTT;
    }
    else if ( p_rev >= 4  )
    {
        res = RADIO_TECH_IS95B;
    }
    else
    {
        res = RADIO_TECH_IS95A;
    }
    return res;
} // qcril_qmi_util_determine_cdma_rev_direct

//===========================================================================
// qcril_qmi_util_retrieve_srv_status
//===========================================================================
nas_service_status_enum_type_v01 qcril_qmi_util_retrieve_srv_status(nas_sys_info_helper_type * nas_sys_info_helper, int is_3gpp)
{
    nas_service_status_enum_type_v01 nas_srv_status;

    nas_srv_status = NAS_SYS_SRV_STATUS_NO_SRV_V01;
    if( NULL != nas_sys_info_helper )
    {
        if( is_3gpp )
        {
            if( nas_sys_info_helper->threegpp_srv_status )
            {
                nas_srv_status = nas_sys_info_helper->threegpp_srv_status->srv_status;
            }
            else
            {
                QCRIL_LOG_DEBUG("3gpp srv status info absent");
            }
        }
        else
        {
            if( nas_sys_info_helper->threegpp2_srv_status )
            {
                nas_srv_status = nas_sys_info_helper->threegpp2_srv_status->srv_status;
            }
            else
            {
                QCRIL_LOG_DEBUG("3gpp2 srv status info absent");
            }
        }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED - nas_sys_info_helper is NULL");
    }

    QCRIL_LOG_DEBUG("completed with %d",(int) nas_srv_status);

    return nas_srv_status;
} //qcril_qmi_util_retrieve_srv_status

//===========================================================================
// qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info
//===========================================================================
void qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info( int is_data,
                                                             int * res,
                                                             nas_reg_reject_info_type_v01 * reg_reject_info,
                                                             qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results )
{

    QCRIL_LOG_FUNC_ENTRY();
    if( reg_reject_info )
    {
        if ( is_data )
        { // data
            switch ( reg_reject_info->reject_srv_domain )
            {
                case SYS_SRV_DOMAIN_PS_ONLY_V01:    // fallthrough
                case SYS_SRV_DOMAIN_CS_PS_V01:
                    switch ( reg_reject_info->rej_cause)
                    {
                        case IMSI_UNKNOWN_IN_HLR:
                        case ILLEGAL_MS:
                        case ILLEGAL_ME:
                        case GPRS_SERVICES_NOT_ALLOWED:
                        case GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
                        case PLMN_NOT_ALLOWED:
                        case LA_NOT_ALLOWED:
                        case NATIONAL_ROAMING_NOT_ALLOWED:
                        case GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN:
                        case NO_SUITABLE_CELLS_IN_LA:
                        case CSG_NOT_AUTHORIZED:
                            *res = RIL_VAL_REG_REGISTRATION_DENIED;
                            break;

                        default:
                             //no action
                            break;
                    }

                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        extra_results->is_managed_roaming  = FALSE;
                        extra_results->reject_cause        = reg_reject_info->rej_cause;
                    }
                    break;

                case SYS_SRV_DOMAIN_NO_SRV_V01:
                case SYS_SRV_DOMAIN_CAMPED_V01:
                    // skip for data
                    break;

                default:
                    // no action
                    break;
            }
        }
        else
        { // voice
            switch ( reg_reject_info->reject_srv_domain )
            {
                case SYS_SRV_DOMAIN_CS_ONLY_V01:    // fallthrough
                case SYS_SRV_DOMAIN_CS_PS_V01:
                case SYS_SRV_DOMAIN_NO_SRV_V01:
                case SYS_SRV_DOMAIN_CAMPED_V01:
                    switch ( reg_reject_info->rej_cause)
                    {
                        case IMSI_UNKNOWN_IN_HLR:
                        case ILLEGAL_MS:
                        case ILLEGAL_ME:
                        case GPRS_SERVICES_NOT_ALLOWED:
                        case GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
                        case PLMN_NOT_ALLOWED:
                        case LA_NOT_ALLOWED:
                        case NATIONAL_ROAMING_NOT_ALLOWED:
                        case GPRS_SERVICES_NOT_ALLOWED_IN_THIS_PLMN:
                        case NO_SUITABLE_CELLS_IN_LA:
                        case CSG_NOT_AUTHORIZED:

                             *res = (RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == *res) ? RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV : RIL_VAL_REG_REGISTRATION_DENIED;
                            break;

                        default:
                             //no action
                            break;

                    }
                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        extra_results->is_managed_roaming  = FALSE;
                        extra_results->reject_cause        = reg_reject_info->rej_cause;
                    }
                    break;

                default:
                    // no action
                    break;
            }
        }
    }
    else
    {
        QCRIL_LOG_INFO("reg_reject_info is NULL");
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET( *res );

} // qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info

//===========================================================================
// qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status
//===========================================================================
int qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status( uint32_t nas_sys_info_flag, nas_sys_info_helper_type * nas_sys_info_helper )
{
    int res,is_data,is_3gpp,is_hdr;
    int ignore_srv_domain;

    nas_net_sel_pref_enum_v01 nw_sel_pref;
    nas_service_status_enum_type_v01 nas_srv_status;
    nas_common_sys_info_type_v01 * common_sys_info;
    nas_3gpp_only_sys_info_type_v01 * threegpp_sys_info;
    uint8_t * is_voice_supported_on_lte;
    nas_3gpp_srv_status_info_type_v01 * threegpp_status_info;
    nas_hdr_only_sys_info_type_v01 * hdr_only_sys_info;
    qcril_qmi_nas_srv_status_convertion_extra_results_type * extra_results;

    QCRIL_LOG_FUNC_ENTRY();

    res = RIL_VAL_REG_UNKNOWN;
    ignore_srv_domain = FALSE;

    if( NULL != nas_sys_info_helper )
    {
        is_data = NAS_IS_BIT_SET(nas_sys_info_flag, NAS_SYS_INFO_IS_DATA);
        is_3gpp = NAS_IS_BIT_SET(nas_sys_info_flag, NAS_SYS_INFO_IS_3GPP);
        is_hdr = NAS_IS_BIT_SET(nas_sys_info_flag, NAS_SYS_INFO_IS_HDR);

        nas_srv_status = qcril_qmi_util_retrieve_srv_status(nas_sys_info_helper, is_3gpp);
        common_sys_info = nas_sys_info_helper->common_sys_info;
        threegpp_sys_info = nas_sys_info_helper->threegpp_only_sys_info;
        is_voice_supported_on_lte = nas_sys_info_helper->voice_support_on_lte;
        threegpp_status_info = nas_sys_info_helper->threegpp_srv_status;
        hdr_only_sys_info = nas_sys_info_helper->hdr_only_sys_info;
        extra_results = nas_sys_info_helper->extra_results;


        QCRIL_LOG_INFO("... nas_srv_status %d, is_data %d, is_3gpp %d, is_hdr %d", (int) nas_srv_status, is_data, is_3gpp, is_hdr );

        // 1st run
        switch ( nas_srv_status )
        {
            case NAS_SYS_SRV_STATUS_NO_SRV_V01:
                res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                break;

            case NAS_SYS_SRV_STATUS_LIMITED_V01:            // fallthrough
            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV;
                break;

            case NAS_SYS_SRV_STATUS_SRV_V01:
                if ( NULL == common_sys_info ||
                     ( common_sys_info->roam_status_valid &&
                       ( ( NAS_SYS_ROAM_STATUS_OFF_V01 == common_sys_info->roam_status ) ||
                         ( ( ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_64 == common_sys_info->roam_status ) ||
                             ( (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_65 == common_sys_info->roam_status ) ||
                             ( (common_sys_info->roam_status >= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_76 ) &&
                               (common_sys_info->roam_status <= (nas_roam_status_enum_type_v01)NAS_VAL_ROAMING_HOME_EX_83 )
                              ) ) && nas_common_info.eri_64_home )
                       )
                     )
                   )
                {
                    res = RIL_VAL_REG_REGISTERED_HOME_NET;
                }
                else
                {
                    res = RIL_VAL_REG_REGISTERED_ROAMING;
                }
                break;

            case NAS_SYS_SRV_STATUS_PWR_SAVE_V01:
                res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                break;

            default:
                res = RIL_VAL_REG_UNKNOWN;
                break;
        }

        QCRIL_LOG_INFO("... intermediate res 1 %d, ... common_sys_info %p", (int) res, common_sys_info  );

        // caps check
        if ( NULL != common_sys_info )
        {
            QCRIL_LOG_INFO("... srv_capability_valid, srv_capability %d, %d ... srv_domain_valid, srv_domain %d, %d",
                           (int) common_sys_info->srv_capability_valid,
                           (int) common_sys_info->srv_capability,
                           (int) common_sys_info->srv_domain_valid,
                           (int) common_sys_info->srv_domain );

            if ( RIL_VAL_REG_REGISTERED_HOME_NET == res || RIL_VAL_REG_REGISTERED_ROAMING == res || RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res )
            {
                if ( !is_data )
                { // voice
                    ignore_srv_domain = qcril_qmi_nas_is_ignore_nas_srv_domain(nas_srv_status,
                                                                               common_sys_info->srv_domain_valid,
                                                                               common_sys_info->srv_domain,
                                                                               is_voice_supported_on_lte);
                    if ( NULL != is_voice_supported_on_lte )
                    {
                        QCRIL_LOG_INFO("... is voice supported on lte dyn %d, setting %d", (int) *is_voice_supported_on_lte, (int)nas_common_info.voice_support_on_lte  );
                    }
                    if ( (FALSE == ignore_srv_domain) &&
                         (
                          ( ( common_sys_info->srv_capability_valid &&
                            SYS_SRV_DOMAIN_CS_ONLY_V01 != common_sys_info->srv_capability &&
                            SYS_SRV_DOMAIN_CS_PS_V01 != common_sys_info->srv_capability) &&
                            ! ( (SYS_SRV_DOMAIN_PS_ONLY_V01 == common_sys_info->srv_capability || SYS_SRV_DOMAIN_CS_PS_V01 == common_sys_info->srv_capability )
                                && (( nas_sys_info_flag & NAS_SYS_INFO_IS_LTE ) && ((NULL != is_voice_supported_on_lte &&
                                TRUE == *is_voice_supported_on_lte) || nas_common_info.voice_support_on_lte)))
                          )
                         ||
                          ( ( common_sys_info->srv_domain_valid && SYS_SRV_DOMAIN_CS_ONLY_V01 != common_sys_info->srv_domain &&
                             SYS_SRV_DOMAIN_CS_PS_V01 != common_sys_info->srv_domain &&
                             RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV != res) &&
                            ! ( SYS_SRV_DOMAIN_PS_ONLY_V01 == common_sys_info->srv_domain &&
                                (( nas_sys_info_flag & NAS_SYS_INFO_IS_LTE ) && ((NULL != is_voice_supported_on_lte &&
                                TRUE == *is_voice_supported_on_lte) || nas_common_info.voice_support_on_lte)))
                           )
                         )
                       )
                    {
                        res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                    }
                }
                else
                { // data
                    if ( is_3gpp )
                    {
                        if ( (common_sys_info->srv_capability_valid && common_sys_info->srv_capability != SYS_SRV_DOMAIN_PS_ONLY_V01 && common_sys_info->srv_capability != SYS_SRV_DOMAIN_CS_PS_V01)
                             ||
                             (common_sys_info->srv_domain_valid && common_sys_info->srv_domain != SYS_SRV_DOMAIN_PS_ONLY_V01 && common_sys_info->srv_domain != SYS_SRV_DOMAIN_CS_PS_V01 && RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV != res)
                             )
                        {
                            res = RIL_VAL_REG_NOT_REGISTERED_SEARCHING;
                        }
                    }
                }
            }
        }
        QCRIL_LOG_INFO("... intermediate res 2 %d, ... hdr_only_sys_info %p", (int) res, hdr_only_sys_info  );

        if( is_hdr )
        {
            if( RIL_VAL_REG_REGISTERED_HOME_NET == res || RIL_VAL_REG_REGISTERED_ROAMING == res || RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res )
            {
                if( NULL != hdr_only_sys_info )
                {
                    QCRIL_LOG_INFO("... hdr_active_prot_valid, hdr_personality_valid %d, %d",
                                   (int) hdr_only_sys_info->hdr_active_prot_valid, (int) hdr_only_sys_info->hdr_personality_valid );
                    if( FALSE == hdr_only_sys_info->hdr_active_prot_valid || FALSE == hdr_only_sys_info->hdr_personality_valid )
                    {
                        res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                    }
                }
                else
                {
                    res = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
                }
            }
        }
        QCRIL_LOG_INFO("... intermediate res 3 %d", (int) res  );

        // reg reject check
        if ( NULL != common_sys_info )
        {
            QCRIL_LOG_INFO("... is_sys_forbidden_valid, is_sys_forbidden %d, %d", (int) common_sys_info->is_sys_forbidden_valid, (int) common_sys_info->is_sys_forbidden );
        }
        if ( NULL != threegpp_sys_info )
        {
            QCRIL_LOG_INFO("... reg_reject_info_valid, reg_reject_info.dmn, reg_reject_info.cause %d, %d, %d",
                                (int) threegpp_sys_info->reg_reject_info_valid,
                                (int) threegpp_sys_info->reg_reject_info.reject_srv_domain,
                                (int) threegpp_sys_info->reg_reject_info.rej_cause );
        }
        if ( threegpp_status_info != NULL )
        {
            QCRIL_LOG_INFO("... true srv status %d", (int) threegpp_status_info->true_srv_status);
        }
        if ( is_3gpp )
        {
            if( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == res || RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == res || RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res )
            {
                if ( !is_data &&
                     ( RIL_E_SUCCESS == qcril_qmi_nas_get_nw_selection_mode( &nw_sel_pref ) && NAS_NET_SEL_PREF_MANUAL_V01 == nw_sel_pref && nas_cached_info.nw_select_state == QMI_RIL_NAS_NW_SELECT_NONE ) // manual selection
                     &&
                     NULL != threegpp_status_info // sanity check
                     &&
                     (  // either limited service
                        ( SYS_SRV_STATUS_LIMITED_V01 == threegpp_status_info->true_srv_status )
                        ||
                        ( // or full service on ps only
                         ( SYS_SRV_STATUS_SRV_V01 == threegpp_status_info->true_srv_status || SYS_SRV_STATUS_PWR_SAVE_V01 == threegpp_status_info->true_srv_status )
                         &&
                         ( NULL != common_sys_info &&  SYS_SRV_DOMAIN_PS_ONLY_V01 == common_sys_info->srv_domain )
                        )
                     )
                     &&
                     (TRUE != nas_common_info.do_not_consider_managed_roam)
                    )
                {   // managed roaming
                    res = RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV;
                    if ( extra_results )
                    {
                        extra_results->is_reject_case      = TRUE;
                        extra_results->is_managed_roaming  = TRUE;
                        extra_results->reject_cause        = RIL_VAL_REG_MANAGED_ROAMING_CAUSE; // dedicated cause for managed roaming
                    }
                }
                else
                {   // common reg reject
                    if ( NULL != common_sys_info && common_sys_info->is_sys_forbidden_valid && common_sys_info->is_sys_forbidden )
                    {
                        res = (RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == res) ? RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV : RIL_VAL_REG_REGISTRATION_DENIED;
                        if ( extra_results )
                        {
                            extra_results->is_reject_case      = TRUE;
                            extra_results->is_managed_roaming  = FALSE;
                            extra_results->reject_cause        = NAS_NIL;
                        }
                    }
                    if ( NULL != threegpp_sys_info && threegpp_sys_info->reg_reject_info_valid )
                    {
                        qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info(is_data, &res, &threegpp_sys_info->reg_reject_info, extra_results);
                    }
                }
            }
            else if( RIL_VAL_REG_REGISTERED_HOME_NET == res || RIL_VAL_REG_REGISTERED_ROAMING == res )
            {
                if ( NULL != threegpp_sys_info && threegpp_sys_info->reg_reject_info_valid &&
                     (
                       ( !is_data &&
                          (SYS_SRV_DOMAIN_CS_ONLY_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain ||
                           SYS_SRV_DOMAIN_CS_PS_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain )
                       ) ||
                       ( is_data &&
                          ( SYS_SRV_DOMAIN_CS_PS_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain ||
                            SYS_SRV_DOMAIN_PS_ONLY_V01 == threegpp_sys_info->reg_reject_info.reject_srv_domain )
                       )
                     )
                   )
                {
                    qcril_qmi_nas_util_process_nas_threegpp_reg_reject_info(is_data, &res, &threegpp_sys_info->reg_reject_info, extra_results);
                }
            }
        }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED - nas_sys_info_helper is NULL");
    }

    QCRIL_LOG_INFO("complete with %d", (int) res  );

    return res;
} // qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status

//===========================================================================
// qcril_qmi_nas_is_ignore_nas_srv_domain
//===========================================================================
int qcril_qmi_nas_is_ignore_nas_srv_domain(nas_service_status_enum_type_v01 nas_srv_status,
                                           uint8_t srv_domain_valid,
                                           nas_service_domain_enum_type_v01 srv_domain,
                                           uint8_t *is_voice_supported_on_lte)
{
    int res;
    int cache_srv_domain;
    int start_srv_domain_camped_timer;
    int cancel_srv_domain_camped_timer;

    QCRIL_LOG_FUNC_ENTRY();

    res = FALSE;
    cache_srv_domain = FALSE;
    start_srv_domain_camped_timer = FALSE;
    cancel_srv_domain_camped_timer = FALSE;

    if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer)
    {
        if(TRUE == srv_domain_valid)
        {
            switch(srv_domain)
            {
                case SYS_SRV_DOMAIN_CAMPED_V01:
                    if(NAS_SYS_SRV_STATUS_SRV_V01 == nas_srv_status &&
                       TRUE == nas_common_info.prev_srv_domain_valid &&
                       (SYS_SRV_DOMAIN_CS_ONLY_V01 == nas_common_info.prev_srv_domain ||
                        SYS_SRV_DOMAIN_CS_PS_V01 == nas_common_info.prev_srv_domain)
                       )
                    {
                        start_srv_domain_camped_timer = TRUE;
                        res = TRUE;
                    }
                    break;

                case SYS_SRV_DOMAIN_CS_ONLY_V01:
                case SYS_SRV_DOMAIN_CS_PS_V01:
                    cache_srv_domain = TRUE;
                    cancel_srv_domain_camped_timer = TRUE;
                    break;

                case SYS_SRV_DOMAIN_PS_ONLY_V01:
                    if((NULL != is_voice_supported_on_lte) && (TRUE == *is_voice_supported_on_lte))
                    {
                        srv_domain = SYS_SRV_DOMAIN_CS_PS_V01;
                        cache_srv_domain = TRUE;
                        cancel_srv_domain_camped_timer = TRUE;
                    }
                    break;

                default: //no action
                    break;
            }
        }

        if(TRUE == cache_srv_domain)
        {
            nas_common_info.prev_srv_domain_valid = TRUE;
            nas_common_info.prev_srv_domain = srv_domain;
        }

        if (TRUE == start_srv_domain_camped_timer)
        {
            qcril_qmi_nas_start_srv_domain_camped_timer();
        }

        if(TRUE == cancel_srv_domain_camped_timer)
        {
            qcril_qmi_nas_cancel_srv_domain_camped_timer();
        }
    }

    QCRIL_LOG_INFO("completed with %d",res);
    return res;
} //qcril_qmi_nas_is_ignore_nas_srv_domain

//===========================================================================
// qcril_qmi_nas_start_srv_domain_camped_timer
//===========================================================================
void qcril_qmi_nas_start_srv_domain_camped_timer()
{
   struct timeval ignore_srv_domain_camped_timeout;

   QCRIL_LOG_FUNC_ENTRY();

   ignore_srv_domain_camped_timeout.tv_sec = nas_common_info.ignore_srv_domain_camped_timer;
   ignore_srv_domain_camped_timeout.tv_usec = NAS_NIL;

   if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer &&
      FALSE == nas_common_info.ignore_srv_domain_camped_timer_id_valid)
   {
       qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb,
                                   &ignore_srv_domain_camped_timeout,
                                   &nas_common_info.ignore_srv_domain_camped_timer_id);
       nas_common_info.ignore_srv_domain_camped_timer_id_valid = TRUE;
       QCRIL_LOG_INFO("ignore_srv_domain_camped_timer started");
   }

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_start_srv_domain_camped_timer


//===========================================================================
// qcril_qmi_nas_cancel_srv_domain_camped_timer
//===========================================================================
void qcril_qmi_nas_cancel_srv_domain_camped_timer()
{
   QCRIL_LOG_FUNC_ENTRY();

   if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer &&
      TRUE == nas_common_info.ignore_srv_domain_camped_timer_id_valid)
   {
       qcril_cancel_timed_callback((void *)(uintptr_t)nas_common_info.ignore_srv_domain_camped_timer_id);
       nas_common_info.ignore_srv_domain_camped_timer_id_valid = FALSE;
       nas_common_info.ignore_srv_domain_camped_timer_id = NAS_NIL;
       QCRIL_LOG_INFO("ignore_srv_domain_camped_timer cancelled");
   }

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_cancel_srv_domain_camped_timer

//===========================================================================
// qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb
//===========================================================================
void qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb(void * params)
{
   int action_needed;
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(params);

   action_needed = FALSE;

   NAS_CACHE_LOCK();
   if(NAS_NIL != nas_common_info.ignore_srv_domain_camped_timer)
   {
       QCRIL_LOG_INFO("ignore_srv_domain_camped_timer timed out, prev srv domain valid %d, value %d",
                      nas_common_info.prev_srv_domain_valid,
                      nas_common_info.prev_srv_domain);
       nas_common_info.ignore_srv_domain_camped_timer_id_valid = FALSE;
       nas_common_info.ignore_srv_domain_camped_timer_id = NAS_NIL;
       nas_common_info.prev_srv_domain_valid = FALSE;
       nas_common_info.prev_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;
       action_needed = TRUE;
   }
   NAS_CACHE_UNLOCK();

   if(TRUE == action_needed)
   {
       qcril_qmi_nas_wave_voice_data_status();
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_ignore_srv_domain_camped_timeout_cb

//===========================================================================
// qcril_qmi_nas_cancel_srv_domain_camped_timer_helper
//===========================================================================
void qcril_qmi_nas_cancel_srv_domain_camped_timer_helper()
{
   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();
   qcril_qmi_nas_cancel_srv_domain_camped_timer();
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_cancel_srv_domain_camped_timer_helper

//===========================================================================
// qcril_qmi_nas_is_mcc_mnc_info_available
//===========================================================================
static int qcril_qmi_nas_is_mcc_mnc_info_available()
{
    int res = FALSE;
    int is_now_registered;

    QCRIL_LOG_FUNC_ENTRY();

    is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
    QCRIL_LOG_INFO( ".. is registered %d", is_now_registered );
    if( is_now_registered )
    {
        if( !qmi_ril_is_qmi_sys_info_available() )
        {
            if( qcril_qmi_nas_is_in_service_of_technology(NAS_SELECTED_NETWORK_3GPP_V01) && (TRUE == NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mnc_includes_pcs_digit)) )
            {
                QCRIL_LOG_INFO("checking serving_system_ind");
                res = TRUE;
            }
        }
        else
        {
            if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.gsm_sys_info))
                && (TRUE == nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id_valid)))
            {
                QCRIL_LOG_INFO("checking sys_info_ind - GSM");
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.wcdma_sys_info))
                && (TRUE == nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id_valid)))
            {
                QCRIL_LOG_INFO("checking sys_info_ind - WCDMA");
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.tdscdma_sys_info))
                && (TRUE == nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id_valid)))
            {
                QCRIL_LOG_INFO("checking sys_info_ind - TDSCDMA");
                res = TRUE;
            }
            else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE) && ((TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sys_info))
                && (TRUE == nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id_valid)))
            {
                QCRIL_LOG_INFO("checking sys_info_ind - LTE");
                res = TRUE;
            }
        }
    }

    QCRIL_LOG_INFO("completed with %d",res);

    return res;
} //qcril_qmi_nas_is_mcc_mnc_info_available

//===========================================================================
// qcril_qmi_nas_fetch_system_info_helper
//===========================================================================
static RIL_Errno qcril_qmi_nas_fetch_system_info_helper()
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    if( !qmi_ril_is_qmi_sys_info_available() )
    {
        res = qcril_qmi_nas_fetch_serving_system_info();
    }
    else
    {
        res = qcril_qmi_nas_fetch_sys_info();
    }

    QCRIL_LOG_INFO("completed with %d",res);

    return res;
} //qcril_qmi_nas_fetch_system_info_helper

//===========================================================================
// RIL_REQUEST_OPERATOR
//===========================================================================
void qcril_qmi_nas_request_operator
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_request_resp_params_type resp;

  qcril_qmi_operator_resp_helper_type ril_resp_helper;

  int           everything_cached;

  nas_get_operator_name_data_resp_msg_v01 * qmi_response = NULL;

  qmi_client_error_type qmi_client_error = QMI_NO_ERR;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_plmn_network_name_type_v01* plmn_nw_name_ptr;

  char * op_name_short;
  char * op_name_long;

  char * mccmnc_param_str;
  int mcc;

  char log_buf[ NAS_OPERATOR_RESP_MAX_EONS_LEN ];

  char mcc_str[NAS_MCC_MNC_MAX_SIZE];
  char mnc_str[NAS_MCC_MNC_MAX_SIZE];
  int hlp;
  int dig;
  int pwr;
  int idx;
  char mcc_3gpp2_str[NAS_3GPP2_MCC_MAX_SIZE];
  char mnc_3gpp2_str[NAS_MCC_MNC_MAX_SIZE];
  uint16_t sid_3gpp2,nid_3gpp2;
  int used_nam_name_len;

  nas_radio_if_enum_v01 plmn_rat = NAS_RADIO_IF_NO_SVC_V01;

  nas_get_3gpp2_subscription_info_req_msg_v01 cdma_subscription_info_req;
  nas_get_3gpp2_subscription_info_resp_msg_v01 cdma_subscription_info_resp;
  int res;

  int is_now_registered;
  int is_service_in_3gpp;
  int is_service_in_3gpp2;

  int is_spn_present;
  int is_plmn_name_present;
  int prefer_spn;

  uint8_t csg_id_valid;
  uint32_t csg_id;

  // ** response holder init

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );
  NAS_CACHE_LOCK();

  memset( &ril_resp_helper, 0, sizeof( ril_resp_helper ) );
  memset( mcc_str, 0, sizeof( mcc_str ) );
  memset( mnc_str, 0, sizeof( mnc_str ) );
  memset( mcc_3gpp2_str, 0, sizeof( mcc_3gpp2_str ) );
  memset( mnc_3gpp2_str, 0, sizeof( mnc_3gpp2_str ) );
  memset( log_buf, 0, sizeof( log_buf ) );

  NAS_CACHE_LOCK();
  is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
  NAS_CACHE_UNLOCK();
  QCRIL_LOG_INFO("now registered %d", (int)is_now_registered);

  if ( is_now_registered )
  {
      ril_resp_helper.operator_info_array[ 0 ] = ril_resp_helper.long_eons;
      ril_resp_helper.operator_info_array[ 1 ] = ril_resp_helper.short_eons;
      ril_resp_helper.operator_info_array[ 2 ] = ril_resp_helper.mcc_mnc_ascii;

      NAS_CACHE_LOCK();
      is_service_in_3gpp = qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP_V01);
      is_service_in_3gpp2 = qcril_qmi_nas_is_in_service_of_technology (NAS_SELECTED_NETWORK_3GPP2_V01);
      NAS_CACHE_UNLOCK();
      if ( is_service_in_3gpp )
      {
          if( FALSE == qcril_qmi_nas_is_centralized_eons_supported() && FALSE == qmi_ril_is_feature_supported(QMI_RIL_FEATURE_8960) )
          {
              // 3gpp
              // ** update cache if necessary
              NAS_CACHE_LOCK();
              everything_cached =   ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) );
              NAS_CACHE_UNLOCK();

              QCRIL_LOG_INFO("everything cached 1 %d", (int)everything_cached);

              if ( !everything_cached )
              {
                  qmi_response = qcril_malloc( sizeof( *qmi_response ) );
                  if ( qmi_response )
                  {

                      qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                 QMI_NAS_GET_OPERATOR_NAME_DATA_REQ_MSG_V01,
                                                                 NULL,
                                                                 NAS_NIL,  // empty request payload
                                                                 (void*) qmi_response,
                                                                 sizeof( *qmi_response ),
                                                                 QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

                      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &qmi_response->resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

                      QCRIL_LOG_INFO("cache subfetch op name data %d, %d, %d", (int)qmi_client_error, (int) ril_req_res, qmi_response->resp.error );

                      if ( RIL_E_SUCCESS == ril_req_res )
                      {
                          NAS_CACHE_LOCK();
                          NAS_CACHE_STORE_ENTRY( nas_cached_info.nitz_information,  qmi_response->nitz_information );
                          qcril_qmi_nas_nitz_persistent_cache_update();
                          NAS_CACHE_UNLOCK();
                      }

                      qcril_free( qmi_response );
                  }
              }

              NAS_CACHE_LOCK();
              everything_cached =   ( TRUE == qcril_qmi_nas_is_mcc_mnc_info_available() );
              NAS_CACHE_UNLOCK();
              if( !everything_cached )
              {
                  ril_req_res = qcril_qmi_nas_fetch_serving_system_info();
              }

              ril_req_res = RIL_E_SUCCESS;
              // ** form answer
              if ( RIL_E_SUCCESS == ril_req_res )
              {
                    NAS_CACHE_LOCK();

                    QCRIL_LOG_INFO("..nitz_information valid %d", (int) NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.nitz_information) );
                    QCRIL_LOG_INFO("..mnc_includes_pcs_digit valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mnc_includes_pcs_digit ) );

                    *ril_resp_helper.long_eons        = NAS_NIL;
                    *ril_resp_helper.short_eons       = NAS_NIL;
                    *ril_resp_helper.mcc_mnc_ascii    = NAS_NIL;

                    if( qcril_qmi_nas_find_current_mcc_mnc(mcc_str, mnc_str, TRUE, NULL) )
                    {
                        snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );
                        QCRIL_LOG_INFO("..mcc_mnc_ascii %s", ril_resp_helper.mcc_mnc_ascii);

                        qcril_qmi_nas_fill_up_operator_name(TRUE,
                                                            mcc_str,
                                                            mnc_str,
                                                            ril_resp_helper.mcc_mnc_ascii,
                                                            ril_resp_helper.long_eons,
                                                            sizeof(ril_resp_helper.long_eons),
                                                            ril_resp_helper.short_eons,
                                                            sizeof(ril_resp_helper.short_eons) );
                    }
                    else
                    {
                        ril_req_res = RIL_E_GENERIC_FAILURE;
                    }

                    NAS_CACHE_UNLOCK();
              }
          }
          else
          {
              *ril_resp_helper.long_eons        = NAS_NIL;
              *ril_resp_helper.short_eons       = NAS_NIL;
              *ril_resp_helper.mcc_mnc_ascii    = NAS_NIL;

              NAS_CACHE_LOCK();
              QCRIL_LOG_INFO( "plmn_id cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id ) );
              QCRIL_LOG_INFO( "spn cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn ) );
              QCRIL_LOG_INFO( "short_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) );
              QCRIL_LOG_INFO( "long_name cached %d",  NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) );

              everything_cached = (
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id )    &&
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn )        &&
                 !is_operator_name_empty_or_white_space( (char *) nas_cached_info.spn->spn, NAS_SPN_LEN_MAX_V01 )&&
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) &&
                 !is_operator_name_empty_or_white_space( (char *) nas_cached_info.short_name->plmn_name, NAS_PLMN_NAME_MAX_V01 ) &&
                 NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name )  &&
                 !is_operator_name_empty_or_white_space( (char *) nas_cached_info.long_name->plmn_name, NAS_PLMN_NAME_MAX_V01 )
                                   );
              NAS_CACHE_UNLOCK();


              if( TRUE == everything_cached &&
                         ((!qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) &&
                         !qcril_qmi_nas_is_sglte3()) ||
                          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ))) //On SGLTE we can have CURRENT_PLMN_NAME_IND from both msm and qsc
              {                                                                                         //thus restricting us from running the logic of choosing the right plmn based
                  NAS_CACHE_LOCK();                                                                     //on persist.radio.sglte.eons_domain and persist.radio.sglte.eons_roam
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.plmn_id ) )
                  {
                      snprintf( mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", nas_cached_info.plmn_id->mcc );
                      if ( nas_cached_info.plmn_id->mnc > 99 || TRUE == nas_cached_info.plmn_id->mnc_includes_pcs_digit )
                      {
                          snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int) nas_cached_info.plmn_id->mnc );
                      }
                      else
                      {
                          snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int) nas_cached_info.plmn_id->mnc );
                      }
                  }
                  snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );

                  is_spn_present = (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.spn ) && nas_cached_info.spn->spn_len > NAS_NIL);
                  is_plmn_name_present = ((NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) && nas_cached_info.short_name->plmn_name_len > NAS_NIL) || (NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) && nas_cached_info.long_name->plmn_name_len > NAS_NIL));
                  prefer_spn = qcril_qmi_util_prefer_spn_over_plmn_name(is_spn_present, is_plmn_name_present, FALSE);
                  if( TRUE == prefer_spn )
                  {
                      if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == nas_cached_info.spn->spn_enc )
                      {
                          qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)nas_cached_info.spn->spn,
                                                                            nas_cached_info.spn->spn_len,
                                                                            ril_resp_helper.short_eons );
                          qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char *)nas_cached_info.spn->spn,
                                                                            nas_cached_info.spn->spn_len,
                                                                            ril_resp_helper.long_eons );
                          QCRIL_LOG_INFO("spn is 7-bit Unpacked data");
                      }
                      else
                      {
                          qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.short_eons,
                                                              NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                              nas_cached_info.spn->spn_enc,
                                                              nas_cached_info.spn->spn,
                                                              nas_cached_info.spn->spn_len);

                          qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.long_eons,
                                                              NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                              nas_cached_info.spn->spn_enc,
                                                              nas_cached_info.spn->spn,
                                                              nas_cached_info.spn->spn_len);
                      }
                      QCRIL_LOG_INFO("short eons derived from spn %s",ril_resp_helper.short_eons);
                      QCRIL_LOG_INFO("long eons derived from spn %s",ril_resp_helper.long_eons);
                  }
                  else
                  {
                    if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.short_name ) )
                    {
                        if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == nas_cached_info.short_name->plmn_name_enc )
                        {
                            qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)nas_cached_info.short_name->plmn_name,
                                                                              nas_cached_info.short_name->plmn_name_len,
                                                                              ril_resp_helper.short_eons );
                            QCRIL_LOG_INFO("plmn short name is 7-bit Unpacked data");
                        }
                        else
                        {
                            qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.short_eons,
                                                                NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                                nas_cached_info.short_name->plmn_name_enc,
                                                                nas_cached_info.short_name->plmn_name,
                                                                nas_cached_info.short_name->plmn_name_len);
                        }
                        QCRIL_LOG_INFO("short eons derived from plmn %s",ril_resp_helper.short_eons);
                    }

                    if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.long_name ) )
                    {
                        if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == nas_cached_info.long_name->plmn_name_enc )
                        {
                            qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)nas_cached_info.long_name->plmn_name,
                                                                              nas_cached_info.long_name->plmn_name_len,
                                                                              ril_resp_helper.long_eons );
                            QCRIL_LOG_INFO("plmn long name is 7-bit Unpacked data");
                        }
                        else
                        {
                            qcril_qmi_util_decode_operator_name_in_little_endian(ril_resp_helper.long_eons,
                                                                NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                                nas_cached_info.long_name->plmn_name_enc,
                                                                nas_cached_info.long_name->plmn_name,
                                                                nas_cached_info.long_name->plmn_name_len);
                        }
                        QCRIL_LOG_INFO("long eons derived from plmn %s",ril_resp_helper.long_eons);
                    }
                  }
                  NAS_CACHE_UNLOCK();
              }
              else
              {
                  NAS_CACHE_LOCK();
                  everything_cached =   ( TRUE == qcril_qmi_nas_is_mcc_mnc_info_available() );
                  NAS_CACHE_UNLOCK();
                  if( FALSE == everything_cached )
                  {
                      qcril_qmi_nas_fetch_sys_info();
                  }

                  NAS_CACHE_LOCK();
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..gsm network id valid %d", nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..wcdma network id valid %d", nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..tdscdma network id valid %d", nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }
                  if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                  {
                      QCRIL_LOG_INFO("..lte network id valid %d", nas_cached_info.lte_sys_info->threegpp_specific_sys_info.network_id_valid);
                  }

                  res = qcril_qmi_nas_find_current_mcc_mnc(mcc_str, mnc_str, TRUE, &plmn_rat);

                  csg_id_valid = FALSE;
                  csg_id = 0;

                  if(nas_common_info.csg_info_available)
                  {
                      if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_csg_info ) )
                      {
                          csg_id_valid = nas_cached_info.wcdma_csg_info_valid;
                          csg_id = nas_cached_info.wcdma_csg_info->id;
                      }
                      else if( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_csg_info ) )
                      {
                          csg_id_valid = nas_cached_info.lte_csg_info_valid;
                          csg_id = nas_cached_info.lte_csg_info->id;
                      }
                  }

                  NAS_CACHE_UNLOCK();

                  if( res )
                  {
                      snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );
                      qcril_qmi_util_handle_centralized_short_long_eons(mcc_str,
                                                                        mnc_str,
                                                                        ril_resp_helper.short_eons,
                                                                        ril_resp_helper.long_eons,
                                                                        FALSE, plmn_rat,
                                                                        csg_id_valid, csg_id );
                  }
                  else
                  {
                      ril_req_res = RIL_E_GENERIC_FAILURE;
                  }
              }
          }

          if ( *ril_resp_helper.long_eons && !*ril_resp_helper.short_eons && TRUE == nas_common_info.fill_eons)
          {
              QCRIL_LOG_INFO("Filling short eons with long eons");
              strlcpy( ril_resp_helper.short_eons, ril_resp_helper.long_eons , sizeof(ril_resp_helper.short_eons));
          }

          if ( *ril_resp_helper.short_eons && !*ril_resp_helper.long_eons && TRUE == nas_common_info.fill_eons)
          {
              QCRIL_LOG_INFO("Filling long eons with short eons");
              strlcpy( ril_resp_helper.long_eons, ril_resp_helper.short_eons , sizeof(ril_resp_helper.long_eons));
          }
      }
      else if ( is_service_in_3gpp2 )
      { // 3gpp2
            // get MCC / MNC
            memset(mcc_3gpp2_str,0,sizeof(mcc_3gpp2_str));
            memset(mnc_3gpp2_str,0,sizeof(mnc_3gpp2_str));
            sid_3gpp2 = 0;
            nid_3gpp2 = 0;
            if ( !qmi_ril_is_qmi_sys_info_available() )
            { // legacy
                NAS_CACHE_LOCK();
                everything_cached =   ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id_ext ) && NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.cdma_system_id) );
                NAS_CACHE_UNLOCK();

                QCRIL_LOG_INFO(".. everything cached non sys_info %d", (int)everything_cached);
                if ( !everything_cached )
                {
                    ril_req_res = qcril_qmi_nas_fetch_serving_system_info();
                }
                else
                {
                    ril_req_res = RIL_E_SUCCESS;
                }

                if ( RIL_E_SUCCESS == ril_req_res )
                {
                    NAS_CACHE_LOCK();
                    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id_ext ) )
                    {
                        if ( nas_cached_info.cdma_system_id_ext.mcc >= 1023 )
                        {
                            mcc = 1023;
                        }
                        else
                        {
                            mcc = 0;
                            hlp = nas_cached_info.cdma_system_id_ext.mcc + 111;
                            pwr = 1;

                            for( idx = 0; idx < 3; idx++ )
                            {
                            dig = hlp % 10;
                            mcc += (pwr * dig);

                            if (dig == 0)
                            {
                              hlp -= 10;
                            }
                            hlp /= 10;
                            pwr *= 10;
                            }
                        }

                        if ( 1023 == mcc )
                        {
                          snprintf( mcc_3gpp2_str, NAS_3GPP2_MCC_MAX_SIZE, "%04d", mcc);
                        }
                        else
                        {
                          snprintf( mcc_3gpp2_str, NAS_3GPP2_MCC_MAX_SIZE, "%03d", mcc);
                        }
                        qcril_qmi_util_convert_3gpp2_mnc_to_ascii_mnc(mnc_3gpp2_str, nas_cached_info.cdma_system_id_ext.imsi_11_12);

                        snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_3gpp2_str, mnc_3gpp2_str );
                        QCRIL_LOG_INFO("..mcc_mnc_ascii %s", ril_resp_helper.mcc_mnc_ascii);
                    }

                    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_system_id ) )
                    {
                        sid_3gpp2 = nas_cached_info.cdma_system_id->sid;
                        nid_3gpp2 = nas_cached_info.cdma_system_id->nid;
                    }
                    NAS_CACHE_UNLOCK();
                }
            }
            else
            { // sys_info
                ril_req_res = qcril_qmi_nas_fetch_sys_info();
                if ( RIL_E_SUCCESS == ril_req_res )
                {
                  NAS_CACHE_LOCK();
                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) && nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id_valid )
                  {
                    if( TRUE == qcril_qmi_nas_is_mcc_mnc_wildcard_entry(nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc,
                                                                        nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc) )
                    {
                        qcril_qmi_nas_fillup_wildcard_mcc_mnc_helper(mcc_3gpp2_str, mnc_3gpp2_str);
                    }
                    else
                    {
                      qcril_qmi_nas_fillup_mcc_mnc_helper( nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mcc, mcc_3gpp2_str);
                      qcril_qmi_nas_fillup_mcc_mnc_helper( nas_cached_info.cdma_sys_info->cdma_specific_sys_info.network_id.mnc, mnc_3gpp2_str);
                    }
                    snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_3gpp2_str, mnc_3gpp2_str );
                    QCRIL_LOG_INFO("..mcc_mnc_ascii %s", ril_resp_helper.mcc_mnc_ascii);
                  }

                  if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) && nas_cached_info.cdma_sys_info->cdma_specific_sys_info.cdma_sys_id_valid )
                  {
                      sid_3gpp2 = nas_cached_info.cdma_sys_info->cdma_specific_sys_info.cdma_sys_id.sid;
                      nid_3gpp2 = nas_cached_info.cdma_sys_info->cdma_specific_sys_info.cdma_sys_id.nid;
                  }
                  NAS_CACHE_UNLOCK();
                }
            }

            res = qcril_qmi_nas_fill_up_3gpp2_operator_name(mcc_3gpp2_str,
                                                            mnc_3gpp2_str,
                                                            sid_3gpp2,
                                                            nid_3gpp2,
                                                            ril_resp_helper.long_eons,
                                                            sizeof(ril_resp_helper.long_eons),
                                                            ril_resp_helper.short_eons,
                                                            sizeof(ril_resp_helper.short_eons) );

            if( RIL_E_SUCCESS != ril_req_res || FALSE == res )
            {

                //fetch nam_name (for filling the long_eons) by sending QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_REQ_MSG_V01
                ril_req_res = RIL_E_GENERIC_FAILURE;
                memset(&cdma_subscription_info_req,0,sizeof(cdma_subscription_info_req));

                cdma_subscription_info_req.nam_id = 0xFF; // current NAM
                cdma_subscription_info_req.get_3gpp2_info_mask_valid = TRUE;
                cdma_subscription_info_req.get_3gpp2_info_mask = QMI_NAS_GET_3GPP2_SUBS_INFO_NAM_NAME_V01;

                qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_REQ_MSG_V01,
                                                           (void*) &cdma_subscription_info_req,
                                                           sizeof( cdma_subscription_info_req ),
                                                           (void*) &cdma_subscription_info_resp,
                                                           sizeof( cdma_subscription_info_resp ),
                                                           QCRIL_QMI_NAS_GET_3GPP2_INFO_SYNC_TIMEOUT );

                ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &cdma_subscription_info_resp.resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

                QCRIL_LOG_INFO("qmi_client_error: %d, ril_req_res: %d, cdma_subscription_info_resp.resp.error: %d",
                                 (int)qmi_client_error, (int) ril_req_res, cdma_subscription_info_resp.resp.error );


                if( RIL_E_SUCCESS == ril_req_res )
                {
                    QCRIL_LOG_INFO("nam name valid %d, len %d", (int)cdma_subscription_info_resp.nam_name_valid, (int) cdma_subscription_info_resp.nam_name_len);
                    if ( cdma_subscription_info_resp.nam_name_valid )
                    {
                      used_nam_name_len = MIN(cdma_subscription_info_resp.nam_name_len,
                                              MIN(NAS_MAX_NAM_NAME_LEN_V01,
                                                  (NAS_OPERATOR_RESP_MAX_EONS_LEN-1) )
                                             );
                      QCRIL_LOG_INFO(".. used_nam_name_len %d", (int)cdma_subscription_info_resp.nam_name_len );
                      memcpy(ril_resp_helper.long_eons, cdma_subscription_info_resp.nam_name, used_nam_name_len );
                      ril_resp_helper.long_eons[ used_nam_name_len ]  = 0;
                      QCRIL_LOG_INFO(".. nam %s", ril_resp_helper.long_eons );
                    }
                }

                if ( *ril_resp_helper.long_eons && !*ril_resp_helper.short_eons && TRUE == nas_common_info.fill_eons)
                {
                    QCRIL_LOG_INFO("Filling short eons with long eons");
                    strlcpy( ril_resp_helper.short_eons, ril_resp_helper.long_eons , sizeof(ril_resp_helper.short_eons));
                }

                if ( *ril_resp_helper.short_eons && !*ril_resp_helper.long_eons && TRUE == nas_common_info.fill_eons)
                {
                    QCRIL_LOG_INFO("Filling long eons with short eons");
                    strlcpy( ril_resp_helper.long_eons, ril_resp_helper.short_eons , sizeof(ril_resp_helper.long_eons));
                }

                if ( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_CDMA2000 ) &&  (!*ril_resp_helper.long_eons) )
                {
                    strlcpy(ril_resp_helper.long_eons, ril_resp_helper.mcc_mnc_ascii , sizeof(ril_resp_helper.long_eons));
                }
            }
      }
      else
      { // No Service
          ril_resp_helper.operator_info_array[ 0 ] = NULL;
          ril_resp_helper.operator_info_array[ 1 ] = NULL;
          ril_resp_helper.operator_info_array[ 2 ] = NULL;
      }

      QCRIL_LOG_INFO(".. res long %s", ril_resp_helper.long_eons);
      QCRIL_LOG_INFO(".. res short %s", ril_resp_helper.short_eons);
      QCRIL_LOG_INFO(".. res mcc_mnc %s", ril_resp_helper.mcc_mnc_ascii);
  }
  else if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) &&
              (nas_cached_info.gsm_srv_status_info->srv_status == NAS_SYS_SRV_STATUS_LIMITED_V01) &&
              NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
              NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id ) &&
              (nas_common_info.ct_operator_name ))
  {
    ril_resp_helper.operator_info_array[ 0 ] = ril_resp_helper.long_eons;
    ril_resp_helper.operator_info_array[ 1 ] = ril_resp_helper.short_eons;
    ril_resp_helper.operator_info_array[ 2 ] = ril_resp_helper.mcc_mnc_ascii;
    *ril_resp_helper.long_eons        = NAS_NIL;
    *ril_resp_helper.short_eons       = NAS_NIL;
    *ril_resp_helper.mcc_mnc_ascii    = NAS_NIL;
    snprintf( mcc_str, NAS_MCC_MNC_MAX_SIZE, "%c%c%c",
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc[0],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc[1],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mcc[2] );

    if ( nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[2] != 0xFF )
    {
      snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%c%c%c",
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[0],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[1],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[2] );
    }
    else
    {
      snprintf( mnc_str, NAS_MCC_MNC_MAX_SIZE, "%c%c",
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[0],
            nas_cached_info.gsm_sys_info->threegpp_specific_sys_info.network_id.mnc[1]);
    }
    snprintf( ril_resp_helper.mcc_mnc_ascii, sizeof(ril_resp_helper.mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );
    QCRIL_LOG_INFO("..mcc_mnc_ascii %s", ril_resp_helper.mcc_mnc_ascii);
    qcril_qmi_nas_fill_up_operator_name(TRUE,
                                        mcc_str,
                                        mnc_str,
                                        ril_resp_helper.mcc_mnc_ascii,
                                        ril_resp_helper.long_eons,
                                        sizeof(ril_resp_helper.long_eons),
                                        ril_resp_helper.short_eons,
                                        sizeof(ril_resp_helper.short_eons) );
    QCRIL_LOG_INFO(".. long_eons %s, short_eons %s", ril_resp_helper.long_eons, ril_resp_helper.short_eons);
  }
  else
  {
      QCRIL_LOG_INFO(".. res empty as not in full service");
  }

  NAS_CACHE_UNLOCK();
  // ** respond
  ril_req_res = RIL_E_SUCCESS;  // should always return success for request_operator
  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );

  resp.resp_pkt = (void *) ril_resp_helper.operator_info_array;
  resp.resp_len = sizeof( ril_resp_helper.operator_info_array  );
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO("complete with %d", (int) ril_req_res  );
} // qcril_qmi_nas_request_operator

//=========================================================================
// qcril_qmi_util_convert_3gpp2_mnc_to_ascii_mnc
//===========================================================================
void qcril_qmi_util_convert_3gpp2_mnc_to_ascii_mnc( char *mnc_3gpp2, uint8_t imsi_11_12)
{
  unsigned int d1, d2, buf = imsi_11_12 + 11;

  QCRIL_LOG_FUNC_ENTRY();

  if( mnc_3gpp2 )
  {
    memset(mnc_3gpp2, 0, NAS_MCC_MNC_MAX_SIZE);
    if ( imsi_11_12 == 0x7F ) // wildcard
    {
      strlcpy(mnc_3gpp2,NAS_PLACEHOLDER_MNC_STR,NAS_MCC_MNC_MAX_SIZE);
    }
    else
    {
      d2 = buf % 10;
      buf = ( d2 == 0 ) ? (buf-10)/10 : buf/10;

      d1 = ( buf == 10 ) ? 0 : buf;

      if ( d1<10 && d2<10 )
      {
       mnc_3gpp2[0] = '0' + d1;
       mnc_3gpp2[1] = '0' + d2;
      }
      else
      {
        QCRIL_LOG_INFO("Invalid MNC");
      }
    }

    QCRIL_LOG_INFO("mnc %s, imsi_11_12 %d", mnc_3gpp2,imsi_11_12);
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_util_convert_3gpp2_mnc_to_ascii_mnc

//==========================================================================================
// qcril_qmi_util_is_plmn_already_added_to_nw_scan_results

// returns TRUE if passed plmn (mcc_str-mnc_str) is already part of nw scan results
//============================================================================================
int qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, qcril_qmi_nw_scan_resp_helper_type  * unique_network_scan_plmns_table, int no_of_unique_network_scan_plmns)
{
    int ret = FALSE;
    int iter_i;
    char plmn_str[NAS_NW_SCAN_RESP_MCCMNC_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    if( mcc_str && mnc_str && unique_network_scan_plmns_table )
    {
        snprintf( plmn_str, sizeof(plmn_str), "%s%s", mcc_str,mnc_str);
        QCRIL_LOG_INFO("checking plmn %s is unique or not",plmn_str);

        for( iter_i = 0; iter_i < no_of_unique_network_scan_plmns; iter_i++ )
        {
            // Compare plmn, short and long eons to identify same plmn with different RAT
            if( (!strcmp(plmn_str, (char*) unique_network_scan_plmns_table->mccmnc_info[iter_i])) && (!strcmp(short_eons, (char*) unique_network_scan_plmns_table->short_eons[iter_i])) && (!strcmp(long_eons, (char*) unique_network_scan_plmns_table->long_eons[iter_i])) ) //identical plmn is already present in the network scan results (RAT might be different)
            {
                ret = TRUE;
                break;
            }

        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_util_is_plmn_already_added_to_nw_scan_results

//=========================================================================
// qcril_qmi_util_prefer_spn_over_plmn_name
//===========================================================================
int qcril_qmi_util_prefer_spn_over_plmn_name(int is_spn_present, int is_plmn_name_present, int is_nw_scan)
{
    int ret = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO("is_nw_scan %d", is_nw_scan);
    QCRIL_LOG_INFO("spn_plmn_name_preference %d", nas_common_info.prefer_spn_over_plmn_name);

    if( is_spn_present )
    {
        QCRIL_LOG_INFO("spn is present");
        ret = TRUE;
    }

    if( is_plmn_name_present )
    {
        QCRIL_LOG_INFO("plmn_name is present");
        switch( nas_common_info.prefer_spn_over_plmn_name )
        {
            case QMI_RIL_NAS_DO_NOT_PREFER_SPN: //when both spn and plmn_name are present, prefer plmn_name over spn by default
                ret = FALSE;
                break;

            case QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_NAME_ONLY: //prefer spn for operator process only
                if( TRUE == is_nw_scan )
                {
                    ret = FALSE;
                }
                break;

            case QMI_RIL_NAS_PREFER_SPN_FOR_NW_SCAN_ONLY: //prefer spn for nw_scan process only
                if( FALSE == is_nw_scan )
                {
                    ret = FALSE;
                }
                break;

            case QMI_RIL_NAS_PREFER_SPN_FOR_OPERATOR_AND_NW_SCAN: //prefer spn for both nw_scan and operator processes If spn is present
            default:
                break;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);

    return ret;
} //qcril_qmi_util_prefer_spn_over_plmn_name

//=========================================================================
// qcril_qmi_util_handle_centralized_short_long_eons
//===========================================================================
void qcril_qmi_util_handle_centralized_short_long_eons(char *mcc_str, char *mnc_str, char *short_eons, char *long_eons, int is_nw_scan, nas_radio_if_enum_v01 plmn_rat, uint8_t csg_id_valid, uint32_t csg_id)
{
  char mcc_mnc_ascii[NAS_OPERATOR_RESP_MAX_EONS_LEN];

  char * internal_long_name;
  char * internal_short_name;

  QCRIL_LOG_FUNC_ENTRY();

  memset( mcc_mnc_ascii,0, sizeof(mcc_mnc_ascii));
  snprintf( mcc_mnc_ascii, sizeof(mcc_mnc_ascii), "%s%s", mcc_str, mnc_str );

  if( mcc_str && mnc_str && short_eons && long_eons )
  {
    // Legacy customer specifc scenario
    if( TRUE == is_nw_scan && TRUE == nas_common_info.use_se_table_only)
    {
      QCRIL_LOG_INFO("Special scenario: get op name from SE 13 only for perform network scan");
      qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, long_eons, TRUE, FALSE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
    }
    else
    {
      if (!(nas_common_info.always_send_plmn_name && is_nw_scan))
      {
        // Use EONS algorithm as is, to obtain operator name
        QCRIL_LOG_INFO("Query modem for EONS op name default.");
        qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, long_eons, FALSE, FALSE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
      }

      if( is_operator_name_empty_or_white_space( long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN ) &&
          is_operator_name_empty_or_white_space( short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN))
      {
        QCRIL_LOG_INFO("Query modem for EONS. Always send PLMN name.");
        // Fall back: Request modem to send PLMN name regardless of SPN
        qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, long_eons, FALSE, TRUE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
      }

      if( is_operator_name_empty_or_white_space( long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN ) &&
          is_operator_name_empty_or_white_space( short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN))
      {
        QCRIL_LOG_INFO("Query modem for EONS op name from SE.13 only");
        // Fall back on SE.13 table only (from modem)
        qcril_qmi_nas_get_plmn_name_from_modem (mcc_str, mnc_str, short_eons, long_eons, TRUE, FALSE, is_nw_scan, plmn_rat, csg_id_valid, csg_id );
      }
    }

    // If all attempts to retrieve operator name from modem fails, reply on QMI RIL's SE.13
    if( is_operator_name_empty_or_white_space( long_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN ) &&
        is_operator_name_empty_or_white_space( short_eons, NAS_OPERATOR_RESP_MAX_EONS_LEN))
    {
      QCRIL_LOG_INFO("EONS long and short names returned are both empty or white space");
      internal_long_name  = NULL;
      internal_short_name = NULL;
      qcril_qmi_nas2_find_startic_operator_name(
                                                mcc_str,
                                                mnc_str,
                                                mcc_mnc_ascii,
                                                &internal_long_name,
                                                &internal_short_name
                                                );
      QCRIL_LOG_INFO("static table: long eons %s, short eons: %s",
                        ( NULL != internal_long_name ) ? internal_long_name : "<empty>" ,
                        ( NULL != internal_short_name )  ? internal_short_name : "<empty>"
                     );

      if ( NULL != internal_long_name )
      {
          strlcpy( long_eons, internal_long_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
      }
      else
      {
          snprintf( long_eons, sizeof (long_eons), "%s-%s", mcc_str, mnc_str );
      }

      if ( NULL != internal_short_name )
      {
          strlcpy( short_eons, internal_short_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
      }
      else
      {
          snprintf( short_eons, sizeof (short_eons), "%s-%s", mcc_str, mnc_str );
      }
    } // fallback to RIL internal table case
  }
  else
  {
    QCRIL_LOG_FATAL("Null pointer passed");
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_util_handle_centralized_short_long_eons

//=========================================================================
// qcril_qmi_nas_get_plmn_name_from_modem
//===========================================================================
static void qcril_qmi_nas_get_plmn_name_from_modem
(
  char *mcc_str,
  char *mnc_str,
  char *short_eons,
  char *long_eons,
  boolean use_static_table_only,
  boolean is_always_send_plmn_name,
  int  is_nw_scan,
  nas_radio_if_enum_v01 plmn_rat,
  uint8_t csg_id_valid,
  uint32_t csg_id
)
{
  int mcc,mnc;
  nas_get_plmn_name_req_msg_v01  get_plmn_req;
  nas_get_plmn_name_resp_msg_v01 get_plmn_resp;
  qmi_client_error_type qmi_client_error = QMI_NO_ERR;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  int is_spn_present;
  int is_plmn_name_present;
  int prefer_spn;
  uint32_t name_len;

  QCRIL_LOG_FUNC_ENTRY();

  if( !mcc_str || !mnc_str || !short_eons || !long_eons )
  {
    QCRIL_LOG_ERROR( "Invalid args. NULL ptr passed.");
    QCRIL_LOG_FUNC_RETURN();
    return;
  }

  memset(&get_plmn_req,0,sizeof(get_plmn_req));
  memset(&get_plmn_resp,0,sizeof(get_plmn_resp));
  memset(short_eons, 0, NAS_OPERATOR_RESP_MAX_EONS_LEN);
  memset(long_eons, 0, NAS_OPERATOR_RESP_MAX_EONS_LEN);

  mcc = atoi(mcc_str);
  mnc = atoi(mnc_str);
  get_plmn_req.plmn.mcc = mcc;
  get_plmn_req.plmn.mnc = mnc;

  if( '0' == mnc_str[0] && NAS_MCC_MNC_MAX_V01 == strlen(mnc_str) )
  {
    get_plmn_req.mnc_includes_pcs_digit_valid = TRUE;
    get_plmn_req.mnc_includes_pcs_digit = TRUE;
  }
  get_plmn_req.suppress_sim_error_valid = TRUE;
  get_plmn_req.suppress_sim_error = TRUE;

  if( use_static_table_only )
  {
    get_plmn_req.use_static_table_only_valid = TRUE;
    get_plmn_req.use_static_table_only = TRUE;
  }

    NAS_CACHE_LOCK();

    // Pass the RAT from network scan response if found valid.
    if ( is_nw_scan )
    {
      if(plmn_rat != NAS_RADIO_IF_NO_SVC_V01)
      {
        get_plmn_req.rat_valid = TRUE;
        get_plmn_req.rat = plmn_rat;
      }
      else
      {
        QCRIL_LOG_INFO("Unknown RAT passed by QMI NAS!");
        get_plmn_req.rat_valid = FALSE;
      }
    }
    else
    {
        if(plmn_rat != NAS_RADIO_IF_NO_SVC_V01)
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = plmn_rat;
        }
        else if(qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_LTE))
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = NAS_RADIO_IF_LTE_V01;
        }
        else if (qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM))
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = NAS_RADIO_IF_GSM_V01;
        }
        else if (qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS))
        {
          get_plmn_req.rat_valid = TRUE;
          get_plmn_req.rat = NAS_RADIO_IF_UMTS_V01;
        }
        else
        {
          //TODO for TDSCDMA.
          get_plmn_req.rat_valid = FALSE;
        }
    }

    if( is_always_send_plmn_name )
    {
      get_plmn_req.always_send_plmn_name_valid = TRUE;
      get_plmn_req.always_send_plmn_name = TRUE;
    }

    if( TRUE == csg_id_valid )
    {
        get_plmn_req.csg_id_valid = csg_id_valid;
        get_plmn_req.csg_id = csg_id;
    }

    NAS_CACHE_UNLOCK();

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                               QMI_NAS_GET_PLMN_NAME_REQ_MSG_V01,
                                               (void*) &get_plmn_req,
                                               sizeof( get_plmn_req ),
                                               (void*) &get_plmn_resp,
                                               sizeof( get_plmn_resp ),
                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &get_plmn_resp.resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

  QCRIL_LOG_INFO("qmi_client_error: %d, ril_req_res: %d, get_plmn_resp.resp.error: %d",
                   (int)qmi_client_error, (int) ril_req_res, get_plmn_resp.resp.error );

  if( RIL_E_SUCCESS == ril_req_res )
  {
      if( TRUE == get_plmn_resp.eons_plmn_name_3gpp_valid )
      {
        is_spn_present = (get_plmn_resp.eons_plmn_name_3gpp.spn_len > NAS_NIL);
        is_plmn_name_present = ((get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_len > NAS_NIL) || (get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_len > NAS_NIL));
        prefer_spn = qcril_qmi_util_prefer_spn_over_plmn_name(is_spn_present, is_plmn_name_present, is_nw_scan);

        if( TRUE == prefer_spn )
        {
          name_len = ( get_plmn_resp.eons_plmn_name_3gpp.spn_len > NAS_SPN_LEN_MAX_V01 ) ?
                    NAS_SPN_LEN_MAX_V01 : get_plmn_resp.eons_plmn_name_3gpp.spn_len;
          if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == get_plmn_resp.eons_plmn_name_3gpp.spn_enc )
          {
              qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                                name_len,
                                                                short_eons );
              qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                                name_len,
                                                                long_eons );
              QCRIL_LOG_INFO("spn is 7-bit Unpacked data");
          }
          else
          {
              qcril_qmi_util_decode_operator_name_in_little_endian(short_eons,
                                                      NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                      get_plmn_resp.eons_plmn_name_3gpp.spn_enc,
                                                      (uint8*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                      name_len);

              qcril_qmi_util_decode_operator_name_in_little_endian(long_eons,
                                                      NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                      get_plmn_resp.eons_plmn_name_3gpp.spn_enc,
                                                      (uint8*)get_plmn_resp.eons_plmn_name_3gpp.spn,
                                                      name_len);

         }
         QCRIL_LOG_INFO("short eons derived from spn %s",short_eons);
         QCRIL_LOG_INFO("long eons derived from spn %s",long_eons);
       }
       else
       {
         name_len = ( get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_len > NAS_PLMN_NAME_MAX_V01 ) ?
                   NAS_PLMN_NAME_MAX_V01 : get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_len;
         if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_enc )
         {
           qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name,
                                                              name_len,
                                                              short_eons );
           QCRIL_LOG_INFO("plmn short name is 7-bit Unpacked data");
         }
         else
         {
           qcril_qmi_util_decode_operator_name_in_little_endian(short_eons,
                                                      NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                      get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name_enc,
                                                      (uint8*)get_plmn_resp.eons_plmn_name_3gpp.plmn_short_name,
                                                      name_len);
           QCRIL_LOG_INFO("short eons derived from plmn %s",short_eons);
         }

         name_len = ( get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_len > NAS_PLMN_NAME_MAX_V01 ) ?
                   NAS_PLMN_NAME_MAX_V01 : get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_len;
         if( NAS_CODING_SCHEME_CELL_BROADCAST_GSM_V01 == get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_enc )
         {
           qcril_cm_ss_convert_gsm8bit_alpha_string_to_utf8( (const char*)get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name,
                                                              name_len,
                                                              long_eons );
            QCRIL_LOG_INFO("plmn long name is 7-bit Unpacked data");
         }
         else
         {
            qcril_qmi_util_decode_operator_name_in_little_endian(long_eons,
                                                      NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                      get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name_enc,
                                                      (uint8*)get_plmn_resp.eons_plmn_name_3gpp.plmn_long_name,
                                                      name_len);
             QCRIL_LOG_INFO("long eons derived from plmn %s",long_eons);
          }
        }
      }
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_plmn_name_from_modem
//=========================================================================
//  FUNCTION: qcril_qmi_util_decode_operator_name
//===========================================================================
void qcril_qmi_util_decode_operator_name
(
  char *dest,
  uint16 max_dest_length,
  int coding_scheme,
  const uint8 *src,
  uint16 src_length
)
{
  uint8 data_length;
  char *temp_buf;
  uint8 i;

  if ( dest!= NULL && src != NULL && src_length > NAS_NIL )
  {
      data_length = ( src_length > max_dest_length ) ? max_dest_length : src_length;

      switch ( coding_scheme )
      {
        case QMI_CODING_SCHEME_CELL_BROADCAST_DATA:
          QCRIL_LOG_INFO( "7-bit coding scheme for NITZ ONS" );
          qcril_cm_ons_decode_packed_7bit_gsm_string( dest, src, data_length );
          QCRIL_LOG_DEBUG( "NITZ 7-bit GSM str: %s", dest );
          break;

        case QMI_CODING_SCHEME_UCS2:
          QCRIL_LOG_INFO( "UC2 coding scheme for NITZ ONS, len %d", data_length );
          if ( ( data_length % 2 ) != 0 )
          {
            QCRIL_LOG_ERROR( "Invalid UCS length %d", data_length );
            break;
          }

          temp_buf = (char *) qcril_malloc( data_length );
          if ( temp_buf == NULL )
          {
            QCRIL_LOG_ERROR( "Fail to allocate buffer for decoding UCS2" );
            break;
          }

          for ( i = 0; i < data_length; i = i + 2 )
          {
            temp_buf[ i ] = src[ i + 1 ];
            temp_buf[ i + 1 ] = src[ i ];
          }

          (void) qcril_cm_ss_convert_ucs2_to_utf8( temp_buf, data_length, dest );
          QCRIL_LOG_DEBUG( "NITZ UCS str: %s", dest );

          qcril_free( temp_buf );
          break;

        default:
          QCRIL_LOG_INFO( "Unknown coding scheme %d for NITZ ONS", coding_scheme );
          break;
      }
  }
  else
  {
      QCRIL_LOG_FATAL("CHECK FAILED");
  }

} // qcril_cm_ons_decode_nitz_operator_name

//=========================================================================
//  FUNCTION: qcril_qmi_util_decode_operator_name_in_little_endian
//===========================================================================
void qcril_qmi_util_decode_operator_name_in_little_endian
(
  char *dest,
  uint16 max_dest_length,
  int coding_scheme,
  const uint8 *src,
  uint16 src_length
)
{
  uint8 data_length;

  QCRIL_LOG_FUNC_ENTRY();

  if ( dest!= NULL && src != NULL && src_length > NAS_NIL )
  {
      data_length = ( src_length > max_dest_length ) ? max_dest_length : src_length;

      switch ( coding_scheme )
      {
        case QMI_CODING_SCHEME_CELL_BROADCAST_DATA:
          QCRIL_LOG_INFO( "7-bit coding scheme for NITZ ONS" );
          qcril_cm_ons_decode_packed_7bit_gsm_string( dest, src, data_length );
          QCRIL_LOG_DEBUG( "NITZ 7-bit GSM str: %s", dest );
          break;

        case QMI_CODING_SCHEME_UCS2:
          QCRIL_LOG_INFO( "UC2 coding scheme for NITZ ONS, len %d", data_length );
          if ( ( data_length % 2 ) != 0 )
          {
            QCRIL_LOG_ERROR( "Invalid UCS length %d", data_length );
            break;
          }
          (void) qcril_cm_ss_convert_ucs2_to_utf8( (char *)src, data_length, dest );
           QCRIL_LOG_DEBUG( "NITZ UCS str: %s", dest );

          break;

        default:
          QCRIL_LOG_INFO( "Unknown coding scheme %d for NITZ ONS", coding_scheme );
          break;
      }
  }
  else
  {
      QCRIL_LOG_FATAL("CHECK FAILED");
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_util_decode_operator_name_in_little_endian

//===========================================================================
// RIL_REQUEST_RADIO_POWER
//===========================================================================
void qcril_qmi_nas_request_power
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_reqlist_u_type reqlist_post_params;
  qcril_reqlist_public_type qcril_req_info;
  int requested_telephony_power_state;
  RIL_Errno res                                            = RIL_E_GENERIC_FAILURE;
  dms_operating_mode_enum_v01 requested_dms_operating_mode;
  uint32 radio_power_event_value;
  qcril_request_resp_params_type resp;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  if ( NULL != params_ptr->data && params_ptr->datalen > NAS_NIL )
  {
      qcril_qmi_nas_update_radio_power_request_info();

      requested_telephony_power_state = *((int*)params_ptr->data);
      switch ( requested_telephony_power_state )
      {
          case RIL_VAL_RADIO_POWER_MODE_ONLINE:
              requested_dms_operating_mode = DMS_VAL_ONLINE;
              res = RIL_E_SUCCESS;
              if(qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm())
              {
                  RADIO_POWER_LOCK();
                  if (TRUE == nas_common_info.modem_power_info.is_not_bootup_radio_power_on)
                  {
                      RADIO_POWER_UNLOCK();
                      if (0 == qcril_qmi_modem_power_voting_state())
                      {
                          RADIO_POWER_LOCK();
                          nas_common_info.modem_power_info.radio_power_process_pending = TRUE;
                          RADIO_POWER_UNLOCK();
                          qcril_qmi_register_for_up_event();
                          qcril_qmi_modem_power_process_apm_off();
                          RADIO_POWER_LOCK();
                          if (TRUE == nas_common_info.modem_power_info.radio_power_process_pending)
                          {
                              res = RADIO_POWER_WAIT();
                              RADIO_POWER_UNLOCK();
                          }
                          else
                          {
                              RADIO_POWER_UNLOCK();
                              QCRIL_LOG_INFO("Already received signal");
                          }
                      }
                  }
                  else
                  {
                      nas_common_info.modem_power_info.is_not_bootup_radio_power_on = TRUE;
                      RADIO_POWER_UNLOCK();
                  }
              }
              break;

          case RIL_VAL_RADIO_POWER_MODE_OFF:
              requested_dms_operating_mode = DMS_VAL_SHUTTING_DOWN;
              res = RIL_E_SUCCESS;
              break;

          case RIL_VAL_RADIO_POWER_MODE_LPM:
              requested_dms_operating_mode = DMS_VAL_LOW_POWER;
              res = RIL_E_SUCCESS;
              break;

          default: // invalid (or unsupported) value
              res = RIL_E_GENERIC_FAILURE;
              break;
      }

      if( RIL_E_SUCCESS == res )
      {
          memset( &reqlist_post_params, 0, sizeof( reqlist_post_params ) );
          reqlist_post_params.nas.required_operating_mode = requested_dms_operating_mode;

          qcril_reqlist_default_entry( params_ptr->t,
                                       params_ptr->event_id,
                                       QCRIL_DEFAULT_MODEM_ID,
                                       QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                       QCRIL_EVT_QMI_REQUEST_POWER_RADIO,
                                       &reqlist_post_params,
                                       &qcril_req_info );

          if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info ) == E_SUCCESS )
          {
              if( TRUE == qcril_qmi_nas_dms_is_in_ftm_mode() ) // Respond with GENERIC_FAILURE If the device is in FTM
              {
                  res = RIL_E_GENERIC_FAILURE;
              }
              else
              {
                  qcril_qmi_nas_radio_power_transaction_handler( requested_telephony_power_state );
                  res = RIL_E_SUCCESS;
              }
          }
          else
          {
              res = RIL_E_GENERIC_FAILURE;
          }

      }
  }

  if ( RIL_E_SUCCESS != res )
  {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         RIL_E_GENERIC_FAILURE,
                                         &resp );
      qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_request_power

//===========================================================================
//qcril_qmi_nas_initiate_radio_power_process
//===========================================================================
void qcril_qmi_nas_initiate_radio_power_process()
{
    QCRIL_LOG_FUNC_ENTRY();

    struct timeval tp;

    gettimeofday(&tp, NULL);
    nas_common_info.is_radio_power_check_enabled = FALSE;
    nas_common_info.radio_power_request_type = QMI_RIL_DMS_RADIO_PWR_REQUEST_NONE;
    nas_common_info.radio_power_cancel_type = QMI_RIL_DMS_RADIO_PWR_CANCEL_NONE;
    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
    nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN;
    nas_common_info.radio_power_multiple_rild_process_complete_num = NAS_NIL;
    nas_common_info.radio_power_multiple_rild_process_timer_valid = FALSE;
    nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE;

    pthread_mutexattr_init( &nas_common_info.radio_pwr_mutex_atr );
    pthread_mutex_init(&nas_common_info.radio_pwr_mutex, &nas_common_info.radio_pwr_mutex_atr);
    pthread_cond_init (&nas_common_info.radio_pwr_cond_var, NULL);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_initiate_radio_power_process

//===========================================================================
//qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally
//===========================================================================
RIL_Errno qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally()
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type current_state;

    QCRIL_LOG_FUNC_ENTRY();

    if( nas_common_info.prov_emer_call_in_lpm )
    {
        RADIO_POWER_LOCK();
        current_state = nas_common_info.radio_pwr_prov_emer_call_lpm_state;
        RADIO_POWER_UNLOCK();

        QCRIL_LOG_INFO("current state %d", current_state);
        if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE == current_state )
        {
            RADIO_POWER_LOCK();
            nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE;
            nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode = DMS_OP_MODE_ONLINE_V01;
            RADIO_POWER_UNLOCK();
            res = qcril_qmi_nas_radio_power_handle_modem_transition(RIL_VAL_RADIO_POWER_MODE_ONLINE);

            RADIO_POWER_LOCK();
            if( RIL_E_SUCCESS == res )
            {
                if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE != nas_common_info.radio_pwr_prov_emer_call_lpm_state ) //modem was already ONLINE, no action needed
                {
                    nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NO_ACTION;
                }
            }
            else
            {
                nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE;
            }
            RADIO_POWER_UNLOCK();
        }
        else if ( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE !=
                  nas_common_info.radio_pwr_prov_emer_call_lpm_state ) {
            res = RIL_E_SUCCESS;
        }
    }
    else
    {
        res = RIL_E_SUCCESS;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} //qcril_qmi_nas_voice_move_device_to_online_for_emer_call_conditionally

//===========================================================================
//qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally
//===========================================================================
RIL_Errno qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally()
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_ril_dms_radio_pwr_prov_emer_call_lpm_state_e_type current_state;

    QCRIL_LOG_FUNC_ENTRY();

    if( nas_common_info.prov_emer_call_in_lpm )
    {
        RADIO_POWER_LOCK();
        current_state = nas_common_info.radio_pwr_prov_emer_call_lpm_state;
        RADIO_POWER_UNLOCK();

        QCRIL_LOG_INFO("current state %d", current_state);
        if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_DONE == current_state ) //modem was moved to ONLINE for emergency call, so need to move it back to LPM once call is ended
        {
            RADIO_POWER_LOCK();
            nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_INITIATE;
            nas_common_info.radio_pwr_prov_emer_call_desired_modem_operating_mode = DMS_OP_MODE_LOW_POWER_V01;
            RADIO_POWER_UNLOCK();
            res = qcril_qmi_nas_radio_power_handle_modem_transition(RIL_VAL_RADIO_POWER_MODE_LPM);
        }
        else if( QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NO_ACTION == current_state ) //modem was already ONLINE before emergency call was made, so need not put it back to LPM
        {
            res = RIL_E_SUCCESS;
        }

        RADIO_POWER_LOCK();
        nas_common_info.radio_pwr_prov_emer_call_lpm_state = QMI_RIL_DMS_RADIO_PWR_PROV_EMER_CALL_LPM_STATE_NONE;
        RADIO_POWER_UNLOCK();
    }
    else
    {
        res = RIL_E_SUCCESS;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} //qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally

//===========================================================================
//qcril_qmi_nas_cancel_radio_power_process
//===========================================================================
void qcril_qmi_nas_cancel_radio_power_process(qmi_ril_dms_radio_pwr_cancel_e_type cancel_reason)
{
    QCRIL_LOG_FUNC_ENTRY();

    RADIO_POWER_LOCK();

    nas_common_info.radio_power_cancel_type = cancel_reason;
    QCRIL_LOG_INFO("Updated radio power process cancel reason to %s",radio_power_cancel_name[nas_common_info.radio_power_cancel_type]);
    RADIO_POWER_SIGNAL();

    RADIO_POWER_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_cancel_radio_power_process


//===========================================================================
//qcril_qmi_nas_radio_power_process_condition_wait_helper
//===========================================================================
IxErrnoType qcril_qmi_nas_radio_power_process_condition_wait_helper()
{
    IxErrnoType res;
    struct timeval tp;
    struct timespec ts;

    gettimeofday(&tp, NULL);
    ts.tv_sec = tp.tv_sec + 74;     //74 seconds
    ts.tv_nsec = tp.tv_usec * 1000;

    if( QMI_RIL_DMS_RADIO_PWR_CANCEL_NONE != nas_common_info.radio_power_cancel_type )
    {
        QCRIL_LOG_INFO("radio power process cancelled due to %s",radio_power_cancel_name[nas_common_info.radio_power_cancel_type]);
        switch( nas_common_info.radio_power_cancel_type )
        {
            case QMI_RIL_DMS_RADIO_PWR_CANCEL_SSR:
                res = ETIMEDOUT;
                break;

            default: //no action
                break;
        }
    }
    else
    {
        QCRIL_LOG_INFO ("Starting to wait for signal");
        res = pthread_cond_timedwait(&nas_common_info.radio_pwr_cond_var, &nas_common_info.radio_pwr_mutex, &ts);
        if( QMI_RIL_DMS_RADIO_PWR_CANCEL_NONE != nas_common_info.radio_power_cancel_type )
        {
            QCRIL_LOG_INFO("radio power process cancelled due to %s",radio_power_cancel_name[nas_common_info.radio_power_cancel_type]);
            switch( nas_common_info.radio_power_cancel_type )
            {
                case QMI_RIL_DMS_RADIO_PWR_CANCEL_SSR:
                    res = ETIMEDOUT;
                    break;

                default: //no action
                    break;
            }
        }
    }

    return res;
} //qcril_qmi_nas_radio_power_process_condition_wait_helper

//===========================================================================
//qcril_qmi_nas_log_radio_power_process_state
//===========================================================================
void qcril_qmi_nas_log_radio_power_process_state(int requested_telephony_power_state,qmi_ril_dms_radio_pwr_state_e_type cur_state)
{
    qcril_card_status_e_type                        cur_card_state;
    dms_operating_mode_enum_v01                     cur_operating_mode;
    uint32_t slot = qmi_ril_get_sim_slot();

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    cur_card_state = nas_common_info.card_info[ slot ].status;
    cur_operating_mode = nas_dms_cached_info.operating_mode;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_DEBUG("telephony %s | ril %s | card %s | modem %s",radio_power_telephony_request_name[requested_telephony_power_state+1],
                                                            radio_power_state_name[cur_state],
                                                            card_status_name[cur_card_state],
                                                            dms_op_mode_name[cur_operating_mode]);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_log_radio_power_process_state

//===========================================================================
//qcril_qmi_nas_radio_power_handle_card_transition
//===========================================================================
RIL_Errno qcril_qmi_nas_radio_power_handle_card_transition( int requested_telephony_power_state )
{
    RIL_Errno transaction_res = RIL_E_SUCCESS;
    qcril_evt_e_type requested_card_state;
    qcril_card_status_e_type cur_card_state;
    int card_state_transition_needed = TRUE;
    int wait_res;
    uint32_t slot = qmi_ril_get_sim_slot();

    QCRIL_LOG_FUNC_ENTRY();

    RADIO_POWER_LOCK();
    NAS_CACHE_LOCK();
    cur_card_state = nas_common_info.card_info[ slot ].status;
    NAS_CACHE_UNLOCK();

    switch ( cur_card_state )
    {
        case QCRIL_CARD_STATUS_UP:
            if( RIL_VAL_RADIO_POWER_MODE_ONLINE != requested_telephony_power_state )
            {
                if( FALSE == qmi_ril_is_feature_supported(QMI_RIL_FEATURE_JB) || // card should not be powered down when RADIO_POWER OFF arrives at bootup and device is not in APM
                    TRUE == qcril_qmi_nas_is_apm_enabled() ||                    // Telephony sends RADIO_POWER OFF at bootup from JB
                    FALSE == qcril_qmi_nas_is_bootup_radio_power_off_request() )
                {
                  requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN;
                }
                else
                {
                  card_state_transition_needed = FALSE;
                }
            }
            else
            {
              card_state_transition_needed = FALSE;
            }
            break;

      case QCRIL_CARD_STATUS_DOWN:
            if( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
            {
              requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP;
            }
            else
            {
              card_state_transition_needed = FALSE;
            }
            break;

        case QCRIL_CARD_STATUS_ABSENT:
            if( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
            {
                requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP;
            }
            else
            {
                if (qcril_qmi_nas_is_bootup_radio_power_off_request())
                {
                    card_state_transition_needed = FALSE;
                }
                else
                {
                    requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN;
                }
            }
            break;

        default:
            card_state_transition_needed = FALSE;
            break;
    }

    if( QCRIL_CARD_STATUS_UNKNOWN == cur_card_state && FALSE == nas_common_info.no_wait_for_card )
    {
        qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_CARD_STATUS);
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD;
        wait_res = RADIO_POWER_WAIT();

        if( ETIMEDOUT == wait_res )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            transaction_res = RIL_E_GENERIC_FAILURE;
        }
        else
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            NAS_CACHE_LOCK();
            cur_card_state = nas_common_info.card_info[ slot ].status;
            NAS_CACHE_UNLOCK();
            if( QCRIL_CARD_STATUS_UP == cur_card_state && //Need to power down the card when device bootsup in APM
                TRUE == qmi_ril_is_feature_supported(QMI_RIL_FEATURE_JB) &&
                TRUE == qcril_qmi_nas_is_apm_enabled() &&
                TRUE == qcril_qmi_nas_is_bootup_radio_power_off_request())
            {
                card_state_transition_needed = TRUE;
                requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN;
            }
            /*During RADIO_POWER OFF if service down event/SSR happen then card_state
              will be UNKNOWN at the time of ONLINE request, so RIL should wait for
              card_state change to DOWN. Then RIL should process CARD_POWER_UP event to UIM.*/
            else if ( ( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state ) &&
                      ( QCRIL_CARD_STATUS_UP != cur_card_state ) &&
                      ( QCRIL_CARD_STATUS_UNKNOWN != cur_card_state )
                    )
            {
                QCRIL_LOG_DEBUG("card status %s", card_status_name[cur_card_state]);
                card_state_transition_needed = TRUE;
                requested_card_state = QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_UP;
            }
        }
    }

    if ( NAS_NIL == nas_common_info.apm_sim_not_pwdn && TRUE == card_state_transition_needed )
    {
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD;
        RADIO_POWER_UNLOCK();

        transaction_res = qcril_qmi_nas_dms_handle_card_status(requested_card_state);

        RADIO_POWER_LOCK();
        if( RIL_E_SUCCESS != transaction_res )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        }
        else
        {
            NAS_CACHE_LOCK();
            cur_card_state = nas_common_info.card_info[ slot ].status;
            NAS_CACHE_UNLOCK();

            if (( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD == nas_common_info.radio_pwr_signal_cond ) &&
                (cur_card_state != QCRIL_CARD_STATUS_ABSENT))
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_CARD_STATUS);
                wait_res = RADIO_POWER_WAIT();
                if( ETIMEDOUT == wait_res )
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                    transaction_res = RIL_E_GENERIC_FAILURE;
                }
                else
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                }
            }
            else
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_CARD_STATUS_SET);
                nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            }
        }
    }
    RADIO_POWER_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(transaction_res);
    return transaction_res;
} //qcril_qmi_nas_radio_power_handle_card_transition

//===========================================================================
//qcril_qmi_nas_radio_power_handle_modem_transition
//===========================================================================
RIL_Errno qcril_qmi_nas_radio_power_handle_modem_transition( int requested_telephony_power_state )
{
    RIL_Errno transaction_res = RIL_E_SUCCESS;
    dms_operating_mode_enum_v01 requested_dms_operating_mode;
    int is_operating_mode_change_needed;
    int wait_res;

    QCRIL_LOG_FUNC_ENTRY();

    switch ( requested_telephony_power_state )
    {
        case RIL_VAL_RADIO_POWER_MODE_ONLINE:
            requested_dms_operating_mode = DMS_VAL_ONLINE;
            break;

        case RIL_VAL_RADIO_POWER_MODE_OFF:
            requested_dms_operating_mode = DMS_VAL_SHUTTING_DOWN;
            break;

        case RIL_VAL_RADIO_POWER_MODE_LPM:
            requested_dms_operating_mode = DMS_VAL_LOW_POWER;
            break;

        default: // invalid (or unsupported) value
            transaction_res = RIL_E_GENERIC_FAILURE;
            break;
    }

    if( RIL_E_SUCCESS == transaction_res )
    {
        RADIO_POWER_LOCK();
        nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM;
        RADIO_POWER_UNLOCK();

        transaction_res = qcril_qmi_nas_dms_handle_modem_operating_mode(requested_dms_operating_mode, &is_operating_mode_change_needed);

        RADIO_POWER_LOCK();
        if( RIL_E_SUCCESS != transaction_res )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        }
        else if( FALSE == is_operating_mode_change_needed )
        {
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET);
            nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
        }
        else
        {
            if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_MODEM == nas_common_info.radio_pwr_signal_cond )
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_SETTING_OP_MODE);
                wait_res = RADIO_POWER_WAIT();
                if( ETIMEDOUT == wait_res )
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                    transaction_res = RIL_E_GENERIC_FAILURE;
                }
                else
                {
                    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET);
                    nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
                }
            }
            else
            {
                qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_OP_MODE_SET);
                nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
            }
        }
        RADIO_POWER_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(transaction_res);
    return transaction_res;
} //qcril_qmi_nas_radio_power_handle_modem_transition

//===========================================================================
//qcril_qmi_nas_radio_power_transaction_handler
//===========================================================================
void qcril_qmi_nas_radio_power_transaction_handler( int requested_telephony_power_state )
{
    RIL_Errno                       transaction_res = RIL_E_SUCCESS;
    errno_enum_type                 found_qcril_request;
    qcril_reqlist_public_type       qcril_req_info;
    qcril_request_resp_params_type  resp;
    uint32_t                        vsid;

    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_NONE);

    if (( RIL_VAL_RADIO_POWER_MODE_ONLINE != requested_telephony_power_state ) &&
          qcril_qmi_nas_is_bootup_radio_power_off_request())
    {
        qcril_qmi_dms_save_prl_info(FALSE, NAS_NIL);
    }

    qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_INITIALIZED);
    if( RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
    { // * to online
        transaction_res = qcril_qmi_nas_radio_power_handle_card_transition(requested_telephony_power_state);
        if( RIL_E_SUCCESS == transaction_res )
        {
            transaction_res = qcril_qmi_nas_radio_power_handle_modem_transition(requested_telephony_power_state);
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
        }
    }
    else
    { // * to LPM
        transaction_res = qcril_qmi_nas_radio_power_handle_modem_transition(requested_telephony_power_state);
        if( RIL_E_SUCCESS == transaction_res )
        {
            transaction_res = qcril_qmi_nas_radio_power_handle_card_transition(requested_telephony_power_state);
            qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_DONE);
        }
    }

    NAS_CACHE_LOCK();
    nas_common_info.is_radio_power_check_enabled = TRUE;
    NAS_CACHE_UNLOCK();

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                        QCRIL_DEFAULT_MODEM_ID,
                                                        QCRIL_EVT_QMI_REQUEST_POWER_RADIO,
                                                        &qcril_req_info );
    if ( E_SUCCESS == found_qcril_request )
    {
        /* send response for RADIO_POWER request right away */
        if ( qmi_ril_is_multi_sim_feature_supported() )
        {
            qcril_qmi_nas_handle_multiple_rild_radio_power_sync(requested_telephony_power_state);
        }

        if (RIL_E_SUCCESS == transaction_res &&
            qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm() &&
            RIL_VAL_RADIO_POWER_MODE_ONLINE != requested_telephony_power_state)
        {
            if (!qcril_qmi_nas_is_bootup_radio_power_off_request())
            {
                qcril_qmi_modem_power_set_voting_state(0);
                qcril_qmi_release_services();
                qcril_qmi_modem_power_process_regular_shutdown();
            }
            else
            {
                if (qcril_qmi_nas_is_apm_enabled())
                {
                    RADIO_POWER_LOCK();
                    nas_common_info.modem_power_info.is_not_bootup_radio_power_on = TRUE;
                    RADIO_POWER_UNLOCK();
                    QCRIL_LOG_INFO("Bootup in APM");
                    qcril_qmi_modem_power_set_voting_state(0);
                    qcril_qmi_release_services();
                    qcril_qmi_modem_power_process_regular_shutdown();
                }
            }
        }

        NAS_CACHE_LOCK();
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           transaction_res,
                                           &resp );
        qcril_send_request_response( &resp );
        NAS_CACHE_UNLOCK();

        // Sometimes modem may send voice system id before telephony is UP.
        // So, send unsol VSID first time after radio on. This is sent here to
        // ensure VSID is available to telephony when it is UP and to enable
        // emergency calls in no SIM scenario as well. It is not applicable to
        // non-dsds as voice_system_id will not be valid.
        if ( nas_cached_info.voice_system_id_valid && RIL_VAL_RADIO_POWER_MODE_ONLINE == requested_telephony_power_state )
        {
          vsid = nas_cached_info.voice_system_id;
          // Send QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID response
          QCRIL_LOG_DEBUG("..Sending VSID %d", vsid);
          qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID,
                                     QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID,
                                     (char*)&vsid, sizeof(vsid));
#ifndef QMI_RIL_UTF
          qcril_am_set_vsid(QCRIL_AM_VS_VOICE, vsid);
#endif
        }

        if( RIL_E_SUCCESS == transaction_res )
        {
            qmi_ril_wave_modem_status();
        }
    }
    else
    {
        QCRIL_LOG_ERROR( "pending event not found %d", (int) found_qcril_request );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_radio_power_transaction_handler

//===========================================================================
// qcril_qmi_nas_dms_handle_modem_operating_mode
//===========================================================================
RIL_Errno qcril_qmi_nas_dms_handle_modem_operating_mode(dms_operating_mode_enum_v01 requested_operating_mode,int * is_operating_mode_change_needed)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_client_error;
    dms_set_operating_mode_req_msg_v01   qmi_request;
    dms_set_operating_mode_resp_msg_v01  qmi_response;
    dms_operating_mode_enum_v01 current_dms_operating_mode   = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    int current_dms_operating_mode_valid                     = FALSE;
    qmi_client_error_type qmi_transport_error;


    QCRIL_LOG_FUNC_ENTRY();
    qcril_qmi_nas_query_cur_power_state(&current_dms_operating_mode_valid, &current_dms_operating_mode);
    if( TRUE == current_dms_operating_mode_valid && requested_operating_mode == current_dms_operating_mode )
    {
        *is_operating_mode_change_needed = FALSE;
        res = RIL_E_SUCCESS;
        QCRIL_LOG_INFO("modem's current operating mode matches the requested operating mode");
    }
    else
    {
        *is_operating_mode_change_needed = TRUE;
        memset(&qmi_request, 0, sizeof(qmi_request));
        qmi_request.operating_mode = requested_operating_mode;

        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                           QMI_DMS_SET_OPERATING_MODE_REQ_V01,
                                                           &qmi_request,
                                                           sizeof( qmi_request ),
                                                           &qmi_response,
                                                           sizeof( qmi_response ),
                                                           QCRIL_QMI_DMS_SET_OPERATING_MODE_SYNC_TIMEOUT );

        /* Device not ready, is reported to SET_OPERATING_MODE only when
           there is a temporary failure.
           In this case, CM will retry to set operating mode.
           Hence passed QCRIL_QMI_ERR_TOLERATE_NOT_READY to tolerate device
           not ready error. */
        res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex(qmi_transport_error,
                                                                         &qmi_response.resp,
                                                                         QCRIL_QMI_ERR_TOLERATE_NOT_READY,
                                                                         NULL);
        QCRIL_LOG_INFO("modem's operating mode needs to be changed");
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

    return res;
} // qcril_qmi_nas_dms_handle_modem_operating_mode

//===========================================================================
// qcril_qmi_nas_dms_handle_card_status
//===========================================================================
RIL_Errno qcril_qmi_nas_dms_handle_card_status(qcril_evt_e_type uim_evt)
{
    RIL_Errno res = RIL_E_SUCCESS;
    IxErrnoType err_no;
    int slot = qmi_ril_get_sim_slot();

    QCRIL_LOG_FUNC_ENTRY();
    err_no = qcril_process_event( slot,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  uim_evt,
                                  (void *) &slot,
                                  sizeof( slot ),
                                  (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    QCRIL_LOG_INFO(".. uim evt postage res %d", (int) err_no );
    if ( E_SUCCESS != err_no )
    {
        res = RIL_E_GENERIC_FAILURE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_dms_handle_card_status

//===========================================================================
// QCRIL_EVT_CM_CARD_STATUS_UPDATED
//===========================================================================
void qcril_qmi_nas_dms_event_card_status_updated
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_card_info_type *card_info_ptr;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    modem_id = params_ptr->modem_id;

    card_info_ptr = ( qcril_card_info_type *) params_ptr->data;

    if( card_info_ptr != NULL )
    {
        qcril_event_queue( instance_id,
                           modem_id,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_NAS_CARD_STATUS_UPDATE,
                           params_ptr->data,
                           params_ptr->datalen,
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

    qcril_qmi_nas_get_sim_mcc_mnc

============================================================================*/
/*!
    @brief
    Get sim card mcc and mnc

    @return
    None
*/
/*=========================================================================*/
int qcril_qmi_nas_get_sim_mcc_mnc
(
    char mcc[QCRIL_MCC_MNC_MAX_SIZE],
    char mnc[QCRIL_MCC_MNC_MAX_SIZE]
)
{
    int res  = E_FAILURE;
    int slot = qmi_ril_get_sim_slot();

    if (mcc && mnc)
    {
        NAS_CACHE_LOCK();

        if (nas_common_info.card_info[slot].valid)
        {
            memcpy(mcc, nas_common_info.card_info[slot].mcc, QCRIL_MCC_MNC_MAX_SIZE);
            memcpy(mnc, nas_common_info.card_info[slot].mnc, QCRIL_MCC_MNC_MAX_SIZE);
            res = E_SUCCESS;
        }

        NAS_CACHE_UNLOCK();

        QCRIL_LOG_DEBUG("card mcc %s", mcc);
        QCRIL_LOG_DEBUG("card mnc %s", mnc);
    }

    return res;
}
/*===========================================================================

    qcril_qmi_nas_update_sim_mcc_mnc

============================================================================*/
/*!
    @brief
    Update sim card mcc and mnc

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_update_sim_mcc_mnc
(
    boolean valid,
    char    mcc[QCRIL_MCC_MNC_MAX_SIZE],
    char    mnc[QCRIL_MCC_MNC_MAX_SIZE]
)
{
    int slot = qmi_ril_get_sim_slot();

    if (mcc && mnc)
    {
        NAS_CACHE_LOCK();

        nas_common_info.card_info[slot].valid = valid;
        if (valid)
        {
            memcpy(nas_common_info.card_info[slot].mcc, mcc, QCRIL_MCC_MNC_MAX_SIZE);
            memcpy(nas_common_info.card_info[slot].mnc, mnc, QCRIL_MCC_MNC_MAX_SIZE);
        }

        NAS_CACHE_UNLOCK();

        QCRIL_LOG_DEBUG("card mcc %s", mcc);
        QCRIL_LOG_DEBUG("card mnc %s", mnc);
    }
}

/*===========================================================================

    qcril_qmi_nas_retrieve_aid_from_app_info

============================================================================*/
/*!
    @brief
    Retrieve aid buffer application info

    @return
    None
*/
/*=========================================================================*/
int qcril_qmi_nas_retrieve_aid_from_app_info
(
    RIL_AppStatus *application,
    char           aid_buffer[QMI_UIM_MAX_AID_LEN+1]
)
{
    int res = E_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();
    if (application && aid_buffer)
    {

        QCRIL_LOG_DEBUG("app type %d", application->app_type);
        QCRIL_LOG_DEBUG("app state %d", application->app_state);

        if ((application->app_state == RIL_APPSTATE_READY) &&
            application->aid_ptr)
        {
            strlcpy(aid_buffer, application->aid_ptr, QMI_UIM_MAX_AID_LEN + 1);
            res = E_SUCCESS;
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

/*===========================================================================

    qcril_qmi_nas_retrieve_aid_from_card_status

============================================================================*/
/*!
    @brief
    Retrieve aid buffer card status info

    @return
    None
*/
/*=========================================================================*/
int qcril_qmi_nas_retrieve_aid_from_card_status
(
    RIL_CardStatus_v6 *ril_card_status,
    char               aid_buffer[QMI_UIM_MAX_AID_LEN+1]
)
{
    RIL_AppType       card_app_type;
    int               res = E_FAILURE;
    int               index;

    QCRIL_LOG_FUNC_ENTRY();

    if (ril_card_status)
    {
        if (ril_card_status->card_state == RIL_CARDSTATE_PRESENT)
        {
            if (ril_card_status->gsm_umts_subscription_app_index != -1)
            {
                index = ril_card_status->gsm_umts_subscription_app_index;

                /* retrieve aid from gsm umts subscription app info */
                res = qcril_qmi_nas_retrieve_aid_from_app_info(
                                                &ril_card_status->applications[index],
                                                aid_buffer);
            }

            if ((res == RIL_E_GENERIC_FAILURE) &&
                (ril_card_status->cdma_subscription_app_index != -1))
            {
                index = ril_card_status->cdma_subscription_app_index;

                /* retrieve aid from cdma subscription app info */
                res = qcril_qmi_nas_retrieve_aid_from_app_info(
                                                &ril_card_status->applications[index],
                                                aid_buffer);
            }

            if ((res == RIL_E_GENERIC_FAILURE) &&
                (ril_card_status->ims_subscription_app_index != -1))
            {
                index = ril_card_status->ims_subscription_app_index;

                /* retrieve aid from ims subscription app info */
                res = qcril_qmi_nas_retrieve_aid_from_app_info(
                                                &ril_card_status->applications[index],
                                                aid_buffer);
            }
        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
}

//===========================================================================
// QCRIL_EVT_QMI_NAS_CARD_STATUS_UPDATE
//===========================================================================
void qcril_qmi_nas_event_card_status_update
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  uint8 slot;
  qcril_card_info_type *card_info_ptr;
  int card_status_changed;
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_reqlist_public_type             qcril_req_info;
  errno_enum_type                       found_qcril_request;
  qcril_request_resp_params_type        resp;
  int                                   card_shutdown_initiated_from_oem_hook = FALSE;
  int                                   need_to_evaluate_emergency_number_list;
  qcril_card_status_e_type              previous_card_status;
  qcril_card_status_e_type              new_card_status;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );
  card_info_ptr = ( qcril_card_info_type *) params_ptr->data;

  if( card_info_ptr != NULL )
  {
      slot = card_info_ptr->slot;
      QCRIL_LOG_INFO( "entered slot %d", (int) slot );

      if( slot == qmi_ril_get_sim_slot() )
      {
          need_to_evaluate_emergency_number_list    = FALSE;
          previous_card_status                      = nas_common_info.card_info[ slot ].status;
          new_card_status                           = card_info_ptr->status;
          QCRIL_LOG_INFO( "Slot %d Card status: %s --> %s",
                           slot,
                          card_status_name[ nas_common_info.card_info[ slot ].status ],
                          card_status_name[ card_info_ptr->status ] );

          NAS_CACHE_LOCK();
          card_status_changed = (nas_common_info.card_info[ slot ].status != card_info_ptr->status) ? TRUE : FALSE;
          NAS_CACHE_UNLOCK();

          QCRIL_LOG_INFO("card status changed %d", card_status_changed );

          if ( card_status_changed )
          {
              qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch( QCRIL_DEFAULT_INSTANCE_ID,
              card_info_ptr->slot, FALSE, card_info_ptr->status );
              RADIO_POWER_LOCK();
              if( QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_CARD == nas_common_info.radio_pwr_signal_cond )
              {
                  RADIO_POWER_SIGNAL();
                  nas_common_info.radio_pwr_signal_cond = QMI_RIL_DMS_RADIO_PWR_SIGNAL_COND_NONE;
              }
              else if( FALSE == nas_common_info.no_wait_for_card || FALSE == qcril_qmi_nas_is_radio_power_check_enabled() )
              {
                  if( QCRIL_CARD_STATUS_UP == card_info_ptr->status && // Power down the card If device is in APM at bootup in Pre JB releases only
                      TRUE == qcril_qmi_nas_is_apm_enabled() &&         // RADIO_POWER OFF is sent in JB even If device bootsup in APM
                      NAS_NIL == nas_common_info.apm_sim_not_pwdn &&
                      FALSE == qmi_ril_is_feature_supported(QMI_RIL_FEATURE_JB) )
                  {

                      qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                  QCRIL_DEFAULT_MODEM_ID,
                                                  qcril_qmi_nas_card_status_translater,
                                                  (void*) QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN,
                                                  NULL,   // immediate
                                                  NULL );
                  }
              }
              RADIO_POWER_UNLOCK();

              found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                          QCRIL_DEFAULT_MODEM_ID,
                                          QCRIL_EVT_QMI_REQUEST_SHUTDOWN,
                                          &qcril_req_info );
              QCRIL_LOG_INFO("found qcril request %d", (int) found_qcril_request);
              if ( ( E_SUCCESS == found_qcril_request ) && card_status_changed && (QCRIL_CARD_STATUS_UP != card_info_ptr->status) )
              {
                  NAS_CACHE_LOCK();
                  card_shutdown_initiated_from_oem_hook = nas_dms_cached_info.card_shutdown_initiated;
                  NAS_CACHE_UNLOCK();

                  if( TRUE == card_shutdown_initiated_from_oem_hook )
                  {
                      qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                  QCRIL_DEFAULT_MODEM_ID,
                                                  qmi_ril_process_oem_hook_shutdown,
                                                  NULL,  // immediate
                                                  NULL );
                  }
              }
              // designated country handling
              switch ( new_card_status )
              {
                  case QCRIL_CARD_STATUS_UP:        // bootup, or after APM still ok to initiate check
                      need_to_evaluate_emergency_number_list = TRUE;
                      qcril_qmi_nas_update_iccid(slot);
                      break;

                  case QCRIL_CARD_STATUS_ABSENT:    // initial or card removal
                  case QCRIL_CARD_STATUS_DOWN:
                  {
                      need_to_evaluate_emergency_number_list = TRUE;
                      qcril_qmi_nas_update_sim_mcc_mnc(FALSE, NULL, NULL);

                      NAS_CACHE_LOCK();
                      *nas_cached_info.mcc_from_imsi_cache = NAS_NIL;
                      NAS_CACHE_UNLOCK();
                      break;
                  }

                  default:
                      break;
              }
          }

          if ( need_to_evaluate_emergency_number_list )
          {
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                           QCRIL_DEFAULT_MODEM_ID,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                           NULL,
                           QMI_RIL_ZERO,
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
          }
      }
  }
  else
  {
     QCRIL_LOG_FATAL("CHECK FAILED");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_event_card_status_updated

/*===========================================================================

    qcril_qmi_nas_event_app_status_update

============================================================================*/
/*!
    @brief
    Handles QCRIL_EVT_CM_CARD_APP_STATUS_CHANGED

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_event_app_status_update
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type       *const ret_ptr
)
{
    uint8                           slot;
    qcril_card_app_info_type       *card_app_info;
    RIL_CardStatus_v6               ril_card_status;
    qcril_uim_get_mcc_mnc_req_type  get_mcc_mnc_req = {0};
    qcril_instance_id_e_type        instance_id;
    qcril_modem_id_e_type           modem_id;
    char                            *aid_parm = NULL;
    int                             aid_parm_len = 0;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);

    card_app_info = (qcril_card_info_type *)params_ptr->data;

    if (card_app_info != NULL)
    {
        /* evaluate possibility of voice radio tech change */
        qcril_qmi_nas_initiate_voice_rte_change_propagation();

        if (card_app_info->app_state == QMI_UIM_APP_STATE_READY)
        {

#ifndef QMI_RIL_UTF

            /* retrieve card status info */
            if (qcril_uim_direct_get_card_status(qmi_ril_get_process_instance_id(),
                                                 &ril_card_status)
                                                           == RIL_E_SUCCESS);
            {
                /* retrieve aid from card status */
                if (qcril_qmi_nas_retrieve_aid_from_card_status(&ril_card_status,
                                                  get_mcc_mnc_req.aid_buffer)
                                                               == E_SUCCESS)
                {
                    // UIM expects NULL when aid is not present
                    if ( strlen(get_mcc_mnc_req.aid_buffer) )
                    {
                       aid_parm = get_mcc_mnc_req.aid_buffer;
                       aid_parm_len = strlen(get_mcc_mnc_req.aid_buffer) + 1;
                    }

                    /* Send event to retrieve mcc and mnc from the card */
                    qcril_event_queue(instance_id, modem_id,
                                      QCRIL_DATA_ON_STACK,
                                      QCRIL_EVT_INTERNAL_UIM_GET_MCC_MNC,
                                      aid_parm,
                                      aid_parm_len,
                                      (RIL_Token)QCRIL_TOKEN_ID_INTERNAL);
                    QCRIL_LOG_INFO(" trigger QCRIL_EVT_INTERNAL_UIM_GET_MCC_MNC");
                }
            }
#endif
        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

    qcril_qmi_nas_request_shutdown

============================================================================*/
/*!
    @brief
    Handles RIL_REQUEST_SHUTDOWN

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_request_shutdown
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    RIL_Errno                   res;
    int                         is_no_wait_for_card;
    qcril_card_status_e_type    card_status;
    int                         action_required;
    dms_operating_mode_enum_v01 operating_mode;
    int                         operating_mode_valid;
    uint32_t                    slot;

    qcril_request_resp_params_type resp;
    qcril_reqlist_public_type      qcril_req_info;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    do
    {
        res             = RIL_E_GENERIC_FAILURE;
        action_required = FALSE;

        qcril_reqlist_default_entry( params_ptr->t,
                                     params_ptr->event_id,
                                     QCRIL_DEFAULT_MODEM_ID,
                                     QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                     QCRIL_EVT_QMI_REQUEST_SHUTDOWN,
                                     NULL,
                                     &qcril_req_info );

        if (E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info ))
        {
            break;
        }

        NAS_CACHE_LOCK();
        slot                 = qmi_ril_get_sim_slot();
        is_no_wait_for_card  = nas_common_info.no_wait_for_card;
        card_status          = nas_common_info.card_info[slot].status;
        operating_mode       = nas_dms_cached_info.operating_mode;
        operating_mode_valid = nas_dms_cached_info.operating_mode_valid;
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("ctx: QCRIL_NO_WAIT_FOR_CARD=%d, card status=%d, oprt_val=%d, oprt=%d",
                       is_no_wait_for_card,
                       (int) card_status,
                       operating_mode_valid,
                       operating_mode);

        res = RIL_E_SUCCESS;

        /* If syncrhonization with card is not suppressed for RIL and
         * card is UP then power down the card first */
        action_required = (!is_no_wait_for_card &&
                          (QCRIL_CARD_STATUS_UP == card_status));

        QCRIL_LOG_INFO(".. action required %d", action_required );

        if (operating_mode_valid && ( DMS_OP_MODE_ONLINE_V01 == operating_mode))
        {
            QCRIL_LOG_DEBUG("Unexpected modem operating mode");
        }

        /* to power down the card */
        if (action_required)
        {
            NAS_CACHE_LOCK();
            if ( !nas_dms_cached_info.card_shutdown_initiated )
            {
                res = qcril_qmi_nas_dms_handle_card_status(QCRIL_EVT_INTERNAL_MMGSDI_CARD_POWER_DOWN);
                nas_dms_cached_info.card_shutdown_initiated = TRUE;
            }

            NAS_CACHE_UNLOCK();
        }

        /* shutdown the modem */
        else
        {
            /* setup an immediate timer callback */
            qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
                                       QCRIL_DEFAULT_MODEM_ID,
                                       qmi_ril_process_oem_hook_shutdown,
                                       NULL,
                                       NULL);
        }
    } while (FALSE);

    if (RIL_E_SUCCESS != res)
    {
        qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                          params_ptr->t,
                                          params_ptr->event_id,
                                          res,
                                          &resp);
        qcril_send_request_response(&resp);
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
} // qcril_qmi_nas_request_shutdown

//===========================================================================
// qmi_ril_process_oem_hook_shutdown
//===========================================================================
void qmi_ril_process_oem_hook_shutdown(void * param)
{
    qcril_reqlist_public_type             qcril_req_info;
    errno_enum_type                       found_qcril_request;
    qcril_request_resp_params_type        resp;
    RIL_Errno                             ril_req_res;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    found_qcril_request = E_FAILURE;
    ril_req_res = RIL_E_GENERIC_FAILURE;

    if (qcril_qmi_modem_power_is_voting_feature_supported())
    {
        qcril_qmi_modem_power_process_regular_shutdown();
        ril_req_res = RIL_E_SUCCESS;
    }
    else if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_APQ) ||
         qmi_ril_is_feature_supported(QMI_RIL_FEATURE_SGLTE2) )
    {
        ril_req_res = qcril_process_mdm_shutdown();
    }
    else
    {
        ril_req_res = RIL_E_SUCCESS;
    }

    found_qcril_request = qcril_reqlist_query_by_event(QCRIL_DEFAULT_INSTANCE_ID,
                                                       QCRIL_DEFAULT_MODEM_ID,
                                                       QCRIL_EVT_QMI_REQUEST_SHUTDOWN,
                                                       &qcril_req_info);

    /* sending response for oem hook shutdown request */
    if (E_SUCCESS == found_qcril_request)
    {
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           ril_req_res,
                                           &resp );
        qcril_send_request_response(&resp);
    }

    QCRIL_LOG_FUNC_RETURN();
} //qmi_ril_process_oem_hook_shutdown

//===========================================================================
// qcril_qmi_nas_card_status_translater
//===========================================================================
void qcril_qmi_nas_card_status_translater(qcril_timed_callback_handler_params_type * handler_params)
{
    qcril_evt_e_type uim_evt;
    RIL_Errno res;

    QCRIL_LOG_FUNC_ENTRY();

    uim_evt = (qcril_evt_e_type) handler_params->custom_param;
    res = qcril_qmi_nas_dms_handle_card_status(uim_evt);

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
} // qcril_qmi_nas_card_status_translater

//===========================================================================
// qcril_qmi_nas_dms_get_current_power_state
//===========================================================================
RIL_RadioState qcril_qmi_nas_dms_get_current_power_state ( qcril_instance_id_e_type instance_id )
{
    RIL_RadioState res = RADIO_STATE_UNAVAILABLE;
    dms_operating_mode_enum_v01 cur_op_mode = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    int cur_op_mode_valid = FALSE;

    QCRIL_LOG_FUNC_ENTRY();
    if ( qcril_qmi_client_is_available() )
    {
        QCRIL_LOG_INFO( ".. client available" );
        instance_id = instance_id;

        NAS_CACHE_LOCK();
        cur_op_mode_valid = NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode );
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
        {
            cur_op_mode = nas_dms_cached_info.operating_mode;
        }
        NAS_CACHE_UNLOCK();

        if ( FALSE == cur_op_mode_valid )
        {  // subfetch
            qcril_qmi_nas_query_cur_power_state(&cur_op_mode_valid, &cur_op_mode);
            QCRIL_LOG_INFO("subfetched" );
        }

        if( cur_op_mode_valid )
        {
            QCRIL_LOG_INFO(".. known modem operating mode %d ", cur_op_mode  );
            switch ( cur_op_mode )
            {
                case DMS_VAL_ONLINE:
                    res = RADIO_STATE_ON;
                    break;

                case DMS_VAL_LOW_POWER:
                case DMS_VAL_OFFLINE:
                case DMS_VAL_RESETTING:
                case DMS_VAL_SHUTTING_DOWN:
                    res = RADIO_STATE_OFF;
                    break;

                case DMS_VAL_FACTORY_TEST_MODE:
                    res = RADIO_STATE_UNAVAILABLE;
                    break;

                default:
                    res = RADIO_STATE_UNAVAILABLE; // still unknown
                    break;
            }
        }
    }
    QCRIL_LOG_INFO("compled with %d", (int) res  );

    return res;
} // qcril_qmi_nas_dms_get_current_power_state

//===========================================================================
// qcril_qmi_nas_dms_is_in_online_mode
//===========================================================================
boolean qcril_qmi_nas_dms_is_in_online_mode()
{
    boolean ret = FALSE;
    NAS_CACHE_LOCK();
    if (  NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode )&&
         DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode )
    {
        ret = TRUE;
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_nas_dms_is_in_online_mode

//===========================================================================
// qcril_qmi_nas_dms_is_in_ftm_mode
//===========================================================================
boolean qcril_qmi_nas_dms_is_in_ftm_mode()
{
    boolean ret = FALSE;
    NAS_CACHE_LOCK();
    if (  NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode )&&
         DMS_OP_MODE_FACTORY_TEST_MODE_V01 == nas_dms_cached_info.operating_mode )
    {
        ret = TRUE;
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_nas_dms_is_in_ftm_mode

//===========================================================================
// qcril_qmi_nas_is_radio_power_check_enabled
//===========================================================================
boolean qcril_qmi_nas_is_radio_power_check_enabled()
{
    boolean ret;
    NAS_CACHE_LOCK();
    ret = nas_common_info.is_radio_power_check_enabled;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} // qcril_qmi_nas_is_radio_power_check_enabled

//===========================================================================
// qcril_qmi_nas_query_cur_power_state
//===========================================================================
void qcril_qmi_nas_query_cur_power_state(int * op_mode_valid, dms_operating_mode_enum_v01 * op_mode)
{
    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    dms_get_operating_mode_resp_msg_v01 qmi_response;
    qmi_client_error_type qmi_transport_error;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_response,0,sizeof(qmi_response));

    NAS_CACHE_LOCK();
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                       QMI_DMS_GET_OPERATING_MODE_REQ_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);

    QCRIL_LOG_INFO("msg send error code %d",ril_req_res);

    if ( RIL_E_SUCCESS == ril_req_res )
    {
        QCRIL_LOG_INFO(".. known modem operating mode %d ", (int) qmi_response.operating_mode );

        NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.operating_mode, qmi_response.operating_mode );

        *op_mode_valid = TRUE;
        *op_mode = qmi_response.operating_mode;

        qcril_qmi_nas_dms_update_common_modem_state();

    }
    else
    {
        *op_mode_valid = FALSE;
        *op_mode = DMS_OPERATING_MODE_ENUM_MIN_ENUM_VAL_V01;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_query_cur_power_state

//===========================================================================
// qcril_qmi_nas_initiate_radio_state_changed_ind
//===========================================================================
void qcril_qmi_nas_initiate_radio_state_changed_ind(void)
{
    QCRIL_LOG_FUNC_ENTRY();
    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_SEND_UNSOL_RADIO_STATE_CHANGED,
                   NULL,
                   NAS_NIL,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_initiate_radio_state_changed_ind


//===========================================================================
// QCRIL_EVT_QMI_RIL_SEND_UNSOL_RADIO_STATE_CHANGED
//===========================================================================
void qcril_qmi_nas_send_unsol_radio_state_changed
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(params_ptr);
    QCRIL_NOTUSED(ret_ptr);

    qmi_ril_wave_modem_status();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_send_unsol_radio_state_changed

//===========================================================================
//qcril_qmi_voice_ims_send_unsol_radio_state_change_helper
//===========================================================================
void qcril_qmi_voice_ims_send_unsol_radio_state_change_helper()
{
   qcril_modem_state_e_type modem_state;

   modem_state = QCRIL_MODEM_STATE_UNAVAILABLE;

   QCRIL_LOG_FUNC_ENTRY();

   NAS_CACHE_LOCK();

   if( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
   {
     switch ( nas_dms_cached_info.operating_mode )
     {
         case DMS_VAL_ONLINE:
             modem_state = QCRIL_MODEM_STATE_ON;
             break;

         case DMS_VAL_LOW_POWER:
         case DMS_VAL_OFFLINE:
         case DMS_VAL_RESETTING:
         case DMS_VAL_SHUTTING_DOWN:
             modem_state = QCRIL_MODEM_STATE_OFF;
             break;

         default:
             modem_state = QCRIL_MODEM_STATE_UNAVAILABLE;
             break;
     }
   }
   NAS_CACHE_UNLOCK();

   QCRIL_LOG_DEBUG("modem_state is %d",modem_state);

   qcril_qmi_voice_ims_send_unsol_radio_state_change(modem_state);

   QCRIL_LOG_FUNC_RETURN_WITH_RET(modem_state);
}//qcril_qmi_voice_ims_send_unsol_radio_state_change_helper

//===========================================================================
// qcril_qmi_nas_dms_update_multisim_config_property
//===========================================================================
void qcril_qmi_nas_dms_update_multisim_config_property()
{

    char prop_val[ QMI_RIL_SYS_PROP_LENGTH_MULTI_SIM + 1 ];
    int is_prop_set_required = FALSE;

    QCRIL_LOG_FUNC_ENTRY();

    property_get( QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val, "" );
    QCRIL_LOG_INFO ( "Multisim prop val %s", prop_val );

    if ( ( nas_dms_cached_info.max_subscriptions == QMI_RIL_NUM_TRIPLE_SUB ) &&
         ( nas_dms_cached_info.max_subscriptions_active == QMI_RIL_NUM_SINGLE_ACTIVE ) )
    {
         if ( strncmp(prop_val, "tsts", QMI_RIL_SYS_PROP_LENGTH_MULTI_SIM ) != 0 )
         {
             strlcpy(prop_val,"tsts",sizeof(prop_val));
             is_prop_set_required = TRUE;
         }
    }
    else if ( ( nas_dms_cached_info.max_subscriptions ==  QMI_RIL_NUM_DUAL_SUB ) &&
              ( nas_dms_cached_info.max_subscriptions_active == QMI_RIL_NUM_DUAL_ACTIVE ) )
    {
        if ( strncmp(prop_val, "dsda", PROPERTY_VALUE_MAX ) != 0 )
        {
            strlcpy(prop_val,"dsda",sizeof(prop_val));
            is_prop_set_required = TRUE;
        }
    }
    else if ( ( nas_dms_cached_info.max_subscriptions == QMI_RIL_NUM_DUAL_SUB ) &&
              ( nas_dms_cached_info.max_subscriptions_active == QMI_RIL_NUM_SINGLE_ACTIVE ) )
    {
        if ( strncmp(prop_val, "dsds", PROPERTY_VALUE_MAX ) != 0 )
        {
            strlcpy(prop_val,"dsds",sizeof(prop_val));
            is_prop_set_required = TRUE;
        }
    }

    if ( is_prop_set_required == TRUE )
    {
        QCRIL_LOG_INFO ( "Setting Multisim prop val %s", prop_val );
        if ( property_set( QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val ) != E_SUCCESS )
        {
            QCRIL_LOG_ERROR( "Fail to save %s to system property", QMI_RIL_SYS_PROP_NAME_MULTI_SIM );
        }
        else
        {
           // On successful property setting, reset multi sim feature info.
           qmi_ril_reset_multi_sim_ftr_info();
        }
    }
    else
    {
        QCRIL_LOG_INFO ( "Property %s already set to %s", QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val );
    }
    QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// qcril_qmi_nas_dms_update_common_modem_state
//===========================================================================
void qcril_qmi_nas_dms_update_common_modem_state()
{
    qcril_modem_state_e_type modem_state;

    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        switch ( nas_dms_cached_info.operating_mode )
        {
            case DMS_VAL_ONLINE:
                modem_state = QCRIL_MODEM_STATE_ON;
                break;

            case DMS_VAL_LOW_POWER:
            case DMS_VAL_OFFLINE:
            case DMS_VAL_RESETTING:
            case DMS_VAL_SHUTTING_DOWN:
                modem_state = QCRIL_MODEM_STATE_OFF;
                break;

            case DMS_VAL_FACTORY_TEST_MODE:    // fallthrough
            default:
                modem_state = QCRIL_MODEM_STATE_UNAVAILABLE; // unknown
                break;
        }
        qcril_qmi_mgr_modem_state_updated( QCRIL_DEFAULT_INSTANCE_ID, modem_state );
    }
} // qcril_qmi_nas_dms_update_common_modem_state

//===========================================================================
// qcril_qmi_nas_update_radio_power_request_info
//===========================================================================
void qcril_qmi_nas_update_radio_power_request_info()
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if( QMI_RIL_DMS_RADIO_PWR_REQUEST_NONE == nas_common_info.radio_power_request_type )
    {
        nas_common_info.radio_power_request_type = QMI_RIL_DMS_RADIO_PWR_REQUEST_BOOTUP_RADIO_POWER_OFF;
    }
    else
    {
        nas_common_info.radio_power_request_type = QMI_RIL_DMS_RADIO_PWR_REQUEST_OTHER;
    }
    QCRIL_LOG_INFO("Updated the radio power request type to %s",radio_power_request_name[nas_common_info.radio_power_request_type]);
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_update_radio_power_request_info

//===========================================================================
// qcril_qmi_nas_is_bootup_radio_power_off_request
//===========================================================================
int qcril_qmi_nas_is_bootup_radio_power_off_request()
{
    int ret = FALSE;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    QCRIL_LOG_INFO("radio power request type is %s",radio_power_request_name[nas_common_info.radio_power_request_type]);
    if( QMI_RIL_DMS_RADIO_PWR_REQUEST_BOOTUP_RADIO_POWER_OFF == nas_common_info.radio_power_request_type )
    {
        ret = TRUE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_is_bootup_radio_power_off_request

//===========================================================================
// qcril_qmi_nas_is_apm_enabled
//===========================================================================
int qcril_qmi_nas_is_apm_enabled()
{
    unsigned long res = FALSE;
    int temp_len;
    char property_name[ 40 ];
    char args[ PROPERTY_VALUE_MAX ];
    char *end_ptr;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QMI_RIL_APM_ON );
    property_get( property_name, args, "" );
    temp_len = strlen( args );
    if ( temp_len > 0 )
    {
      res = strtoul( args, &end_ptr, 0 );
      if ( (( errno == ERANGE ) && ( res == ULONG_MAX )) || res > 1 )
      {
        QCRIL_LOG_ERROR( "Fail to convert QMI_RIL_APM_ON %s", args );
        res = FALSE;
      }
    }

    QCRIL_LOG_INFO( "completed, QMI_RIL_APM_ON = %d", res);

    return res;

} // qcril_qmi_nas_is_apm_enabled

//===========================================================================
//qcril_qmi_nas_multiple_rild_radio_power_timeout_cb
//===========================================================================
void qcril_qmi_nas_multiple_rild_radio_power_timeout_cb(void * param)
{
    qcril_reqlist_public_type             qcril_req_info;
    errno_enum_type                       found_qcril_request;
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(param);

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                        QCRIL_DEFAULT_MODEM_ID,
                                                        QCRIL_EVT_QMI_REQUEST_POWER_RADIO,
                                                        &qcril_req_info );

    RADIO_POWER_LOCK();
    nas_common_info.radio_power_multiple_rild_process_timer_valid = FALSE;

    if ( E_SUCCESS != found_qcril_request )
    {
       //communicate to the other rild that your radio power process is complete - FAKE signal
       nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN;
       nas_common_info.radio_power_multiple_rild_process_complete_num = NAS_NIL;
       qcril_multiple_rild_ipc_radio_power_propagation_helper_func(FALSE);
    }
    RADIO_POWER_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_multiple_rild_radio_power_timeout_cb

//===========================================================================
// qcril_qmi_nas_handle_multiple_rild_radio_power_sync
//===========================================================================
void qcril_qmi_nas_handle_multiple_rild_radio_power_sync(int requested_telephony_power_state)
{
  QCRIL_LOG_FUNC_ENTRY();

  RADIO_POWER_LOCK();
  qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_INITIATING_MULTIPLE_RILD_SYNC);

  if( TRUE == nas_common_info.radio_power_multiple_rild_process_timer_valid )
  {
      QCRIL_LOG_INFO("Cancelling the radio power expiry timer as we have completed our radio power process");
      qcril_cancel_timed_callback( (void*)(uintptr_t) nas_common_info.radio_power_multiple_rild_process_timer );
      nas_common_info.radio_power_multiple_rild_process_timer_valid = FALSE;
  }

  qcril_multiple_rild_ipc_radio_power_propagation_helper_func(TRUE); //communicate to the other rild that your radio power process is complete  - GENUINE signal
  if( QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_DONE != nas_common_info.radio_power_sync_type ) //other rild's radio power process is not yet complete, so wait for its completion
  {
      qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_WAITING_FOR_MULTIPLE_RILD_SYNC);
      nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_WAITING;
      RADIO_POWER_WAIT();
  }
  nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_UNKNOWN; //resetting state information
  qcril_qmi_nas_log_radio_power_process_state(requested_telephony_power_state,QMI_RIL_DMS_RADIO_PWR_STATE_MULTIPLE_RILD_SYNC_DONE);
  RADIO_POWER_UNLOCK();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_handle_multiple_rild_radio_power_sync


//===========================================================================
// qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation
//===========================================================================
//called when the other rild wants to indicate that its radio power process is complete
void qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation(int is_genuine_signal)
{
  qcril_reqlist_public_type             qcril_req_info;
  errno_enum_type                       found_qcril_request;
  const struct timeval radio_power_tmr_expiry = { 5 , 0 }; // 5 seconds
  int wake_up_radio_power_thread = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_QMI_REQUEST_POWER_RADIO,
                                                      &qcril_req_info );

  RADIO_POWER_LOCK();
  if ( is_genuine_signal || E_SUCCESS == found_qcril_request )
  {
       nas_common_info.radio_power_multiple_rild_process_complete_num++;
  }

  QCRIL_LOG_INFO( "is_genuine_signal from other rild %d, completed number of other rilds %d,"
                  "is radio power request received %d, radio power expiry timer already created %d",
                  is_genuine_signal,
                  nas_common_info.radio_power_multiple_rild_process_complete_num,
                  (E_SUCCESS == found_qcril_request),
                  nas_common_info.radio_power_multiple_rild_process_timer_valid );

  //other rild's have completed their radio power processes
  if( nas_common_info.radio_power_multiple_rild_process_complete_num == (qmi_ril_retrieve_number_of_rilds() - 1) )
  {
      // if our radio power process is NOT complete, we just remember that the other rild's radio power
      // process is complete.
      wake_up_radio_power_thread = ( QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_WAITING
                                    == nas_common_info.radio_power_sync_type );
      nas_common_info.radio_power_sync_type = QMI_RIL_DMS_RADIO_PWR_MULTIPLE_RILD_RADIO_POWER_SYNC_DONE;
      nas_common_info.radio_power_multiple_rild_process_complete_num = NAS_NIL;
  }

  // radio power request has been sent to us
  if ( E_SUCCESS == found_qcril_request )
  {
       // our radio power process thread is complete and is waiting
       if( TRUE == wake_up_radio_power_thread )
       {
          // since the other rild's radio power process is complete,wake up our radio power
          // process thread so that it can respond back to RADIO_POWER request
          RADIO_POWER_SIGNAL();
       }
  }
  // no radio power request has been sent to us- We would fake signal the other rilds after
  // radio_power_tmr_expiry time period. We create a radio_power timer only If the signal is
  // genuine and we have not already created it.
  else
  {
      if( TRUE == is_genuine_signal && FALSE == nas_common_info.radio_power_multiple_rild_process_timer_valid )
      {
          nas_common_info.radio_power_multiple_rild_process_timer_valid = TRUE;
          qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      qcril_qmi_nas_multiple_rild_radio_power_timeout_cb,
                                      &radio_power_tmr_expiry,
                                      &nas_common_info.radio_power_multiple_rild_process_timer );
      }
  }

  RADIO_POWER_UNLOCK();
  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_handle_multiple_rild_radio_power_state_propagation


//===========================================================================
// RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE
//===========================================================================
void qcril_qmi_nas_query_network_selection_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_get_system_selection_preference_resp_msg_v01 qmi_response;
  qmi_client_error_type qmi_client_error;
  int is_cached;
  int network_selection_mode = 0;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );
  NAS_CACHE_LOCK();

  is_cached = NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.net_sel_pref);
  QCRIL_LOG_INFO( "is_cached=%d",is_cached );
  if( !is_cached )
  {
      memset(&qmi_response,0,sizeof(qmi_response));
      qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                NULL,
                                NAS_ZERO,
                                (void*) &qmi_response,
                                sizeof( qmi_response ),
                                QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);
      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
      QCRIL_LOG_INFO( "code=%d-value=%d",ril_req_res,qmi_response.net_sel_pref_valid );
      if( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();
          NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.net_sel_pref, qmi_response.net_sel_pref);
          if( !NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.net_sel_pref))
          {
              ril_req_res = RIL_E_GENERIC_FAILURE;
          }
          NAS_CACHE_UNLOCK();
      }
  }
  else
  {
      ril_req_res = RIL_E_SUCCESS;
  }

  if( RIL_E_SUCCESS == ril_req_res )
  {
      NAS_CACHE_LOCK();
      network_selection_mode = (nas_cached_info.net_sel_pref == NAS_NET_SEL_PREF_MANUAL_V01) ? 1 : 0; // 0 - auto, 1 - manual
      NAS_CACHE_UNLOCK();
  }
  else
  {
      network_selection_mode = 0;
  }

  QCRIL_LOG_INFO( "network_selection_mode: %d, ril_req_res: %d", (int)network_selection_mode, (int)ril_req_res );
  NAS_CACHE_UNLOCK();
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
  resp.resp_pkt = &network_selection_mode;
  resp.resp_len = sizeof(network_selection_mode);
  qcril_send_request_response( &resp );
} // qcril_qmi_nas_query_network_selection_mode

//===========================================================================
// RIL_REQUEST_SET_BAND_MODE
//===========================================================================
void qcril_qmi_nas_set_band_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  int* req_val;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_set_system_selection_preference_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  if ( params_ptr->datalen > NAS_ZERO && params_ptr->data != NULL )
  {
      // todo: add check if manual nw selection or nw scan is ongoing -> block set band mode in that case

      req_val = (int * )params_ptr->data;
      memset( &qmi_request, 0, sizeof( qmi_request ) );
      qmi_request.band_pref_valid = TRUE;

      ril_req_res = RIL_E_SUCCESS;
      switch ( *req_val )
      {
          case RIL_VAL_BAND_ANY: // for "unspecified" (selected by baseband automatically)
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_ANY;
              break;

          case RIL_VAL_BAND_EURO: // for "EURO band" (GSM-900 / DCS-1800 / WCDMA-IMT-2000)
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_EURO;
              break;

          case RIL_VAL_BAND_US: // for "US band" (GSM-850 / PCS-1900 / WCDMA-850 / WCDMA-PCS-1900)
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_US;
              break;

          case RIL_VAL_BAND_JPN: // for "JPN band" (WCDMA-800 / WCDMA-IMT-2000)
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_JPN;
              break;

          case RIL_VAL_BAND_AUS: // for "AUS band" (GSM-900 / DCS-1800 / WCDMA-850 / WCDMA-IMT-2000):
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_AUS;
              break;

          case RIL_VAL_BAND_AUS2: // for "AUS band 2" (GSM-900 / DCS-1800 / WCDMA-850)
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_AUS2;
              break;

          case RIL_VAL_BAND_CELLULAR: // for "Cellular (800-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_CELLULAR;
              break;

          case RIL_VAL_BAND_PCS: // for "PCS (1900-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_PCS;
              break;

          case RIL_VAL_BAND_JTACS: // for "Band Class 3 (JTACS Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_JTACS;
              break;

          case RIL_VAL_BAND_KOREAN_PCS: // for "Band Class 4 (Korean PCS Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_KOREAN_PCS;
              break;

          case RIL_VAL_BAND_450_MHZ: // for "Band Class 5 (450-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_450_MHZ;
              break;

          case RIL_VAL_BAND_2_GHZ: // for "Band Class 6 (2-GMHz IMT2000 Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_2_GHZ;
              break;

          case RIL_VAL_BAND_UPPER_700_MHZ: // for "Band Class 7 (Upper 700-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ;
              break;

          case RIL_VAL_BAND_1800_MHZ: // for "Band Class 8 (1800-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_1800_MHZ;
              break;

          case RIL_VAL_BAND_900_MHZ: // for "Band Class 9 (900-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_900_MHZ;
              break;


          case RIL_VAL_BAND_SEC_800_MHZ: // for "Band Class 10 (Secondary 800-MHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ;
              break;

          case RIL_VAL_BAND_SEC_EUOROPEAN_PAMR: // for "Band Class 11 (400-MHz European PAMR Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR;
              break;

          case RIL_VAL_BAND_SEC_AWS: // for "Band Class 15 (AWS Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_AWS;
              break;

          case RIL_VAL_BAND_SEC_US_2_5_GHZ: // for "Band Class 16 (US 2.5-GHz Band)"
              qmi_request.band_pref = NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ;
              break;

          default: // unsupported
              ril_req_res = RIL_E_GENERIC_FAILURE;
              break;
      }

      if ( RIL_E_SUCCESS == ril_req_res )
      {
          qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                             QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                             &qmi_request,
                                                             sizeof( qmi_request ),
                                                             (void*) &qmi_response,
                                                             sizeof( qmi_response ),
                                                             QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

          ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res );

} // qcril_qmi_nas_set_band_mode

//===========================================================================
// RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE
//===========================================================================
void qcril_qmi_nas_query_available_band_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  int ril_response[ NAS_RIL_MAX_BAND_CAPACITY_LIST_SIZE ];
  int cur_band_idx = NAS_NIL;

  uint64_t  band_capability_remains;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  dms_get_band_capability_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  QCRIL_LOG_FUNC_ENTRY();

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  ril_response[ NAS_ZERO ] = NAS_NIL;
  memset(&qmi_response, 0, sizeof(qmi_response));

  QCRIL_NOTUSED( ret_ptr );
  NAS_CACHE_LOCK();
  qmi_client_error =  qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                      QMI_DMS_GET_BAND_CAPABILITY_REQ_V01,
                                                         NULL,
                                                         NAS_ZERO, // empty payload
                                                         (void*) &qmi_response,
                                                         sizeof( qmi_response ),
                                                         QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

      if ( RIL_E_SUCCESS == ril_req_res )
      {
          NAS_CACHE_LOCK();
          NAS_CACHE_STORE_TINY_ENTRY_VAL( nas_dms_cached_info.band_capability, qmi_response.band_capability );
          NAS_CACHE_UNLOCK();
      }
      else
      {
          QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)ril_req_res, (int)qmi_client_error );
      }

  if ( RIL_E_SUCCESS == ril_req_res )
  {
      NAS_CACHE_LOCK();
      band_capability_remains = nas_dms_cached_info.band_capability;
      NAS_CACHE_UNLOCK();

      // check for any
      if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_ANY) == NAS_VAL_BAND_PREF_COMB_ANY )
      {
          ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_ANY;
      }
      else
      {
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_EURO ) == NAS_VAL_BAND_PREF_COMB_EURO )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_EURO;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_US ) == NAS_VAL_BAND_PREF_COMB_US )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_US;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_JPN ) == NAS_VAL_BAND_PREF_COMB_JPN )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_JPN;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_AUS ) == NAS_VAL_BAND_PREF_COMB_AUS )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_AUS;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_AUS2 ) == NAS_VAL_BAND_PREF_COMB_AUS2 )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_AUS2;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_CELLULAR ) == NAS_VAL_BAND_PREF_COMB_CELLULAR )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_CELLULAR;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_PCS ) == NAS_VAL_BAND_PREF_COMB_PCS )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_PCS;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_JTACS ) == NAS_VAL_BAND_PREF_COMB_JTACS )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_JTACS;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_KOREAN_PCS ) == NAS_VAL_BAND_PREF_COMB_KOREAN_PCS )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_KOREAN_PCS;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_450_MHZ ) == NAS_VAL_BAND_PREF_COMB_450_MHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_450_MHZ;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_2_GHZ ) == NAS_VAL_BAND_PREF_COMB_2_GHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_2_GHZ;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ ) == NAS_VAL_BAND_PREF_COMB_UPPER_700_MHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_UPPER_700_MHZ;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_1800_MHZ ) == NAS_VAL_BAND_PREF_COMB_1800_MHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_1800_MHZ;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_900_MHZ ) == NAS_VAL_BAND_PREF_COMB_900_MHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_900_MHZ;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ ) == NAS_VAL_BAND_PREF_COMB_SEC_800_MHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_SEC_800_MHZ;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR ) == NAS_VAL_BAND_PREF_COMB_EUOROPEAN_PAMR )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_SEC_EUOROPEAN_PAMR;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_AWS ) == NAS_VAL_BAND_PREF_COMB_AWS )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_SEC_AWS;
          }
          if ( (band_capability_remains & NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ ) == NAS_VAL_BAND_PREF_COMB_US_2_5_GHZ )
          {
              ril_response[ ++cur_band_idx ] = RIL_VAL_BAND_SEC_US_2_5_GHZ;
          }
      }
      ril_response[ NAS_ZERO ] = cur_band_idx; // count

  }

  NAS_CACHE_UNLOCK();
  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_LOG_INFO( ".. nof bands returned %d", ril_response[ NAS_ZERO ] );
      resp.resp_pkt = &ril_response;
      resp.resp_len = sizeof( int ) * (ril_response[ NAS_ZERO ] + 1) ;
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_FUNC_RETURN_WITH_RET( ril_req_res );
} // qcril_qmi_nas_query_available_band_mode

//===========================================================================
// qcril_qmi_nas_retrieve_scan_network_type
//===========================================================================
int qcril_qmi_nas_retrieve_scan_network_type(nas_network_type_mask_type_v01 *scan_network_type)
{
    int ret;
    uint8_t mode_pref_valid;
    uint16_t mode_pref;

    QCRIL_LOG_FUNC_ENTRY();

    ret = FALSE;

    if( scan_network_type )
    {
        *scan_network_type = NAS_NIL;
        mode_pref_valid = qcril_qmi_nas_get_mode_pref(&mode_pref);
        if( FALSE == mode_pref_valid )
        {
            qcril_qmi_fetch_system_selection_preference();
            mode_pref_valid = qcril_qmi_nas_get_mode_pref(&mode_pref);
        }

        if( TRUE == mode_pref_valid )
        {
            if( mode_pref & QMI_NAS_RAT_MODE_PREF_GSM_V01 )
            {
                *scan_network_type |= NAS_NETWORK_TYPE_GSM_ONLY_V01;
            }
            if( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS_V01 )
            {
                *scan_network_type |= NAS_NETWORK_TYPE_WCDMA_ONLY_V01;
            }
            if( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE_V01 )
            {
                *scan_network_type |= NAS_NETWORK_TYPE_LTE_ONLY_V01;
            }
            if( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA_V01 )
            {
                *scan_network_type |= NAS_NETWORK_TYPE_TDSCDMA_ONLY_V01;
            }
            ret = TRUE;
        }
        QCRIL_LOG_INFO("scan network type is %d", *scan_network_type);
    }
    else
    {
        QCRIL_LOG_FATAL("Null pointer passed for scan_network_type");
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
} //qcril_qmi_nas_retrieve_scan_network_type

int qcril_qmi_nas_fill_network_scan_response
(
uint32 nw_info_len,
qcril_qmi_nas_nw_scan_info_helper_type * nw_scan_helper,
qcril_qmi_nw_scan_resp_helper_type * ril_rep_helper,
int *p_entries
)
{
  unsigned int nw_cnt = 0;
  unsigned int no_of_entries;
  unsigned int iter_j;
  unsigned int iter_i;

  char * info_str;
  uint8_t nw_status;
  int res, is_current_nw, duplicate_name_found;
  char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],current_mnc_str[NAS_MCC_MNC_MAX_SIZE],qmi_nw_info_mcc_str[NAS_MCC_MNC_MAX_SIZE],qmi_nw_info_mnc_str[NAS_MCC_MNC_MAX_SIZE];
  int rat = RADIO_TECH_UNKNOWN;
  char*  ref_name;
  char   ref_name_org[NAS_OPERATOR_RESP_MAX_EONS_LEN];

  char*  long_name_for_dup;
  char*  short_name_for_dup;
  int    any_changes_from_duplicate_filtering;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();
  res = qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, TRUE, NULL);
  NAS_CACHE_UNLOCK();

  no_of_entries = ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_LEGACY_RAT) ) ?
      NUM_OF_STRINGS_WITH_LEGACY_RAT : NUM_OF_STRINGS_WITH_COMBINED_RAT_OR_NO_RAT;
  *p_entries = no_of_entries;
  memset( ril_rep_helper, 0, sizeof( qcril_qmi_nw_scan_resp_helper_type ) );
  QCRIL_LOG_INFO("Network Info (long/short/mcc_mnc/status)");
  QCRIL_LOG_INFO("Number of Scanned Network(s) : %d", nw_info_len);
  for ( iter_i = 0; iter_i < nw_info_len; iter_i++ )
  {
    snprintf( qmi_nw_info_mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)nw_scan_helper->mcc );
    if ( (nw_scan_helper->mnc > 99) ||  (nw_scan_helper->mnc_includes_pcs_digit) )
    {
      snprintf( qmi_nw_info_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)nw_scan_helper->mnc );
    }
    else
    {
      snprintf( qmi_nw_info_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int)nw_scan_helper->mnc );
    }
    info_str = ril_rep_helper->mccmnc_info[ nw_cnt ];
    snprintf( ril_rep_helper->mccmnc_info[ nw_cnt ], sizeof(ril_rep_helper->mccmnc_info[ nw_cnt ]), "%s%s", qmi_nw_info_mcc_str,qmi_nw_info_mnc_str);
    is_current_nw = res && !strcmp(current_mcc_str,qmi_nw_info_mcc_str) && !strcmp(current_mnc_str,qmi_nw_info_mnc_str);
    if( TRUE == qcril_qmi_nas_is_centralized_eons_supported() || TRUE == qmi_ril_is_feature_supported(QMI_RIL_FEATURE_8960) )
    {
      if ( nw_scan_helper->plmn_rat_valid )
      {
        QCRIL_LOG_INFO ("RAT received in perform_nw_scan response %d", (int) nw_scan_helper->plmn_rat);
      }
      qcril_qmi_util_handle_centralized_short_long_eons(qmi_nw_info_mcc_str, qmi_nw_info_mnc_str, ril_rep_helper->short_eons[ nw_cnt ], ril_rep_helper->long_eons[ nw_cnt ], TRUE, nw_scan_helper->plmn_rat, FALSE, 0);
    }
    else
    {
      NAS_CACHE_LOCK();
      qcril_qmi_nas_fill_up_operator_name(is_current_nw,
                                          qmi_nw_info_mcc_str,
                                          qmi_nw_info_mnc_str,
                                          info_str,
                                          ril_rep_helper->long_eons[ nw_cnt ],            // long alpha ONS or EONS
                                          sizeof(ril_rep_helper->long_eons[ nw_cnt ]),
                                          ril_rep_helper->short_eons[ nw_cnt ],           // short alpha ONS or EONS
                                          sizeof(ril_rep_helper->short_eons[ nw_cnt ]) );
       NAS_CACHE_UNLOCK();
    }


    if ( *(ril_rep_helper->long_eons[ nw_cnt ]) && !*(ril_rep_helper->short_eons[ nw_cnt ]) && TRUE == nas_common_info.fill_eons)
    {
      QCRIL_LOG_INFO("Filling short eons with long eons");
      strlcpy( ril_rep_helper->short_eons[ nw_cnt ], ril_rep_helper->long_eons[ nw_cnt ] , sizeof(ril_rep_helper->short_eons[ nw_cnt ]));
    }

    if ( *(ril_rep_helper->short_eons[ nw_cnt ]) && !*(ril_rep_helper->long_eons[ nw_cnt ]) && TRUE == nas_common_info.fill_eons)
    {
      QCRIL_LOG_INFO("Filling long eons with short eons");
      strlcpy( ril_rep_helper->long_eons[ nw_cnt ], ril_rep_helper->short_eons[ nw_cnt ] , sizeof(ril_rep_helper->long_eons[ nw_cnt ]));
    }

    if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() ) //Need to filter duplicate PLMN's when RAT reporting is not supported in ril.h interface
    {
      if( TRUE == qcril_qmi_util_is_plmn_already_added_to_nw_scan_results(qmi_nw_info_mcc_str, qmi_nw_info_mnc_str, ril_rep_helper->short_eons[ nw_cnt ], ril_rep_helper->long_eons[ nw_cnt ], ril_rep_helper, nw_cnt) )
      {
        QCRIL_LOG_INFO("PLMN already added!");
        nw_scan_helper++;
        ril_rep_helper->short_eons[ nw_cnt ][0] = '\0';
        ril_rep_helper->long_eons[ nw_cnt ][0]  = '\0';
        continue;
      }
    }

    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ] = ril_rep_helper->long_eons[ nw_cnt ];
    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ] = ril_rep_helper->short_eons[ nw_cnt ];
    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ] = info_str;  // 5 or 6 digit numeric code (MCC + MNC)


    nw_status = nw_scan_helper->network_status;
    if ( is_current_nw && (nw_status & NAS_NW_SCAN_RES_ENTRY_CUR_SERVING) )
    {
      info_str = "current";
    }
    else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_FORBIDDEN )
    {
      info_str = "forbidden";
    }
    else if ( nw_status & NAS_NW_SCAN_RES_ENTRY_AVAILABLE )
    {
      info_str = "available";
    }
    else
    {
      info_str = "unknown";
    }
    ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ] = info_str;  // nw status
    if ( QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() )
    {
      if( nw_scan_helper->plmn_rat_valid )
      {
        switch(nw_scan_helper->plmn_rat)
        {
          case NAS_RADIO_IF_GSM:
               rat = RADIO_TECH_EDGE;
               break;

          case NAS_RADIO_IF_UMTS:
               rat = RADIO_TECH_UMTS;
               break;

          case NAS_RADIO_IF_LTE:
               rat = RADIO_TECH_LTE;
               break;

          case NAS_RADIO_IF_TDSCDMA:
               rat = RADIO_TECH_TD_SCDMA;
               break;

          default:
               rat = RADIO_TECH_UNKNOWN;
               break;
        }
      }
      else
      {
        rat = RADIO_TECH_UNKNOWN;
      }

      QCRIL_SNPRINTF( ril_rep_helper->rat[ nw_cnt ], sizeof( ril_rep_helper->rat[ nw_cnt ] ), "%d", rat );
      if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_LEGACY_RAT) )
      {
        ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 4 ] =  ril_rep_helper->rat[ nw_cnt ];
        QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s/%s",nw_cnt+1,
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 4 ]);
      }
      else if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_COMBINE_RAT) )
      {

        /*
         * Append "+RAT" to PLMN string
         * ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ]
         * is pointing to ril_rep_helper->mccmnc_info[ nw_cnt ]
         */
         strlcat( ril_rep_helper->mccmnc_info[ nw_cnt ], "+",
                sizeof( ril_rep_helper->mccmnc_info[ nw_cnt ] ) );
         strlcat( ril_rep_helper->mccmnc_info[ nw_cnt ],
                ril_rep_helper->rat[ nw_cnt ], sizeof( ril_rep_helper->mccmnc_info[ nw_cnt ] ) );
         ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ] =
                ril_rep_helper->mccmnc_info[ nw_cnt ];
         QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s",nw_cnt+1,
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ],
                ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ]);
      }
    }
    else
    {
      QCRIL_LOG_INFO("Network #%d - %s/%s/%s/%s",nw_cnt+1,
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt ],
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 1 ],
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 2 ],
                                   ril_rep_helper->nw_scan_info_array[ no_of_entries * nw_cnt + 3 ]);
    }
    nw_cnt++;
    nw_scan_helper++;
  } /* for loop of iter_i */

  if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() && nw_cnt > 1 && TRUE == nas_common_info.process_duplicate_nw_scan_names )
  {
    any_changes_from_duplicate_filtering = FALSE;
    QCRIL_LOG_INFO( "attempt to filter out duplicate names" );
    for ( iter_i = 0; iter_i < (unsigned)(nw_cnt - 1); iter_i++ )
    {
      // long
      ref_name = ril_rep_helper->long_eons[ iter_i ];
      duplicate_name_found = FALSE;
      for ( iter_j = iter_i + 1; iter_j < nw_cnt && !duplicate_name_found ; iter_j++ )
      {
        if ( 0 == strcmp( ref_name, ril_rep_helper->long_eons[ iter_j ] ) )
        {
          duplicate_name_found = TRUE;
        }
      }
      if ( duplicate_name_found )
      { // patch all duplicate names
        strlcpy( ref_name_org, ref_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
        for ( iter_j = iter_i; iter_j < nw_cnt; iter_j++ )
        {
          if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->long_eons[ iter_j ] ) ) )
          {
             long_name_for_dup   = NULL;
             qcril_qmi_nas2_find_elaboration_static_name( ril_rep_helper->mccmnc_info[ iter_j ], &long_name_for_dup, NULL );
             if ( NULL != long_name_for_dup )
             {
               strlcpy( ril_rep_helper->long_eons[ iter_j ], long_name_for_dup, NAS_OPERATOR_RESP_MAX_EONS_LEN );
               any_changes_from_duplicate_filtering = TRUE;
             }
           } // if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->long_eons[ iter_j ] ) ) )
         }
       }  // if ( duplicate_name_found )

       // short
       ref_name = ril_rep_helper->short_eons[ iter_i ];
       duplicate_name_found = FALSE;
       for ( iter_j = iter_i + 1; iter_j < nw_cnt && !duplicate_name_found ; iter_j++ )
       {
         if ( 0 == strcmp( ref_name, ril_rep_helper->short_eons[ iter_j ] ) )
         {
           duplicate_name_found = TRUE;
         }
       }
       if ( duplicate_name_found )
       { // patch all duplicate names
         strlcpy( ref_name_org, ref_name, NAS_OPERATOR_RESP_MAX_EONS_LEN );
         for ( iter_j = iter_i; iter_j < nw_cnt; iter_j++ )
         {
           if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->short_eons[ iter_j ] ) ) )
           {
              short_name_for_dup  = NULL;
              qcril_qmi_nas2_find_elaboration_static_name( ril_rep_helper->mccmnc_info[ iter_j ], NULL, &short_name_for_dup  );
              if ( NULL != short_name_for_dup )
              {
                strlcpy( ril_rep_helper->short_eons[ iter_j ], short_name_for_dup, NAS_OPERATOR_RESP_MAX_EONS_LEN );
                any_changes_from_duplicate_filtering = TRUE;
              }
           } // if ( (iter_j == iter_i) || ( 0 == strcmp( ref_name_org, ril_rep_helper->short_eons[ iter_j ] ) ) )
          }
        } // if ( duplicate_name_found )

    } // for ( iter_i = 0; iter_i < (nw_cnt - 1); iter_i++ )

    QCRIL_LOG_INFO( "duplicate names filtering applied %d", any_changes_from_duplicate_filtering );
    if ( any_changes_from_duplicate_filtering )
    {
       for ( iter_i = 0; iter_i < nw_cnt; iter_i++ )
       {
          QCRIL_LOG_INFO("post filter network #%d - %s/%s/%s/%s", iter_i+1,
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ],
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1 ],
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2 ],
                                  ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3 ]);
       }
    } // any_changes_from_duplicate_filtering

  } // if ( !QCRIL_NW_SCAN_SELECTION_RADIO_SUPPORT() && nw_cnt > 1 && && TRUE == nas_common_info.process_duplicate_nw_scan_names )
  QCRIL_LOG_FUNC_RETURN();
  return nw_cnt;
}

void qcril_qmi_nas_perform_incremental_network_scan_ind_handler
(
nas_perform_incremental_network_scan_ind_msg_v01 * nw_scan_ind
)
{
  qcril_qmi_nw_scan_resp_helper_type *    ril_rep_helper = NULL;
  int nw_cnt = 0, iter_i, no_of_entries, scan_info_len;
  uint16_t len = 0, total_len = 0;
  unsigned char *resp_byte_stream_ptr = NULL;
  unsigned char *resp_byte_stream = NULL;
  qcril_qmi_nas_nw_scan_info_helper_type * nw_scan_helper = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  if (nw_scan_ind)
  {
    QCRIL_LOG_INFO("Scan Status : %d", nw_scan_ind->scan_status);
    scan_info_len = nw_scan_ind->nas_network_scan_info_len;
    QCRIL_LOG_INFO("Scan info len: %d", scan_info_len);
    if ( scan_info_len > 0 )
    {
      nw_scan_helper = qcril_malloc (sizeof(qcril_qmi_nas_nw_scan_info_helper_type)*scan_info_len);
      ril_rep_helper = qcril_malloc (sizeof(qcril_qmi_nw_scan_resp_helper_type)*scan_info_len);
      if ( ril_rep_helper && nw_scan_helper )
      {
        memset(nw_scan_helper, 0, sizeof(qcril_qmi_nas_nw_scan_info_helper_type)*scan_info_len);
        memset(ril_rep_helper, 0, sizeof(qcril_qmi_nw_scan_resp_helper_type)*scan_info_len);
        for ( iter_i = 0; iter_i < scan_info_len; iter_i++)
        {
          nw_scan_helper[iter_i].mcc = nw_scan_ind->nas_network_scan_info[iter_i].mobile_country_code;
          nw_scan_helper[iter_i].mnc_includes_pcs_digit = nw_scan_ind->nas_network_scan_info[iter_i].mnc_includes_pcs_digit;
          nw_scan_helper[iter_i].mnc = nw_scan_ind->nas_network_scan_info[iter_i].mobile_network_code;
          nw_scan_helper[iter_i].network_status = nw_scan_ind->nas_network_scan_info[iter_i].network_status;
          nw_scan_helper[iter_i].plmn_rat_valid = TRUE;
          nw_scan_helper[iter_i].plmn_rat = nw_scan_ind->nas_network_scan_info[iter_i].rat;
        }
        nw_cnt = qcril_qmi_nas_fill_network_scan_response (nw_scan_ind->nas_network_scan_info_len,
                                            nw_scan_helper,
                                            ril_rep_helper,
                                            &no_of_entries);
        QCRIL_LOG_INFO("Network scan plmn count = %d", nw_cnt );
      }
    }
    // Send UNSOL OEM HOOK response to telephony
    // NOTE: for RAT, incrementenal search only support "combine". It does not support "legacy"
    len = (sizeof(qcril_qmi_nw_scan_resp_helper_type) * nw_cnt) + (sizeof(uint16) * no_of_entries * nw_cnt) + 2;
    resp_byte_stream = qcril_malloc(len);
    if ( resp_byte_stream )
    {
      resp_byte_stream_ptr = resp_byte_stream;
      memset( resp_byte_stream, 0, len );
      // Scan status
      *resp_byte_stream_ptr = (uint8_t) nw_scan_ind->scan_status;
      resp_byte_stream_ptr = resp_byte_stream_ptr + 1;
      total_len =  total_len + 1;
      // No. of network info
      *resp_byte_stream_ptr = (uint8_t)nw_cnt;
      resp_byte_stream_ptr = resp_byte_stream_ptr + 1;
      total_len =  total_len + 1;
      for ( iter_i = 0; iter_i < nw_cnt; iter_i++ )
      {
        QCRIL_LOG_INFO("Network scan response #%d - %s/%s/%s/%s", iter_i+1,
                       ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ],
                       ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1 ],
                       ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2 ],
                       ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3 ]);
        // Length followed by value
        // long alpha ONS or EONS
        len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ]);
        memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
        resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
        memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i ], len);
        resp_byte_stream_ptr = resp_byte_stream_ptr + len;
        total_len =  total_len +  sizeof(uint16) + len;

        // short alpha ONS or EONS
        len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1 ]);
        memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
        resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
        memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 1], len);
        resp_byte_stream_ptr = resp_byte_stream_ptr + len;
        total_len =  total_len +  sizeof(uint16) + len;

        // MCC+MNC
        len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2]);
        memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
        resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
        memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 2], len);
        resp_byte_stream_ptr = resp_byte_stream_ptr + len;
        total_len =  total_len +  sizeof(uint16) + len;

        // NW status
        len = strlen(ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3]);
        memcpy(resp_byte_stream_ptr,(void *)&len, sizeof(uint16));
        resp_byte_stream_ptr = resp_byte_stream_ptr + sizeof(uint16);
        memcpy(resp_byte_stream_ptr, (void *)ril_rep_helper->nw_scan_info_array[ no_of_entries * iter_i + 3], len);
        resp_byte_stream_ptr = resp_byte_stream_ptr + len;
        total_len =  total_len +  sizeof(uint16) + len;
      }
      QCRIL_LOG_INFO("RIL response len: %d", total_len);
      resp_byte_stream_ptr = resp_byte_stream;
      qcril_qmi_print_hex( resp_byte_stream_ptr,total_len);
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_INCREMENTAL_NW_SCAN_IND, (void*) resp_byte_stream, total_len);
    }
    if (nw_scan_helper)
    {
      qcril_free(nw_scan_helper);
    }
    if (ril_rep_helper)
    {
      qcril_free(ril_rep_helper);
    }
    if (resp_byte_stream)
    {
      qcril_free(resp_byte_stream);
    }
  }
  QCRIL_LOG_FUNC_RETURN();
}

static void qcril_qmi_nas_get_serv_cell_sib_ind_handler
(
    nas_get_serv_cell_sib_ind_msg_v01 * serv_cell_sib_ind
)
{
  qcril_request_resp_params_type   resp;
  embms_get_sib_plmn_resp_msg_v01  ril_resp_payload;
  RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type        request_info;

  int i;

  memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
  NAS_CACHE_LOCK();
  ril_resp_payload.dbg_trace_id = nas_cached_info.sib_info.dbg_trace_id;
  uint8_t sequence = nas_cached_info.sib_info.sequence;
  NAS_CACHE_UNLOCK();

  // Update nas cache, send RIL RESP if all inds are received
  IxErrnoType all_ind_received = E_IN_PROGRESS;

  do
  {
    // Invalid indication with wrong order after RIL RESP has been sent
    if ( E_SUCCESS != qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN,
                                                     &request_info))
    {
      QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN not found");
      all_ind_received = E_ALREADY_DONE;
      break;
    }
    // Sequence number doesn't match
    if (serv_cell_sib_ind->sequence != sequence)
    {
      all_ind_received = E_FAILURE;
      break;
    }
    else
    {
      NAS_CACHE_LOCK();
      uint32_t current_size = nas_cached_info.sib_info.current_size;
      uint32_t max_size = nas_cached_info.sib_info.bin_data.len;
      boolean data_valid = nas_cached_info.sib_info.bin_data.data ? TRUE: FALSE;
      NAS_CACHE_UNLOCK();
      uint32_t sib_pkt_size = serv_cell_sib_ind->sib_pkt_len;

      // bin data is not initilized
      if (!data_valid)
      {
        all_ind_received = E_FAILURE;
        break;
      }

      // Received size exceed allowed maximum
      if (current_size + sib_pkt_size > max_size)
      {
        all_ind_received = E_FAILURE;
        break;
      }

      // No error
      NAS_CACHE_LOCK();
      nas_cached_info.sib_info.sequence++;
      memcpy(&nas_cached_info.sib_info.bin_data.data[current_size],
             serv_cell_sib_ind->sib_pkt,
             sib_pkt_size);
      nas_cached_info.sib_info.current_size = current_size + sib_pkt_size;
      NAS_CACHE_UNLOCK();
      if (current_size + sib_pkt_size == max_size)
      {
        all_ind_received = E_SUCCESS;
      }
      break;
    }
  } while(0);

  if (all_ind_received == E_SUCCESS) // All indication received, send RIL RESP SUCCESS
  {
    // Update RIL RESP
    NAS_CACHE_LOCK();
    ril_req_res = qcril_qmi_nas_embms_parse_embms_plmn(nas_cached_info.sib_info.bin_data,
                                         PLMN_LIST_MAX_V01,
                                         &ril_resp_payload.plmn_len,
                                         ril_resp_payload.plmn);
    NAS_CACHE_UNLOCK();

    if (ril_req_res == RIL_E_SUCCESS)
    {
      QCRIL_LOG_INFO("plmn len: %d", ril_resp_payload.plmn_len);
      for (i = 0; i < ril_resp_payload.plmn_len; ++i)
      {
        QCRIL_LOG_INFO("plmn[%d] mcc:%s, mnc:%s", i,
                        ril_resp_payload.plmn[i].mcc,
                        ril_resp_payload.plmn[i].mnc);
      }
    }
    // Send RIL RESP
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       request_info.t,
                                       request_info.request,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &ril_resp_payload;
    resp.resp_len = sizeof( ril_resp_payload );
    qcril_send_request_response( &resp );
    NAS_CACHE_LOCK();
    if (nas_cached_info.sib_info.bin_data.data)
    {
      qcril_free(nas_cached_info.sib_info.bin_data.data);
      nas_cached_info.sib_info.bin_data.data = NULL;
    }
    NAS_CACHE_UNLOCK();
  }
  else if (all_ind_received == E_FAILURE)
  {
    // Send RIL RESP
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       request_info.t,
                                       request_info.request,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &ril_resp_payload;
    resp.resp_len = sizeof( ril_resp_payload );
    qcril_send_request_response( &resp );
    NAS_CACHE_LOCK();
    if (nas_cached_info.sib_info.bin_data.data)
    {
      qcril_free(nas_cached_info.sib_info.bin_data.data);
      nas_cached_info.sib_info.bin_data.data = NULL;
    }
    NAS_CACHE_UNLOCK();
  }
  else if (all_ind_received == E_ALREADY_DONE)
  {
    NAS_CACHE_LOCK();
    if (nas_cached_info.sib_info.bin_data.data)
    {
      qcril_free(nas_cached_info.sib_info.bin_data.data);
      nas_cached_info.sib_info.bin_data.data = NULL;
    }
    NAS_CACHE_UNLOCK();
  }
  else // if (all_ind_received == E_IN_PROGRESS
  {
    // Waiting for more indications to come
    // Nothing need to be done here
    // Intentionally leave blank
  }
  QCRIL_LOG_FUNC_RETURN();
  return;
}

//===========================================================================
// QCRIL_EVT_HOOK_PERFORM_INCREMENTAL_NW_SCAN
//===========================================================================
void qcril_qmi_nas_perform_incremental_network_scan
(
const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;


  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_perform_incremental_network_scan_req_msg_v01 qmi_request;
  nas_perform_incremental_network_scan_resp_msg_v01 qmi_response;

  qcril_reqlist_public_type qcril_req_info_ptr;

  qmi_client_error_type qmi_client_error;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_request, 0, sizeof(qmi_request));
  qmi_request.network_type_valid = qcril_qmi_nas_retrieve_scan_network_type(&qmi_request.network_type);

  qmi_client_error =  qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                 QMI_NAS_PERFORM_INCREMENTAL_NETWORK_SCAN_REQ_MSG_V01,
                                                                 &qmi_request,
                                                                 sizeof(qmi_request),
                                                                 (void*) &qmi_response,
                                                                 sizeof( qmi_response ),
                                                                 QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                                   );
  ril_req_res = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;

  if ( ril_req_res == RIL_E_SUCCESS )
  {
    if (qmi_response.resp.result != QMI_RESULT_SUCCESS_V01)
    {
      QCRIL_LOG_ERROR("QMI Result = %d,error=%d\n", qmi_response.resp.result,qmi_response.resp.error);
      ril_req_res =  RIL_E_GENERIC_FAILURE;
    }
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", ril_req_res );
}
//===========================================================================
// RIL_REQUEST_QUERY_AVAILABLE_NETWORKS
//===========================================================================
void qcril_qmi_nas_query_available_networks
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_perform_network_scan_req_msg_v01 qmi_request;
  nas_perform_network_scan_resp_msg_v01 * qmi_response = NULL;
  qmi_txn_handle txn_handle;

  qcril_qmi_nw_scan_resp_helper_type * ril_rep_helper = NULL;

  qcril_reqlist_public_type qcril_req_info_ptr;

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_NW_SCAN,
                               NULL,
                               &qcril_req_info_ptr );
  if ( qcril_reqlist_new( instance_id, &qcril_req_info_ptr ) == E_SUCCESS )
  {
      qmi_response = qcril_malloc( sizeof( *qmi_response ) );
      if ( qmi_response )
      {
          ril_rep_helper = qcril_malloc( sizeof( *ril_rep_helper ) );

          if ( ril_rep_helper )
          {
              memset(&qmi_request, 0, sizeof(qmi_request));
              qmi_request.network_type_valid = qcril_qmi_nas_retrieve_scan_network_type(&qmi_request.network_type);

              qmi_client_error =  qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                 QMI_NAS_PERFORM_NETWORK_SCAN_REQ_MSG_V01,
                                                                 &qmi_request,
                                                                 sizeof(qmi_request),
                                                                 (void*) qmi_response,
                                                                 sizeof( *qmi_response ),
                                                                 qcril_qmi_nas_perform_network_scan_command_cb,
                                                                 (void *)ril_rep_helper,
                                                                 &txn_handle
                                                   );
              ril_req_res = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
          }
      }

      if ( RIL_E_SUCCESS != ril_req_res )
      {
          qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
          qcril_send_request_response( &resp );

          if ( ril_rep_helper )
          {
              qcril_free( ril_rep_helper );
          }
          if ( qmi_response )
          {
              qcril_free( qmi_response );
          }
      }
  }
  QCRIL_LOG_INFO("completed with %d", ril_req_res );
} // qcril_qmi_nas_query_available_networks

//===========================================================================
// qcril_qmi_nas_perform_network_scan_command_cb
//===========================================================================
void qcril_qmi_nas_perform_network_scan_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
  qmi_resp_callback_type qmi_resp_callback;

  QCRIL_LOG_FUNC_ENTRY();

  qmi_resp_callback.user_handle = user_handle;
  qmi_resp_callback.msg_id = msg_id;
  qmi_resp_callback.data_buf = (void*) resp_c_struct;
  qmi_resp_callback.data_buf_len = resp_c_struct_len;
  qmi_resp_callback.cb_data = resp_cb_data;
  qmi_resp_callback.transp_err = transp_err;

  qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                 QCRIL_DEFAULT_MODEM_ID,
                 QCRIL_DATA_ON_STACK,
                 QCRIL_EVT_QMI_REQUEST_NW_SCAN,
                 (void*) &qmi_resp_callback,
                 sizeof(qmi_resp_callback),
                 (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

  QCRIL_LOG_FUNC_RETURN();
}/* qcril_qmi_nas_perform_network_scan_command_cb */


/*
 * this function will allocate a buffer, pointed by
 * nw_scan_helper
 */
RIL_Errno qcril_qmi_nas_copy_from_scan_msg
(
nas_perform_network_scan_resp_msg_v01 *scan_resp, /* from */
qcril_qmi_nas_nw_scan_info_helper_type **p_nw_scan_helper, /* to */
int *nw_scan_len
)
{
    RIL_Errno ret = RIL_E_GENERIC_FAILURE;
    qcril_qmi_nas_nw_scan_info_helper_type *nw_scan_helper;
    unsigned int i;
    int j;

    *nw_scan_len = 0;
    *p_nw_scan_helper = NULL;

    /* NOTE: if scan_result is not valid, we will go on */
    if ( (scan_resp == NULL) || ( scan_resp->resp.result != QMI_RESULT_SUCCESS_V01 )
        || ( ( scan_resp->scan_result_valid ) && ( scan_resp->scan_result != NAS_SCAN_SUCCESS_V01 ) )
        || !( ( scan_resp->nas_3gpp_network_info_valid ) && ( scan_resp->nas_3gpp_network_info_len > 0 ) ) )
    {
        QCRIL_LOG_ERROR("Network scan response error");

    }
    else
    {
      /* allocate the memory and reset all as 0 */
      if ( scan_resp->nas_3gpp_network_info_len <= NAS_3GPP_NETWORK_INFO_LIST_MAX_V01 )
      {
        nw_scan_helper = qcril_malloc(sizeof(qcril_qmi_nas_nw_scan_info_helper_type)
                * scan_resp->nas_3gpp_network_info_len );
        if ( nw_scan_helper )
        {
          memset( nw_scan_helper, 0, sizeof(qcril_qmi_nas_nw_scan_info_helper_type) *
                                    scan_resp->nas_3gpp_network_info_len );
          *nw_scan_len = scan_resp->nas_3gpp_network_info_len;
          *p_nw_scan_helper = nw_scan_helper;
          ret = RIL_E_SUCCESS;

          for (i = 0; i < scan_resp->nas_3gpp_network_info_len; i++)
          {
            nw_scan_helper[i].mcc = scan_resp->nas_3gpp_network_info[i].mobile_country_code;
            nw_scan_helper[i].mnc = scan_resp->nas_3gpp_network_info[i].mobile_network_code;
            nw_scan_helper[i].network_status = scan_resp->nas_3gpp_network_info[i].network_status;
            if ( scan_resp->nas_network_radio_access_technology_valid )
            {
              nw_scan_helper[i].plmn_rat_valid = 1;
              nw_scan_helper[i].plmn_rat = scan_resp->nas_network_radio_access_technology[i].rat;
            }
            if ( scan_resp->mnc_includes_pcs_digit_valid )
            {
              nw_scan_helper[i].mnc_includes_pcs_digit = scan_resp->mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
            }
          } /* for loop i */
        } /* nw_scan_helper not NULL */
      } /* scan_resp->nas_3gpp_network_info_len <= NAS_3GPP_NETWORK_INFO_LIST_MAX_V01 */
    }

    return ret;
}
//===========================================================================
// qcril_qmi_nas_perform_network_scan_command_cb_helper // QCRIL_EVT_QMI_REQUEST_NW_SCAN
//===========================================================================
void qcril_qmi_nas_perform_network_scan_command_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno   ril_req_res                                = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type qcril_req_info;
    errno_enum_type           found_qcril_request;
    int  nw_cnt = 0, nw_scan_len;
    qcril_request_resp_params_type resp;
    qmi_resp_callback_type * qmi_resp_callback;
    nas_perform_network_scan_resp_msg_v01 * qmi_response;
    qcril_qmi_nw_scan_resp_helper_type *    ril_rep_helper = NULL;
    qcril_qmi_nas_nw_scan_info_helper_type *nw_scan_helper = NULL;
    qmi_client_error_type        transp_err;
    int no_of_entries;

    qmi_resp_callback = (qmi_resp_callback_type *) params_ptr->data;

    QCRIL_NOTUSED(ret_ptr);
    if ( qmi_resp_callback )
    {
        qmi_response = qmi_resp_callback->data_buf;
        ril_rep_helper = qmi_resp_callback->cb_data;
        transp_err =qmi_resp_callback->transp_err;

        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_DEFAULT_MODEM_ID,
                                      QCRIL_EVT_QMI_REQUEST_NW_SCAN,
                                      &qcril_req_info );


        if ( qmi_response && (E_SUCCESS == found_qcril_request) && ril_rep_helper  )
        {
            if ( QMI_NO_ERR == transp_err && qmi_response->nas_3gpp_network_info_valid )
            {
                ril_req_res = qcril_qmi_nas_copy_from_scan_msg( qmi_response, &nw_scan_helper, &nw_scan_len);
                if ( ril_req_res == RIL_E_SUCCESS && nw_scan_helper )
                {
                    nw_cnt = qcril_qmi_nas_fill_network_scan_response(nw_scan_len,
                                            nw_scan_helper, ril_rep_helper, &no_of_entries);
                    ril_req_res = (nw_cnt > 0) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
                    if ( nw_scan_helper )
                    {
                      qcril_free( nw_scan_helper );
                    }
                }
            }
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t,
                                        qcril_req_info.request, ril_req_res, &resp );
            if ( RIL_E_SUCCESS == ril_req_res )
            {
                resp.resp_pkt = (void *) ril_rep_helper->nw_scan_info_array;
                resp.resp_len = sizeof( char * ) * no_of_entries * nw_cnt;
            }
            qcril_send_request_response( &resp );
        }

        if ( qmi_response )
        {
            qcril_free( qmi_response ); // we own it
        }
        if ( ril_rep_helper )
        {
            qcril_free( ril_rep_helper ); // we own it too
        }
    }
    QCRIL_LOG_INFO("completed with %d", ril_req_res );

} // qcril_qmi_nas_perform_network_scan_command_cb_helper

/*=========================================================================

  FUNCTION:  qcril_qmi_nas_parse_csg_scan_oem_req

===========================================================================*/
/*!
    @brief
    Parse OEM Hook Header related to Network scan.

    @return
    If success then the Filled structure will be returned
*/
/*=========================================================================*/

RIL_Errno qcril_qmi_nas_parse_csg_scan_oem_req(uint8 *oem_hook_data,nas_perform_network_scan_req_msg_v01 *filled_data,uint8 oem_data_len )
{
  uint16 i=0,len=0;
  RIL_Errno result = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  memset(filled_data,0,sizeof(nas_perform_network_scan_req_msg_v01));
  QCRIL_LOG_DEBUG("Length : %d, found while parsing request",oem_data_len);

  for(i=0;i<oem_data_len;)
  {
    switch(oem_hook_data[i])
    {
      case  0x10:
        if ( i + 1 < oem_data_len )
        {
          memcpy(&len,(void *)&oem_hook_data[i+1],sizeof(uint16));
          if(len == 1)
          {
            if ( i + 3 < oem_data_len )
            {
              filled_data->network_type_valid = TRUE;
              filled_data->network_type = oem_hook_data[i+3];
              i=i+4;
            }
            else
            {
              QCRIL_LOG_ERROR("out of boundary when parsing");
              result = RIL_E_GENERIC_FAILURE;
            }
          }
          else if(len == 0)
          {
            i=i+3;
          }
          else
          {
            QCRIL_LOG_ERROR("Invalid Tag length : %d, found while parsing",len);
            result = RIL_E_GENERIC_FAILURE;
          }
          len=0;
        }
        else
        {
            QCRIL_LOG_ERROR("out of boundary when parsing");
            result = RIL_E_GENERIC_FAILURE;
        }
        break;
      case  0x11:
        if ( i + 1 < oem_data_len )
        {
          memcpy(&len,(void *)&oem_hook_data[i+1],sizeof(uint16));
          if(len == 1)
          {
            if ( i + 3 < oem_data_len )
            {
              filled_data->scan_type_valid = TRUE;
              filled_data->scan_type = (nas_nw_scan_type_enum_v01)oem_hook_data[i+3];
              i=i+4;
            }
            else
            {
              QCRIL_LOG_ERROR("out of boundary when parsing");
              result = RIL_E_GENERIC_FAILURE;
            }
          }
          else if(len == 0)
          {
            filled_data->scan_type_valid = TRUE;
            filled_data->scan_type = NAS_SCAN_TYPE_CSG_V01;
            i=i+3;
          }
          else
          {
            QCRIL_LOG_ERROR("Invalid Tag length : %d, found while parsing",len);
            result = RIL_E_GENERIC_FAILURE;
          }
          len=0;
        }
        else
        {
            QCRIL_LOG_ERROR("out of boundary when parsing");
            result = RIL_E_GENERIC_FAILURE;
        }
        break;
      default:
        QCRIL_LOG_ERROR("Invalid Tag:%d, length :%d, found while parsing",oem_hook_data[i],len);
        result = RIL_E_GENERIC_FAILURE;
    }

    if( RIL_E_GENERIC_FAILURE == result )
       break;
  }
  QCRIL_LOG_FUNC_RETURN();
  return result;
}


/*=========================================================================

  FUNCTION:  qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan

===========================================================================*/
/*!
    @brief
    Perform CSG related Network scan.

    @return
    If success then the neighboring cells information is returned
*/
/*=========================================================================*/
void qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan
(
 const qcril_request_params_type *const params_ptr,
 qcril_request_return_type *const ret_ptr /*!< Output parameter */
 )
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_perform_network_scan_req_msg_v01 qmi_request;
  nas_perform_network_scan_resp_msg_v01 * qmi_response = NULL;
  qmi_txn_handle txn_handle;

  qcril_qmi_nas_perform_network_scan_csg_resp_msg * ril_rep_helper = NULL;

  qcril_reqlist_public_type qcril_req_info_ptr;

  qmi_client_error_type qmi_client_error;

  uint8 csg_perform_nw_scan_req[QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD];
  uint8 *csg_perform_nw_scan_req_ptr;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_request,0,sizeof(qmi_request));
  memset(csg_perform_nw_scan_req,0,QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD);


  do
  {
    if ( params_ptr->datalen > QCRIL_QMI_NAS_MAX_CSG_REQ_PAYLOAD )
    {
        ril_req_res = RIL_E_GENERIC_FAILURE;
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
        qcril_send_request_response( &resp );
        break;
    }

    memcpy(csg_perform_nw_scan_req, params_ptr->data, params_ptr->datalen);
    csg_perform_nw_scan_req_ptr = csg_perform_nw_scan_req;
    QCRIL_LOG_DEBUG("Recieved Data length from oem hook: %d ",params_ptr->datalen);
    qcril_qmi_print_hex((unsigned char *) csg_perform_nw_scan_req_ptr,params_ptr->datalen);

    ril_req_res = qcril_qmi_nas_parse_csg_scan_oem_req(csg_perform_nw_scan_req_ptr,&qmi_request,(uint8)params_ptr->datalen);

    if( ril_req_res == RIL_E_GENERIC_FAILURE )
    {
        qcril_default_request_resp_params( instance_id,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        qcril_send_request_response( &resp );
        break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                 QCRIL_EVT_HOOK_CSG_PERFORM_NW_SCAN,
                                 NULL,
                                 &qcril_req_info_ptr );
    if ( qcril_reqlist_new( instance_id, &qcril_req_info_ptr ) == E_SUCCESS )
    {
        qmi_response = qcril_malloc( sizeof( *qmi_response ) );
        if ( qmi_response )
        {
            ril_rep_helper = qcril_malloc( sizeof( *ril_rep_helper ) );

            if ( ril_rep_helper )
            {
                qmi_client_error =  qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                   QMI_NAS_PERFORM_NETWORK_SCAN_REQ_MSG_V01,
                                                                   &qmi_request,
                                                                   sizeof(qmi_request),
                                                                   (void*) qmi_response,
                                                                   sizeof( *qmi_response ),
                                                                   qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb,
                                                                   (void *)ril_rep_helper,
                                                                   &txn_handle
                                                     );
                ril_req_res = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
            }
        }

        if ( RIL_E_SUCCESS != ril_req_res )
        {
            qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
            qcril_send_request_response( &resp );

            if ( ril_rep_helper )
            {
                qcril_free( ril_rep_helper );
            }
            if ( qmi_response )
            {
                qcril_free( qmi_response );
            }
        }
    }
  } while (0);

  QCRIL_LOG_INFO("completed with %d", ril_req_res );
  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan */

//===========================================================================
// qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb
//===========================================================================
void qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
  nas_perform_network_scan_resp_msg_v01 * qmi_response   = (nas_perform_network_scan_resp_msg_v01 *) resp_c_struct;
  qcril_qmi_nas_perform_network_scan_csg_resp_msg *ril_resp_helper =  (qcril_qmi_nas_perform_network_scan_csg_resp_msg *) resp_cb_data;
  RIL_Errno   ril_req_res                                = RIL_E_SUCCESS;
  qcril_reqlist_public_type qcril_req_info;
  errno_enum_type           found_qcril_request;
  qcril_request_resp_params_type resp;
  unsigned int i=0;
  uint16 total_len=0,csg_len=0,csg_info_len_position=0,csg_sig_len=0,csg_sig_info_len_position=0;
  user_handle = user_handle;
  uint8 *resp_byte_stream_ptr = NULL;
  uint8 *resp_byte_stream = NULL;
 uint8  *resp_print = NULL;
  msg_id = msg_id;
  resp_c_struct_len = resp_c_struct_len;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_DEBUG("resp_c_struct_len = %d", resp_c_struct_len );

  memset( &qcril_req_info, 0, sizeof(qcril_req_info) );

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_HOOK_CSG_PERFORM_NW_SCAN,
                                                      &qcril_req_info );
  do
  {
    if ( qmi_response && (E_SUCCESS == found_qcril_request) )
    {
      resp_byte_stream = qcril_malloc(sizeof(*ril_resp_helper)); //Max length allocated may not be the final length sent in response.
      resp_byte_stream_ptr = resp_byte_stream;

      if(NULL == resp_byte_stream)
      {
        QCRIL_LOG_ERROR("resp_byte_stream malloc failed");
        ril_req_res = RIL_E_GENERIC_FAILURE;
        break;
      }

      if ( QMI_NO_ERR == transp_err )
      {
        memset( ril_resp_helper, 0, sizeof(*ril_resp_helper) );
        memset(resp_byte_stream, 0, sizeof(*ril_resp_helper));
        if( qmi_response->resp.result == QMI_RESULT_SUCCESS_V01 )
        {
          ril_resp_helper->resp.error = QMI_ERR_NONE_V01;
          ril_resp_helper->resp.result = QMI_RESULT_SUCCESS_V01; //No  need to calcualte len for this as we dont send in response.
          QCRIL_LOG_DEBUG("Result from QMI-NAS = %d,%d", qmi_response->resp.error,qmi_response->resp.result);

          /*Scan result TLV parsing*/
          if(qmi_response->scan_result_valid == TRUE)
          {
            QCRIL_LOG_DEBUG("Scan result TLV filled from QMI-NAS = %d", qmi_response->scan_result);
            ril_resp_helper->scan_result_tag = 0x13;
            *resp_byte_stream_ptr = ril_resp_helper->scan_result_tag;
            total_len= total_len+1;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;

            ril_resp_helper->scan_result_len = 4;
            memcpy(resp_byte_stream_ptr, &ril_resp_helper->scan_result_len,sizeof(uint16));
            total_len= total_len+2;
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;

            ril_resp_helper->scan_result = (uint32_t)qmi_response->scan_result;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->scan_result,sizeof(uint32));
            total_len = total_len+4;
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
          }
          else
          {
            ril_resp_helper->scan_result_tag = 0x13;
            *resp_byte_stream_ptr = ril_resp_helper->scan_result_tag;
            total_len = total_len+1;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;

            ril_resp_helper->scan_result_len = 0;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->scan_result_len,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
          }

        QCRIL_LOG_DEBUG("Total length filled after processing scan result = %d", total_len);
        resp_print = resp_byte_stream;
        qcril_qmi_print_hex((unsigned char *) resp_print,total_len);
        resp_print = resp_byte_stream;

        /*CSG Info TLV parsing*/
        if(qmi_response->csg_info_valid == TRUE && qmi_response->csg_info_len > 0)
        {
          QCRIL_LOG_DEBUG("CSG result TLV got from QMI-NAS no of entries = %d", qmi_response->csg_info_len);
          ril_resp_helper->csg_info_tag = 0x14;
          *resp_byte_stream_ptr=ril_resp_helper->csg_info_tag;

          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          resp_print = resp_byte_stream;
          qcril_qmi_print_hex((unsigned char *) resp_print,total_len);

          csg_info_len_position = total_len; //Noted the position of csg_info_len
          //2-bytes Space holder for CSG total length calculated later.
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;

          ril_resp_helper->csg_info_no_of_entries = (uint8)qmi_response->csg_info_len;
          *resp_byte_stream_ptr = ril_resp_helper->csg_info_no_of_entries;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;

          resp_print = resp_byte_stream;
          qcril_qmi_print_hex((unsigned char *) resp_print,total_len);


          if(qmi_response->csg_info_len > 0 )
          {
            csg_len=1; // Default one byte for no of entries
          }
          else
          {
            csg_len = 0;
          }

          for(i=0;i<qmi_response->csg_info_len;i++)
          {
            ril_resp_helper->csg_info[i].mcc = qmi_response->csg_info[i].mcc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_info[i].mcc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_len = csg_len+2;

            ril_resp_helper->csg_info[i].mnc = qmi_response->csg_info[i].mnc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_info[i].mnc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_len = csg_len+2;

            if(qmi_response->mnc_includes_pcs_digit_valid)
            {
              ril_resp_helper->csg_info[i].mnc_includes_pcs_digit = qmi_response->mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
            }
            else
            {
              ril_resp_helper->csg_info[i].mnc_includes_pcs_digit = FALSE;
            }

            /*CSG pcs 1-bytes*/
            *resp_byte_stream_ptr = ril_resp_helper->csg_info[i].mnc_includes_pcs_digit;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;
            total_len = total_len+1;
            csg_len = csg_len+1;

            /*CSG Category 4-bytes*/
            ril_resp_helper->csg_info[i].csg_list_cat = qmi_response->csg_info[i].csg_list_cat ;
            memcpy(resp_byte_stream_ptr,&ril_resp_helper->csg_info[i].csg_list_cat,sizeof(uint32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_len = csg_len+4;

            /*CSG ID 4-bytes*/
            ril_resp_helper->csg_info[i].csg_info.id = qmi_response->csg_info[i].csg_info.id ;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_info[i].csg_info.id,sizeof(uint32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_len = csg_len+4;

            /*CSG name_len 1-bytes*/
            ril_resp_helper->csg_info[i].csg_info.name_len = qmi_response->csg_info[i].csg_info.name_len;
            *resp_byte_stream_ptr = ril_resp_helper->csg_info[i].csg_info.name_len;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;
            total_len = total_len+1;
            csg_len = csg_len+1;

            /*CSG name  len*2-UCS2 bytes*/
            memcpy(ril_resp_helper->csg_info[i].csg_info.name,qmi_response->csg_info[i].csg_info.name,ril_resp_helper->csg_info[i].csg_info.name_len*2) ;
            memcpy(resp_byte_stream_ptr,(void *)ril_resp_helper->csg_info[i].csg_info.name,ril_resp_helper->csg_info[i].csg_info.name_len*2);
            resp_byte_stream_ptr = resp_byte_stream_ptr+(ril_resp_helper->csg_info[i].csg_info.name_len*2);
            total_len = total_len+(ril_resp_helper->csg_info[i].csg_info.name_len*2);
            csg_len = csg_len+(ril_resp_helper->csg_info[i].csg_info.name_len*2);

          } //For loop
          /*Filing the finally calculated csg_length Here*/

          ril_resp_helper->csg_info_total_len = csg_len;
          memcpy(&resp_byte_stream[csg_info_len_position],(void *)&csg_len,sizeof(uint16));
          QCRIL_LOG_DEBUG("CSG total TLV length  = %d\n", resp_byte_stream[csg_info_len_position]);
          resp_print = resp_byte_stream;
          qcril_qmi_print_hex((unsigned char *) resp_print,total_len);
        }
        else
        {
          QCRIL_LOG_DEBUG("CSG result TLV not present=%d or len is = %d", qmi_response->csg_info_valid,qmi_response->csg_info_len);
          ril_resp_helper->csg_info_tag = 0x14;
          *resp_byte_stream_ptr = ril_resp_helper->csg_info_tag;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          ril_resp_helper->csg_info_total_len = csg_len; //In this case csg len = 0
          memcpy(resp_byte_stream_ptr,(void *)&csg_len,sizeof(uint16));
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;
        }

        /*CSG Signal Strength Info TLV parsing*/
        if(qmi_response->csg_sig_info_valid == TRUE && qmi_response->csg_sig_info_len > 0)
        {
          QCRIL_LOG_DEBUG("CSG Signal Strength result TLV got from QMI-NAS no of entries = %d", qmi_response->csg_sig_info_len);
          ril_resp_helper->csg_sig_info_tag = 0x15;
          *resp_byte_stream_ptr=ril_resp_helper->csg_sig_info_tag;

          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          resp_print = resp_byte_stream;
          qcril_qmi_print_hex((unsigned char *) resp_print,total_len);

          csg_sig_info_len_position = total_len; //Noted the position of csg_sig_info_len
          //2-bytes Space holder for CSG Signal Strength total length calculated later.
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;

          ril_resp_helper->csg_sig_info_no_of_entries = (uint8)qmi_response->csg_sig_info_len;
          *resp_byte_stream_ptr = ril_resp_helper->csg_sig_info_no_of_entries;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;

          resp_print = resp_byte_stream;
          qcril_qmi_print_hex((unsigned char *) resp_print,total_len);


          if(qmi_response->csg_sig_info_len > 0 )
          {
            csg_sig_len=1; // Default one byte for no of entries
          }
          else
          {
            csg_sig_len = 0;
          }

          for(i=0;i<qmi_response->csg_sig_info_len;i++)
          {
            ril_resp_helper->csg_sig_info[i].mcc = qmi_response->csg_sig_info[i].mcc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].mcc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_sig_len = csg_sig_len+2;

            ril_resp_helper->csg_sig_info[i].mnc = qmi_response->csg_sig_info[i].mnc;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].mnc,sizeof(uint16));
            resp_byte_stream_ptr = resp_byte_stream_ptr+2;
            total_len = total_len+2;
            csg_sig_len = csg_sig_len+2;

            if(qmi_response->mnc_includes_pcs_digit_valid)
            {
              ril_resp_helper->csg_sig_info[i].mnc_includes_pcs_digit = qmi_response->mnc_includes_pcs_digit[i].mnc_includes_pcs_digit;
            }
            else
            {
              ril_resp_helper->csg_sig_info[i].mnc_includes_pcs_digit = FALSE;
            }

            *resp_byte_stream_ptr = ril_resp_helper->csg_sig_info[i].mnc_includes_pcs_digit;
            resp_byte_stream_ptr = resp_byte_stream_ptr+1;
            total_len = total_len+1;
            csg_sig_len = csg_sig_len+1;

            ril_resp_helper->csg_sig_info[i].csg_id = qmi_response->csg_sig_info[i].csg_id;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].csg_id,sizeof(uint32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_sig_len = csg_sig_len+4;

            ril_resp_helper->csg_sig_info[i].signal_strength = qmi_response->csg_sig_info[i].signal_strength;
            memcpy(resp_byte_stream_ptr,(void *)&ril_resp_helper->csg_sig_info[i].signal_strength,sizeof(int32));
            resp_byte_stream_ptr = resp_byte_stream_ptr+4;
            total_len = total_len+4;
            csg_sig_len = csg_sig_len+4;
          }

          /*Filing the finally calculated csg_sig_length Here*/

          ril_resp_helper->csg_sig_info_total_len = csg_sig_len;
          memcpy(&resp_byte_stream[csg_sig_info_len_position],(void *)&csg_sig_len,sizeof(uint16));
          QCRIL_LOG_DEBUG("CSG Signal Strength total TLV length  = %d\n", resp_byte_stream[csg_sig_info_len_position]);
          resp_print = resp_byte_stream;
          qcril_qmi_print_hex((unsigned char *) resp_print,total_len);
        }
        else
        {
          QCRIL_LOG_DEBUG("CSG Signal Strength result TLV not present=%d or len is = %d", qmi_response->csg_sig_info_valid,qmi_response->csg_sig_info_len);
          ril_resp_helper->csg_sig_info_tag = 0x15;
          *resp_byte_stream_ptr = ril_resp_helper->csg_sig_info_tag;
          resp_byte_stream_ptr = resp_byte_stream_ptr+1;
          total_len = total_len+1;
          ril_resp_helper->csg_sig_info_total_len = csg_sig_len; //In this case csg_sig_len = 0
          memcpy(resp_byte_stream_ptr,(void *)&csg_sig_len,sizeof(uint16));
          resp_byte_stream_ptr = resp_byte_stream_ptr+2;
          total_len = total_len+2;
        }
       } //if check response
       else
       {
         QCRIL_LOG_ERROR("QMI-NAS CSG Scan Response Not success  = %d\n", qmi_response->resp.result);
         ril_req_res = RIL_E_GENERIC_FAILURE;
       }
     }//if Transport no error
     else
     {
       QCRIL_LOG_DEBUG("Transport error = %d\n", transp_err);
       ril_req_res = RIL_E_GENERIC_FAILURE;
     }
    }//if Found
    else
    {
      QCRIL_LOG_DEBUG("Request list not found = %d\n", found_qcril_request);
      ril_req_res = RIL_E_GENERIC_FAILURE;
    }
  }while(0);

  if (found_qcril_request == E_SUCCESS)
  {
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, ril_req_res , &resp );
    if ( RIL_E_SUCCESS == ril_req_res )
    {
      QCRIL_LOG_DEBUG("Final response length = %d,Data in Hex=\n", total_len);
      resp_byte_stream_ptr = resp_byte_stream;
      qcril_qmi_print_hex((unsigned char *) resp_byte_stream_ptr,total_len);
      resp.resp_pkt = (void *) resp_byte_stream;
      resp.resp_len = total_len;
    }
    qcril_send_request_response( &resp );
  }



  if ( qmi_response )
  {
    qcril_free( qmi_response );
  }
  if ( ril_resp_helper )
  {
    qcril_free( ril_resp_helper );
  }
  if ( resp_byte_stream )
  {
    qcril_free( resp_byte_stream );
  }
}/* qcril_qmi_nas_csg_handle_oem_hook_perform_network_scan_command_cb */

/*=========================================================================

  FUNCTION:  qcril_qmi_nas_parse_csg_sys_selection_req

===========================================================================*/
/*!
    @brief
    Parse OEM Hook Header related to Manual System selection.

    @return
    If success then the Filled structure will be returned
*/
/*=========================================================================*/

RIL_Errno qcril_qmi_nas_parse_csg_sys_selection_req(uint8 *oem_hook_data,nas_set_system_selection_preference_req_msg_v01 *filled_data,uint8 oem_data_len )
{
  uint16 i=0,len=0;
  RIL_Errno result = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  if( NULL == oem_hook_data || NULL == filled_data)
    return RIL_E_GENERIC_FAILURE;

  memset(filled_data,0,sizeof(nas_set_system_selection_preference_req_msg_v01));
  QCRIL_LOG_DEBUG("Length : %d, found while parsing request",oem_data_len);

  for(i=0;i<oem_data_len;)
  {
    switch(oem_hook_data[i])
    {
      case  0x20:
        memcpy(&len,(void *)&oem_hook_data[i+1],sizeof(uint16));
        if(len == 10)
        {
          filled_data->csg_info_valid = TRUE;
          memcpy(&filled_data->csg_info.mcc,&oem_hook_data[i+3],sizeof(uint16));
          memcpy(&filled_data->csg_info.mnc,&oem_hook_data[i+5],sizeof(uint16));
          memcpy(&filled_data->csg_info.mnc_includes_pcs_digit,&oem_hook_data[i+7],sizeof(uint8));
          memcpy(&filled_data->csg_info.id,&oem_hook_data[i+8],sizeof(uint32));
          memcpy(&filled_data->csg_info.rat,&oem_hook_data[i+12],sizeof(uint8));

          i=i+13;
        }
        else if(len == 0)
        {
          filled_data->net_sel_pref.net_sel_pref = NAS_NET_SEL_PREF_AUTOMATIC_V01;
          filled_data->net_sel_pref_valid = TRUE;
          i=i+3;
          result = RIL_E_SUCCESS;
        }
        else
        {
          QCRIL_LOG_ERROR("Invalid Tag length : %d, found while parsing",len);
          result = RIL_E_GENERIC_FAILURE;
        }
        len=0;
        break;

      default:
        QCRIL_LOG_ERROR("Invalid Tag:%d, length :%d, found while parsing",oem_hook_data[i],len);
        result = RIL_E_GENERIC_FAILURE;
    }

    if( RIL_E_GENERIC_FAILURE == result || TRUE == filled_data->net_sel_pref_valid )
        break;
  }
  QCRIL_LOG_FUNC_RETURN();
  return result;
}/*qcril_qmi_nas_parse_csg_sys_selection_req*/


/*=========================================================================

  FUNCTION:  qcril_qmi_nas_csg_handle_oem_hook_set_sys_selection

===========================================================================*/
/*!
    @brief
    Manually select a CSG Network.

    @return
    If success then it indicates sys selection is set
*/
/*=========================================================================*/
void qcril_qmi_nas_csg_handle_oem_hook_set_sys_selection
(
 const qcril_request_params_type *const params_ptr,
 qcril_request_return_type *const ret_ptr /*!< Output parameter */
 )
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_set_system_selection_preference_resp_msg_v01 qmi_response;
  nas_get_system_selection_preference_resp_msg_v01 qmi_response_get;

  qcril_reqlist_public_type qcril_req_info_ptr;

  qmi_client_error_type qmi_client_error;

  uint8 csg_set_sys_sel_req[QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD];
  uint8 *csg_set_sys_sel_req_ptr;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  memset(&qmi_request,0,sizeof(qmi_request));
  memset(csg_set_sys_sel_req,0,QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD);

  if( params_ptr->datalen > QCRIL_QMI_NAS_MAX_CSG_SYS_SELECTION_PREF_REQ_PAYLOAD)
  {
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       RIL_E_GENERIC_FAILURE,
                                       &resp );
    qcril_send_request_response( &resp );
    QCRIL_LOG_ERROR("Recieved Data length from oem hook is exceeded the maximum limit");
    return;
  }

  memcpy(csg_set_sys_sel_req, params_ptr->data, params_ptr->datalen);

  csg_set_sys_sel_req_ptr = csg_set_sys_sel_req;

  QCRIL_LOG_DEBUG("Recieved Data length from oem hook: %d ",params_ptr->datalen);
  qcril_qmi_print_hex((unsigned char *) csg_set_sys_sel_req_ptr,params_ptr->datalen);

  ril_req_res = qcril_qmi_nas_parse_csg_sys_selection_req(csg_set_sys_sel_req_ptr,&qmi_request,(uint8)params_ptr->datalen);

  if( ril_req_res == RIL_E_GENERIC_FAILURE )
  {
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );
    QCRIL_LOG_ERROR("Failed to parse CSG selction request.");
    return;
  }

  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                               QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                               NULL,
                                               NAS_ZERO,
                                               (void*) &qmi_response_get,
                                               sizeof( qmi_response_get ),
                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

  if ( qmi_response_get.csg_info_valid && ( qmi_response_get.csg_info.id == qmi_request.csg_info.id )
        && ( qmi_response_get.csg_info.mcc == qmi_request.csg_info.mcc )
        && ( qmi_response_get.csg_info.mnc == qmi_request.csg_info.mnc ) )
  {
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       RIL_E_SUCCESS,
                                       &resp );
    qcril_send_request_response( &resp );
    QCRIL_LOG_DEBUG("Already camped on requested CSG ID");
    return;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_HOOK_CSG_SET_SYS_SEL_PREF,
                               NULL,
                               &qcril_req_info_ptr );

  if ( qcril_reqlist_new( instance_id, &qcril_req_info_ptr ) == E_SUCCESS )
  {
    qmi_client_error =  qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                  QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                  &qmi_request,
                                                  sizeof(qmi_request),
                                                  (void*) &qmi_response,
                                                  sizeof( qmi_response ),
                                                  QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);

    if ( RIL_E_SUCCESS == qmi_client_error )
    {
        if (qmi_response.resp.result != QMI_RESULT_SUCCESS_V01)
        {
           QCRIL_LOG_ERROR("CSG Manual Selection error,QMI Result = %d,error=%d\n", qmi_response.resp.result,qmi_response.resp.error);
           qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
           resp.resp_pkt = (void *) NULL;
           resp.resp_len = 0;
           qcril_send_request_response( &resp );
        }
        else
        {
           QCRIL_LOG_DEBUG("Waiting for System selection pref indication from QMI-NAS..");
        }
    }
    else
    {
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
        qcril_send_request_response( &resp );
    }
  }

  QCRIL_LOG_FUNC_RETURN();
} /* qcril_qmi_nas_csg_handle_oem_hook_set_sys_selection */

//===========================================================================
// qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler
//===========================================================================

void qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler(nas_system_selection_preference_ind_msg_v01* qmi_ind)
{
  RIL_Errno   ril_req_res   = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type qcril_req_info;
  errno_enum_type           found_qcril_request;
  qcril_request_resp_params_type resp;
  unsigned int i=0;

  QCRIL_LOG_FUNC_ENTRY();

  memset( &qcril_req_info, 0, sizeof(qcril_req_info) );

  found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                      QCRIL_DEFAULT_MODEM_ID,
                                                      QCRIL_EVT_HOOK_CSG_SET_SYS_SEL_PREF,
                                                      &qcril_req_info );

  if ( (qmi_ind != NULL) && (E_SUCCESS == found_qcril_request) )
  {
    if ( qmi_ind->csg_info_valid )
    {
      QCRIL_LOG_DEBUG("CSG Manual Selection Set Successfully: CSG_ID: %d, MCC: %03d, MNC: %03d\n",
                       qmi_ind->csg_info.id, qmi_ind->csg_info.mcc, qmi_ind->csg_info.mnc);
      ril_req_res = RIL_E_SUCCESS;
    }
    else if ( qmi_ind->net_sel_pref_valid )
    {
      QCRIL_LOG_DEBUG("CSG Manual Selection Set Successfully: %d\n", qmi_ind->net_sel_pref);
      ril_req_res = RIL_E_SUCCESS;
    }
    else
    {
      QCRIL_LOG_ERROR("CSG Manual Selection Set Failed\n");
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, ril_req_res , &resp );
    resp.resp_pkt = NULL;
    resp.resp_len = 0;
    qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_csg_handle_oem_hook_sys_sel_pref_ind_handler

//===========================================================================
// qcril_qmi_nas_fill_up_operator_name
//===========================================================================
void qcril_qmi_nas_fill_up_operator_name
(
  int is_current_nw,
  char * mcc_str,
  char * mnc_str,
  char * mcc_mnc_str_ref,
  char *long_ons_ptr,
  size_t long_ons_ptr_size,
  char *short_ons_ptr,
  size_t short_ons_ptr_size
)
{
    int res = FALSE;
    char * op_name_short;
    char * op_name_long;
    nas_plmn_network_name_type_v01* plmn_nw_name_ptr;

    *long_ons_ptr  = NAS_NIL;
    *short_ons_ptr = NAS_NIL;

    if ( NULL != mcc_str && NULL != mnc_str )
    {
        QCRIL_LOG_INFO("is_current_nw=%d", is_current_nw );
        if( is_current_nw )
        {
            QCRIL_LOG_INFO(".. nitz info is valid %d ", (int)NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) );
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) )
            {
                QCRIL_LOG_INFO(".. nitz long len %d, nitz short len %d ", (int)nas_cached_info.nitz_information->long_name_len, (int)nas_cached_info.nitz_information->short_name_len );
            }
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.nitz_information ) &&
                 (
                   ( nas_cached_info.nitz_information->long_name_len > NAS_ZERO && nas_cached_info.nitz_information->short_name_len > NAS_ZERO ) ||
                   ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_ICS ) && ( nas_cached_info.nitz_information->long_name_len > NAS_ZERO || nas_cached_info.nitz_information->short_name_len > NAS_ZERO ) )
                  )
                )
            { // operator name is with nitz message
              QCRIL_LOG_INFO( "..inclanation for nitz" );
              plmn_nw_name_ptr = nas_cached_info.nitz_information;
              qcril_qmi_util_decode_operator_name(long_ons_ptr,
                                                  NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                  plmn_nw_name_ptr->coding_scheme,
                                                  plmn_nw_name_ptr->long_name,
                                                  plmn_nw_name_ptr->long_name_len);

              qcril_qmi_util_decode_operator_name(short_ons_ptr,
                                                  NAS_OPERATOR_RESP_MAX_EONS_LEN,
                                                  plmn_nw_name_ptr->coding_scheme,
                                                  plmn_nw_name_ptr->short_name,
                                                  plmn_nw_name_ptr->short_name_len);

              QCRIL_LOG_INFO("..will return nitz %s, %s", long_ons_ptr, short_ons_ptr );
              res = TRUE;
            }
            else if ( qcril_qmi_nas_nitz_persistent_cache_is_shadow_available() &&
                    !strcmp(nas_cached_info.persistent_cached_mobile_country_code,mcc_str) &&
                    !strcmp(nas_cached_info.persistent_cached_mobile_network_code,mnc_str) )
            { // nitz shadow cache
              QCRIL_LOG_INFO( "..inclanation for shadow" );
              snprintf( long_ons_ptr, long_ons_ptr_size, "%s", nas_cached_info.persistent_cached_nitz_op_name_long);
              snprintf( short_ons_ptr, short_ons_ptr_size, "%s", nas_cached_info.persistent_cached_nitz_op_name_short );
              QCRIL_LOG_INFO("..will return shadow %s, %s", long_ons_ptr, short_ons_ptr );
              res = TRUE;
            }
        }

        if( FALSE == res )
        {  // look up for operator name in static table
          QCRIL_LOG_INFO( "..inclanation for static" );

          op_name_short = NULL;
          op_name_long = NULL;
          qcril_qmi_nas2_find_startic_operator_name(
                                                    mcc_str,
                                                    mnc_str,
                                                    mcc_mnc_str_ref,
                                                    &op_name_long,
                                                    &op_name_short
                                                    );
          if ( NULL != op_name_long )
          {
              snprintf( long_ons_ptr, long_ons_ptr_size, "%s", op_name_long);
          }
          if ( NULL != op_name_short )
          {
              snprintf( short_ons_ptr, short_ons_ptr_size, "%s", op_name_short);
          }
          QCRIL_LOG_INFO("..will return static %s, %s", long_ons_ptr, short_ons_ptr );
        }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }
} // qcril_qmi_nas_fill_up_operator_name

//===========================================================================
// qcril_qmi_nas_fill_up_3gpp2_operator_name
//===========================================================================
int qcril_qmi_nas_fill_up_3gpp2_operator_name
(
  char * mcc_str,
  char * mnc_str,
  uint16_t sid,
  uint16_t nid,
  char *long_ons_ptr,
  size_t long_ons_ptr_size,
  char *short_ons_ptr,
  size_t short_ons_ptr_size
)
{
    int res = FALSE;
    char * op_name_short;
    char * op_name_long;
    nas_plmn_network_name_type_v01* plmn_nw_name_ptr;

    if( NULL != mcc_str && NULL != mnc_str )
    {
      QCRIL_LOG_INFO("mcc %s mnc %s sid %d nid %d",mcc_str,mnc_str,sid,nid);
      // look up for operator name in static table
      op_name_short = NULL;
      op_name_long = NULL;
      res = qcril_qmi_nas2_find_3gpp2_static_operator_name(mcc_str,
                                                           mnc_str,
                                                           sid,
                                                           nid,
                                                           &op_name_long,
                                                           &op_name_short
                                                           );
      if ( NULL != op_name_long )
      {
          snprintf( long_ons_ptr, long_ons_ptr_size, "%s", op_name_long);
      }
      if ( NULL != op_name_short )
      {
          snprintf( short_ons_ptr, short_ons_ptr_size, "%s", op_name_short);
      }
      QCRIL_LOG_INFO("..will return static %s, %s", long_ons_ptr, short_ons_ptr );
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

    QCRIL_LOG_INFO("completed with %d",res);
    return res;
} // qcril_qmi_nas_fill_up_3gpp2_operator_name


//===========================================================================
// qcril_qmi_nas_get_nw_select_state
//===========================================================================
qmi_ril_nas_nw_select_state_e_type qcril_qmi_nas_get_nw_select_state(void)
{
    qmi_ril_nas_nw_select_state_e_type res;
    NAS_CACHE_LOCK();
    res = nas_cached_info.nw_select_state;
    NAS_CACHE_UNLOCK();
    return res;
} // qcril_qmi_nas_get_nw_select_state

//===========================================================================
// qcril_qmi_nas_set_nw_select_state
//===========================================================================
RIL_Errno qcril_qmi_nas_set_nw_select_state(qmi_ril_nas_nw_select_state_e_type new_state)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    qmi_ril_nas_nw_select_state_e_type cur_state;
    qmi_ril_nas_nw_select_state_e_type final_new_state;

    qmi_client_error_type   client_err;
    uint32                  new_timeout_watch = 0;
    int                     new_timeout_set_res;
    qmi_client_error_type   qmi_transport_error;
    qmi_client_type         dedicated_client;
    qmi_client_os_params    os_params;
    int                     time_out = 4;


    nas_indication_register_req_msg_v01     nwreg_indications_qmi_request;
    nas_indication_register_resp_msg_v01    nwreg_indications_qmi_response;

    const struct timeval nw_select_timeout = {60 , 0}; // 60 seconds
    const struct timeval nw_select_limited_timeout = {25 , 0}; // 25 seconds

    nas_bind_subscription_req_msg_v01   nas_bind_request;
    nas_bind_subscription_resp_msg_v01  nas_bind_resp;



    QCRIL_LOG_INFO( "new_state: %d", (int) new_state );

    NAS_CACHE_LOCK();
    cur_state = nas_cached_info.nw_select_state;
    NAS_CACHE_UNLOCK();
    final_new_state = cur_state;
    QCRIL_LOG_INFO( ".. cur state %d (entry)", (int) cur_state );


    switch ( new_state )
    {
        case QMI_RIL_NAS_NW_SELECT_WAKING_UP:
            if ( QMI_RIL_NAS_NW_SELECT_NONE == cur_state )
            {
                NAS_CACHE_LOCK();
                nas_cached_info.nw_select_nas_client    = NAS_NIL;
                nas_cached_info.nw_select_timeout_watch = NAS_NIL;
                nas_common_info.manual_nw_reject_cause_counter = 0;

                NAS_CACHE_UNLOCK();

                dedicated_client = NULL;

                // open new client
                NAS_NW_SEL_LOCK();
                client_err = qmi_client_init_instance(nas_get_service_object_v01(),
                                                      qmi_ril_client_get_master_port(),
                                                      qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb,
                                                      NULL,
                                                      &os_params,
                                                      time_out,
                                                      &dedicated_client);
                if ( client_err == QMI_NO_ERR )
                {
                    NAS_CACHE_LOCK();
                    nas_cached_info.nw_select_nas_client = dedicated_client;
                    NAS_CACHE_UNLOCK();
                }

                if ( NULL != dedicated_client )
                {
                    /* Bind required only if its multi sim target */
                    if ( qmi_ril_is_multi_sim_feature_supported() )
                    {
                        memset( &nas_bind_request, 0, sizeof( nas_bind_request ) );

                        if ( QCRIL_MODEM_TERTIARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id())
                        {
                            nas_bind_request.subs_type = NAS_TERTIARY_SUBSCRIPTION_V01;
                        }
                        else if (QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id())
                        {
                            nas_bind_request.subs_type = NAS_SECONDARY_SUBSCRIPTION_V01;
                        }
                        else
                        {
                            nas_bind_request.subs_type = NAS_PRIMARY_SUBSCRIPTION_V01;
                        }

                        (void)qmi_client_send_msg_sync_with_shm( dedicated_client,
                                                         QMI_NAS_BIND_SUBSCRIPTION_REQ_MSG_V01,
                                                         (void*)&nas_bind_request,
                                                         sizeof( nas_bind_request ),
                                                         (void*) &nas_bind_resp,
                                                         sizeof( nas_bind_resp ),
                                                         QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                                          );
                        QCRIL_LOG_INFO( " .. dsds 2nd qmi_nas client bind res %d", (int) res );
                    }
                }

                NAS_NW_SEL_UNLOCK();

                if ( client_err != QMI_NO_ERR )
                {
                   // failed to init client
                   QCRIL_LOG_ERROR( "Failed to open new nas client w/%d ",
                                    (int) client_err );
                   QCRIL_ASSERT(0); // this is a noop in release build
                }
                else
                { // go on
                    QCRIL_LOG_INFO( ".. new nas client open res %d ", (int) client_err );

                    // subscribe for events
                    memset( &nwreg_indications_qmi_request, 0, sizeof( nwreg_indications_qmi_request ) );
                    nwreg_indications_qmi_request.reg_sys_sel_pref_valid = TRUE;
                    nwreg_indications_qmi_request.reg_sys_sel_pref = TRUE;

                    nwreg_indications_qmi_request.reg_ddtm_events_valid = TRUE;
                    nwreg_indications_qmi_request.reg_ddtm_events = FALSE;

                    nwreg_indications_qmi_request.dual_standby_pref_valid = TRUE;
                    nwreg_indications_qmi_request.dual_standby_pref = FALSE;

                    nwreg_indications_qmi_request.subscription_info_valid = TRUE;
                    nwreg_indications_qmi_request.subscription_info = FALSE;

                    nwreg_indications_qmi_request.reg_network_time_valid = TRUE;
                    nwreg_indications_qmi_request.reg_network_time = FALSE;

                    nwreg_indications_qmi_request.reg_rtre_cfg_valid = TRUE;
                    nwreg_indications_qmi_request.reg_rtre_cfg = FALSE;

                    nwreg_indications_qmi_request.reg_embms_status_valid = TRUE;
                    nwreg_indications_qmi_request.reg_embms_status = FALSE;

                    nwreg_indications_qmi_request.sig_info_valid = TRUE;
                    nwreg_indications_qmi_request.sig_info = FALSE;

                    nwreg_indications_qmi_request.err_rate_valid = TRUE;
                    nwreg_indications_qmi_request.err_rate = FALSE;

                    nwreg_indications_qmi_request.reg_managed_roaming_valid = TRUE;
                    nwreg_indications_qmi_request.reg_managed_roaming = FALSE;

                    nwreg_indications_qmi_request.reg_hdr_session_close_valid = TRUE;
                    nwreg_indications_qmi_request.reg_hdr_session_close = FALSE;

                    nwreg_indications_qmi_request.reg_hdr_uati_valid = TRUE;
                    nwreg_indications_qmi_request.reg_hdr_uati = FALSE;

                    nwreg_indications_qmi_request.reg_current_plmn_name_valid = TRUE;
                    nwreg_indications_qmi_request.reg_current_plmn_name = FALSE;

                    if (nas_common_info.manual_nw_reject_cause_counter_enabled)
                    {
                        nwreg_indications_qmi_request.network_reject_valid  = TRUE;
                        nwreg_indications_qmi_request.network_reject.reg_network_reject  = TRUE;
                        nwreg_indications_qmi_request.network_reject.suppress_sys_info   = FALSE;
                    }

                    if( qmi_ril_is_qmi_sys_info_available() )
                    {
                        nwreg_indications_qmi_request.sys_info_valid = TRUE;
                        nwreg_indications_qmi_request.sys_info = TRUE;

                        nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
                        nwreg_indications_qmi_request.req_serving_system = FALSE;
                    }
                    else
                    {
                        nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
                        nwreg_indications_qmi_request.req_serving_system = TRUE;
                    }

                    qmi_transport_error = qmi_client_send_msg_sync_with_shm(
                                            nas_cached_info.nw_select_nas_client,
                                            QMI_NAS_INDICATION_REGISTER_REQ_MSG_V01,
                                            (void*) &nwreg_indications_qmi_request,
                                            sizeof( nwreg_indications_qmi_request ),
                                            (void*) &nwreg_indications_qmi_response,
                                            sizeof( nwreg_indications_qmi_response ),
                                            QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                             );
                    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &nwreg_indications_qmi_response.resp );

                    QCRIL_LOG_INFO( ".. secondary QMI NAS handle configuring res %d, %d ", (int) res, (int) nwreg_indications_qmi_response.resp.error );

                    if ( RIL_E_SUCCESS == res )
                    {
                        // set timeout
                        new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                                          QCRIL_DEFAULT_MODEM_ID,
                                                                          qcril_qmi_nas_nw_select_timeout_cb,
                                                                          &nw_select_timeout, &new_timeout_watch );
                        QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );

                        if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
                        {
                            res = RIL_E_GENERIC_FAILURE;
                        }
                        else
                        {
                            // otherwise waking up is done
                            final_new_state = QMI_RIL_NAS_NW_SELECT_AWAKEN;
                            NAS_CACHE_LOCK();
                            nas_cached_info.nw_select_nw_reg_received       = FALSE;
                            nas_cached_info.nw_select_nw_set_pref_ackd      = FALSE;
                            nas_cached_info.nw_select_nw_reg_result         = RIL_E_RADIO_NOT_AVAILABLE;
                            nas_cached_info.nw_select_nw_set_pref_result    = RIL_E_RADIO_NOT_AVAILABLE;
                            nas_cached_info.nw_select_is_manual             = FALSE;
                            nas_cached_info.nw_select_is_current            = FALSE;
                            memset(&nas_cached_info.nw_select_manual_mcc_str, NAS_NIL, sizeof(nas_cached_info.nw_select_manual_mcc_str));
                            memset(&nas_cached_info.nw_select_manual_mnc_str, NAS_NIL, sizeof(nas_cached_info.nw_select_manual_mnc_str));
                            nas_cached_info.nw_select_is_modem_sel_pref_auto = FALSE;
                            nas_cached_info.nw_select_timeout_watch = new_timeout_watch;
                            NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sim_rej_info);
                            NAS_CACHE_UNLOCK();
                        }

                    }

                    // check if need to rollback
                    if ( RIL_E_SUCCESS != res )
                    {
                        qcril_qmi_nas_nw_select_total_cleanup();
                    }
                }
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
            if ( QMI_RIL_NAS_NW_SELECT_AWAKEN == cur_state )
            {
                final_new_state = QMI_RIL_NAS_NW_SELECT_SETTING_PREF;
                res = RIL_E_SUCCESS;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
            if ( QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state || QMI_RIL_NAS_NW_SELECT_AWAITING_REG == cur_state )
            {
                new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, qcril_qmi_nas_nw_select_limited_timeout_cb, &nw_select_limited_timeout, &new_timeout_watch );
                QCRIL_LOG_INFO( ".. set limited timeout cb res %d ", (int) new_timeout_set_res );
                if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
                {
                    res = RIL_E_GENERIC_FAILURE;
                    qcril_qmi_nas_nw_select_total_cleanup(); //rollback
                }
                else
                {
                    NAS_CACHE_LOCK();
                    nas_cached_info.nw_select_limited_timeout_watch    = new_timeout_watch;
                    NAS_CACHE_UNLOCK();
                    final_new_state = QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD;
                    res = RIL_E_SUCCESS;
                }
            }
            break;


        case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
            if ( QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state || QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD == cur_state )
            {
                final_new_state = QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD;
                res = RIL_E_SUCCESS;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
                    final_new_state = QMI_RIL_NAS_NW_SELECT_AWAITING_REG;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    // skip
                    break;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_CANCELLING_REQ:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:   // fallthrough
                case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
                    final_new_state = QMI_RIL_NAS_NW_SELECT_NONE;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    break;
            }
            break;


        case QMI_RIL_NAS_NW_SELECT_DONE:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:        // fallthrough
                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:   // fallthrough
                case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
                    qcril_qmi_nas_nw_select_total_cleanup();
                    final_new_state = QMI_RIL_NAS_NW_SELECT_NONE;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    break;
            }
            break;

        case QMI_RIL_NAS_NW_SELECT_ROLLBACK:
            switch ( cur_state )
            {
                case QMI_RIL_NAS_NW_SELECT_AWAKEN:
                    qcril_qmi_nas_nw_select_total_cleanup();
                    final_new_state = QMI_RIL_NAS_NW_SELECT_NONE;
                    res = RIL_E_SUCCESS;
                    break;

                default:
                    break;
            }
            break;

        default: // invalid state or state may not be set directly
            break;
    }

    if ( RIL_E_SUCCESS == res  )
    {
        NAS_CACHE_LOCK();
        nas_cached_info.nw_select_state = final_new_state;
        NAS_CACHE_UNLOCK();
    }
    QCRIL_LOG_INFO( "completed with %d and new state is %d ", (int)res, (int) final_new_state );
    return res;
} // qcril_qmi_nas_set_nw_select_state

//===========================================================================
//qcril_qmi_nas_nw_select_total_cleanup
//===========================================================================
void qcril_qmi_nas_nw_select_total_cleanup(void)
{
    QCRIL_LOG_FUNC_ENTRY();
    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_NAS_CLEANUP_NW_SEL,
                   NULL,
                   NAS_NIL,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
} // qcril_qmi_nas_nw_select_total_cleanup

//===========================================================================
// QCRIL_EVT_QMI_REQUEST_CLEANUP_NW_SEL
//===========================================================================
void qcril_qmi_nas_nw_select_handle_total_cleanup
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qmi_client_type         new_nas_client;
  uint32                  new_timeout_watch,new_limited_timeout_watch;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params_ptr );
  QCRIL_NOTUSED( ret_ptr );


  NAS_CACHE_LOCK();
  new_nas_client = nas_cached_info.nw_select_nas_client;
  NAS_CACHE_UNLOCK();
  if ( NAS_NIL != new_nas_client )
  {
      NAS_NW_SEL_LOCK();
      qmi_client_release(new_nas_client);
      NAS_CACHE_LOCK();
      nas_cached_info.nw_select_nas_client = NAS_NIL;
      NAS_CACHE_UNLOCK();
      NAS_NW_SEL_UNLOCK();
  }

  NAS_CACHE_LOCK();
  new_timeout_watch = nas_cached_info.nw_select_timeout_watch;
  new_limited_timeout_watch = nas_cached_info.nw_select_limited_timeout_watch;
  NAS_CACHE_UNLOCK();
  if ( NAS_NIL != new_timeout_watch )
  {
      qcril_cancel_timed_callback((void*)(uintptr_t)new_timeout_watch);
      NAS_CACHE_LOCK();
      nas_cached_info.nw_select_timeout_watch = NAS_NIL;
      NAS_CACHE_UNLOCK();
  }

  if ( NAS_NIL != new_limited_timeout_watch )
  {
      qcril_cancel_timed_callback((void*)(uintptr_t)new_limited_timeout_watch);
      NAS_CACHE_LOCK();
      nas_cached_info.nw_select_limited_timeout_watch = NAS_NIL;
      NAS_CACHE_UNLOCK();
  }

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_nw_select_handle_total_cleanup


/*=========================================================================

    FUNCTION: qcril_qmi_nas_is_permanent_failure

===========================================================================*/
/*!

    @brief
    Check if reject_cause is a permanent failure or not.

    @return
    TRUE or FALSE

*/
/*=========================================================================*/
boolean qcril_qmi_nas_is_permanent_failure
(
    int reject_cause
)
{
    boolean ret;

    switch (reject_cause)
    {
        case ILLEGAL_MS:
        case GPRS_SERVICES_AND_NON_GPRS_SERVICES_NOT_ALLOWED:
        case PLMN_NOT_ALLOWED:
        case LA_NOT_ALLOWED:
        case NATIONAL_ROAMING_NOT_ALLOWED:
        {
            ret = TRUE;
            break;
        }

        default:
        {
            ret = FALSE;
            break;
        }
    }

    return ret;
}
/*=========================================================================

    FUNCTION: qcril_qmi_nas_nw_select_restart_timer

===========================================================================*/
/*!

    @brief
    restart manual network selection timer

    @return
    0 on success.

*/
/*=========================================================================*/
int qcril_qmi_nas_nw_select_restart_timer
(
    void
)
{
    int             res = RIL_E_SUCCESS;
    const struct    timeval nw_select_timeout = {60 , 0};
    uint32          new_timeout_watch = 0;
    int             new_timeout_set_res;

    NAS_CACHE_LOCK();
    new_timeout_watch = nas_cached_info.nw_select_timeout_watch;

    if ( NAS_NIL != new_timeout_watch )
    {
        qcril_cancel_timed_callback((void*)(uintptr_t)new_timeout_watch);
        nas_cached_info.nw_select_timeout_watch = NAS_NIL;
    }

    new_timeout_set_res = qcril_setup_timed_callback(QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     qcril_qmi_nas_nw_select_timeout_cb,
                                                     &nw_select_timeout,
                                                     &new_timeout_watch );

    QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );
    if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
    {
        res = RIL_E_GENERIC_FAILURE;
    }
    else
    {
        nas_cached_info.nw_select_timeout_watch = new_timeout_watch;
    }

    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
    return res;
}

//===========================================================================
//qcril_qmi_nas_nw_select_timeout_handler
//===========================================================================
void qcril_qmi_nas_nw_select_timeout_handler()
{
  RIL_Errno init_res;
  qmi_ril_nas_nw_select_state_e_type cur_state;

  qcril_reqlist_public_type qcril_req_info;
  IxErrnoType           found_qcril_request;
  qcril_request_resp_params_type resp;
  int     is_full_service;
  int     illegal_sim_or_me = FALSE;

  QCRIL_LOG_FUNC_ENTRY();

  cur_state = qcril_qmi_nas_get_nw_select_state();
  QCRIL_LOG_INFO(".. cur state 1 %d", (int) cur_state );

  switch ( cur_state )
  {
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
      case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
          // update NW reg info
          if ( qmi_ril_is_qmi_sys_info_available() )
          {
              qcril_qmi_nas_fetch_sys_info();
          }
          else
          {
              qcril_qmi_nas_fetch_serving_system_info();
          }
          NAS_CACHE_LOCK();
          is_full_service = qcril_qmi_nas_is_considered_registered(NULL);
          NAS_CACHE_UNLOCK();
          QCRIL_LOG_INFO(".. is full service %d", (int) is_full_service );
          if ( is_full_service )
          {
              NAS_CACHE_LOCK();
              nas_cached_info.nw_select_nw_reg_received       = TRUE;
              nas_cached_info.nw_select_nw_reg_result         = RIL_E_SUCCESS;
              NAS_CACHE_UNLOCK();
              qcril_qmi_nas_select_nw_conclusion_check();
          }
          else if( qmi_ril_is_qmi_sys_info_available() )
          {
              NAS_CACHE_LOCK();
              if( ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason ) &&
                  ( QCRIL_QMI_NAS_REGISTRATION_REJECT_CAUSE_ILLEGAL_MS ==
                    nas_cached_info.registration_reject_reason->reject_cause ) ) ||
                  ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.sim_rej_info ) &&
                  ( ( NAS_SIM_NOT_AVAILABLE_V01 == nas_cached_info.sim_rej_info ) ||
                  ( NAS_SIM_CS_PS_INVALID_V01 == nas_cached_info.sim_rej_info ) ) )
                )
              {
                  illegal_sim_or_me = TRUE;
              }
              NAS_CACHE_UNLOCK();

              if( TRUE == illegal_sim_or_me )
              {
                  NAS_CACHE_LOCK();
                  nas_cached_info.nw_select_nw_reg_received       = TRUE;
                  nas_cached_info.nw_select_nw_reg_result         = RIL_E_ILLEGAL_SIM_OR_ME;
                  NAS_CACHE_UNLOCK();
                  qcril_qmi_nas_select_nw_conclusion_check();
              }
          }
          break;

      default:
          break;
  }

  // still nothing?
  cur_state = qcril_qmi_nas_get_nw_select_state();
  QCRIL_LOG_INFO(".. cur state 2 %d", (int) cur_state );
  switch ( cur_state )
  {
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
      case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
      case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
          // cancel op
          qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_DONE );
          found_qcril_request = (E_SUCCESS == qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, QCRIL_EVT_QMI_REQUEST_NW_SELECT, &qcril_req_info));
          if ( found_qcril_request )
          {
              if ( ( qcril_req_info.request == RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL )
                    && ( nas_common_info.is_restore_prev_mode_pref ) )
              {
                  qcril_qmi_nas_restore_modem_pref();
              }
              qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, RIL_E_GENERIC_FAILURE , &resp );
              qcril_send_request_response( &resp );
              qcril_qmi_nas_wave_voice_data_status();
          }
          break;

      default:
          // ignore
          break;
  }
  // todo

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_timeout_handler


//===========================================================================
//qcril_qmi_nas_nw_select_timeout_cb
//===========================================================================
void qcril_qmi_nas_nw_select_timeout_cb(void * params)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params );
  qcril_qmi_nas_nw_select_timeout_handler();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_timeout_cb

//===========================================================================
//qcril_qmi_nas_nw_select_limited_timeout_cb
//===========================================================================
void qcril_qmi_nas_nw_select_limited_timeout_cb(void * params)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params );
  qcril_qmi_nas_nw_select_timeout_handler();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_limited_timeout_cb

//===========================================================================
//qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn
//===========================================================================
int qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(nas_common_network_id_type_v01 * reported_plmn)
{
  int ret = FALSE;
  char reported_mcc_str[NAS_MCC_MNC_MAX_SIZE],reported_mnc_str[NAS_MCC_MNC_MAX_SIZE];

  QCRIL_LOG_FUNC_ENTRY();

  if( reported_plmn )
  {
    qcril_qmi_nas_fillup_mcc_mnc_helper(reported_plmn->mcc, reported_mcc_str);
    qcril_qmi_nas_fillup_mcc_mnc_helper(reported_plmn->mnc, reported_mnc_str);

    QCRIL_LOG_INFO("reported mcc %s, mnc %s", reported_mcc_str, reported_mnc_str);
    QCRIL_LOG_INFO("requested mcc %s, mnc %s", nas_cached_info.nw_select_manual_mcc_str, nas_cached_info.nw_select_manual_mnc_str);
    ret = (!strcmp(reported_mcc_str,nas_cached_info.nw_select_manual_mcc_str) &&
           !strcmp(reported_mnc_str,nas_cached_info.nw_select_manual_mnc_str));
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} // qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn

//===========================================================================
// qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb
//===========================================================================
void qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb
(
  qmi_client_type                user_handle,
  unsigned int                   message_id,
  void                          *ind_buf,
  unsigned int                   ind_buf_len,
  void                          *ind_cb_data
)
{
  IxErrnoType res;
  qmi_ril_nw_reg_nw_select_passover_params_type * passover;
  int                                             is_success;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ind_cb_data );
  QCRIL_NOTUSED( user_handle );

  do
  {
      passover   = NULL;
      is_success = FALSE;

      passover = qcril_malloc( sizeof(qmi_ril_nw_reg_nw_select_passover_params_type)  );
      if ( NULL == passover )
      {
          QCRIL_LOG_ERROR("passover alloc failure");
          break;
      }

      if ( ind_buf_len > NAS_NIL )
      {
          passover->payload = qcril_malloc( ind_buf_len  );
          if ( NULL == passover->payload )
          {
              QCRIL_LOG_ERROR("passover payload alloc failure");
              break;
          }
          memcpy( passover->payload, ind_buf, ind_buf_len );

          passover->payload_len = ind_buf_len;
      }

      passover->message_id = message_id;

      res = qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID,
                       QCRIL_DATA_NOT_ON_STACK,
                       QCRIL_EVT_QMI_NAS_PASSOVER_NW_SEL_IND,
                       passover,
                       sizeof(*passover),
                       (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

      if( E_SUCCESS == res )
      {
          is_success = TRUE;
      }

  } while ( FALSE );

  if ( !is_success )
  {
      if ( NULL != passover )
      {
          if ( NULL != passover->payload )
          {
              qcril_free( passover->payload );
          }
          qcril_free( passover );
      }
  }

  QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_nw_select_dedicated_unsolicited_indication_cb

//===========================================================================
// qcril_qmi_nas_nw_select_dedicated_unsolicited_indicaton_event_thrd_handler // QCRIL_EVT_QMI_NAS_PASSOVER_NW_SEL_IND
//===========================================================================
void qcril_qmi_nas_nw_select_dedicated_unsolicited_indicaton_event_thrd_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)

{
    qmi_ril_nw_reg_nw_select_passover_params_type * passover;

    unsigned long                                   message_id;
    unsigned char*                                  ind_buf;
    int                                             ind_buf_len;

    void *                                          decoded_payload = NULL;
    qmi_client_error_type                           qmi_err;
    uint32_t                                        decoded_payload_len;

    qmi_client_type                                 dedicated_nas_client;
    int                                             cs_reg_rej;

    int                                             nw_reg_occured = FALSE;
    RIL_Errno                                       nw_reg_result = RIL_E_GENERIC_FAILURE;

    nas_system_selection_preference_ind_msg_v01 *   sys_sel_pref_ind;
    nas_network_reject_ind_msg_v01                 *network_reject_ind_msg = NULL;
    nas_serving_system_ind_msg_v01 *                serving_system_ind;
    nas_sys_info_ind_msg_v01 *                      sys_info_ind;
    nas_3gpp_only_sys_info_type_v01*                three_3gpp_info;

    uint16_t                                        mode_pref;
    int                                             is_now_registered;


    qmi_ril_nas_nw_select_state_e_type              cur_state;
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED( ret_ptr );

    if ( NULL != params_ptr )
    {
        passover = ( qmi_ril_nw_reg_nw_select_passover_params_type* ) (qmi_resp_callback_type *) params_ptr->data;

        if ( NULL != passover && NAS_NIL != passover->message_id )
        {

              message_id   = passover->message_id;
              ind_buf      = passover->payload;
              ind_buf_len  = passover->payload_len;

              do
              {
                  QCRIL_LOG_INFO("invoked msg 0x%x", (int) message_id);

                  qmi_err = qmi_idl_get_message_c_struct_len(nas_get_service_object_v01(),
                                                           QMI_IDL_INDICATION,
                                                           message_id,
                                                           &decoded_payload_len);

                  if ( qmi_err != QMI_NO_ERR ) {
                      QCRIL_LOG_ERROR("Failed to process qmi message w/%d", qmi_err);
                      break;
                  }

                  if( decoded_payload_len )
                  {
                      decoded_payload = qcril_malloc( decoded_payload_len );
                      if (decoded_payload)
                      {
                        memset( decoded_payload, 0, decoded_payload_len );

                        NAS_NW_SEL_LOCK();

                        NAS_CACHE_LOCK();
                        dedicated_nas_client = nas_cached_info.nw_select_nas_client;
                        NAS_CACHE_UNLOCK();

                        if( NAS_NIL != dedicated_nas_client )
                        {
                            qmi_err = qmi_client_message_decode(  dedicated_nas_client,
                                                                QMI_IDL_INDICATION,
                                                                message_id,
                                                                ind_buf,
                                                                ind_buf_len,
                                                                decoded_payload,
                                                                (int)decoded_payload_len);
                        }
                        else
                        {
                            qmi_err = QMI_INTERNAL_ERR;
                        }

                        NAS_NW_SEL_UNLOCK();

                        if ( QMI_NO_ERR == qmi_err )
                        {
                            nw_reg_occured = FALSE;

                            cur_state = qcril_qmi_nas_get_nw_select_state();
                            QCRIL_LOG_INFO(".. nw sel state %d", (int) cur_state);

                            switch ( cur_state )
                            {
                                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
                                case QMI_RIL_NAS_NW_SELECT_AWAITING_REG:
                                case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
                                    switch ( message_id )
                                    {
                                      case QMI_NAS_SERVING_SYSTEM_IND_MSG_V01:
                                          if ( !qmi_ril_is_qmi_sys_info_available() )
                                          {
                                              serving_system_ind = (nas_serving_system_ind_msg_v01*)decoded_payload;
                                              if ( serving_system_ind )
                                              {
                                                  NAS_CACHE_LOCK();
                                                  qmi_ril_nw_reg_update_serving_system_cache_from_ind( serving_system_ind ); // update cache to keep it up to date
                                                  NAS_CACHE_UNLOCK();

                                                  if( TRUE == serving_system_ind->srv_sys_no_change_valid && TRUE == serving_system_ind->srv_sys_no_change )
                                                  {
                                                      NAS_CACHE_LOCK();
                                                      is_now_registered = qcril_qmi_nas_is_considered_registered(NULL);
                                                      NAS_CACHE_UNLOCK();
                                                      if( is_now_registered )
                                                      {
                                                          nw_reg_occured = TRUE;
                                                          nw_reg_result = RIL_E_SUCCESS;
                                                      }
                                                      else
                                                      {
                                                          nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                      }
                                                      QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                  }
                                                  else
                                                  {
                                                      QCRIL_LOG_INFO("change in PLMN");
                                                      QCRIL_LOG_INFO(".. srv system reg state %d", (int) serving_system_ind->serving_system.registration_state);
                                                      switch ( serving_system_ind->serving_system.registration_state )
                                                      {
                                                          case NAS_REGISTERED_V01:
                                                              nw_reg_occured = TRUE;
                                                              nw_reg_result  = RIL_E_SUCCESS;
                                                              break;

                                                          case NAS_REGISTRATION_DENIED_V01:
                                                              QCRIL_LOG_INFO(".. srv system - reg denied");
                                                              qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD );
                                                              break;

                                                          default:
                                                              // skip
                                                              break;
                                                      }
                                                  }
                                              }
                                          }
                                          break;

                                      case QMI_NAS_NETWORK_REJECT_IND_V01:
                                          {
                                              network_reject_ind_msg = (nas_network_reject_ind_msg_v01*)decoded_payload;
                                              if (network_reject_ind_msg)
                                              {
                                                  QCRIL_LOG_INFO(".. reg reject domain, cause %d, %d",
                                                                 network_reject_ind_msg->reject_srv_domain,
                                                                 network_reject_ind_msg->rej_cause);

                                                  if (nas_common_info.manual_nw_reject_cause_counter_enabled &&
                                                       (network_reject_ind_msg->rej_cause == QCRIL_REJECT_CAUSE_NETWORK_FAIL))
                                                  {
                                                      QCRIL_LOG_INFO(".. counter %d",
                                                                     nas_common_info.manual_nw_reject_cause_counter);
                                                      nas_common_info.manual_nw_reject_cause_counter++;
                                                      qcril_qmi_nas_nw_select_restart_timer();
                                                      if (nas_common_info.manual_nw_reject_cause_counter == QMI_RIL_MANUAL_NW_REJECT_MAX_COUNT)
                                                      {
                                                          nas_common_info.manual_nw_reject_cause_counter = 0;
                                                          nw_reg_occured = TRUE;
                                                          nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                      }
                                                  }
                                              }
                                          }

                                          break;

                                      case QMI_NAS_SYS_INFO_IND_MSG_V01:
                                          sys_info_ind = (nas_sys_info_ind_msg_v01*)decoded_payload;

                                          if ( NULL != sys_info_ind )
                                          {
                                              NAS_CACHE_LOCK();
                                              qmi_ril_nw_reg_update_sys_info_cache_from_ind( sys_info_ind ); // store sys_info indication so we get adequate and up-to-date cache

                                              three_3gpp_info = NULL;

                                              if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) )
                                              {
                                                  mode_pref = nas_cached_info.mode_pref; // this must be valid
                                              }
                                              else
                                              {
                                                  mode_pref = QMI_NAS_RAT_MODE_PREF_GSM_UMTS_TDSCDMA_LTE;
                                              }
                                              QCRIL_LOG_INFO(".. mode pref %d", (int) mode_pref);

                                              // gsm
                                              if ( mode_pref & QMI_NAS_RAT_MODE_PREF_GSM )
                                              {
                                                  if ( sys_info_ind->gsm_srv_status_info_valid && sys_info_ind->gsm_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->gsm_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->gsm_sys_info.threegpp_specific_sys_info.network_id)) ||
                                                TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                            if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                            {
                                                                nw_reg_occured = TRUE;
                                                                nw_reg_result = RIL_E_SUCCESS;
                                                            }
                                                            else
                                                            {
                                                                nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                            }
                                                            QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. gsm srv status %d", (int) sys_info_ind->gsm_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->gsm_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for GSM
                                                    if( ((TRUE == sys_info_ind->gsm_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->gsm_sys_info.threegpp_specific_sys_info.network_id)) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->gsm_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              // wcdma
                                              if ( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS )
                                              {
                                                  if ( sys_info_ind->wcdma_srv_status_info_valid && sys_info_ind->wcdma_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info.network_id)) ||
                                               TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                          if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                          {
                                                              nw_reg_occured = TRUE;
                                                              nw_reg_result = RIL_E_SUCCESS;
                                                          }
                                                          else
                                                          {
                                                              nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                          }
                                                          QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. wcdma srv status %d", (int) sys_info_ind->wcdma_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->wcdma_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for WCDMA
                                                    if( ((TRUE == sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info.network_id)) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->wcdma_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              // tdscdma
                                              if ( ( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA ) ||
                                                   ( ( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS ) &&
                                                     qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) &&
                                                     !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ) ) )
                                              {
                                                  if ( sys_info_ind->tdscdma_srv_status_info_valid && sys_info_ind->tdscdma_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info.network_id)) ||
                                               TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                          nw_reg_occured = TRUE;
                                                          if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                          {
                                                              nw_reg_result = RIL_E_SUCCESS;
                                                          }
                                                          else
                                                          {
                                                              nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                          }
                                                          QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. tdscdma srv status %d", (int) sys_info_ind->tdscdma_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->tdscdma_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for TDSCDMA
                                                    if( ((TRUE == sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info.network_id)) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->tdscdma_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              // lte
                                              if ( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE )
                                              {
                                                  if ( sys_info_ind->lte_srv_status_info_valid && sys_info_ind->lte_sys_info_valid )
                                                  {
                                                      if( TRUE == sys_info_ind->sys_info_no_change_valid &&
                                                          TRUE == sys_info_ind->sys_info_no_change &&
                                              ((TRUE == sys_info_ind->lte_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                              TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->lte_sys_info.threegpp_specific_sys_info.network_id)) ||
                                               TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto)
                                                        )
                                                      {
                                                        if( TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                        {
                                                            nw_reg_occured = TRUE;
                                                            nw_reg_result = RIL_E_SUCCESS;
                                                        }
                                                        else
                                                        {
                                                            nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                        }
                                                        QCRIL_LOG_INFO(".. No change in PLMN - is_registered %d", (RIL_E_SUCCESS == nw_reg_result));
                                                      }
                                                      else
                                                      {
                                                        QCRIL_LOG_INFO("change in PLMN");
                                                        QCRIL_LOG_INFO(".. lte srv status %d", (int) sys_info_ind->lte_srv_status_info.srv_status);
                                                        switch ( sys_info_ind->lte_srv_status_info.srv_status )
                                                        {
                                                            case NAS_SYS_SRV_STATUS_SRV_V01:
                                                                // full service for LTE
                                                    if( ((TRUE == sys_info_ind->lte_sys_info.threegpp_specific_sys_info.network_id_valid &&
                                                        TRUE == qcril_qmi_nas_nw_select_is_reported_plmn_same_as_requested_plmn(&sys_info_ind->lte_sys_info.threegpp_specific_sys_info.network_id)) ||
                                                         TRUE == nas_cached_info.nw_select_is_modem_sel_pref_auto) &&
                                                                    TRUE == qcril_qmi_nas_is_considered_registered(NULL) )
                                                                {
                                                                  nw_reg_occured = TRUE;
                                                                  nw_reg_result  = RIL_E_SUCCESS;
                                                                }
                                                                break;

                                                            case NAS_SYS_SRV_STATUS_LIMITED_V01:          // fall through
                                                            case NAS_SYS_SRV_STATUS_LIMITED_REGIONAL_V01:
                                                                three_3gpp_info = &sys_info_ind->lte_sys_info.threegpp_specific_sys_info;
                                                                break;

                                                            default:
                                                                // skip
                                                                break;
                                                        }
                                                      }
                                                  }
                                              }
                                              NAS_CACHE_UNLOCK();


                                              if ( three_3gpp_info && three_3gpp_info->reg_reject_info_valid )
                                              {
                                                  QCRIL_LOG_INFO(".. reg reject domain, cause %d, %d",
                                                                 (int) three_3gpp_info->reg_reject_info.reject_srv_domain,
                                                                 (int) three_3gpp_info->reg_reject_info.rej_cause);

                                                  if (!nas_common_info.manual_nw_reject_cause_counter_enabled ||
                                                       (nas_common_info.manual_nw_reject_cause_counter_enabled &&
                                                        three_3gpp_info->reg_reject_info.rej_cause !=
                                                                                 QCRIL_REJECT_CAUSE_NETWORK_FAIL))
                                                  {
                                                      /* Check if we can return failure right away */
                                                      if (qcril_qmi_nas_is_permanent_failure(
                                                                        three_3gpp_info->reg_reject_info.rej_cause))
                                                      {
                                                          nw_reg_occured = TRUE;
                                                          nw_reg_result  = RIL_E_GENERIC_FAILURE;
                                                      }
                                                      else
                                                      {
                                                          /* if temeporary failure, we should wait for modem retry */
                                                          qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD );
                                                      }
                                                  }
                                              }
                                          }

                                          break;

                                        case QMI_NAS_SYSTEM_SELECTION_PREFERENCE_IND_MSG_V01:
                                            sys_sel_pref_ind = (nas_system_selection_preference_ind_msg_v01*)decoded_payload;
                                            if( sys_sel_pref_ind )
                                            {
                                                QCRIL_LOG_INFO(".. net sel pref valid %d, net sel pref %d",
                                                               (int) sys_sel_pref_ind->net_sel_pref_valid,
                                                               (int) sys_sel_pref_ind->net_sel_pref );

                                    if( sys_sel_pref_ind->net_sel_pref_valid && NAS_NET_SEL_PREF_AUTOMATIC_V01 == sys_sel_pref_ind->net_sel_pref )
                                                {
                                                    NAS_CACHE_LOCK();
                                                    nas_cached_info.nw_select_is_modem_sel_pref_auto = TRUE;
                                                    NAS_CACHE_UNLOCK();
                                                }
                                            }
                                            break;

                                      default:
                                          break;
                                    }
                                    if ( nw_reg_occured && QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state)
                                    {
                                        qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD );
                                    }
                                    break;

                                default:
                                    // skip
                                    break;
                            }
                        }
                        else
                        {
                            nw_reg_occured = FALSE;
                        }

                        qcril_free( decoded_payload );
                      }
                  }

                  if ( nw_reg_occured )
                  {
                      NAS_CACHE_LOCK();
                      nas_cached_info.nw_select_nw_reg_received = TRUE;
                      nas_cached_info.nw_select_nw_reg_result   = nw_reg_result;
                      NAS_CACHE_UNLOCK();
                      qcril_qmi_nas_select_nw_conclusion_check();
                  }
              } while(0);

        }

        if ( NULL != passover )
        {
            qcril_free( passover->payload );
            qcril_free( passover );
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_nw_select_dedicated_unsolicited_indicaton_event_thrd_handler

//===========================================================================
// qcril_qmi_nas_select_nw_conclusion_check
//===========================================================================
void qcril_qmi_nas_select_nw_conclusion_check(void)
{
    qcril_reqlist_public_type qcril_req_info;
    IxErrnoType           found_qcril_request;
    RIL_Errno   ril_req_res;
    qcril_request_resp_params_type resp;

    int                                reg_received;
    RIL_Errno                          reg_result;
    int                                pref_ackd;
    RIL_Errno                          pref_result;


    QCRIL_LOG_FUNC_ENTRY();


    found_qcril_request = (E_SUCCESS == qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID, QCRIL_EVT_QMI_REQUEST_NW_SELECT, &qcril_req_info));
    QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );


    NAS_CACHE_LOCK();
    if( nas_cached_info.nw_select_is_manual && nas_cached_info.nw_select_is_current && qcril_qmi_nas_is_considered_registered(NULL) )
    {//sending response to Android without waiting for serving_system ind/sys_info ind as there is no change w.r.t network state
        QCRIL_LOG_INFO("Manual registration on current network");
        reg_received = TRUE;
        reg_result   = RIL_E_SUCCESS;
    }
    else
    {
        reg_received = nas_cached_info.nw_select_nw_reg_received;
        reg_result   = nas_cached_info.nw_select_nw_reg_result;
    }
    pref_ackd    = nas_cached_info.nw_select_nw_set_pref_ackd;
    pref_result  = nas_cached_info.nw_select_nw_set_pref_result;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. reg recv, res %d, %d", (int) reg_received, (int)reg_result );
    QCRIL_LOG_INFO( ".. pref ackd, res %d, %d", (int) pref_ackd, (int)pref_result );

    if ( reg_received && pref_ackd )
    { // all is done
        qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_DONE );

        if ( found_qcril_request )
        {
            if ( RIL_E_SUCCESS == reg_result && RIL_E_SUCCESS == pref_result )
            {
                ril_req_res = RIL_E_SUCCESS;
            }
            else if ( RIL_E_SUCCESS == pref_result )
            {
                ril_req_res = reg_result;
            }
            else if ( RIL_E_SUCCESS == reg_result )
            {
                ril_req_res = pref_result;
            }
            else
            {
                ril_req_res = pref_result;
            }

            if ( ( qcril_req_info.request == RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL )
                && ( nas_common_info.is_restore_prev_mode_pref ) )
            {
                qcril_qmi_nas_restore_modem_pref();
            }
            QCRIL_LOG_INFO( ".. reporting %d", (int) ril_req_res );
            // signal done
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, ril_req_res , &resp );
            qcril_send_request_response( &resp );
            qcril_qmi_arb_reset_pref_data_snapshot();
            if ( RIL_E_SUCCESS == ril_req_res )
            {
                qmi_ril_nw_reg_initiate_post_cfg_ban_for_data_reg_extrapolation_ncl();
            }
            qcril_qmi_nas_wave_voice_data_status();
        }
    }


    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_select_nw_conclusion_check

//===========================================================================
// RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC
//===========================================================================
void qcril_qmi_nas_set_network_selection_automatic
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{

  QCRIL_NOTUSED( ret_ptr );
  qcril_qmi_util_initiate_network_selection_check(params_ptr, TRUE, NAS_NIL, NAS_NIL, TRUE, NAS_NIL, RADIO_TECH_UNKNOWN );
} // qcril_qmi_nas_set_network_selection_automatic

//===========================================================================
// RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL
//===========================================================================
void qcril_qmi_nas_set_network_selection_manual
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;


  char * param_str = NULL;
  char * p_str;
  char * rat_start;
  char **in_data;

  int mcc;
  int mnc;

  int ok,pcs_digit_present;

  int rat = RADIO_TECH_UNKNOWN;
  qcril_request_resp_params_type resp;

  QCRIL_NOTUSED( ret_ptr );

  if ( params_ptr->datalen == 0  || params_ptr->data == NULL )
  {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE , &resp );
      qcril_send_request_response( &resp );
  }
  else
  {
      /*
       * new format when RAT is enabled
       * This will avoid any changes in ril_command.h
       */
      if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_COMBINE_RAT) )
      {
        /* format: "mcc_mnc+rat\0" */
        p_str = (char *) (params_ptr->data);
        param_str = NULL;
        rat_start = strchr(p_str, '+');
        if (rat_start)
        {
          /* replace '+' as '\0' */
          *rat_start = 0;
          rat_start++;
          param_str = (char*) p_str;
          rat = atoi((char*)rat_start);
        }
      }
      /* legacy format when RAT is enabled */
      else if ( qmi_ril_is_feature_supported(QMI_RIL_FEATURE_LEGACY_RAT) )
      {
        /* format: string1: mmc_mnc\0 string2: rat\0 */
        in_data = (char **) (params_ptr->data);
        param_str = (char*) in_data[0];
        rat = atoi((char*) in_data[1]);
      }
      /* not RAT support */
      else
      {
        param_str = (char*) params_ptr->data;
      }

      if ( param_str )
      {
          pcs_digit_present = ((strlen(param_str) == MCC_MNC_PCS_DIGIT_LEN) && (param_str[MCC_MNC_PCS_DIGIT_POS] == '0'));
          ok = ( EOF != sscanf( param_str, "%03d%03d", &mcc, &mnc ) );
          QCRIL_LOG_INFO("mcc = %d, mnc = %d, rat = %d\n", mcc, mnc, rat);
      }
      else
      {
          ok = FALSE;
          mcc = NAS_NIL;
          mnc = NAS_NIL;
          pcs_digit_present = FALSE;
      }

      qcril_qmi_util_initiate_network_selection_check(params_ptr, FALSE, mcc, mnc, ok, pcs_digit_present, rat );
  }
} // qcril_qmi_nas_set_network_selection_manual

//===========================================================================
// qcril_qmi_util_initiate_network_selection_check
//===========================================================================
void qcril_qmi_util_initiate_network_selection_check(const qcril_request_params_type *const params_ptr, int is_automatic, int mcc, int mnc, int move_on,int pcs_digit_present, RIL_RadioTechnology rat)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type qcril_req_info;
    qcril_request_resp_params_type resp;
    qmi_ril_nas_nw_select_state_e_type cur_nw_select_state;
    uint32 nw_reg_event_value;

    QCRIL_LOG_INFO( "entry, is_auto %d, mcc %d, mnc %d, move_on %d, pcs_digit_present %d rat %d", (int) is_automatic, (int) mcc, (int) mnc, (int) move_on, (int) pcs_digit_present, rat );

    qcril_reqlist_default_entry( params_ptr->t,
                                 params_ptr->event_id,
                                 QCRIL_DEFAULT_MODEM_ID,
                                 QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                 QCRIL_EVT_QMI_REQUEST_NW_SELECT,
                                 NULL,
                                 &qcril_req_info ); // this does not fail

    cur_nw_select_state = qcril_qmi_nas_get_nw_select_state();
    QCRIL_LOG_INFO( ".. cur nw select state %d ", (int) cur_nw_select_state );
    if ( QMI_RIL_NAS_NW_SELECT_NONE != cur_nw_select_state )
    {  // remains of previous request
        qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_CANCELLING_REQ );
        qcril_qmi_nas_nw_select_handle_total_cleanup(NULL, NULL);
    }

    if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info ) == E_SUCCESS )
    {
        res = qcril_qmi_util_initiate_network_selection(params_ptr, is_automatic, mcc, mnc, move_on, pcs_digit_present, rat);
    }
    else
    {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         qcril_req_info.t,
                                         qcril_req_info.request,
                                         res,
                                         &resp );
      qcril_send_request_response( &resp );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET( (int)res );
} // qcril_qmi_util_initiate_network_selection_check


//===========================================================================
// qcril_qmi_util_initiate_network_selection
//===========================================================================
RIL_Errno qcril_qmi_util_initiate_network_selection(const qcril_request_params_type *const params_ptr, int is_automatic, int mcc, int mnc, int move_on,int pcs_digit_present, RIL_RadioTechnology rat)
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;
    nas_set_system_selection_preference_req_msg_v01 qmi_request;
    nas_get_system_selection_preference_resp_msg_v01 qmi_get_mode_pref_response;
    qmi_txn_handle txn_handle;
    nas_set_system_selection_preference_resp_msg_v01 * res_holder = NULL;
    qmi_client_error_type qmi_client_error;
    qcril_request_resp_params_type resp;
    IxErrnoType req_list_res;
    qmi_ril_nas_nw_select_state_e_type cur_nw_select_state;
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE],current_mnc_str[NAS_MCC_MNC_MAX_SIZE];

    QCRIL_LOG_INFO( "entry, is_auto %d, mcc %d, mnc %d, move_on %d, pcs_digit_present %d, rat %d ", (int) is_automatic, (int) mcc, (int) mnc, (int) move_on, (int) pcs_digit_present, rat );

    do
    {
        if ( !move_on )
            break;

        // fetch cur pref
        if ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref ) )
        {
            res = qcril_qmi_client_send_msg_sync_ex( QCRIL_QMI_CLIENT_NAS,
                                                               QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                               NULL,
                                                               NAS_ZERO, // empty payload
                                                               (void*) &qmi_get_mode_pref_response,
                                                               sizeof( qmi_get_mode_pref_response ),
                                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
            QCRIL_LOG_INFO( ".. mode_pref cache sub fetch val %d ", (int) res  );
            if ( RIL_E_SUCCESS == res )
            {
                NAS_CACHE_LOCK();
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.mode_pref, qmi_get_mode_pref_response.mode_pref );
                NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.lte_disable_cause, qmi_get_mode_pref_response.lte_disable_cause );
                NAS_CACHE_UNLOCK();
                QCRIL_LOG_INFO( ".. mode_pref cache sub fetch ok " );
            }
        }
        else
        {
            res = RIL_E_SUCCESS;
        }
        if ( RIL_E_SUCCESS != res )
            break;


        // set direction
        res = qcril_qmi_nas_set_nw_select_state(QMI_RIL_NAS_NW_SELECT_WAKING_UP);
        QCRIL_LOG_INFO( ".. set nw sel state %d ", (int) res  );
        if ( RIL_E_SUCCESS != res )
            break;

        qcril_qmi_nas_set_nw_select_state(QMI_RIL_NAS_NW_SELECT_SETTING_PREF); // this may not fail

        // initiate request

        memset( &qmi_request, 0, sizeof(qmi_request) );
        qmi_request.net_sel_pref_valid = TRUE;
        qmi_request.net_sel_pref.net_sel_pref = is_automatic ? NAS_NET_SEL_PREF_AUTOMATIC_V01 : NAS_NET_SEL_PREF_MANUAL_V01;
        if ( !is_automatic )
        {
            qmi_request.net_sel_pref.mcc = mcc;
            qmi_request.net_sel_pref.mnc = mnc;

            if( TRUE == pcs_digit_present )
            {
                qmi_request.mnc_includes_pcs_digit_valid = TRUE;
                qmi_request.mnc_includes_pcs_digit = TRUE;
            }
            NAS_CACHE_LOCK();
            nas_cached_info.nw_select_is_manual = TRUE;
            snprintf( nas_cached_info.nw_select_manual_mcc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)mcc );
            if ( (mnc > 99) ||  TRUE == pcs_digit_present )
            {
                snprintf( nas_cached_info.nw_select_manual_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%03d", (int)mnc );
            }
            else
            {
                snprintf( nas_cached_info.nw_select_manual_mnc_str, NAS_MCC_MNC_MAX_SIZE, "%02d", (int)mnc );
            }

            if( qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, TRUE, NULL) )
            {
                QCRIL_LOG_INFO( "checking selected network is current or not - current_mcc=%s current_mnc=%s selected_mcc=%s selected_mnc=%s ",current_mcc_str,current_mnc_str,
                                nas_cached_info.nw_select_manual_mcc_str,nas_cached_info.nw_select_manual_mnc_str );
                nas_cached_info.nw_select_is_current = (!strcmp(current_mcc_str,nas_cached_info.nw_select_manual_mcc_str) &&
                                                        !strcmp(current_mnc_str,nas_cached_info.nw_select_manual_mnc_str));
            }

            QCRIL_LOG_INFO( ".. mode_pref cache valid %d ", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref)  );

            if( RADIO_TECH_UNKNOWN != rat )
            {
                if ( !qmi_ril_is_rat_tlv_support_available() )
                {
                    qmi_request.mode_pref_valid = TRUE;
                    qmi_request.mode_pref = qcril_qmi_nas2_convert_rat_to_mode_pref(rat);
                    QCRIL_LOG_INFO( ".. requesting mode_pref valid %d, value %d",
                                    (int) qmi_request.mode_pref_valid,qmi_request.mode_pref );
                    if ( !NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref) || qmi_request.mode_pref != nas_cached_info.mode_pref ||
                         (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_disable_cause) &&
                          (NAS_LTE_DISABLE_CAUSE_DOM_SEL_V01 == nas_cached_info.lte_disable_cause ||
                           NAS_LTE_DISABLE_CAUSE_DAM_V01 == nas_cached_info.lte_disable_cause))
                       )
                    {
                        nas_cached_info.nw_select_is_current = FALSE;
                        if ( ( nas_common_info.is_restore_prev_mode_pref )
                                && NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref) )
                        {
                            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.prev_mode_pref, nas_cached_info.mode_pref );
                        }
                        else
                        {
                            NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
                        }
                    }
                    else
                    {
                        // if the request mode_pref is the same as the previous one, no need to restore
                        NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
                    }
                }
                else
                {
                    qmi_request.rat_valid = TRUE;
                    qmi_request.rat = qcril_qmi_nas2_convert_qcril_rat_to_qmi_rat(rat);
                }
            }

            NAS_CACHE_UNLOCK();
        }

        res_holder = qcril_malloc( sizeof(*res_holder) );
        if ( res_holder )
        {
            qmi_client_error = qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                               QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                               (void*) &qmi_request,
                                                               sizeof( qmi_request ),
                                                               (void*) res_holder,
                                                               sizeof( *res_holder ),
                                                               qcril_qmi_nas_set_nw_selection_command_cb,
                                                               NULL,
                                                               &txn_handle
                                                 );
            res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );
            QCRIL_LOG_INFO("QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01 req sent error=%d",res);
        }
        else
        {
            res = RIL_E_GENERIC_FAILURE;
        }

    } while (FALSE);

    if ( RIL_E_SUCCESS != res )
    { // not done -- rollback
        cur_nw_select_state = qcril_qmi_nas_get_nw_select_state();
        QCRIL_LOG_INFO( ".. rolling back res, state %d, %d ", (int) res, (int) cur_nw_select_state );
        if ( QMI_RIL_NAS_NW_SELECT_AWAKEN == cur_nw_select_state )
        {
            qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_ROLLBACK );
        }
        if ( res_holder )
        {
            qcril_free( res_holder );
        }
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, res , &resp );
        qcril_send_request_response( &resp );
        qcril_qmi_nas_wave_voice_data_status();
    }

    QCRIL_LOG_INFO( "completion, res %d ", (int) res );

    return res;
} // qcril_qmi_util_initiate_network_selection

//===========================================================================
// qcril_qmi_nas_restore_modem_pref
//===========================================================================
void qcril_qmi_nas_restore_modem_pref()
{
  qmi_client_error_type qmi_client_error;
  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_get_system_selection_preference_resp_msg_v01 qmi_response;
  RIL_Errno res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    memset( &qmi_request, 0, sizeof(qmi_request) );
    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.prev_mode_pref) )
    {
      QCRIL_LOG_INFO( "reset mode to %d", nas_cached_info.prev_mode_pref );
      qmi_request.mode_pref = nas_cached_info.prev_mode_pref;
      qmi_request.mode_pref_valid = TRUE;
    }
    NAS_CACHE_UNLOCK();

    if ( !qmi_request.mode_pref_valid )
    {
      QCRIL_LOG_ERROR("no saved previous mode preference");
      break;
    }

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                 QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                 &qmi_request,
                                                 sizeof( qmi_request ),
                                                 (void*) &qmi_response,
                                                 sizeof( qmi_response ),
                                                 QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
    if ( RIL_E_SUCCESS != res )
    {
      QCRIL_LOG_INFO( ".. fail to set mode back to %d ", qmi_request.mode_pref );
    }

    NAS_CACHE_LOCK();
    NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
    NAS_CACHE_UNLOCK();

  } while (0);

  QCRIL_LOG_FUNC_RETURN();
}


void qcril_qmi_nas_post_event
(
    qmi_client_type              user_handle,
    unsigned int                 msg_id,
    qcril_evt_e_type             qcril_event_id,
    void                         *resp_c_struct,
    unsigned int                 resp_c_struct_len,
    void                         *resp_cb_data,
    qmi_client_error_type        transp_err
 )
{
    qmi_resp_callback_type qmi_resp_callback;

    QCRIL_LOG_FUNC_ENTRY();

    qmi_resp_callback.user_handle = user_handle;
    qmi_resp_callback.msg_id = msg_id;
    qmi_resp_callback.data_buf = (void*) resp_c_struct;
    qmi_resp_callback.data_buf_len = resp_c_struct_len;
    qmi_resp_callback.cb_data = resp_cb_data;
    qmi_resp_callback.transp_err = transp_err;

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   qcril_event_id,
                   (void*) &qmi_resp_callback,
                   sizeof(qmi_resp_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

    QCRIL_LOG_FUNC_RETURN();
}


//===========================================================================
// qcril_qmi_nas_set_nw_selection_command_cb
//===========================================================================
void qcril_qmi_nas_set_nw_selection_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_post_event(user_handle,
                             msg_id,
                             QCRIL_EVT_QMI_REQUEST_NW_SELECT,
                             resp_c_struct,
                             resp_c_struct_len,
                             resp_cb_data,
                             transp_err);
    QCRIL_LOG_FUNC_RETURN();
}


//===========================================================================
// qcril_qmi_nas_set_nw_selection_command_cb_helper
//===========================================================================
void qcril_qmi_nas_set_nw_selection_command_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    void *resp_c_struct;
    qmi_client_error_type  transp_err;
    qmi_resp_callback_type * qmi_resp_callback;
    nas_set_system_selection_preference_resp_msg_v01 * res_holder;
    RIL_Errno                                          ril_req_res;
    qmi_ril_nas_nw_select_state_e_type                 cur_state;

    qmi_resp_callback = (qmi_resp_callback_type *) params_ptr->data;
    resp_c_struct = qmi_resp_callback->data_buf;
    transp_err = qmi_resp_callback->transp_err;

    do
    {
        if (!resp_c_struct) {
           QCRIL_LOG_ERROR("Invalid parameter resp_c_struct is NULL, aborting!");
           QCRIL_ASSERT(0);
           break;
        }

        res_holder = (nas_set_system_selection_preference_resp_msg_v01 *) resp_c_struct;
        QCRIL_LOG_INFO( "trans_err, resp.err  %d, %d ", (int) transp_err, (int) res_holder->resp.error );

        cur_state = qcril_qmi_nas_get_nw_select_state();
        QCRIL_LOG_INFO( ".. nw sel state %d", (int) cur_state );

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &res_holder->resp );
        QCRIL_LOG_INFO( ".. set pref res %d, %d, %d ", (int) transp_err, (int) res_holder->resp.error, (int) ril_req_res );

        switch ( cur_state )
        {
            case QMI_RIL_NAS_NW_SELECT_SETTING_PREF:
            case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_LIMITED_REGD:
            case QMI_RIL_NAS_NW_SELECT_SETTING_PREF_REGD:
                NAS_CACHE_LOCK();
                nas_cached_info.nw_select_nw_set_pref_ackd   = TRUE;
                nas_cached_info.nw_select_nw_set_pref_result = ril_req_res;
                NAS_CACHE_UNLOCK();
                if ( QMI_RIL_NAS_NW_SELECT_SETTING_PREF == cur_state )
                {
                    qcril_qmi_nas_set_nw_select_state( QMI_RIL_NAS_NW_SELECT_AWAITING_REG );
                }
                qcril_qmi_nas_select_nw_conclusion_check();
                break;

            default: // skip
                break;
        }

        if ( res_holder )
        {
            qcril_free( res_holder );
        }
    } while(0);

    QCRIL_LOG_FUNC_RETURN();

}  // qcril_qmi_nas_set_nw_selection_command_cb

//===========================================================================
// qcril_qmi_nas_wave_voice_data_status
//===========================================================================
void qcril_qmi_nas_wave_voice_data_status()
{
    qcril_unsol_resp_params_type unsol_resp_params;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO("qcril_qmi_nas_wave_voice_data_status");

    qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
    qcril_send_unsol_response( &unsol_resp_params );

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_wave_voice_data_status

//===========================================================================
// RIL_REQUEST_SCREEN_STATE
//===========================================================================
void qcril_qmi_nas_request_screen_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_request_resp_params_type
              resp;
  char*       req_val;
  int         enable;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qmi_ril_gen_operational_status_type
              operational_state;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );
  if ( params_ptr->datalen > NAS_ZERO && params_ptr->data != NULL )
  {
      operational_state = qmi_ril_get_operational_status();

      req_val = (char * )params_ptr->data;
      if ( *req_val )
      { // on
          enable = TRUE;
      }
      else
      { // off
          enable = FALSE;
      }
      QCRIL_LOG_INFO( ".. SCREEN_STATE commands to enable %d, while operation state %d ", (int) enable, operational_state );

      NAS_CACHE_LOCK();
      nas_common_info.is_screen_off = enable ? FALSE : TRUE;
      NAS_CACHE_UNLOCK();

      switch ( operational_state )
      {
          case QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING: // fallthrough
          case QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED: // fallthrough
          case QMI_RIL_GEN_OPERATIONAL_STATUS_RESUMING:
              qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_DATA_ON_STACK,
                               QCRIL_EVT_QMI_RIL_COMMON_IND_SUBSCRIBE_CONSIDER_ACTION,
                               NULL,
                               NAS_NIL,
                               (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
              break;

          default:
              // no action, just track UI's SCREEN_STATE
              break;
      }

      ril_req_res = RIL_E_SUCCESS;
  }

  // ** respond
  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );

  QCRIL_LOG_FUNC_RETURN_WITH_RET( (int) ril_req_res );
} // qcril_qmi_nas_request_screen_state


//===========================================================================
//qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl
//===========================================================================
void qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl( void )
{
  qcril_data_limited_sys_ind_switch_type limited_data_sys_ind_switch;
  int res;
  int action_needed;

  NAS_CACHE_LOCK();
  if (nas_common_info.data_limited_sys_ind_toggle)
  {
    action_needed = TRUE;
  }
  else
  {
    action_needed = FALSE;
  }

  limited_data_sys_ind_switch = nas_common_info.is_screen_off ? LIMITED_SYS_INDICATIONS_ON : LIMITED_SYS_INDICATIONS_OFF;
  NAS_CACHE_UNLOCK();

  if (action_needed)
  {
    res = qcril_data_toggle_limited_sys_indications( limited_data_sys_ind_switch );
    QCRIL_LOG_INFO( ".. data limited sys indications req: %d, res: %d", (int)limited_data_sys_ind_switch, res );
  }

} // qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl


//===========================================================================
//qmi_ril_nwreg_enforce_data_dormancy_as_applicable
//===========================================================================
void qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl( void )
{
    int                                   action_needed;
    qcril_data_dormancy_ind_switch_type   data_dormancy_switch;
    int                                   is_currently_online;
    int                                   data_dormancy_res;

    action_needed = FALSE;

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
    }
    else
    {
        is_currently_online  = TRUE; // assumed
    }

    if ( !nas_common_info.data_dormancy_no_toggle )
    { // no setting to not to toggle data dormancy
        if ( is_currently_online )
        { // online
            data_dormancy_switch                            = nas_common_info.is_screen_off ? DORMANCY_INDICATIONS_OFF : DORMANCY_INDICATIONS_ON;
            nas_common_info.data_dormancy_ind_enabled       = nas_common_info.is_screen_off ? FALSE : TRUE;
            action_needed                                   = TRUE;
        }
        else
        { // LPM etc
            if ( nas_common_info.data_dormancy_ind_enabled )
            { // ind enabled
                data_dormancy_switch                      = DORMANCY_INDICATIONS_OFF;
                action_needed                             = TRUE;
                nas_common_info.data_dormancy_ind_enabled = FALSE;
            }
            else
            { // already disabled
                action_needed        = FALSE;
            }
        }
    }
    else
    { // setting to not to toggle data dormancy
        if ( is_currently_online )
        { // online
            if ( !nas_common_info.data_dormancy_ind_enabled )
            { // no ind enabled
                data_dormancy_switch                        = DORMANCY_INDICATIONS_ON;
                action_needed                               = TRUE;
                nas_common_info.data_dormancy_ind_enabled   = TRUE;
            }
            else
            { // already enabled
                action_needed        = FALSE;
            }
        }
        else
        { // LPM etc
            if ( nas_common_info.data_dormancy_ind_enabled )
            { // still enabled
                data_dormancy_switch                        = DORMANCY_INDICATIONS_OFF;
                action_needed                               = TRUE;
                nas_common_info.data_dormancy_ind_enabled   = FALSE;
            }
            else
            { // already disabled
                action_needed        = FALSE;
            }
        }
    }
    NAS_CACHE_UNLOCK();
    if ( action_needed )
    {
        data_dormancy_res = qcril_data_toggle_dormancy_indications( data_dormancy_switch );
        QCRIL_LOG_INFO( ".. data dormancy req %d, %d", (int)data_dormancy_switch, (int)data_dormancy_res );
    }
} // qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl

//===========================================================================
//qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search_as_applicable_ncl
//===========================================================================
void qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search_as_applicable_ncl( void )
{
    int                                   is_currently_online;
    int                                   enable;
    int                                   action_needed;
    int                                   action_needed_for_pbm;

    action_needed = FALSE;
    action_needed_for_pbm = FALSE;

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
    }
    else
    {
        is_currently_online  = TRUE; // assumed
    }
    if ( is_currently_online )
    { // modem online
        enable                                           =  nas_common_info.is_screen_off ? FALSE : TRUE;
        nas_cached_info.common_indications_is_subscribed = enable;
        action_needed                                    = TRUE;
    }
    else
    { // in LPM etc
        if ( nas_cached_info.common_indications_is_subscribed )
        {
            enable                                           = FALSE;
            nas_cached_info.common_indications_is_subscribed = FALSE;
            action_needed                                    = TRUE;
        }
        enable = FALSE;
    }

    if( action_needed )
    {
        action_needed_for_pbm = TRUE;

        //Do not enable or disable the PBM indications when the
        //window for keeping the PBM indications enabled is active
        //When the window has passed, We will disable the PBM indications If the modem is in LPM or the Screen is OFF
        if( nas_common_info.wait_for_pbm_ind && nas_common_info.wait_for_pbm_ind_timer_id_valid)
        {
            action_needed_for_pbm = FALSE;
        }
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO(".. action needed %d, action_needed_for_pbm %d, enable %d, is_online %d ", action_needed, action_needed_for_pbm, enable, is_currently_online );

    if ( action_needed )
    {
        (void)qcril_qmi_util_enable_networking_indications( enable, enable );
        qcril_qmi_voice_toggle_ind_reg_on_screen_state( enable );
    }

    if( action_needed_for_pbm )
    {
        (void)qcril_qmi_pbm_enable_emergency_number_indications( enable );
    }

    if ( action_needed && enable && is_currently_online )
    {
        if( nas_common_info.force_nw_search )
        {
            qcril_qmi_nas_force_network_search();
        }
    }

} // qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search_as_applicable_ncl


//===========================================================================
//qcril_qmi_nas_force_network_search
//===========================================================================
void qcril_qmi_nas_force_network_search()
{
    QCRIL_LOG_FUNC_ENTRY();

    RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_force_network_search_resp_msg_v01 qmi_response;
    qmi_client_error_type qmi_transport_error;


    memset(&qmi_response,0,sizeof(qmi_response));
    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                       QMI_NAS_FORCE_NETWORK_SEARCH_REQ_MSG_V01,
                                                       NULL,
                                                       NAS_NIL,
                                                       (void*) &qmi_response,
                                                       sizeof( qmi_response ),
                                                       QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &qmi_response.resp);

    QCRIL_LOG_INFO("msg send error code %d, nas result %d, nas error code %d",ril_req_res,qmi_response.resp.result,qmi_response.resp.error);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_force_network_search


/*===========================================================================
  qcril_qmi_nas_populate_sig_config_delta_info
============================================================================*/
void qcril_qmi_nas_populate_sig_config_delta_info()
{
    QCRIL_LOG_FUNC_ENTRY();

    if ( qcril_db_query_sig_config("cdma_ecio_delta",&nas_common_info.sig_config.cdma_ecio_delta) ||
         nas_common_info.sig_config.cdma_ecio_delta == 0 )
    {
       nas_common_info.sig_config.cdma_ecio_delta = QMI_RIL_NAS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("cdma_rssi_delta",&nas_common_info.sig_config.cdma_rssi_delta)||
        nas_common_info.sig_config.cdma_rssi_delta == 0 )
    {
        nas_common_info.sig_config.cdma_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("gsm_rssi_delta",&nas_common_info.sig_config.gsm_rssi_delta) ||
        nas_common_info.sig_config.gsm_rssi_delta == 0 )
    {
        nas_common_info.sig_config.gsm_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("hdr_ecio_delta",&nas_common_info.sig_config.hdr_ecio_delta) ||
        nas_common_info.sig_config.hdr_ecio_delta == 0 )
    {
        nas_common_info.sig_config.hdr_ecio_delta = QMI_RIL_NAS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("hdr_rssi_delta",&nas_common_info.sig_config.hdr_rssi_delta) ||
        nas_common_info.sig_config.hdr_rssi_delta == 0 )
    {
        nas_common_info.sig_config.hdr_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("hdr_sinr_delta",&nas_common_info.sig_config.hdr_sinr_delta) ||
        nas_common_info.sig_config.hdr_sinr_delta == 0 )
    {
        nas_common_info.sig_config.hdr_sinr_delta = QMI_RIL_NAS_SINR_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rsrp_delta",&nas_common_info.sig_config.lte_rsrp_delta) ||
        nas_common_info.sig_config.lte_rsrp_delta == 0 )
    {
        nas_common_info.sig_config.lte_rsrp_delta = QMI_RIL_NAS_RSRP_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rsrq_delta",&nas_common_info.sig_config.lte_rsrq_delta) ||
        nas_common_info.sig_config.lte_rsrq_delta == 0 )
    {
        nas_common_info.sig_config.lte_rsrq_delta = QMI_RIL_NAS_RSRQ_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_rssi_delta",&nas_common_info.sig_config.lte_rssi_delta) ||
        nas_common_info.sig_config.lte_rssi_delta == 0 )
    {
        nas_common_info.sig_config.lte_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("lte_snr_delta",&nas_common_info.sig_config.lte_snr_delta) ||
        nas_common_info.sig_config.lte_snr_delta == 0 )
    {
        nas_common_info.sig_config.lte_snr_delta = QMI_RIL_NAS_SNR_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_ecio_delta",&nas_common_info.sig_config.tdscdma_ecio_delta) ||
        nas_common_info.sig_config.tdscdma_ecio_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_ecio_delta = QMI_RIL_NAS_TDS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_rscp_delta",&nas_common_info.sig_config.tdscdma_rscp_delta) ||
        nas_common_info.sig_config.tdscdma_rscp_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_rscp_delta = QMI_RIL_NAS_RSCP_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_rssi_delta",&nas_common_info.sig_config.tdscdma_rssi_delta) ||
        nas_common_info.sig_config.tdscdma_rssi_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_rssi_delta = QMI_RIL_NAS_TDS_RSSI_DELTA;
    }
    if ( qcril_db_query_sig_config("tdscdma_sinr_delta",&nas_common_info.sig_config.tdscdma_sinr_delta) ||
        nas_common_info.sig_config.tdscdma_sinr_delta == 0 )
    {
        nas_common_info.sig_config.tdscdma_sinr_delta = QMI_RIL_NAS_SINR_DELTA;
    }
    if ( qcril_db_query_sig_config("wcdma_ecio_delta",&nas_common_info.sig_config.wcdma_ecio_delta) ||
        nas_common_info.sig_config.wcdma_ecio_delta == 0 )
    {
        nas_common_info.sig_config.wcdma_ecio_delta = QMI_RIL_NAS_ECIO_DELTA;
    }
    if ( qcril_db_query_sig_config("wcdma_rssi_delta",&nas_common_info.sig_config.wcdma_rssi_delta) ||
        nas_common_info.sig_config.wcdma_rssi_delta == 0 )
    {
        nas_common_info.sig_config.wcdma_rssi_delta = QMI_RIL_NAS_RSSI_DELTA;
    }

    QCRIL_LOG_FUNC_RETURN();
    return;
}

/*===========================================================================
  qcril_qmi_nas_configure_sig_info2
============================================================================*/
RIL_Errno qcril_qmi_nas_configure_sig_info2()
{
    RIL_Errno ril_err = RIL_E_GENERIC_FAILURE;
    qmi_client_error_type qmi_transport_error;

    QCRIL_LOG_FUNC_ENTRY();

    nas_config_sig_info2_req_msg_v01 *light_indications_sig_info2_qmi_request;
    nas_config_sig_info2_resp_msg_v01 light_indications_sig_info2_qmi_response;

    light_indications_sig_info2_qmi_request = qcril_malloc( sizeof( *light_indications_sig_info2_qmi_request ) );

    if( light_indications_sig_info2_qmi_request )
    {
        memset( light_indications_sig_info2_qmi_request, 0, sizeof( *light_indications_sig_info2_qmi_request ) );

        light_indications_sig_info2_qmi_request->cdma_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->cdma_ecio_delta = nas_common_info.sig_config.cdma_ecio_delta;

        light_indications_sig_info2_qmi_request->cdma_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->cdma_rssi_delta = nas_common_info.sig_config.cdma_rssi_delta;

        light_indications_sig_info2_qmi_request->gsm_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->gsm_rssi_delta = nas_common_info.sig_config.gsm_rssi_delta;

        light_indications_sig_info2_qmi_request->hdr_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->hdr_ecio_delta = nas_common_info.sig_config.hdr_ecio_delta;

        light_indications_sig_info2_qmi_request->hdr_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->hdr_rssi_delta = nas_common_info.sig_config.hdr_rssi_delta;

        light_indications_sig_info2_qmi_request->hdr_sinr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->hdr_sinr_delta = nas_common_info.sig_config.hdr_sinr_delta;

        light_indications_sig_info2_qmi_request->lte_rsrp_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_rsrp_delta = nas_common_info.sig_config.lte_rsrp_delta;

        light_indications_sig_info2_qmi_request->lte_rsrq_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_rsrq_delta = nas_common_info.sig_config.lte_rsrq_delta;

        light_indications_sig_info2_qmi_request->lte_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_rssi_delta = nas_common_info.sig_config.lte_rssi_delta;

        light_indications_sig_info2_qmi_request->lte_snr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->lte_snr_delta = nas_common_info.sig_config.lte_snr_delta;

        light_indications_sig_info2_qmi_request->tdscdma_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_ecio_delta = (float)nas_common_info.sig_config.tdscdma_ecio_delta;

        light_indications_sig_info2_qmi_request->tdscdma_rscp_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_rscp_delta = nas_common_info.sig_config.tdscdma_rscp_delta;

        light_indications_sig_info2_qmi_request->tdscdma_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_rssi_delta = (float)nas_common_info.sig_config.tdscdma_rssi_delta;

        light_indications_sig_info2_qmi_request->tdscdma_sinr_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->tdscdma_sinr_delta = (float)nas_common_info.sig_config.tdscdma_sinr_delta;

        light_indications_sig_info2_qmi_request->wcdma_ecio_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->wcdma_ecio_delta = nas_common_info.sig_config.wcdma_ecio_delta;

        light_indications_sig_info2_qmi_request->wcdma_rssi_delta_valid = TRUE;
        light_indications_sig_info2_qmi_request->wcdma_rssi_delta = nas_common_info.sig_config.wcdma_rssi_delta;


        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                            QMI_NAS_CONFIG_SIG_INFO2_REQ_MSG_V01,
                                                            (void*) light_indications_sig_info2_qmi_request,
                                                            sizeof( *light_indications_sig_info2_qmi_request ),
                                                            (void*) &light_indications_sig_info2_qmi_response,
                                                            sizeof( light_indications_sig_info2_qmi_response ),
                                                            QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &light_indications_sig_info2_qmi_response.resp );
        QCRIL_LOG_INFO( ".. requested nas config info %d, %d", (int)qmi_transport_error, (int)ril_err );
        qcril_free(light_indications_sig_info2_qmi_request);
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ril_err);
    return ril_err;
}


//===========================================================================
//qcril_qmi_util_enable_networking_indications
//===========================================================================
RIL_Errno qcril_qmi_util_enable_networking_indications( int enable, int force_update )
{
    int iter_i = 0;
    nas_set_event_report_req_msg_v01  light_indications_qmi_request;
    nas_set_event_report_resp_msg_v01 light_indications_qmi_response;
    nas_indication_register_req_msg_v01 nwreg_indications_qmi_request;
    nas_indication_register_resp_msg_v01 nwreg_indications_qmi_response;
    nas_limit_sys_info_ind_reporting_req_msg_v01 limit_sys_info_qmi_request;
    nas_limit_sys_info_ind_reporting_resp_msg_v01 limit_sys_info_qmi_response;

    int old_rte;
    int new_rte;

    uint8_t enable_indications;

    qmi_client_error_type qmi_transport_error;

    qcril_unsol_resp_params_type unsol_resp_params;

    RIL_Errno                        ril_err;
    RIL_Errno                        ril_err_fallback;

    qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
    qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
    int                              any_rte_change;

    int                              is_currently_online;
    uint8_t                          always_enable_action;

    qmi_ril_nw_reg_rte_type                 vrte;
    qmi_ril_nw_reg_rte_type                 drte;
    qmi_ril_nw_reg_rat_confidence_tag_type  vrte_confidence;
    qmi_ril_nw_reg_rat_confidence_tag_type  drte_confidence;

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
        always_enable_action = is_currently_online;
    }
    else
    {
        is_currently_online  = TRUE; // assumed
        always_enable_action = TRUE;
    }
    NAS_CACHE_UNLOCK();

    enable_indications = ( enable && is_currently_online )  ? NAS_REQ_REPORT : NAS_REQ_DO_NOT_REPORT;

    QCRIL_LOG_INFO( "enable: prm %d, action context_enable %d, action always_enable %d ", (int) enable, (int)enable_indications, (int)always_enable_action );

    if( !qmi_ril_is_qmi_sys_info_available() )
    {
        // request signal strength ind
        memset( &light_indications_qmi_request, 0, sizeof( light_indications_qmi_request ) );
        light_indications_qmi_request.signal_strength_valid = TRUE;
        light_indications_qmi_request.signal_strength.report_signal_strength = enable_indications;
        light_indications_qmi_request.signal_strength.report_signal_strength_threshold_list_len = 2;
        light_indications_qmi_request.signal_strength.report_signal_strength_threshold_list[0]  = 1;
        light_indications_qmi_request.signal_strength.report_signal_strength_threshold_list[0]  = -1;

        light_indications_qmi_request.report_rf_band_info_valid = TRUE;
        light_indications_qmi_request.report_rf_band_info = enable_indications;

        light_indications_qmi_request.report_reg_reject_valid = TRUE;
        light_indications_qmi_request.report_reg_reject       = always_enable_action;  // we cannot loose this one

        light_indications_qmi_request.rssi_indicator_valid = TRUE;
        light_indications_qmi_request.rssi_indicator.report_rssi = enable_indications;
        light_indications_qmi_request.rssi_indicator.rssi_delta = 1;

        light_indications_qmi_request.ecio_indicator_valid = TRUE;
        light_indications_qmi_request.ecio_indicator.report_ecio = enable_indications;
        light_indications_qmi_request.ecio_indicator.ecio_delta = 2;


        light_indications_qmi_request.io_indicator_valid = TRUE;
        light_indications_qmi_request.io_indicator.report_io = enable_indications;
        light_indications_qmi_request.io_indicator.io_delta = 1;

        light_indications_qmi_request.sinr_indicator_valid = TRUE;
        light_indications_qmi_request.sinr_indicator.report_sinr = enable_indications;
        light_indications_qmi_request.sinr_indicator.sinr_delta  = 1;

        light_indications_qmi_request.report_error_rate_valid = TRUE;
        light_indications_qmi_request.report_error_rate       = enable_indications;

        light_indications_qmi_request.rsrq_indicator_valid = TRUE;
        light_indications_qmi_request.rsrq_indicator.report_rsrq = enable_indications;
        light_indications_qmi_request.rsrq_indicator.rsrq_delta = 5;

        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_SET_EVENT_REPORT_REQ_MSG_V01,
                                                           (void*) &light_indications_qmi_request,
                                                           sizeof( light_indications_qmi_request ),
                                                           (void*) &light_indications_qmi_response,
                                                           sizeof( light_indications_qmi_response ),
                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &light_indications_qmi_response.resp );
        QCRIL_LOG_INFO( ".. requested nas event report %d, %d", (int)qmi_transport_error, (int)ril_err );
    }
    else
    {

        ril_err = qcril_qmi_nas_configure_sig_info2();

        // fallback support for reg reject over event_report
        memset( &light_indications_qmi_request, 0, sizeof( light_indications_qmi_request ) );
        light_indications_qmi_request.report_reg_reject_valid = TRUE;
        light_indications_qmi_request.report_reg_reject = TRUE;

        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                            QMI_NAS_SET_EVENT_REPORT_REQ_MSG_V01,
                                                            (void*) &light_indications_qmi_request,
                                                            sizeof( light_indications_qmi_request ),
                                                            (void*) &light_indications_qmi_response,
                                                            sizeof( light_indications_qmi_response ),
                                                            QCRIL_QMI_SYNC_REQ_DEF_TIMEOUT );

        ril_err_fallback = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &light_indications_qmi_response.resp );
        QCRIL_LOG_INFO( ".. requested nas event report fallback %d, %d", (int)qmi_transport_error, (int)ril_err_fallback ); // fallback err is ignored only logged

    }

    if ( RIL_E_SUCCESS == ril_err )
    {

        // request other inds
        memset( &nwreg_indications_qmi_request, 0, sizeof( nwreg_indications_qmi_request ) );

        nwreg_indications_qmi_request.reg_sys_sel_pref_valid = TRUE;
        nwreg_indications_qmi_request.reg_sys_sel_pref       = TRUE;  // always receive sys sel preference - esp. emergency callback mode change updates

        nwreg_indications_qmi_request.dual_standby_pref_valid = TRUE;
        nwreg_indications_qmi_request.dual_standby_pref       = TRUE; // always receive DSDS indications

        nwreg_indications_qmi_request.subscription_info_valid = TRUE;
        nwreg_indications_qmi_request.subscription_info       = TRUE;

        nwreg_indications_qmi_request.reg_network_time_valid = TRUE;
        nwreg_indications_qmi_request.reg_network_time       = always_enable_action;  // receive network time update unless in LPM

        nwreg_indications_qmi_request.reg_lte_sib16_network_time_valid = TRUE;
        nwreg_indications_qmi_request.reg_lte_sib16_network_time = always_enable_action;

        nwreg_indications_qmi_request.reg_rtre_cfg_valid = TRUE;
        nwreg_indications_qmi_request.reg_rtre_cfg       = TRUE;

        nwreg_indications_qmi_request.reg_embms_status_valid = TRUE;
        nwreg_indications_qmi_request.reg_embms_status       = always_enable_action;

        if( qmi_ril_is_qmi_sys_info_available() )
        {
            nwreg_indications_qmi_request.sig_info_valid = TRUE;
            nwreg_indications_qmi_request.sig_info       = enable_indications;

            nwreg_indications_qmi_request.err_rate_valid = TRUE;
            nwreg_indications_qmi_request.err_rate       = enable_indications;

            nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
            nwreg_indications_qmi_request.req_serving_system       = FALSE;       // always suppress serving system inds when sys_info available

            nwreg_indications_qmi_request.reg_current_plmn_name_valid = TRUE;
            nwreg_indications_qmi_request.reg_current_plmn_name       = enable_indications;

            if( QCRIL_IS_COEX_ENABLED())
            {
                NAS_CACHE_LOCK();
                if(NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.mode_pref) &&
                   (( NAS_NIL != ( QMI_NAS_RAT_MODE_PREF_LTE & nas_cached_info.mode_pref ) ) ||
                    ( NAS_NIL != ( QMI_NAS_RAT_MODE_PREF_GSM & nas_cached_info.mode_pref ) )))
                {
                  // Enable RF band indications if LTE
                  nwreg_indications_qmi_request.reg_rf_band_info_valid = TRUE;
                  nwreg_indications_qmi_request.reg_rf_band_info       = always_enable_action;  // lte coex
                }
                else
                {
                  nwreg_indications_qmi_request.reg_rf_band_info_valid = TRUE;
                  nwreg_indications_qmi_request.reg_rf_band_info = FALSE;
                }
                NAS_CACHE_UNLOCK();
            }

            if ( nas_common_info.add_power_save_enabled )
            {
                nwreg_indications_qmi_request.sys_info_valid = TRUE;
                nwreg_indications_qmi_request.sys_info       = enable_indications;
            }
            else if ( is_currently_online )
            {
                if ( !nas_common_info.registered_sys_serv_ind )
                {
                    nwreg_indications_qmi_request.sys_info_valid = TRUE;
                    nwreg_indications_qmi_request.sys_info       = TRUE;
                    nas_common_info.registered_sys_serv_ind      = TRUE;
                }
                else
                {
                    memset( &limit_sys_info_qmi_request, 0, sizeof( limit_sys_info_qmi_request ) );
                    memset( &limit_sys_info_qmi_response, 0, sizeof( limit_sys_info_qmi_response ) );
                    limit_sys_info_qmi_request.limit_sys_info_chg_rpt = enable ? 0 : NAS_LIMIT_BY_SRV_STATUS_V01 | NAS_LIMIT_BY_SRV_DOMAIN_V01;
                    QCRIL_LOG_INFO( "Requesting nas limit sys info ind reporting [%d].. enable [%d]", limit_sys_info_qmi_request.limit_sys_info_chg_rpt, enable );
                    qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                             QMI_NAS_LIMIT_SYS_INFO_IND_REPORTING_REQ_MSG_V01,
                                                             &limit_sys_info_qmi_request,
                                                             sizeof( limit_sys_info_qmi_request ),
                                                             (void*) &limit_sys_info_qmi_response,
                                                             sizeof( limit_sys_info_qmi_response ),
                                                             QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
                    ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &limit_sys_info_qmi_response.resp );
                    QCRIL_LOG_INFO( ".. requested nas limit sys info ind %d, %d", (int)qmi_transport_error, (int)ril_err );
                }
            }
        }
        else
        {
            if( nas_common_info.add_power_save_enabled )
            {
                nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
                nwreg_indications_qmi_request.req_serving_system = enable_indications;
            }
            else if( !nas_common_info.registered_sys_serv_ind && is_currently_online )
            {
                nwreg_indications_qmi_request.req_serving_system_valid = TRUE;
                nwreg_indications_qmi_request.req_serving_system = TRUE;
                nas_common_info.registered_sys_serv_ind = TRUE;
            }

            nwreg_indications_qmi_request.reg_managed_roaming_valid = TRUE;
            nwreg_indications_qmi_request.reg_managed_roaming       = always_enable_action;  // we may not miss it
        }


        qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_INDICATION_REGISTER_REQ_MSG_V01,
                                                           (void*) &nwreg_indications_qmi_request,
                                                           sizeof( nwreg_indications_qmi_request ),
                                                           (void*) &nwreg_indications_qmi_response,
                                                           sizeof( nwreg_indications_qmi_response ),
                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

        ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &nwreg_indications_qmi_response.resp );

        QCRIL_LOG_INFO( ".. requested nas indication reports %d, %d", (int)qmi_transport_error, (int)ril_err );
    }

    if ( enable_indications && RIL_E_SUCCESS == ril_err )
    {
        qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
        qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );

        // invalidate cache
        NAS_CACHE_LOCK();
        qcril_qmi_nas_drop_nw_info_cache();
        NAS_CACHE_UNLOCK();
        // refetch what we can refetch
        if ( qmi_ril_is_qmi_sys_info_available() )
        {
            qcril_qmi_nas_fetch_sys_info();
        }
        else
        {
            qcril_qmi_nas_fetch_serving_system_info();
        }
        qcril_qmi_nas_fetch_signal_strength_observations();
        qcril_qmi_nas_embms_fetch_embms_status();

        // force update ?
        if ( force_update && QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED == qmi_ril_get_operational_status() )
        {
            qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
            qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
            qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
            any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
            QCRIL_LOG_INFO( "any rte change %d", any_rte_change);

            if ( any_rte_change )
            {
                qcril_qmi_nas_initiate_voice_rte_change_propagation();
            }

            qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp_params );
            qcril_send_unsol_response( &unsol_resp_params );

            // restrict status
            NAS_CACHE_LOCK();
            qcril_qmi_nas_restricted_state_handle_event( QMI_RIL_NAS_RESTRICTED_DETAILS_EVENT_CHECK_FOR_CHANGE );
            NAS_CACHE_UNLOCK();

            qcril_qmi_nas_send_known_signal_strength();
        }
    }
    QCRIL_LOG_INFO( "completed with %d", (int) ril_err );

    return ril_err;

} // qcril_qmi_util_enable_networking_indications

//===========================================================================
//RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE
//===========================================================================
void qcril_qmi_nas_exit_emergency_callback_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_set_system_selection_preference_req_msg_v01 qmi_request;
  nas_set_system_selection_preference_resp_msg_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  NAS_CACHE_LOCK();
  nas_cached_info.nas_enter_ecbm_propagation_pending = FALSE;
  if (nas_cached_info.eme_call_end_recently)
  {
    nas_cached_info.eme_call_end_recently = FALSE;
    qcril_cancel_timed_callback((void *)(uintptr_t)nas_cached_info.eme_call_end_recently_tcb_id);
  }
  NAS_CACHE_UNLOCK();

  // ** prepare qmi req and exec
  memset( &qmi_request, 0, sizeof( qmi_request ) );

  qmi_request.emergency_mode_valid = TRUE;
  qmi_request.emergency_mode       = NAS_CMN_EMERGENCY_MODE_OFF;

  qmi_client_error =  qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                     QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                     &qmi_request,
                                                     sizeof( qmi_request ),
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO("qmi_client_error %d, ril_req_res %d", (int) qmi_client_error, (int) ril_req_res );

  // ** respond
  qcril_send_empty_payload_request_response( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_exit_emergency_callback_mode

//===========================================================================
//qcril_qmi_nas_control_signal_nas_on_current_calls_change
//===========================================================================
void qcril_qmi_nas_control_signal_nas_on_current_calls_change()
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qcril_qmi_nas_reevaluate_vrte_helper,
                                        NULL,
                                        NULL, // immediate
                                        NULL );

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_control_signal_nas_on_current_calls_change

//===========================================================================
//qcril_qmi_nas_reevaluate_vrte_helper
//===========================================================================
void qcril_qmi_nas_reevaluate_vrte_helper (qcril_timed_callback_handler_params_type *param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(param);

    qcril_qmi_nas_evaluate_voice_rte_propagation();

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_reevaluate_vrte_helper

//===========================================================================
//qcril_qmi_nas_evaluate_voice_rte_propagation
//===========================================================================
void qcril_qmi_nas_evaluate_voice_rte_propagation()
{
    unsigned int reported_voice_radio_tech;
    unsigned int calculated_voice_radio_tech;
    unsigned int reported_voice_radio_tech_family;
    unsigned int calculated_voice_radio_tech_family;
    qcril_unsol_resp_params_type unsol_resp_params;

    int                  propagation_expiry_res;
    uint32               propagation_expiry;
    const struct timeval propagation_expiry_timeout = {0 , 500000 }; // 0.5 sec
    int                  is_eme_oos;

    RIL_Errno                        ril_err;
    qmi_client_error_type            qmi_transport_error;

    qmi_ril_nw_reg_rte_type                 vrte;
    qmi_ril_nw_reg_rte_type                 drte;
    qmi_ril_nw_reg_rat_confidence_tag_type  vrte_confidence;
    qmi_ril_nw_reg_rat_confidence_tag_type  drte_confidence;

    int                                     iter_i;

    QCRIL_LOG_FUNC_ENTRY();

    calculated_voice_radio_tech = qcril_qmi_get_voice_radio_technology();
    reported_voice_radio_tech = qcril_qmi_nas_get_reported_voice_radio_tech();
    reported_voice_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(reported_voice_radio_tech);
    calculated_voice_radio_tech_family = qcril_qmi_voice_nas_control_convert_radio_tech_to_radio_tech_family(calculated_voice_radio_tech);

    is_eme_oos = qmi_ril_voice_is_eme_oos();

    QCRIL_LOG_INFO("is eme oos %d", is_eme_oos );
    QCRIL_LOG_INFO("reported tech %d, family %d - calculated tech %d, family %d",
                   (int)reported_voice_radio_tech,
                   (int)reported_voice_radio_tech_family,
                   (int)calculated_voice_radio_tech,
                   (int)calculated_voice_radio_tech_family);

    if (reported_voice_radio_tech != calculated_voice_radio_tech)
    {
        // RAT propagation is needed AND is inevitable under RAT family change
        if ( is_eme_oos && reported_voice_radio_tech_family != calculated_voice_radio_tech_family )
        {
            qmi_ril_voice_eme_oos_immunity_reload();
        }

        // time window setup for post RAT propagation
        propagation_expiry      = NAS_NIL;
        propagation_expiry_res  = qcril_setup_timed_callback(
                                                        QCRIL_DEFAULT_INSTANCE_ID,
                                                        QCRIL_DEFAULT_MODEM_ID,
                                                        qmi_ril_nwreg_rte_change_propagation_expired_handler,
                                                        &propagation_expiry_timeout,
                                                        &propagation_expiry );
        QCRIL_LOG_INFO("propagation res %d, val %d", (int) propagation_expiry_res , (int) propagation_expiry );
        if ( E_SUCCESS == propagation_expiry_res && NAS_NIL != propagation_expiry )
        {
            NAS_CACHE_LOCK();
            nas_cached_info.rte_change_propagation_change_expiry = propagation_expiry;
            NAS_CACHE_UNLOCK();
        }

        // logistics of propagation
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, &unsol_resp_params );
        qcril_qmi_nas_set_reported_voice_radio_tech( calculated_voice_radio_tech );
        unsol_resp_params.resp_pkt = (void *) &calculated_voice_radio_tech;
        unsol_resp_params.resp_len = sizeof( calculated_voice_radio_tech );
        qcril_send_unsol_response( &unsol_resp_params );

        // defered call updates check initiate
        qcril_setup_timed_callback(
                                  QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte,
                                  NULL,   // immediate
                                  NULL
                                  );

        // Send the known signal strength on Voice RTE Change
        if(calculated_voice_radio_tech != RADIO_TECH_UNKNOWN)
        {
            qcril_qmi_nas_send_known_signal_strength();
        }

        // adjust ecio threshold depending on RAT
        NAS_CACHE_LOCK();
        vrte            = nas_cached_info.voice_rte;
        drte            = nas_cached_info.data_rte;
        vrte_confidence = nas_cached_info.voice_rte_confidence_tag;
        drte_confidence = nas_cached_info.data_rte_confidence_tag;
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_evaluate_voice_rte_propagation

//===========================================================================
// qmi_ril_nwreg_rte_change_propagation_expired_handler
//===========================================================================
void qmi_ril_nwreg_rte_change_propagation_expired_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.rte_change_propagation_change_expiry = NAS_ZERO;
    NAS_CACHE_UNLOCK();

    qmi_ril_voice_post_rte_change_propagation_follow_up();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_rte_change_propagation_expired_handler

//===========================================================================
//qmi_ril_nwreg_is_vrte_post_change_window
//===========================================================================
int qmi_ril_nwreg_is_vrte_post_change_window( void )
{
    int res;

    NAS_CACHE_LOCK();
    res = ( NAS_ZERO != nas_cached_info.rte_change_propagation_change_expiry ) ? TRUE : FALSE;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( (int) res );

    return res;
} // qmi_ril_nwreg_is_vrte_post_change_window

//===========================================================================
//RIL_REQUEST_VOICE_RADIO_TECH
//===========================================================================
void qcril_qmi_nas_request_radio_tech
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_request_resp_params_type        resp;
  int                                   ril_response;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  ril_response = NAS_NIL;

  ril_response = qcril_qmi_get_voice_radio_technology();
  qcril_qmi_nas_set_reported_voice_radio_tech( ril_response );

  qcril_setup_timed_callback(
                          QCRIL_DEFAULT_INSTANCE_ID,
                          QCRIL_DEFAULT_MODEM_ID,
                          qcril_qmi_voice_nas_control_process_calls_pending_for_right_voice_rte,
                          NULL,   // immediate
                          NULL
                          );


  // ** respond
  qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp ); // always successful response
  resp.resp_pkt = &ril_response;
  resp.resp_len = sizeof( ril_response );
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with rt %d ", (int) ril_response );

  QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_request_radio_tech

//===========================================================================
//qcril_qmi_nas_set_reported_voice_radio_tech
//===========================================================================
void qcril_qmi_nas_set_reported_voice_radio_tech(RIL_RadioTechnology voice_radio_tech)
{
    QCRIL_LOG_INFO("entered voice_radio_tech %d", voice_radio_tech);

    NAS_CACHE_LOCK();
    nas_cached_info.reported_voice_radio_tech = voice_radio_tech;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_set_reported_voice_radio_tech

//===========================================================================
//qcril_qmi_nas_get_reported_voice_radio_tech
//===========================================================================
RIL_RadioTechnology qcril_qmi_nas_get_reported_voice_radio_tech()
{
    RIL_RadioTechnology voice_radio_tech;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    voice_radio_tech = nas_cached_info.reported_voice_radio_tech;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO("completed with voice_radio_tech %d", voice_radio_tech);
    return voice_radio_tech;
} //qcril_qmi_nas_get_reported_voice_radio_tech

//===========================================================================
//qcril_qmi_nas_initiate_voice_rte_change_propagation
//===========================================================================
void qcril_qmi_nas_initiate_voice_rte_change_propagation( void )
{
    QCRIL_LOG_FUNC_ENTRY();

    qmi_ril_suppress_android_unsol_resp( RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED ); // will be enabled in QCRIL_EVT_QMI_RIL_POST_VOICE_RTE_CHANGE_IND


    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_POST_VOICE_RTE_CHANGE_IND,
                   NULL,
                   NAS_NIL,
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_initiate_voice_rte_change_propagation

//===========================================================================
//QCRIL_EVT_QMI_RIL_POST_VOICE_RTE_CHANGE_IND
//===========================================================================
void qcril_qmi_nas_post_voice_rte_change_ind_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno                    ril_req_res;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);

    ril_req_res = RIL_E_GENERIC_FAILURE;

    if( TRUE == qcril_qmi_nas_check_power_save_and_screen_off_status() )
    {
      ril_req_res = qcril_qmi_nas_fetch_system_info_helper();
    }
    else
    {
      ril_req_res = RIL_E_SUCCESS;
    }

    if( RIL_E_SUCCESS == ril_req_res )
    {
       qcril_qmi_nas_evaluate_voice_rte_propagation();
    }

    qmi_ril_unsuppress_android_unsol_resp( RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED ); // was disabled in qcril_qmi_nas_initiate_voice_rte_change_propagation()

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_post_voice_rte_change_ind

//===========================================================================
//qcril_qmi_nas_is_atel_rat_3gpp
//===========================================================================
inline int qcril_qmi_nas_is_atel_rat_3gpp(RIL_RadioTechnology atel_rat)
{
    int res;

    res = FALSE;

    switch( atel_rat )
    {
        case RADIO_TECH_TD_SCDMA:
        case RADIO_TECH_UMTS:
        case RADIO_TECH_GSM:
        case RADIO_TECH_EDGE:
        case RADIO_TECH_GPRS:
        case RADIO_TECH_HSDPA:
        case RADIO_TECH_HSUPA:
        case RADIO_TECH_HSPA:
        case RADIO_TECH_HSPAP:
            res = TRUE;
            break;

        default:
            //no action
            break;
    }

    return res;
} //qcril_qmi_nas_is_atel_rat_3gpp

//===========================================================================
//qcril_qmi_nas_is_atel_rat_3gpp2
//===========================================================================
inline int qcril_qmi_nas_is_atel_rat_3gpp2(RIL_RadioTechnology atel_rat)
{
    int res;

    res = FALSE;

    switch( atel_rat )
    {
        case RADIO_TECH_IS95A:
        case RADIO_TECH_IS95B:
        case RADIO_TECH_1xRTT:
        case RADIO_TECH_EVDO_0:
        case RADIO_TECH_EVDO_A:
        case RADIO_TECH_EVDO_B:
        case RADIO_TECH_EHRPD:
            res = TRUE;
            break;

        default:
            //no action
            break;
    }

    return res;
} //qcril_qmi_nas_is_atel_rat_3gpp2

//===========================================================================
//process_3gpp_radio_technology
//===========================================================================
inline RIL_RadioTechnology process_3gpp_radio_technology(RIL_RadioTechnology reported_radio_technology, uint16_t mode_pref)
{
  RIL_RadioTechnology radio_technology;
  radio_technology = RADIO_TECH_UNKNOWN;
  if (TRUE == qcril_qmi_nas_is_atel_rat_3gpp(reported_radio_technology))
  {
    radio_technology = reported_radio_technology; //to avoid ping pong between 3gpp technologies in no service
  }
  else
  {
      if( QMI_NAS_RAT_MODE_PREF_UMTS & mode_pref )
      {
          radio_technology = RADIO_TECH_UMTS;
      }
      else if( QMI_NAS_RAT_MODE_PREF_GSM & mode_pref )
      {
          radio_technology = RADIO_TECH_GSM;
      }
      else if( QMI_NAS_RAT_MODE_PREF_TDSCDMA & mode_pref )
      {
          radio_technology = RADIO_TECH_TD_SCDMA;
      }
      else
      {
          radio_technology = RADIO_TECH_UMTS;
      }
  }
  return radio_technology;
}//process_3gpp_radio_technology

//===========================================================================
//process_3gpp2_radio_technology
//===========================================================================
inline RIL_RadioTechnology process_3gpp2_radio_technology(RIL_RadioTechnology reported_radio_technology,uint16_t mode_pref)
{
  RIL_RadioTechnology radio_technology;
  radio_technology = RADIO_TECH_UNKNOWN;

  QCRIL_NOTUSED(mode_pref);
  if( TRUE == qcril_qmi_nas_is_atel_rat_3gpp2(reported_radio_technology) )
  {
      radio_technology = reported_radio_technology; //to avoid ping pong between 3gpp2 technologies in no service
  }
  else
  {
      radio_technology = RADIO_TECH_IS95A;
  }
  return radio_technology;
}//process_3gpp2_radio_technology

//===========================================================================
//qcril_qmi_nas_is_3gpp2_roaming
//===========================================================================
inline int qcril_qmi_nas_is_3gpp2_roaming(uint8_t reg_state_valid,
                                          int reg_state,
                                          uint8_t reg_tech_valid,
                                          int reg_tech)
{
    int res;

    res = FALSE;

    if( TRUE == reg_state_valid &&
        RIL_VAL_REG_REGISTERED_ROAMING == reg_state &&
        TRUE == reg_tech_valid &&
        TRUE == qcril_qmi_nas_is_atel_rat_3gpp2(reg_tech)
        )
    {
        res = TRUE;
    }

    return res;
}//qcril_qmi_nas_is_3gpp2_roaming

//===========================================================================
//qcril_qmi_nas_fetch_mode_pref
//===========================================================================
int qcril_qmi_nas_fetch_mode_pref(mode_pref_mask_type_v01 *mode_pref)
{
    int mode_pref_available;
    RIL_Errno ril_req_res;
    nas_get_mode_pref_resp_msg_v01 nas_get_mode_pref_resp_msg;

    mode_pref_available = FALSE;
    ril_req_res = RIL_E_GENERIC_FAILURE;
    memset(&nas_get_mode_pref_resp_msg, NAS_NIL, sizeof(nas_get_mode_pref_resp_msg));

    if( mode_pref )
    {
        if(FALSE == qcril_qmi_nas_get_mode_pref(mode_pref))
        {
            qcril_qmi_fetch_system_selection_preference();
            if(FALSE == qcril_qmi_nas_get_mode_pref(mode_pref))
            {
                ril_req_res = qcril_qmi_client_send_msg_sync_ex ( QCRIL_QMI_CLIENT_NAS,
                                                                  QMI_NAS_GET_MODE_PREF_REQ_MSG_V01,
                                                                  NULL,
                                                                  NAS_NIL,
                                                                  (void*)&nas_get_mode_pref_resp_msg,
                                                                  sizeof( nas_get_mode_pref_resp_msg ),
                                                                  QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                                                                  );
                if ( RIL_E_SUCCESS == ril_req_res )
                {
                    if ( !qmi_ril_is_multi_sim_feature_supported() ||
                         (QCRIL_DEFAULT_INSTANCE_ID == qmi_ril_get_process_instance_id()) )
                    {
                        if ( nas_get_mode_pref_resp_msg.idx0_mode_pref_valid )
                        {
                            *mode_pref = nas_get_mode_pref_resp_msg.idx0_mode_pref;
                            mode_pref_available = TRUE;
                        }
                    }
                    else
                    {
                        if ( nas_get_mode_pref_resp_msg.idx1_mode_pref_valid &&
                             (QCRIL_SECOND_INSTANCE_ID == qmi_ril_get_process_instance_id()) )
                        {
                            *mode_pref = nas_get_mode_pref_resp_msg.idx1_mode_pref;
                            mode_pref_available = TRUE;
                        }
                        else if ( nas_get_mode_pref_resp_msg.idx2_mode_pref_valid &&
                                  (QCRIL_THIRD_INSTANCE_ID == qmi_ril_get_process_instance_id()) )
                        {
                            *mode_pref = nas_get_mode_pref_resp_msg.idx2_mode_pref;
                            mode_pref_available = TRUE;
                        }
                    }
                }
            }
            else
            {
                mode_pref_available = TRUE;
            }
        }
        else
        {
            mode_pref_available = TRUE;
        }
    }

    if( mode_pref_available )
    {
        QCRIL_LOG_DEBUG("mode preference %d", *mode_pref );
    }
    else
    {
        QCRIL_LOG_DEBUG("mode preference unavailable");
    }

    return mode_pref_available;
} //qcril_qmi_nas_fetch_mode_pref

//===========================================================================
//qcril_qmi_convert_rte_to_radio_technology
//===========================================================================
RIL_RadioTechnology qcril_qmi_convert_rte_to_radio_technology(qmi_ril_nw_reg_rte_type rte)
{
    RIL_RadioTechnology radio_technology;
    nas_cdma_only_sys_info_type_v01 *cdma_only_sys_info;
    nas_hdr_only_sys_info_type_v01  *hdr_only_sys_info;

    radio_technology = RADIO_TECH_UNKNOWN;
    cdma_only_sys_info = NULL;

    switch ( rte )
    {
        case QMI_RIL_RTE_1x:
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) )
            {
              cdma_only_sys_info = &nas_cached_info.cdma_sys_info->cdma_specific_sys_info;
            }
            else
            {
              cdma_only_sys_info = NULL;
            }
            radio_technology = qcril_qmi_nas_util_determine_cdma_rev( cdma_only_sys_info );
            break;

        case QMI_RIL_RTE_SUB_DO:
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) )
            {
              hdr_only_sys_info = &nas_cached_info.hdr_sys_info->hdr_specific_sys_info;
            }
            else
            {
              hdr_only_sys_info = NULL;
            }
            radio_technology = qcril_qmi_nas_util_determine_hdr_rev( hdr_only_sys_info );
            break;

        case QMI_RIL_RTE_GSM:
            if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) &&
                 nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp_valid &&
                 NAS_SYS_EGPRS_SUPPORT_AVAIL == nas_cached_info.gsm_sys_info->gsm_specific_sys_info.egprs_supp )
            {
                radio_technology = RADIO_TECH_EDGE; // edge
            }
            else
            {
                radio_technology = RADIO_TECH_GPRS; // conclude  -  gprs
            }
            break;

        case QMI_RIL_RTE_WCDMA:
            radio_technology = RADIO_TECH_UMTS;
            break;

        case QMI_RIL_RTE_TDSCDMA:
            radio_technology = RADIO_TECH_TD_SCDMA;
            break;

        case QMI_RIL_RTE_SUB_LTE:
            radio_technology = RADIO_TECH_LTE;
            break;

        default:
            radio_technology = RADIO_TECH_UNKNOWN;
            break;
    }

    QCRIL_LOG_DEBUG("radio technlogy %d for rte %d", radio_technology, rte);
    return radio_technology;
} //qcril_qmi_convert_rte_to_radio_technology

/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_sim_app

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from current current sim app type

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_sim_app
(
    void
)
{
    int                   radio_tech_family = NAS_VAL_RADIO_TECH_UNKNOWN;
    RIL_CardStatus_v6     ril_card_status;
    int                   index;
    nas_rtre_cfg_enum_v01 rtre_cfg;

    do {

#ifndef QMI_RIL_UTF

        /* retrieve card status info */
        if (qcril_uim_direct_get_card_status(qmi_ril_get_process_instance_id(),
                                             &ril_card_status) != RIL_E_SUCCESS)
        {
            break;
        }

        QCRIL_LOG_INFO("card status : %d", ril_card_status.card_state);
        QCRIL_LOG_INFO("gsm index : %d", ril_card_status.gsm_umts_subscription_app_index);
        QCRIL_LOG_INFO("cdma index : %d", ril_card_status.cdma_subscription_app_index);


        NAS_CACHE_LOCK();
        rtre_cfg = nas_common_info.nas_rtre_cfg;
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("rtre_cfg : %d", rtre_cfg);

        /* convert operator type to corresponding radio tech */
        if (ril_card_status.card_state == RIL_CARDSTATE_PRESENT)
        {
            if (ril_card_status.gsm_umts_subscription_app_index != -1)
            {
                index = ril_card_status.gsm_umts_subscription_app_index;
                QCRIL_LOG_INFO("gsm app state : %d",
                               ril_card_status.applications[index].app_state);
                if (ril_card_status.applications[index].app_state !=
                                                        RIL_APPSTATE_UNKNOWN)
                {
                    radio_tech_family = NAS_VAL_RADIO_TECH_3GPP;
                }
            }

            if (ril_card_status.cdma_subscription_app_index != -1)
            {
                if (radio_tech_family != NAS_VAL_RADIO_TECH_UNKNOWN)
                {
                    radio_tech_family = NAS_VAL_RADIO_TECH_UNKNOWN;
                }
                else
                {
                    index = ril_card_status.cdma_subscription_app_index;
                    QCRIL_LOG_INFO("cdma app state : %d",
                                   ril_card_status.applications[index].app_state);
                    if (ril_card_status.applications[index].app_state !=
                                                        RIL_APPSTATE_UNKNOWN)
                    {
                        radio_tech_family = NAS_VAL_RADIO_TECH_3GPP2;
                    }
                }
            }

            /* If subscription source is NV, then use 3GPP app type only if
             * pin is locked */
            if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
            {
                if (NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01 == rtre_cfg)
                {
                    if ((ril_card_status.applications[index].app_state !=
                                                            RIL_APPSTATE_PIN) &&
                        (ril_card_status.applications[index].app_state !=
                                                             RIL_APPSTATE_PUK))
                    {
                        QCRIL_LOG_INFO("resetting radio tech family source is nv and"
                                        "app state is not locked",
                                   ril_card_status.applications[index].app_state);
                        radio_tech_family = NAS_VAL_RADIO_TECH_UNKNOWN;
                    }
                }
            }
        }
        else if (ril_card_status.card_state == RIL_CARDSTATE_ABSENT)
        {
            if (NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01 == rtre_cfg)
            {
                radio_tech_family = NAS_VAL_RADIO_TECH_3GPP2;
            }
        }

#endif
    } while (0);

    QCRIL_LOG_INFO( "radio tech family: %d", radio_tech_family);

    return radio_tech_family;
}

/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_mcc_mnc

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from mcc and mnc

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_mcc_mnc
(
    char mcc_str[NAS_MCC_MNC_MAX_SIZE],
    char mnc_str[NAS_MCC_MNC_MAX_SIZE]
)
{
    char operator_type[QCRIL_DB_MAX_OPERATOR_TYPE_LEN] = {0};

    int radio_tech_family  = NAS_VAL_RADIO_TECH_UNKNOWN;

    do {

        if (!mcc_str || !mnc_str)
        {
            break;
        }

        /* retrieve operator type using mcc and mnc */
        qcril_db_query_operator_type(mcc_str, mnc_str, operator_type);

        /* convert operator type to corresponding radio tech */
        if (!strcmp(operator_type, "3gpp"))
        {
            radio_tech_family = NAS_VAL_RADIO_TECH_3GPP;
        }
        else if (!strcmp(operator_type, "3gpp2"))
        {
            radio_tech_family = NAS_VAL_RADIO_TECH_3GPP2;
        }

        QCRIL_LOG_INFO( "mcc : %s, mnc: %s",
                        mcc_str, mnc_str);
        QCRIL_LOG_INFO( "radio tech family: %d, operator: %s",
                        radio_tech_family, operator_type);

    } while (0);

    return radio_tech_family;
}

/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_current_operator_info

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from current operator info like mcc and mnc

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_current_operator_info
(
    void
)
{
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char current_mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};

    int radio_tech_family  = NAS_VAL_RADIO_TECH_UNKNOWN;

    do {

        /* get mcc and mnc of current operator */
        if (!qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str,
                                                current_mnc_str, TRUE, NULL))
        {
            break;
        }

        /* retrieve rte family type using current mcc and mnc */
        radio_tech_family = qcril_qmi_retrieve_rte_family_from_mcc_mnc(
                                                current_mcc_str,
                                                current_mnc_str);

    } while (0);

    return radio_tech_family;
}
/*===========================================================================

  FUNCTION  qcril_qmi_retrieve_rte_family_from_card_mcc_mnc

===========================================================================*/
/*!
    @brief
    Retrieve radio tech family from card mcc and mnc

    @return
    NAS_VAL_RADIO_TECH_UNKNOWN
    NAS_VAL_RADIO_TECH_3GPP
    NAS_VAL_RADIO_TECH_3GPP2
*/
/*=========================================================================*/
int qcril_qmi_retrieve_rte_family_from_card_mcc_mnc
(
    void
)
{
    char card_mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char card_mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};

    int radio_tech_family  = NAS_VAL_RADIO_TECH_UNKNOWN;

    do {

        /* get mcc and mnc of card */
        if (qcril_qmi_nas_get_sim_mcc_mnc(card_mcc_str,
                                          card_mnc_str))
        {
            break;
        }

        /* retrieve rte family type using card mcc and mnc */
        radio_tech_family = qcril_qmi_retrieve_rte_family_from_mcc_mnc(
                                                        card_mcc_str,
                                                        card_mnc_str);

    } while (0);

    return radio_tech_family;
}

/*===========================================================================

  FUNCTION  qcril_qmi_store_learnt_rte_family_type

===========================================================================*/
/*!
    @brief
    Store learnt rte family type to persistent memory.

    @return
    E_SUCCESS for success
    E_FAILURE for failure
*/
/*=========================================================================*/
void qcril_qmi_store_learnt_rte_family_type
(
    RIL_RadioTechnology radio_technology
)
{
    char current_mcc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char current_mnc_str[NAS_MCC_MNC_MAX_SIZE] = {0};
    char operator_type[QCRIL_DB_MAX_OPERATOR_TYPE_LEN] = {0};
    char is_learning_enabled[5];

    do {

        /* check if voice radio tech learning is disabled */
        if (!nas_common_info.is_ril_vrte_learning_enabled)
        {
            break;
        }

        /* get mcc and mnc of current operator */
        if (!qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str,
                                                current_mnc_str, TRUE, NULL))
        {
            break;
        }

        /* retrieve operator type using mcc and mnc */
        qcril_db_query_operator_type(current_mcc_str, current_mnc_str, operator_type);

        /* retrieve operator type from rat */
        if (qcril_qmi_nas_is_atel_rat_3gpp2(radio_technology))
        {
            if (!strlen(operator_type))
            {
                strlcpy(operator_type, "3gpp2", sizeof(operator_type));
            }
            else if (strcmp(operator_type, "3gpp"))
            {
                strlcpy(operator_type, "both", sizeof(operator_type));
            }

            /* if there exist an entry, do not proceed */
            else
            {
                break;
            }
        }
        else if (qcril_qmi_nas_is_atel_rat_3gpp(radio_technology))
        {
            if (!strlen(operator_type))
            {
                strlcpy(operator_type, "3gpp", sizeof(operator_type));
            }
            else if (strcmp(operator_type, "3gpp2"))
            {
                strlcpy(operator_type, "both", sizeof(operator_type));
            }

            /* if there exist an entry, do not proceed */
            else
            {
                break;
            }
        }
        else
        {
            /* non modem rat */
            break;
        }

        /* insert entry to db */
        qcril_db_insert_operator_type(current_mcc_str, current_mnc_str, operator_type);

        QCRIL_LOG_INFO( "mcc: %s, mnc: %s, operator: %s",
                        current_mcc_str, current_mnc_str, operator_type);

    } while (0);


    return;
}

/*===========================================================================

 qcril_qmi_get_voice_radio_technology

============================================================================*/
/*!
    @brief
    Calculate voice radio technology

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_RadioTechnology qcril_qmi_get_voice_radio_technology
(
    void
)
{
    /* radio tachnology to be calculated  */
    RIL_RadioTechnology      radio_technology = RADIO_TECH_UNKNOWN;

    /* current mode preference */
    uint16_t                 mode_pref        = NAS_NIL;

    /* is mode preference info available */
    int                      mode_pref_info_available;

    /* Previously reported voice radio  technology */
    RIL_RadioTechnology      reported_radio_technology;

    /* indicates whether radio tech is of 3gpp or 3gpp2 family */
    int                      radio_tech_family;

    /* cached voice rte */
    qmi_ril_nw_reg_rte_type  voice_rte;

    /* cached data rte */
    qmi_ril_nw_reg_rte_type  data_rte;

    /* voice rte confidence level */
    qmi_ril_nw_reg_rat_confidence_tag_type voice_rte_confidence;

    /* data rte confidence level */
    qmi_ril_nw_reg_rat_confidence_tag_type data_rte_confidence;

    /* lte sms status, indicating sms csfb type or ims availability */
    nas_sms_status_enum_type_v01       lte_sms_status;

    /* indicated if lte sms status is valid */
    uint8_t                            lte_sms_status_valid;

    /* lte voice status, indicating voice csfb type or ims availability */
    nas_lte_voice_status_enum_type_v01 lte_voice_status;

    /* indicated if lte voice status is valid */
    uint8_t                            lte_voice_status_valid;

    /* fetch current mode preference */
    mode_pref_info_available  = qcril_qmi_nas_fetch_mode_pref(&mode_pref);

    /* fetch previously reported voice radio technology */
    reported_radio_technology = qcril_qmi_nas_get_reported_voice_radio_tech();

    NAS_CACHE_LOCK();

    /* fetch cached voice rte and data rte */
    voice_rte            = nas_cached_info.voice_rte;
    voice_rte_confidence = nas_cached_info.voice_rte_confidence_tag;
    data_rte             = nas_cached_info.data_rte;
    data_rte_confidence  = nas_cached_info.data_rte_confidence_tag;

    /* fetch cached lte sms and voice status */
    qcril_qmi_nas_fetch_lte_voice_status(&lte_voice_status_valid,
                                         &lte_voice_status);
    qcril_qmi_nas_fetch_lte_sms_status(&lte_sms_status_valid, &lte_sms_status);

    /* Proceed if mode pref is available, if it is not available that indicates
     * system is not in a valid state */
    if (mode_pref_info_available)
    {
        QCRIL_LOG_INFO("mode preference %d, last reported rte %d",
                        mode_pref, reported_radio_technology);
        QCRIL_LOG_INFO("voice rte %d - confidence %d",
                        voice_rte, voice_rte_confidence);
        QCRIL_LOG_INFO("data rte %d - confidence %d",
                       data_rte, data_rte_confidence);

        do
        {
            /* In case of LTE only mode, the only possible rat is LTE and
             * only possible voice call is through IMS. */
            if (QMI_NAS_RAT_MODE_PREF_LTE == mode_pref)
            {
                radio_technology = RADIO_TECH_LTE;
                break;
            }

            if (QMI_RIL_RTE_NONE != voice_rte &&
                (QMI_RIL_RAT_CONFIDENCE_FULL_SVC == voice_rte_confidence ||
                 QMI_RIL_RAT_CONFIDENCE_LTD_SVC == voice_rte_confidence))
            {
                radio_technology =
                        qcril_qmi_convert_rte_to_radio_technology(voice_rte);

                if (RADIO_TECH_UNKNOWN != radio_technology)
                {
                    nas_cached_info.is_calculated_vrte_used = 1;
                }

                if ((RADIO_TECH_UNKNOWN != radio_technology) &&
                    (RADIO_TECH_LTE != radio_technology))
                {
                    /* Add entry to peristent memory, to remember the operator.
                     * this helps in resolving the scenario
                     * where family information is not available */
                    qcril_qmi_store_learnt_rte_family_type(radio_technology);

                    /* current radio technology -
                     * No further calculations needed */
                    break;
                }
            }

            if ((RADIO_TECH_UNKNOWN == radio_technology) &&
                QMI_RIL_RTE_NONE != data_rte &&
               ((QMI_RIL_RAT_CONFIDENCE_FULL_SVC == data_rte_confidence) ||
                (QMI_RIL_RAT_CONFIDENCE_LTD_SVC == data_rte_confidence)))
            {
                radio_technology =
                        qcril_qmi_convert_rte_to_radio_technology(data_rte);

                if (RADIO_TECH_UNKNOWN != radio_technology)
                {
                    nas_cached_info.is_calculated_vrte_used = 1;
                }

                if ((RADIO_TECH_UNKNOWN != radio_technology) &&
                    (RADIO_TECH_LTE != radio_technology))
                {
                    /* Add entry to peristent memory, to remember the operator.
                     * This helps in resolving the scenario where
                     * family information is not available */
                    qcril_qmi_store_learnt_rte_family_type(radio_technology);

                    /* current radio technology -
                     * No further calculations needed */
                    break;
                }
            }

            /* Check if only 3gpp2 rats are in mode pref */
            if (FALSE == (QMI_NAS_RAT_MODE_PREF_GSM_UMTS_TDSCDMA & mode_pref))
            {
                radio_technology = process_3gpp2_radio_technology(
                                            reported_radio_technology,
                                            mode_pref);
                break;
            }

            /* check if only 3gpp rats are in mode pref */
            if (FALSE == (QMI_NAS_RAT_MODE_PREF_CDMA_HRPD & mode_pref))
            {
                radio_technology = process_3gpp_radio_technology(
                                            reported_radio_technology,
                                            mode_pref);
                break;
            }

            /* If the radio_technology is reported as LTE, the lte voice tlv of
               QMI_NAS_SYS_INFO_IND and QMI_GET_SYS_INFO response messages,
               are checked to determine
               whether it is 3gpp or 3gpp2 technology*/
            if (RADIO_TECH_LTE == radio_technology)
            {
                if (lte_voice_status_valid)
                {
                    if (NAS_LTE_VOICE_STATUS_3GPP_V01 == lte_voice_status)
                    {
                        radio_technology = process_3gpp_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                        /* Add entry to peristent memory, to remember the operator.
                         * This helps in resolving the scenario where
                         * family information is not available */
                        qcril_qmi_store_learnt_rte_family_type(radio_technology);

                        break;
                    }
                    else if (NAS_LTE_VOICE_STATUS_1X_V01 == lte_voice_status)
                    {
                        radio_technology = process_3gpp2_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);

                        /* Add entry to peristent memory, to remember the operator.
                         * This helps in resolving the scenario where
                         * family information is not available */
                        qcril_qmi_store_learnt_rte_family_type(radio_technology);

                        break;
                    }
                }

                /* check if the operator is a 3gpp operator or 3gpp2 */
                radio_tech_family =
                    qcril_qmi_retrieve_rte_family_from_current_operator_info();

                if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
                {
                    radio_technology = process_3gpp_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                    break;
                }
                else if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP2)
                {
                    radio_technology = process_3gpp2_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                    break;
                }

                /*If the radio_technology is reported as LTE, the lte sms tlv of
                  QMI_NAS_SYS_INFO_IND and QMI_GET_SYS_INFO response messages,
                  are checked to determine
                  whether it is 3gpp or 3gpp2 technology*/
                if (lte_sms_status_valid)
                {
                    if (NAS_SMS_STATUS_3GPP_V01 == lte_sms_status)
                    {
                        radio_technology = process_3gpp_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                        break;
                    }
                    else if (NAS_SMS_STATUS_1X_V01 == lte_sms_status)
                    {
                        radio_technology = process_3gpp2_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                        break;
                    }
                }
            }

            if (RADIO_TECH_UNKNOWN == radio_technology)
            {
                /* check if active sim app type can be used
                 * to predict radio technology */
                radio_tech_family = qcril_qmi_retrieve_rte_family_from_sim_app();
                if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
                {
                    radio_technology = process_3gpp_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                    break;
                }
                else if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP2)
                {
                    radio_technology = process_3gpp2_radio_technology(
                                                reported_radio_technology,
                                                mode_pref);
                    break;
                }

                /* check if the operator is a 3gpp operator or 3gpp2
                 * using card mcc and mnc if we don't have any previously
                 * reported voice radio tech */
                if (!nas_cached_info.is_calculated_vrte_used)
                {
                    radio_tech_family =
                        qcril_qmi_retrieve_rte_family_from_card_mcc_mnc();

                    if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP)
                    {
                        radio_technology = process_3gpp_radio_technology(
                                                    reported_radio_technology,
                                                    mode_pref);
                        break;
                    }
                    else if (radio_tech_family == NAS_VAL_RADIO_TECH_3GPP2)
                    {
                        radio_technology = process_3gpp2_radio_technology(
                                                    reported_radio_technology,
                                                    mode_pref);
                        break;
                    }
                }
            }
        } while(0);
    }
    else
    {
        QCRIL_LOG_INFO( "mode preference info unavailable");
    }

    /* Could not resolve or predict voice radio technology
     * Report default voice radio tech or previously reported
     * radio technology or default radio technology */
    if (RADIO_TECH_UNKNOWN == radio_technology)
    {
        QCRIL_LOG_INFO("retrieving reported radio technology");
        radio_technology = reported_radio_technology;
    }

    QCRIL_LOG_INFO( "radio technology %d", radio_technology );

    NAS_CACHE_UNLOCK();

    return radio_technology;
} // qcril_qmi_get_voice_radio_technology

//===========================================================================
//qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg
//===========================================================================
int qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg( call_mode_enum_v02 call_mode )
{
    int                                   res;
    uint16_t                              mode_pref;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    QCRIL_LOG_INFO( ".. mode_pref valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref ) );

    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mode_pref ) )
    {
      mode_pref = nas_cached_info.mode_pref;
    }
    else
    {
      mode_pref = NAS_NIL;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO( ".. mode_pref %d", (int) mode_pref );

    if ( NAS_NIL == mode_pref )
    { // whatever fits
        res = TRUE;
    }
    else
    {
        switch ( call_mode )
        {
          case CALL_MODE_CDMA_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_CDMA ) ? TRUE : FALSE;
              break;

          case CALL_MODE_GSM_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_GSM ) ? TRUE : FALSE;
              break;

          case CALL_MODE_UMTS_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_UMTS ) ? TRUE : FALSE;
              break;

          case CALL_MODE_TDS_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_TDSCDMA ) ? TRUE : FALSE;
              break;

          case CALL_MODE_LTE_V02:
              res = ( mode_pref & QMI_NAS_RAT_MODE_PREF_LTE ) ? TRUE : FALSE;
              break;

          default:
              res = TRUE;
              break;
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );

    return res;
} // qmi_ril_nw_reg_voice_is_voice_call_mode_reasonable_against_dev_cfg

//===========================================================================
//qcril_qmi_voice_technology_updated
//===========================================================================
void qcril_qmi_voice_technology_updated()
{
    qcril_radio_tech_e_type voice_technology = QCRIL_RADIO_TECH_NONE;
    qmi_ril_nw_reg_rte_type considered_rte = QMI_RIL_RTE_NONE;

    QCRIL_LOG_FUNC_ENTRY();

    if ( !qmi_ril_is_qmi_sys_info_available() )
    { // legacy
        QCRIL_LOG_INFO( "..nas_cached_info.serving_system valid %d", (int) NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) );

        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) )
        {
            QCRIL_LOG_INFO( ".. selected NW %d", (int) nas_cached_info.serving_system->selected_network );
            QCRIL_LOG_INFO( ".. NW state %d", (int) nas_cached_info.serving_system->registration_state );

            switch ( nas_cached_info.serving_system->selected_network  )
            {
                case NAS_SELECTED_NETWORK_3GPP_V01:
                    voice_technology = QCRIL_RADIO_TECH_3GPP;
                    break;

                case NAS_SELECTED_NETWORK_3GPP2_V01:
                    voice_technology = QCRIL_RADIO_TECH_3GPP2;
                    break;

                case NAS_SELECTED_NETWORK_UNKNOWN_V01:     // fallthrough
                default:
                    voice_technology = QCRIL_RADIO_TECH_NONE;
                    break;
            }
        }
    }
    else
    {  // sys_info driven

        if ( QMI_RIL_RTE_NONE != nas_cached_info.ims_rte )
        {
            considered_rte = nas_cached_info.ims_rte;
        }
        else if ( QMI_RIL_RTE_NONE != nas_cached_info.voice_rte )
        {
            considered_rte = nas_cached_info.voice_rte;
        }
        else
        {
            considered_rte = nas_cached_info.data_rte;
        }

        QCRIL_LOG_INFO( "..nas_cached_info.voice_rte %d, nas_cached_info.data_rte %d, nas_cached_info.ims_rte %d, will be considered %d",
                        (int) nas_cached_info.voice_rte,
                        (int) nas_cached_info.data_rte,
                        (int) nas_cached_info.ims_rte,
                        (int) considered_rte );

        switch ( considered_rte )
        {
            case QMI_RIL_RTE_1x: // fallthrough
            case QMI_RIL_RTE_SUB_DO:
                voice_technology = QCRIL_RADIO_TECH_3GPP2;
                break;

            case QMI_RIL_RTE_GSM:     // fallthrough
            case QMI_RIL_RTE_WCDMA:   // fallthrough
            case QMI_RIL_RTE_TDSCDMA:   // fallthrough
            case QMI_RIL_RTE_SUB_LTE:
                voice_technology = QCRIL_RADIO_TECH_3GPP;
                break;

            default:
                voice_technology = QCRIL_RADIO_TECH_NONE;
                break;
        }
    }

    qcril_qmi_mgr_voice_technology_updated( voice_technology );

    QCRIL_LOG_FUNC_RETURN_WITH_RET( (int) voice_technology );

} // qcril_qmi_voice_technology_updated
//===========================================================================
//RIL_REQUEST_GET_NEIGHBORING_CELL_IDS
//===========================================================================
void qcril_qmi_nas_get_neighboring_cell_ids
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_request_resp_params_type resp;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_txn_handle txn_handle;
  qcril_reqlist_public_type qcril_req_info_ptr;
  qmi_client_error_type qmi_client_error;

  nas_get_cell_location_info_resp_msg_v01 *qmi_response = NULL;
  qcril_nas_neighboring_cell_type *ril_resp_helper = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_NEIGHBOR_CELL_INFO,
                               NULL,
                               &qcril_req_info_ptr );

  if ( qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) == E_SUCCESS )
  {
      qmi_response = qcril_malloc( sizeof( *qmi_response ) );
      if ( qmi_response )
      {
          ril_resp_helper = qcril_malloc( sizeof( *ril_resp_helper ) );

          if ( ril_resp_helper )
          {
              qmi_client_error =  qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                 QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                                 NULL,
                                                                 NAS_ZERO, // empty payload
                                                                 (void*) qmi_response,
                                                                 sizeof( *qmi_response ),
                                                                 qcril_qmi_nas_get_neighboring_cells_cb,
                                                                 (void *)ril_resp_helper,
                                                                 &txn_handle
                                                   );
              ril_req_res = ( QMI_NO_ERR == qmi_client_error ) ? RIL_E_SUCCESS : RIL_E_GENERIC_FAILURE;
          }
      }
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
      qcril_send_request_response( &resp );

      if ( ril_resp_helper )
      {
          qcril_free( ril_resp_helper );
      }
      if ( qmi_response )
      {
          qcril_free( qmi_response );
      }
  }

  QCRIL_LOG_ESSENTIAL( "completed with %d", ril_req_res);
} // qcril_qmi_nas_get_neighboring_cell_ids


//===========================================================================
// qcril_qmi_nas_get_neighboring_cells_cb
//===========================================================================
void qcril_qmi_nas_get_neighboring_cells_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                         *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                         *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    nas_get_cell_location_info_resp_msg_v01 *   qmi_response            = (nas_get_cell_location_info_resp_msg_v01 *) resp_c_struct;
    qcril_nas_neighboring_cell_type *           ril_resp_helper         = (qcril_nas_neighboring_cell_type *) resp_cb_data;
    RIL_Errno                                   ril_req_res             = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type                   qcril_req_info;
    errno_enum_type                             found_qcril_request;
    qcril_request_resp_params_type              resp;

    unsigned int iter=0,iter_j=0,iter_k=0;
    int cell_info_len=0;

    user_handle = user_handle;
    msg_id = msg_id;
    resp_c_struct_len = resp_c_struct_len;

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  QCRIL_EVT_QMI_REQUEST_NEIGHBOR_CELL_INFO,
                                  &qcril_req_info );

    if ( qmi_response && (E_SUCCESS == found_qcril_request) && ril_resp_helper  )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( transp_err, &qmi_response->resp, QCRIL_QMI_ERR_CTX_NONE, NULL );
        QCRIL_LOG_ESSENTIAL(".. qmi error %d, resultqmi  %d, qmi transp_err %d, ril res %d",
                            (int)qmi_response->resp.error,
                            (int)qmi_response->resp.result,
                            (int)transp_err,
                            (int)ril_req_res );
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            QCRIL_LOG_INFO("gsm resp %d/%d, wcdma resp %d/%d, lte intra resp %d/%d, lte inter resp %d/%d",
                           qmi_response->geran_info_valid, qmi_response->geran_info.nmr_cell_info_len,
                           qmi_response->umts_info_valid, qmi_response->umts_info.umts_monitored_cell_len,
                           qmi_response->lte_intra_valid, qmi_response->lte_intra.cells_len,
                           qmi_response->lte_inter_valid, qmi_response->lte_inter.freqs_len
                           );

            memset( ril_resp_helper, 0, sizeof( *ril_resp_helper ) );

            if (qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_GSM ))
            {
                QCRIL_LOG_INFO( ".. in GSM");
                ril_req_res = RIL_E_SUCCESS;
                if ( qmi_response->geran_info_valid && qmi_response->geran_info.nmr_cell_info_len <= NAS_NMR_MAX_NUM_V01)
                {
                    for (iter=0; iter < qmi_response->geran_info.nmr_cell_info_len; iter++)
                    {
                        ril_resp_helper->neighbor_cell_list[iter] = &ril_resp_helper->neighbor_cell[iter];
                        ril_resp_helper->neighbor_cell[iter].cid = ril_resp_helper->cid[iter];

                        QCRIL_SNPRINTF( ril_resp_helper->cid[iter], NAS_CID_ASCII_MAX_LEN, "%04x%04x", (uint) qmi_response->geran_info.nmr_cell_info[iter].nmr_lac, (uint) qmi_response->geran_info.nmr_cell_info[iter].nmr_cell_id );
                        ril_resp_helper->neighbor_cell[iter].rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(qmi_response ->geran_info.nmr_cell_info[iter].nmr_rx_lev );
                    }
                    cell_info_len = qmi_response->geran_info.nmr_cell_info_len;
                }
            }
            else if ( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_UMTS ) )
            {
                QCRIL_LOG_INFO( ".. in UMTS");
                ril_req_res = RIL_E_SUCCESS;
                if ( qmi_response->umts_info_valid && qmi_response->umts_info.umts_monitored_cell_len <= NAS_UMTS_MAX_MONITORED_CELL_SET_NUM_V01)
                {
                    for (iter=0; iter < qmi_response->umts_info.umts_monitored_cell_len; iter++)
                    {
                        ril_resp_helper->neighbor_cell_list[iter] = &ril_resp_helper->neighbor_cell[iter];
                        ril_resp_helper->neighbor_cell[iter].cid = ril_resp_helper->cid[iter];

                        QCRIL_SNPRINTF( ril_resp_helper->cid[iter], NAS_CID_ASCII_MAX_LEN, "%08x", (uint) qmi_response->umts_info.umts_monitored_cell[iter].umts_psc);
                        ril_resp_helper->neighbor_cell[iter].rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(qmi_response->umts_info.umts_monitored_cell[iter].umts_rscp);
                    }
                    cell_info_len = qmi_response->umts_info.umts_monitored_cell_len;
                }
            }
            else if ( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_LTE ) )
            {
                QCRIL_LOG_INFO( ".. in LTE");
                ril_req_res = RIL_E_SUCCESS;

                iter = 0;
                if ( qmi_response->lte_intra_valid && qmi_response->lte_intra.cells_len <= NAS_MAX_LTE_NGBR_NUM_CELLS_V01)
                {
                    for (iter_j=0; iter_j < qmi_response->lte_intra.cells_len; iter_j++ )
                    {
                        ril_resp_helper->neighbor_cell_list[iter] = &ril_resp_helper->neighbor_cell[iter];
                        ril_resp_helper->neighbor_cell[iter].cid = ril_resp_helper->cid[iter];

                        QCRIL_SNPRINTF( ril_resp_helper->cid[iter], NAS_CID_ASCII_MAX_LEN, "%08x", (uint) qmi_response->lte_intra.cells[iter_j].pci );
                        ril_resp_helper->neighbor_cell[iter].rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(qmi_response->lte_intra.cells[iter_j].rssi);
                        iter++;
                    }
                }
                if ( qmi_response->lte_inter_valid && qmi_response->lte_inter.freqs_len <= NAS_MAX_LTE_NGBR_NUM_FREQS_V01)
                {
                    for (iter_j=0; iter_j < qmi_response->lte_inter.freqs_len; iter_j++)
                    {
                        if ( qmi_response->lte_inter.freqs[iter_j].cells_len <= NAS_MAX_LTE_NGBR_NUM_CELLS_V01)
                        {
                            for ( iter_k=0; iter_k < qmi_response->lte_inter.freqs[iter_j].cells_len; iter_k++ )
                            {
                                ril_resp_helper->neighbor_cell_list[iter] = &ril_resp_helper->neighbor_cell[iter];
                                ril_resp_helper->neighbor_cell[iter].cid = ril_resp_helper->cid[iter];

                                QCRIL_SNPRINTF( ril_resp_helper->cid[iter], NAS_CID_ASCII_MAX_LEN, "%08x", (uint) qmi_response->lte_inter.freqs[iter_j].cells[iter_k].pci );
                                ril_resp_helper->neighbor_cell[iter].rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(qmi_response->lte_inter.freqs[iter_j].cells[iter_k].rssi);

                                iter++;
                            }
                        }
                    }
                }
                if ( qmi_response->lte_gsm_valid && qmi_response->lte_gsm.freqs_len <= NAS_MAX_LTE_NGBR_GSM_NUM_FREQS_V01)
                {
                    for (iter_j=0; iter_j < qmi_response->lte_gsm.freqs_len; iter_j++)
                    {
                        if ( qmi_response->lte_gsm.freqs[iter_j].cells_len <= NAS_MAX_LTE_NGBR_GSM_NUM_CELLS_V01)
                        {
                            for ( iter_k=0; iter_k < qmi_response->lte_gsm.freqs[iter_j].cells_len; iter_k++ )
                            {
                                ril_resp_helper->neighbor_cell_list[iter] = &ril_resp_helper->neighbor_cell[iter];
                                ril_resp_helper->neighbor_cell[iter].cid = ril_resp_helper->cid[iter];

                                QCRIL_SNPRINTF( ril_resp_helper->cid[iter], NAS_CID_ASCII_MAX_LEN, "%08x", (uint) qmi_response->lte_gsm.freqs[iter_j].cells[iter_k].bsic_id );
                                ril_resp_helper->neighbor_cell[iter].rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(qmi_response->lte_gsm.freqs[iter_j].cells[iter_k].rssi);

                                iter++;
                            }
                        }
                    }
                }
                if ( qmi_response->lte_wcdma_valid && qmi_response->lte_wcdma.freqs_len <= NAS_MAX_LTE_NGBR_WCDMA_NUM_FREQS_V01)
                {
                    for (iter_j=0; iter_j < qmi_response->lte_wcdma.freqs_len; iter_j++)
                    {
                        if ( qmi_response->lte_wcdma.freqs[iter_j].cells_len <= NAS_MAX_LTE_NGBR_WCDMA_NUM_CELLS_V01)
                        {
                            for ( iter_k=0; iter_k < qmi_response->lte_wcdma.freqs[iter_j].cells_len; iter_k++ )
                            {
                                ril_resp_helper->neighbor_cell_list[iter] = &ril_resp_helper->neighbor_cell[iter];
                                ril_resp_helper->neighbor_cell[iter].cid = ril_resp_helper->cid[iter];

                                QCRIL_SNPRINTF( ril_resp_helper->cid[iter], NAS_CID_ASCII_MAX_LEN, "%08x", (uint) qmi_response->lte_wcdma.freqs[iter_j].cells[iter_k].psc );
                                ril_resp_helper->neighbor_cell[iter].rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi(qmi_response->lte_wcdma.freqs[iter_j].cells[iter_k].cpich_rscp);

                                iter++;
                            }
                        }
                    }
                }

                cell_info_len = iter;
            }
            else
            {
                QCRIL_LOG_INFO( ".. no active 3gpp RATs");

                ril_req_res     = RIL_E_SUCCESS;
                cell_info_len   = NAS_NIL;
            }
        }
        else
        { // some error code from QMI NAS
            if ( QMI_RESULT_FAILURE_V01 == qmi_response->resp.result && QMI_ERR_NO_NETWORK_FOUND_V01 == qmi_response->resp.error )
            {   // report empty payload
                QCRIL_LOG_INFO( ".. no network found");

                ril_req_res     = RIL_E_SUCCESS;
                cell_info_len   = NAS_NIL;
            }
        }
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID, qcril_req_info.t, qcril_req_info.request, ril_req_res , &resp );
        if ( RIL_E_SUCCESS == ril_req_res )
        {
            resp.resp_pkt = (void *) ril_resp_helper->neighbor_cell_list;
            resp.resp_len = sizeof( *ril_resp_helper->neighbor_cell_list ) * cell_info_len;
        }
        qcril_send_request_response( &resp );
    }
    if ( qmi_response )
    {
        qcril_free( qmi_response );
    }
    if ( ril_resp_helper )
    {
        qcril_free( ril_resp_helper );
    }
    QCRIL_LOG_ESSENTIAL( "completed with %d with %d entries", (int)ril_req_res, cell_info_len );

} // qcril_qmi_nas_get_neighboring_cells_cb

//===========================================================================
//qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache
//===========================================================================
int qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(int cell_value, int radioif)
{
  int rssi = 0, dbm =0;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_DEBUG("cell_value: %d. radioif: 0x%x", cell_value, radioif);

  switch(radioif)
  {
    case NAS_RADIO_IF_GSM:
    {
      /**<   Serving cell Rx measurement. Values range between 0 and 63, which is
           mapped to a measured signal level:

           - cell_value 0 is a signal strength less than -110 dBm
           - cell_value 1 is -110 dBm to -109 dBm
           - cell_value 2 is -109 dBm to -108 dBm
           - ...
           - cell_value is -49 dBm to -48 dBm
           - cell_value is greater than -48 dBm
       */

      //For GSM, rssi ranges from 0 to 31 (dBm = -113 + 2*rssi) 0 means "-113 dBm or less" and 31 means "-51 dBm or greater"

      dbm = 111 - cell_value;
      if( dbm > 110 )
      {
        rssi = 0;
      }
      else if( dbm < 51 )
      {
        rssi = 31;
      }
      else
      {
        rssi = (int) ((113 - dbm) / 2);
      }
      break;
    }
    case NAS_RADIO_IF_UMTS:
    {
      // For UMTS, rssi is the Level index of CPICH RSCP (cell_value)
      rssi = cell_value;
      break;
    }
    case NAS_RADIO_IF_LTE:
    {
      /**<   Absolute power level (in 1/10 dBm) of the common pilot channel as
        received by the UE. Range: -1200 to -250 (e.g., -250 means -25.0 dBm).
        Defined in [S14].  */

      rssi = (cell_value * -1) / 10;
      break;
    }
    default:
    {
      QCRIL_LOG_INFO("Unsupported RAT");
      rssi = 0;
      break;
    }
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(rssi);
  return rssi;
} //qcril_qmi_nas_util_calculate_neighbor_cell_rssi

//===========================================================================
//qcril_qmi_nas_util_calculate_neighbor_cell_rssi
//===========================================================================
int qcril_qmi_nas_util_calculate_neighbor_cell_rssi(int cell_value)
{
  int rssi = 0, dbm =0;

  QCRIL_LOG_FUNC_ENTRY();

  if( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_GSM ) )
  {
    rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(cell_value, NAS_RADIO_IF_GSM);
  }
  else if( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_UMTS ) )
  {
    rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(cell_value, NAS_RADIO_IF_UMTS);
  }
  else if( qcril_qmi_nas_is_using_radio_if( NAS_RADIO_IF_LTE ) )
  {
    rssi = qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(cell_value, NAS_RADIO_IF_LTE);
  }
  else
  {
    QCRIL_LOG_INFO("Unsupported RAT");
    rssi = 0;
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(rssi);
  return rssi;
} //qcril_qmi_nas_util_calculate_neighbor_cell_rssi

//===========================================================================
//RIL_REQUEST_SET_LOCATION_UPDATES
//===========================================================================
void qcril_qmi_nas_set_location_updates
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  int* req_val;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );
  if ( params_ptr->datalen > NAS_ZERO && params_ptr->data != NULL )
  {
      req_val = (int * )params_ptr->data;
      NAS_CACHE_LOCK();
      switch ( *req_val )
      {
          case 1:   // enable
              nas_common_info.location_updates_enabled = TRUE;
              ril_req_res = RIL_E_SUCCESS;
              break;

          case 0:   // disable
              nas_common_info.location_updates_enabled = FALSE;
              ril_req_res = RIL_E_SUCCESS;
              break;

          default: // no action
              break;
      }
      NAS_CACHE_UNLOCK();
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_set_location_updates


//===========================================================================
// qcril_qmi_nas_cell_location_is_geran_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_geran_changed
(
  nas_geran_cell_info_type_v01 *first,
  nas_geran_cell_info_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        if (first->cell_id != NAS_CELL_ID_NOT_PRESENT &&
            second->cell_id != NAS_CELL_ID_NOT_PRESENT)
        {
            ret = first->cell_id != second->cell_id ||
                      memcmp(first->plmn, second->plmn, NAS_PLMN_LEN_V01) ||
                      first->lac != second->lac;
        }
        else if ((first->cell_id == NAS_CELL_ID_NOT_PRESENT) !=
                 (second->cell_id == NAS_CELL_ID_NOT_PRESENT))
        {
            ret = TRUE;
        }
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_geran_changed

//===========================================================================
// qcril_qmi_nas_cell_location_is_umts_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_umts_changed
(
  nas_umts_cell_info_type_v01 *first,
  nas_umts_cell_info_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        if (first->cell_id != NAS_CELL_ID_NOT_PRESENT &&
            second->cell_id != NAS_CELL_ID_NOT_PRESENT)
        {
            ret = memcmp(first->plmn, second->plmn, NAS_PLMN_LEN_V01) ||
                  first->lac != second->lac ||
                  first->psc != second->psc;
        }
        else if ((first->cell_id == NAS_CELL_ID_NOT_PRESENT) !=
                 (second->cell_id == NAS_CELL_ID_NOT_PRESENT))
        {
            ret = TRUE;
        }
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
}

//===========================================================================
// qcril_qmi_nas_cell_location_is_cdma_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_cdma_changed
(
  nas_cdma_cell_info_type_v01 *first,
  nas_cdma_cell_info_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        ret = first->sid != second->sid ||
              first->nid != second->nid ||
              first->base_id != second->base_id ||
              first->base_long != second->base_long ||
              first->base_lat != second->base_lat;
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_cdma_changed

//===========================================================================
// qcril_qmi_nas_cell_location_is_lte_intra_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_lte_intra_changed
(
  nas_lte_intra_freq_type_v01 *first,
  nas_lte_intra_freq_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        ret = memcmp(first->plmn, second->plmn, NAS_PLMN_LEN_V01) ||
              first->global_cell_id != second->global_cell_id ||
              first->serving_cell_id != second->serving_cell_id ||
              first->tac != second->tac;
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_lte_intra_changed

//===========================================================================
// qcril_qmi_nas_cell_location_is_lte_inter_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_lte_inter_changed
(
  nas_lte_inter_freq_type_v01 *first,
  nas_lte_inter_freq_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        ret = FALSE; // TODO: Compare neighbors
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_lte_inter_changed

//===========================================================================
// qcril_qmi_nas_cell_location_is_lte_gsm_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_lte_gsm_changed
(
  nas_lte_ngbr_gsm_type_v01 *first,
  nas_lte_ngbr_gsm_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        ret = FALSE; // TODO: Compare neighbors
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_lte_gsm_changed

//===========================================================================
// qcril_qmi_nas_cell_location_is_lte_wcdma_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_lte_wcdma_changed
(
  nas_lte_ngbr_wcdma_type_v01 *first,
  nas_lte_ngbr_wcdma_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        ret = FALSE; // TODO: Compare neighbors
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_lte_wcdma_changed

//===========================================================================
// qcril_qmi_nas_cell_location_is_wcdma_lte_changed
//===========================================================================
boolean qcril_qmi_nas_cell_location_is_wcdma_lte_changed
(
  nas_wcdma_ngbr_lte_type_v01 *first,
  nas_wcdma_ngbr_lte_type_v01 *second
)
{
    boolean ret = FALSE;
    if (first && second)
    {
        ret = FALSE; // TODO: Compare neighbors
    }
    else if (!first != !second)
    {
        ret = TRUE;
    }


    return ret;
} // qcril_qmi_nas_cell_location_is_wcdma_lte_changed

//===========================================================================
// qcril_qmi_nas_is_cell_location_changed_cl
//===========================================================================
boolean qcril_qmi_nas_is_cell_location_changed_cl
(
  nas_get_cell_location_info_resp_msg_v01 *resp
)
{
    boolean cache_valid, resp_valid, changed = FALSE;
    nas_get_cell_location_info_resp_msg_v01 *cptr;


    if (nas_cached_info.cell_location_info)
    {
      cptr = nas_cached_info.cell_location_info;
      cache_valid = nas_cached_info.cell_location_info &&
                    NAS_CELL_LOCATION_VALID(cptr);

      resp_valid = NAS_CELL_LOCATION_VALID(resp);

      changed = (cache_valid != resp_valid) ||
            ( qcril_qmi_nas_cell_location_is_geran_changed(&cptr->geran_info, &resp->geran_info) ||
              qcril_qmi_nas_cell_location_is_umts_changed(&cptr->umts_info, &resp->umts_info) ||
              qcril_qmi_nas_cell_location_is_cdma_changed(&cptr->cdma_info, &resp->cdma_info) ||
              qcril_qmi_nas_cell_location_is_lte_intra_changed(&cptr->lte_intra, &resp->lte_intra) ||
              qcril_qmi_nas_cell_location_is_lte_inter_changed(&cptr->lte_inter, &resp->lte_inter) ||
              qcril_qmi_nas_cell_location_is_lte_gsm_changed(&cptr->lte_gsm, &resp->lte_gsm) ||
              qcril_qmi_nas_cell_location_is_lte_wcdma_changed(&cptr->lte_wcdma, &resp->lte_wcdma) ||
              qcril_qmi_nas_cell_location_is_umts_changed(&cptr->umts_info, &resp->umts_info) ||
              qcril_qmi_nas_cell_location_is_wcdma_lte_changed(&cptr->wcdma_lte, &resp->wcdma_lte)
            );
    }
    else
    {
      // Marking as changed, since cache is not available.This will ensure delivery of indications
      // even when memory allocation for cache failed
      changed = TRUE;
    }

    return changed;
} // qcril_qmi_nas_is_cell_location_changed_cl

//===========================================================================
// qcril_qmi_nas_count_cell_location_info_cells
//===========================================================================
unsigned qcril_qmi_nas_count_cell_location_info_cells
(
  nas_get_cell_location_info_resp_msg_v01 *cell_location_info
)
{
    nas_get_cell_location_info_resp_msg_v01 *li = cell_location_info;
    unsigned ncells = 0;
    unsigned ratcells = 0;
    unsigned i = 0;

    if (li)
    {
      // GERAN
      if (li->geran_info_valid)
      {
        ratcells = 0;
        if (li->geran_info.cell_id != NAS_CELL_ID_NOT_PRESENT)
        {
          /* If cell id is present (not NAS_CELL_ID_NOT_PRESENT) we have a serving cell on gsm */
          ratcells ++;
        }
        else
        {
          QCRIL_LOG_DEBUG("GERAN Cell id invalid. Neighbor len: %d", li->geran_info.nmr_cell_info_len);
        }
        ratcells += li->geran_info.nmr_cell_info_len;
        QCRIL_LOG_DEBUG("GERAN Cells found %d", ratcells);
        ncells += ratcells;
      }

      // UMTS
      if (li->umts_info_valid)
      {
        ratcells = 0;
        if (li->umts_info.cell_id != NAS_CELL_ID_NOT_PRESENT)
        {
          ratcells ++;
        }
        else
        {
          QCRIL_LOG_DEBUG("UMTS Cell id invalid. Monitored len: %d. Neighbor len: %d",
                           li->umts_info.umts_monitored_cell_len,
                           li->umts_info.umts_geran_nbr_cell_len);
        }
        ratcells += li->umts_info.umts_monitored_cell_len;
        QCRIL_LOG_DEBUG("UMTS Cells found: %d", ratcells);
        ncells += ratcells;
        ratcells = 0;
        /* Do we need to account for duplicates if multiple rats are available? */
        ratcells += li->umts_info.umts_geran_nbr_cell_len;
        QCRIL_LOG_DEBUG("UMTS - GERAN neighbor Cells found: %d", ratcells);
        ncells += ratcells;
      }

      // CDMA
      if (li->cdma_info_valid)
      {
        ncells ++;
        QCRIL_LOG_DEBUG("CDMA Cell found");
      }

      // LTE Intra Frequency
      if (li->lte_intra_valid)
      {
        ratcells = 1; // Serving cell information
        for( i = 0; i < li->lte_intra.cells_len; i++ )
        {
            if( li->lte_intra.cells[i].pci != li->lte_intra.serving_cell_id )
            {
                ratcells += 1; // Neighbouring Cell information
            }
        }

        QCRIL_LOG_DEBUG("LTE Intra-freq Cells found %d", ratcells);
        ncells += ratcells;
      }

      // LTE - Inter Frequency Neighbors
      if (li->lte_inter_valid)
      {
        ratcells = 0;
        for (i = 0; i < li->lte_inter.freqs_len; i++)
        {
          ratcells += li->lte_inter.freqs[i].cells_len;
        }
        QCRIL_LOG_DEBUG("LTE Inter-freq cells found: %d", ratcells);
        ncells += ratcells;
      }

      // LTE - GSM Neighbors
      if (li->lte_gsm_valid)
      {
        ratcells = 0;
        for (i = 0; i < li->lte_gsm.freqs_len; i++)
        {
          ratcells += li->lte_gsm.freqs[i].cells_len;
        }

        QCRIL_LOG_DEBUG("LTE - GSM Neighbor Cells found: %d", ratcells);
        ncells += ratcells;
      }

      // LTE - WCDMA Neighbors
      if (li->lte_wcdma_valid)
      {
        ratcells = 0;
        for (i = 0; i < li->lte_wcdma.freqs_len; i++)
        {
          ratcells += li->lte_wcdma.freqs[i].cells_len;
        }

        QCRIL_LOG_DEBUG("LTE - WCDMA Neighbor Cells found: %d", ratcells);
        ncells += ratcells;
      }

      if (li->umts_cell_id_valid)
      {
        QCRIL_LOG_DEBUG("Umts Cell Id valid");
      }

      if (li->wcdma_lte_valid)
      {
        ratcells = 0;
        ratcells += li->wcdma_lte.umts_lte_nbr_cell_len;
        QCRIL_LOG_DEBUG("WCDMA - LTE Neighbor Cells found: %d", ratcells);
        ncells += ratcells;
      }

      QCRIL_LOG_DEBUG("Total Cells found: %d", ncells);
    }

    return ncells;
} // qcril_qmi_nas_count_cell_location_info_cells

//===========================================================================
// qcril_qmi_nas_convert_geran_cells_to_ril_cellinfo
//===========================================================================
unsigned qcril_qmi_nas_convert_geran_cells_to_ril_cellinfo
(
  nas_get_cell_location_info_resp_msg_v01 *nas_location_info,
  uint64_t *timestamp,
  RIL_CellInfo **ril_info,
  unsigned ril_info_items
)
{
  nas_get_cell_location_info_resp_msg_v01 *li = nas_location_info;
  RIL_CellInfo *curr_cel = NULL;
  unsigned i;
  unsigned ret = 0;

  if (li && li->geran_info_valid && ril_info && *ril_info && timestamp && ril_info_items > 0)
  {
    curr_cel = *ril_info;
    if ( li->geran_info.cell_id != NAS_CELL_ID_NOT_PRESENT )
    {
      memset(curr_cel, 0, sizeof(*curr_cel));
      curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_GSM;
      curr_cel->registered = TRUE;
      curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
      curr_cel->timeStamp = *timestamp;
      QCRIL_LOG_DEBUG("PLMN From Geran:");
      qcril_qmi_print_hex((unsigned char*)li->geran_info.plmn, NAS_PLMN_LEN_V01);
      curr_cel->CellInfo.gsm.cellIdentityGsm.mcc = QCRIL_MCC_FROM_BCD_PLMN(li->geran_info.plmn);
      curr_cel->CellInfo.gsm.cellIdentityGsm.mnc = QCRIL_MNC_FROM_BCD_PLMN(li->geran_info.plmn);
      curr_cel->CellInfo.gsm.cellIdentityGsm.lac = li->geran_info.lac;
      curr_cel->CellInfo.gsm.cellIdentityGsm.cid = li->geran_info.cell_id;

      curr_cel->CellInfo.gsm.signalStrengthGsm.signalStrength =
              qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(li->geran_info.rx_lev, NAS_RADIO_IF_GSM);

      curr_cel->CellInfo.gsm.signalStrengthGsm.bitErrorRate = 99;
      ++(*ril_info);
      curr_cel = *ril_info;
      ret ++;
    }

    for (i = 0; i < li->geran_info.nmr_cell_info_len && ret < ril_info_items; i++)
    {
      memset(curr_cel, 0, sizeof(*curr_cel));
      curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_GSM;
      curr_cel->registered = FALSE;
      curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
      curr_cel->timeStamp = *timestamp;
      curr_cel->CellInfo.gsm.cellIdentityGsm.mcc =
              QCRIL_MCC_FROM_BCD_PLMN(li->geran_info.nmr_cell_info[i].nmr_plmn);
      curr_cel->CellInfo.gsm.cellIdentityGsm.mnc =
              QCRIL_MNC_FROM_BCD_PLMN(li->geran_info.nmr_cell_info[i].nmr_plmn);
      curr_cel->CellInfo.gsm.cellIdentityGsm.lac = li->geran_info.nmr_cell_info[i].nmr_lac;
      curr_cel->CellInfo.gsm.cellIdentityGsm.cid = li->geran_info.nmr_cell_info[i].nmr_cell_id;

      curr_cel->CellInfo.gsm.signalStrengthGsm.signalStrength =
              qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                      li->geran_info.nmr_cell_info[i].nmr_rx_lev, NAS_RADIO_IF_GSM);

      curr_cel->CellInfo.gsm.signalStrengthGsm.bitErrorRate = 99;
      ++(*ril_info);
      curr_cel = *ril_info;
      ret ++;
    }
    if (i < li->geran_info.nmr_cell_info_len)
    {
      QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for GERAN. "
                      "Slots: %d. Want %d more",
                      ril_info_items,
                      li->geran_info.nmr_cell_info_len - i);
    }
  }
  return ret;
} // qcril_qmi_nas_convert_geran_cells_to_ril_cellinfo

//===========================================================================
// qcril_qmi_nas_convert_umts_cells_to_ril_cellinfo
//===========================================================================
unsigned qcril_qmi_nas_convert_umts_cells_to_ril_cellinfo
(
  nas_get_cell_location_info_resp_msg_v01 *nas_location_info,
  uint64_t *timestamp,
  RIL_CellInfo **ril_info,
  unsigned ril_info_items
)
{
  nas_get_cell_location_info_resp_msg_v01 *li = nas_location_info;
  RIL_CellInfo *curr_cel = NULL;
  unsigned ret = 0;
  unsigned i;

  if (li && li->umts_info_valid && li->umts_cell_id_valid && ril_info && *ril_info && timestamp &&
      ril_info_items > 0)
  {
    curr_cel = *ril_info;
    if ( li->umts_info.cell_id != NAS_CELL_ID_NOT_PRESENT )
    {
      memset(curr_cel, 0, sizeof(*curr_cel));
      curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
      curr_cel->registered = TRUE;
      curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
      curr_cel->timeStamp = *timestamp;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.mcc = QCRIL_MCC_FROM_BCD_PLMN(li->umts_info.plmn);
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.mnc = QCRIL_MNC_FROM_BCD_PLMN(li->umts_info.plmn);
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.lac = li->umts_info.lac;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.cid = li->umts_cell_id;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.psc = li->umts_info.psc;

      qcril_cm_util_rssi_to_gw_signal_strength(
              -qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                      li->umts_info.rscp,
                      NAS_RADIO_IF_UMTS),
              &curr_cel->CellInfo.wcdma.signalStrengthWcdma.signalStrength);

      curr_cel->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate = 99;
      ++(*ril_info);
      curr_cel = *ril_info;
      ret ++;
    }

    // UMTS Neighbors
    for (i = 0; i < li->umts_info.umts_monitored_cell_len && ret < ril_info_items; i++)
    {
      memset(curr_cel, 0, sizeof(*curr_cel));
      curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
      curr_cel->registered = FALSE;
      curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
      curr_cel->timeStamp = *timestamp;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.mcc = INT_MAX;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.mnc = INT_MAX;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.lac = INT_MAX;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.cid = INT_MAX;
      curr_cel->CellInfo.wcdma.cellIdentityWcdma.psc = li->umts_info.umts_monitored_cell[i].umts_psc;

      qcril_cm_util_rssi_to_gw_signal_strength(
              -qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                      li->umts_info.umts_monitored_cell[i].umts_rscp,
                      NAS_RADIO_IF_UMTS),
              &curr_cel->CellInfo.wcdma.signalStrengthWcdma.signalStrength);

      curr_cel->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate = 99;
      curr_cel = ++(*ril_info);
      ret ++;
    }
    if (i < li->umts_info.umts_monitored_cell_len)
    {
      QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for UMTS Monitored Cells. "
                      "Slots: %d. Need: %d more",
                      ril_info_items,
                      li->umts_info.umts_monitored_cell_len - i);
    }

    // GERAN Neighbors
    for (i = 0; i < li->umts_info.umts_geran_nbr_cell_len && ret < ril_info_items; i++)
    {
      memset(curr_cel, 0, sizeof(*curr_cel));
      curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_GSM;
      curr_cel->registered = FALSE;
      curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
      curr_cel->timeStamp = *timestamp;
      curr_cel->CellInfo.gsm.cellIdentityGsm.cid = INT_MAX;
      curr_cel->CellInfo.gsm.cellIdentityGsm.mcc = INT_MAX;
      curr_cel->CellInfo.gsm.cellIdentityGsm.mnc = INT_MAX;
      curr_cel->CellInfo.gsm.cellIdentityGsm.lac = INT_MAX;

      qcril_cm_util_rssi_to_gw_signal_strength(
              -qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                      li->umts_info.umts_geran_nbr_cell[i].geran_rssi,
                      NAS_RADIO_IF_UMTS),
              &curr_cel->CellInfo.gsm.signalStrengthGsm.signalStrength);

      curr_cel->CellInfo.gsm.signalStrengthGsm.bitErrorRate = 99;
      ++(*ril_info);
      curr_cel = (*ril_info);
      ret ++;
    }

    if (i < li->umts_info.umts_geran_nbr_cell_len)
    {
      QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for Geran Neighbors. "
                      "Slots: %d. Need: %d more",
                      ril_info_items,
                      li->umts_info.umts_geran_nbr_cell_len - i);
    }
  }
  return ret;
} // qcril_qmi_nas_convert_umts_cells_to_ril_cellinfo

//===========================================================================
// qcril_qmi_nas_initialize_cdma_ril_cellinfo
//===========================================================================
void qcril_qmi_nas_initialize_cdma_ril_cellinfo
(
  RIL_CellInfo *cell_info,
  boolean registered,
  RIL_TimeStampType timestampType,
  uint64_t *timestamp
)
{
  if (cell_info)
  {
      memset(cell_info, 0, sizeof(*cell_info));
      cell_info->cellInfoType = RIL_CELL_INFO_TYPE_CDMA;
      cell_info->registered = registered;
      if (timestamp)
      {
        cell_info->timeStamp = *timestamp;
      }
      cell_info->timeStampType = timestampType;

      cell_info->CellInfo.cdma.cellIdentityCdma.networkId = INT_MAX;
      cell_info->CellInfo.cdma.cellIdentityCdma.systemId = INT_MAX;
      cell_info->CellInfo.cdma.cellIdentityCdma.basestationId = INT_MAX;
      cell_info->CellInfo.cdma.cellIdentityCdma.longitude = INT_MAX;
      cell_info->CellInfo.cdma.cellIdentityCdma.latitude = INT_MAX;

      cell_info->CellInfo.cdma.signalStrengthCdma.dbm = INT_MAX;
      cell_info->CellInfo.cdma.signalStrengthCdma.ecio = INT_MAX;

      cell_info->CellInfo.cdma.signalStrengthEvdo.dbm = INT_MAX;
      cell_info->CellInfo.cdma.signalStrengthEvdo.ecio = INT_MAX;
      cell_info->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio = INT_MAX;
  }
} // qcril_qmi_nas_initialize_cdma_ril_cellinfo

//===========================================================================
// qcril_qmi_nas_convert_cdma_cells_to_ril_cellinfo
//===========================================================================
unsigned qcril_qmi_nas_convert_cdma_cells_to_ril_cellinfo
(
  nas_get_cell_location_info_resp_msg_v01 *nas_location_info,
  uint64_t *timestamp,
  RIL_CellInfo **ril_info,
  unsigned ril_info_items
)
{
  nas_get_cell_location_info_resp_msg_v01 *li = nas_location_info;
  RIL_CellInfo *curr_cel = NULL;
  RIL_SignalStrength ss;
  unsigned ret = 0;

  if (li && li->cdma_info_valid && ril_info && *ril_info && timestamp && ril_info_items > 0)
  {
    curr_cel = *ril_info;

    qcril_qmi_nas_initialize_cdma_ril_cellinfo(curr_cel,
                                               TRUE,
                                               RIL_TIMESTAMP_TYPE_OEM_RIL,
                                               timestamp);
    curr_cel->CellInfo.cdma.cellIdentityCdma.networkId = li->cdma_info.nid;
    curr_cel->CellInfo.cdma.cellIdentityCdma.systemId = li->cdma_info.sid;
    curr_cel->CellInfo.cdma.cellIdentityCdma.basestationId = li->cdma_info.base_id;
    curr_cel->CellInfo.cdma.cellIdentityCdma.longitude = li->cdma_info.base_long;
    curr_cel->CellInfo.cdma.cellIdentityCdma.latitude = li->cdma_info.base_lat;

    // QMI_NAS_GET_CELL_LOCATION_INFO doesn't have SS information for CDMA.
    // Get from cache
    if (qcril_qmi_nas_signal_strength_con_conv_cache2ril(&ss) == E_SUCCESS)
    {
      if (ss.CDMA_SignalStrength.dbm != NAS_SIGNAL_STRENGTH_UNK)
      {
        curr_cel->CellInfo.cdma.signalStrengthCdma.dbm = ss.CDMA_SignalStrength.dbm;
      }
      if (ss.CDMA_SignalStrength.ecio != NAS_SIGNAL_STRENGTH_UNK)
      {
        curr_cel->CellInfo.cdma.signalStrengthCdma.ecio = ss.CDMA_SignalStrength.ecio;
      }

      if (ss.EVDO_SignalStrength.dbm != NAS_SIGNAL_STRENGTH_UNK)
      {
        curr_cel->CellInfo.cdma.signalStrengthEvdo.dbm = ss.EVDO_SignalStrength.dbm;
      }
      if (ss.EVDO_SignalStrength.ecio != NAS_SIGNAL_STRENGTH_UNK)
      {
        curr_cel->CellInfo.cdma.signalStrengthEvdo.ecio = ss.EVDO_SignalStrength.ecio;
      }
      if (ss.EVDO_SignalStrength.signalNoiseRatio != NAS_SIGNAL_STRENGTH_UNK)
      {
        curr_cel->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio = ss.EVDO_SignalStrength.signalNoiseRatio;
      }
    }
    else
    {
      QCRIL_LOG_INFO("qcril_qmi_nas_signal_strength_con_conv_cache2ril returns error."
                     " No SS available for cdma/evdo");
    }

    ++(*ril_info);
    curr_cel = (*ril_info);
    ret ++;
  }
  return ret;
} // qcril_qmi_nas_convert_cdma_cells_to_ril_cellinfo

//===========================================================================
// qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo
//===========================================================================
unsigned qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo
(
  nas_get_cell_location_info_resp_msg_v01 *nas_location_info,
  uint64_t *timestamp,
  RIL_CellInfo **ril_info,
  unsigned ril_info_items
)
{
  nas_get_cell_location_info_resp_msg_v01 *li = nas_location_info;
  RIL_CellInfo *curr_cel = NULL, *srv_cell = NULL;
  unsigned ret =0;
  unsigned i = 0, j;

  if (li && ril_info && *ril_info && timestamp && ril_info_items > 0)
  {
    curr_cel = *ril_info;

    if ( li->lte_intra_valid )
    {
      memset(curr_cel, 0, sizeof(*curr_cel));
      curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_LTE;
      curr_cel->registered = TRUE;
      curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
      curr_cel->timeStamp = *timestamp;
      curr_cel->CellInfo.lte.cellIdentityLte.mcc = QCRIL_MCC_FROM_BCD_PLMN(li->lte_intra.plmn);
      curr_cel->CellInfo.lte.cellIdentityLte.mnc = QCRIL_MNC_FROM_BCD_PLMN(li->lte_intra.plmn);
      curr_cel->CellInfo.lte.cellIdentityLte.ci = li->lte_intra.global_cell_id;
      curr_cel->CellInfo.lte.cellIdentityLte.pci = li->lte_intra.serving_cell_id;
      curr_cel->CellInfo.lte.cellIdentityLte.tac = li->lte_intra.tac;

      curr_cel->CellInfo.lte.signalStrengthLte.signalStrength = 99;
      curr_cel->CellInfo.lte.signalStrengthLte.rsrp = INT_MAX;
      curr_cel->CellInfo.lte.signalStrengthLte.rsrq = INT_MAX;
      curr_cel->CellInfo.lte.signalStrengthLte.rssnr = INT_MAX;
      curr_cel->CellInfo.lte.signalStrengthLte.cqi = INT_MAX;
      curr_cel->CellInfo.lte.signalStrengthLte.timingAdvance = INT_MAX;
      srv_cell = curr_cel;
      ++(*ril_info);
      curr_cel = (*ril_info);
      ret ++;

      // Neighbors
      for (i = 0; i < li->lte_intra.cells_len && ril_info_items > 0; i++)
      {
        if (li->lte_intra.cells[i].pci == srv_cell->CellInfo.lte.cellIdentityLte.pci)
        {
          /* This is for the Serving Cell */
          srv_cell->CellInfo.lte.signalStrengthLte.rsrq =
                  -(li->lte_intra.cells[i].rsrq / 10);
          srv_cell->CellInfo.lte.signalStrengthLte.rsrp =
                  -(li->lte_intra.cells[i].rsrp / 10);
          qcril_cm_util_rssi_to_gw_signal_strength(
                  qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                          li->lte_intra.cells[i].rssi,
                          NAS_RADIO_IF_LTE),
                  &srv_cell->CellInfo.lte.signalStrengthLte.signalStrength);

          QCRIL_LOG_DEBUG("Serving cell rsrp: %d. rssi: %d. srxlev: %d. output signal Strength: %d",
                  -(li->lte_intra.cells[i].rsrp / 10),
                  li->lte_intra.cells[i].rssi,
                  li->lte_intra.cells[i].srxlev,
                  srv_cell->CellInfo.lte.signalStrengthLte.signalStrength);

        }
        else
        {
          /* This is for a neighbor Cell */
          memset(curr_cel, 0, sizeof(*curr_cel));
          curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_LTE;
          curr_cel->registered = FALSE;
          curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
          curr_cel->timeStamp = *timestamp;
          curr_cel->CellInfo.lte.cellIdentityLte.mcc = INT_MAX;
          curr_cel->CellInfo.lte.cellIdentityLte.mnc = INT_MAX;
          curr_cel->CellInfo.lte.cellIdentityLte.ci = INT_MAX;
          curr_cel->CellInfo.lte.cellIdentityLte.pci = li->lte_intra.cells[i].pci;
          curr_cel->CellInfo.lte.cellIdentityLte.tac = INT_MAX;

          qcril_cm_util_rssi_to_gw_signal_strength(
                  qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                          li->lte_intra.cells[i].rssi,
                          NAS_RADIO_IF_LTE),
                  &curr_cel->CellInfo.lte.signalStrengthLte.signalStrength);

          curr_cel->CellInfo.lte.signalStrengthLte.rsrp = -(li->lte_intra.cells[i].rsrp / 10);
          curr_cel->CellInfo.lte.signalStrengthLte.rsrq = -(li->lte_intra.cells[i].rsrq / 10);
          curr_cel->CellInfo.lte.signalStrengthLte.rssnr = INT_MAX;
          curr_cel->CellInfo.lte.signalStrengthLte.cqi = INT_MAX;
          curr_cel->CellInfo.lte.signalStrengthLte.timingAdvance = INT_MAX;

          QCRIL_LOG_DEBUG("Neighbor cell rsrp: %d. rssi: %d. srxlev: %d. output signal Strength: %d",
                  -(li->lte_intra.cells[i].rsrp / 10),
                  li->lte_intra.cells[i].rssi,
                  li->lte_intra.cells[i].srxlev,
                  curr_cel->CellInfo.lte.signalStrengthLte.signalStrength);

          ++(*ril_info);
          curr_cel = (*ril_info);
          ret ++;
        }
      }
      if (i < li->lte_intra.cells_len)
      {
        QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for LTE - Intra. "
                        "Slots: %d. Want %d more",
                        ril_info_items,
                        li->lte_intra.cells_len - i);
      }
    }

    if ( li->lte_inter_valid )
    {
      for (i = 0; i < li->lte_inter.freqs_len; i++)
      {
        for (j = 0; j < li->lte_inter.freqs[i].cells_len && ret < ril_info_items; j++)
        {
          memset(curr_cel, 0, sizeof(*curr_cel));
          curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_LTE;
          curr_cel->registered = FALSE;
          curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
          curr_cel->timeStamp = *timestamp;
          curr_cel->CellInfo.lte.cellIdentityLte.mcc = INT_MAX;
          curr_cel->CellInfo.lte.cellIdentityLte.mnc = INT_MAX;
          curr_cel->CellInfo.lte.cellIdentityLte.ci = INT_MAX;
          curr_cel->CellInfo.lte.cellIdentityLte.pci = li->lte_inter.freqs[i].cells[j].pci;
          curr_cel->CellInfo.lte.cellIdentityLte.tac = INT_MAX;

          qcril_cm_util_rssi_to_gw_signal_strength(
                  qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                          li->lte_inter.freqs[i].cells[j].rssi,
                          NAS_RADIO_IF_LTE),
                  &curr_cel->CellInfo.lte.signalStrengthLte.signalStrength);

          curr_cel->CellInfo.lte.signalStrengthLte.rsrp = -(li->lte_inter.freqs[i].cells[j].rsrp / 10);
          curr_cel->CellInfo.lte.signalStrengthLte.rsrq = -(li->lte_inter.freqs[i].cells[j].rsrq / 10);
          curr_cel->CellInfo.lte.signalStrengthLte.rssnr = INT_MAX;
          curr_cel->CellInfo.lte.signalStrengthLte.cqi = INT_MAX;
          curr_cel->CellInfo.lte.signalStrengthLte.timingAdvance = INT_MAX;

          QCRIL_LOG_DEBUG("Neighbor cell (inter) rsrp: %d. rssi: %d. srxlev: %d. output signal Strength: %d",
                  -(li->lte_intra.cells[i].rsrp / 10),
                  li->lte_intra.cells[i].rssi,
                  li->lte_intra.cells[i].srxlev,
                  curr_cel->CellInfo.lte.signalStrengthLte.signalStrength);

          ++(*ril_info);
          curr_cel = (*ril_info);
          ret ++;
        }
        if ( j < li->lte_inter.freqs[i].cells_len )
        {
          QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for LTE - Inter, freq %d. "
                          "Slots: %d. Want %d more",
                          i,
                          ril_info_items,
                          li->lte_inter.freqs[i].cells_len - j);
        }
      }
    }

    if ( li->lte_gsm_valid )
    {
      for (i = 0; i < li->lte_gsm.freqs_len; i++)
      {
        for (j = 0; j < li->lte_gsm.freqs[i].cells_len && ret < ril_info_items; j++)
        {
          memset(curr_cel, 0, sizeof(*curr_cel));
          curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_GSM;
          curr_cel->registered = FALSE;
          curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
          curr_cel->timeStamp = *timestamp;
          curr_cel->CellInfo.gsm.cellIdentityGsm.mcc = INT_MAX;
          curr_cel->CellInfo.gsm.cellIdentityGsm.mnc = INT_MAX;
          curr_cel->CellInfo.gsm.cellIdentityGsm.lac = INT_MAX;
          curr_cel->CellInfo.gsm.cellIdentityGsm.cid = INT_MAX;

          qcril_cm_util_rssi_to_gw_signal_strength(
                  qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                          li->lte_gsm.freqs[i].cells[j].rssi,
                          NAS_RADIO_IF_LTE),
                  &curr_cel->CellInfo.gsm.signalStrengthGsm.signalStrength);

          curr_cel->CellInfo.gsm.signalStrengthGsm.bitErrorRate = 99;

          ++(*ril_info);
          curr_cel = (*ril_info);
          ret ++;
        }
        if ( j < li->lte_gsm.freqs[i].cells_len )
        {
          QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for LTE - GSM Neighbors, freq %d. "
                          "Slots: %d. Want %d more",
                          i,
                          ril_info_items,
                          li->lte_gsm.freqs[i].cells_len - j);
        }
      }
    }

    if ( li->lte_wcdma_valid )
    {
      for (i = 0; i < li->lte_wcdma.freqs_len; i++)
      {
        for (j = 0; j < li->lte_wcdma.freqs[i].cells_len && ret < ril_info_items; j++)
        {
          memset(curr_cel, 0, sizeof(*curr_cel));
          curr_cel->cellInfoType = RIL_CELL_INFO_TYPE_WCDMA;
          curr_cel->registered = FALSE;
          curr_cel->timeStampType = RIL_TIMESTAMP_TYPE_OEM_RIL;
          curr_cel->timeStamp = *timestamp;
          curr_cel->CellInfo.wcdma.cellIdentityWcdma.mcc = INT_MAX;
          curr_cel->CellInfo.wcdma.cellIdentityWcdma.mnc = INT_MAX;
          curr_cel->CellInfo.wcdma.cellIdentityWcdma.lac = INT_MAX;
          curr_cel->CellInfo.wcdma.cellIdentityWcdma.cid = INT_MAX;
          curr_cel->CellInfo.wcdma.cellIdentityWcdma.psc = li->lte_wcdma.freqs[i].cells[j].psc;

          qcril_cm_util_rssi_to_gw_signal_strength(
                  qcril_qmi_nas_util_calculate_neighbor_cell_rssi_no_cache(
                          li->lte_wcdma.freqs[i].cells[j].cpich_rscp,
                          NAS_RADIO_IF_LTE),
                  &curr_cel->CellInfo.wcdma.signalStrengthWcdma.signalStrength);

          curr_cel->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate = 99;

          ++(*ril_info);
          curr_cel = (*ril_info);
          ret ++;
        }
        if ( j < li->lte_wcdma.freqs[i].cells_len )
        {
          QCRIL_LOG_ERROR("Not enough RIL_CellInfo slots for LTE - WCDMA Neighbors, freq %d. "
                          "Slots: %d. Want %d more",
                          i,
                          ril_info_items,
                          li->lte_wcdma.freqs[i].cells_len - j);
        }
      }
    }
  }
  return ret;
} // qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo

//===========================================================================
// qcril_ril_cellinfo_free
//===========================================================================
void qcril_ril_cellinfo_free
(
  RIL_CellInfo *cellinfo
)
{
  if (cellinfo)
  {
    qcril_free(cellinfo);
  }
} // qcril_ril_cellinfo_free

//===========================================================================
// qcril_qmi_nas_convert_cell_location_to_ril_cellinfo
//
//  Convert a qmi nas get_cell_location_info response into the format used
//  by Android
//
//  nas_location_info: The get_cell_location_info response data from qmi nas
//  cellinfo: Output parameter in which the function will put a pointer to the
//            array of RIL_CellInfo
//  time: Timestamp at which the information was captured
//  number_of_cells:   Output parameter. Number of elements in the array pointed
//                     to by *cellinfo
//
//===========================================================================
void qcril_qmi_nas_convert_cell_location_to_ril_cellinfo
(
  nas_get_cell_location_info_resp_msg_v01 *nas_location_info,
  RIL_CellInfo **cellinfo,
  uint64_t *time,
  unsigned *number_of_cells
)
{
  unsigned totcells, ncells;
  unsigned consumed_cells = 0;
  int buflen;
  int i, j;
  RIL_CellInfo *cellinfobuf = NULL, *cellinfoptr;
  nas_get_cell_location_info_resp_msg_v01 *li = nas_location_info;

  if (nas_location_info && cellinfo && time)
  {
    *cellinfo = NULL;
    totcells = ncells = qcril_qmi_nas_count_cell_location_info_cells(li);
    buflen = ncells * sizeof(RIL_CellInfo);
    QCRIL_LOG_DEBUG("CellInfo slots allocated: %d. Buflen: %d", ncells, buflen);
    cellinfobuf = qcril_malloc(buflen);
    cellinfoptr = cellinfobuf;
    if (cellinfobuf)
    {
      do
      {
        consumed_cells = qcril_qmi_nas_convert_geran_cells_to_ril_cellinfo(
                                     nas_location_info,
                                     time,
                                     &cellinfoptr,
                                     ncells);

        if (consumed_cells > ncells)
        {
          QCRIL_LOG_ERROR("GERAN consumed more cell slots than available: %d", consumed_cells);
          break;
        }
        else
        {
          QCRIL_LOG_DEBUG("GERAN consumed %d cell slots", consumed_cells);
        }
        ncells -= consumed_cells;

        consumed_cells = qcril_qmi_nas_convert_umts_cells_to_ril_cellinfo(
                                     nas_location_info,
                                     time,
                                     &cellinfoptr,
                                     ncells);
        if (consumed_cells > ncells)
        {
          QCRIL_LOG_ERROR("UMTS consumed more cell slots than available: %d", consumed_cells);
          break;
        }
        else
        {
          QCRIL_LOG_DEBUG("UMTS consumed %d cell slots", consumed_cells);
        }
        ncells -= consumed_cells;

        consumed_cells = qcril_qmi_nas_convert_cdma_cells_to_ril_cellinfo(
                                     nas_location_info,
                                     time,
                                     &cellinfoptr,
                                     ncells);
        if (consumed_cells > ncells)
        {
          QCRIL_LOG_ERROR("CDMA Consumed more cell slots than available: %d", consumed_cells);
          break;
        }
        else
        {
          QCRIL_LOG_DEBUG("CDMA consumed %d cell slots", consumed_cells);
        }
        ncells -= consumed_cells;

        consumed_cells = qcril_qmi_nas_convert_lte_cells_to_ril_cellinfo(
                                     nas_location_info,
                                     time,
                                     &cellinfoptr,
                                     ncells);
        if (consumed_cells > ncells)
        {
          QCRIL_LOG_ERROR("LTE Consumed more cell slots than available: %d", consumed_cells);
          break;
        }
        else
        {
          QCRIL_LOG_DEBUG("LTE consumed %d cell slots", consumed_cells);
        }
        ncells -= consumed_cells;

      } while(0);
    }

    (*cellinfo) = cellinfobuf;
  }
  else
  {
    QCRIL_LOG_DEBUG("NULL parameters passed");
  }

  if (number_of_cells)
  {
    QCRIL_LOG_DEBUG("Total Cells: %d. Used cells: %d", totcells, totcells - ncells);
    *number_of_cells = totcells - ncells;
  }
} // qcril_qmi_nas_convert_cell_location_to_ril_cellinfo

//===========================================================================
// qcril_qmi_nas_cell_location_unsol_cl
//===========================================================================
void qcril_qmi_nas_cell_location_unsol_cl
(
  nas_get_cell_location_info_resp_msg_v01 *cell_location_info
)
{
  qcril_unsol_resp_params_type unsol_resp_params;
  RIL_CellInfo *results;
  unsigned num_of_cells;

  if (cell_location_info)
  {
    qcril_qmi_nas_convert_cell_location_to_ril_cellinfo(cell_location_info,
                                                        &results,
                                                        &nas_cached_info.cell_location_info_time,
                                                        &num_of_cells);
  }

  qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_CELL_INFO_LIST, &unsol_resp_params );
  unsol_resp_params.resp_pkt = (void *) results;
  unsol_resp_params.resp_len = num_of_cells * sizeof(*results);
  qcril_send_unsol_response( &unsol_resp_params );
  qcril_ril_cellinfo_free(results);
} // qcril_qmi_nas_cell_location_unsol_cl

//===========================================================================
// qcril_qmi_nas_cell_info_list_changed
//===========================================================================
void qcril_qmi_nas_cell_info_list_changed
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);
} // qcril_qmi_nas_cell_info_list_changed

void qcril_qmi_nas_cell_location_update_timer_cl
(
  qmi_ril_cell_location_period_action action
)
{
  int conf_rate = nas_common_info.unsol_cell_info_rate;
  int max_period = nas_common_info.unsol_cell_info_rate_sweep_limit;
  int rate = nas_common_info.unsol_cell_info_current_rate;

  if (INT_MAX == conf_rate)
  {
    rate = conf_rate;
  }
  else
  {
    switch(action)
    {
      case QCRIL_CELL_LOCATION_INCREASE_PERIOD:
        rate = (rate << 1) | 0x7f;
        if (rate < 0 || rate > max_period)
        {
          rate = max_period;
        }
        break;
      case QCRIL_CELL_LOCATION_REDUCE_PERIOD:
        rate = rate >> 1;
        if (rate < conf_rate)
        {
          rate = conf_rate;
        }
        break;
      case QCRIL_CELL_LOCATION_RESET_PERIOD:
        rate = nas_common_info.unsol_cell_info_rate;
        break;
    }
  }
  nas_common_info.unsol_cell_info_current_rate = rate;
}

//===========================================================================
// qcril_qmi_nas_queue_cell_info_poll
//
// Queue an event to perform a poll for cell location info. This function
// can be called from any context
//
//
//===========================================================================
void
qcril_qmi_nas_queue_cell_info_poll
(
)
{
  qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
             QCRIL_DEFAULT_MODEM_ID,
             QCRIL_DATA_ON_STACK,
             QCRIL_EVT_QMI_RIL_POLL_CELL_INFO_LIST,
             NULL,
             0,
             (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
} // qcril_qmi_nas_queue_cell_info_poll


//===========================================================================
// qcril_qmi_nas_cell_info_timer_cb
//===========================================================================
void qcril_qmi_nas_cell_info_timer_cb
(
  void *param
)
{
    uint32 timer_id = (uint32)(uintptr_t) param;

    NAS_CACHE_LOCK();
    if (nas_common_info.cell_info_poll_timer_id_valid &&
        timer_id == nas_common_info.cell_info_poll_timer_id)
    {
      nas_common_info.cell_info_poll_timer_id_valid = FALSE;
      qcril_qmi_nas_queue_cell_info_poll();
    }
    else
    {
        QCRIL_LOG_DEBUG( "Timer was already canceled. Not polling %d\n", timer_id);
    }
    NAS_CACHE_UNLOCK();
} // qcril_qmi_nas_cell_info_timer_cb
//===========================================================================
// qcril_qmi_nas_cell_info_schedule_polling_cl
//===========================================================================
RIL_Errno qcril_qmi_nas_cell_info_schedule_polling_cl
(
  void
)
{
  struct timeval time;
  uint32_t ms;
  RIL_Errno ret = RIL_E_SUCCESS;

  QCRIL_LOG_FUNC_ENTRY();

  if ( INT_MAX != nas_common_info.unsol_cell_info_current_rate )
  {
    if ( nas_common_info.cell_info_poll_timer_id_valid )
    {
      qcril_cancel_timed_callback( (void *)(uintptr_t) nas_common_info.cell_info_poll_timer_id );
      nas_common_info.cell_info_poll_timer_id_valid = FALSE;
    }
    // Convert the time provided as milliseconds into seconds and useconds for timeval
    ms = nas_common_info.unsol_cell_info_current_rate;
    QCRIL_MS_TO_TIMEVAL( &time, ms );

    ret = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                QCRIL_DEFAULT_MODEM_ID,
                                qcril_qmi_nas_cell_info_timer_cb,
                                &time,
                                &nas_common_info.cell_info_poll_timer_id );
    if ( RIL_E_SUCCESS == ret)
    {
      nas_common_info.cell_info_poll_timer_id_valid = TRUE;
    }
  }
  else
  {
    QCRIL_LOG_DEBUG("Current rate set to INT_MAX. Not polling");
  }

  return ret;
} // qcril_qmi_nas_cell_info_schedule_polling_cl

//===========================================================================
// qcril_qmi_nas_poll_cell_info_list
//
// Handler function for QCRIL_EVT_QMI_RIL_POLL_CELL_INFO_LIST.
// This function will be called when a timer expires or after an explicit
// poll of cell info is requested.
//
// Should only be called in the context of the event thread.
//===========================================================================
void qcril_qmi_nas_poll_cell_info_list
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
    RIL_Errno rc;
    nas_get_cell_location_info_resp_msg_v01 get_cell_location_info_resp;
    uint8_t get_cell_location_info_resp_valid = FALSE;
    uint64_t timestamp;
    // Fetch Cell Location info
    rc = qcril_qmi_nas_get_cell_location_data_sync(&get_cell_location_info_resp, &timestamp);

    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);
    if (RIL_E_SUCCESS == rc)
    {
        NAS_CACHE_LOCK();
        // Compare with current values.
        if ( qcril_qmi_nas_is_cell_location_changed_cl(&get_cell_location_info_resp) )
        {
            get_cell_location_info_resp_valid = TRUE;
            if (!nas_cached_info.cell_location_info)
            {
              nas_cached_info.cell_location_info = qcril_malloc(
                      sizeof(*nas_cached_info.cell_location_info));
            }

            if ( nas_cached_info.cell_location_info )
            {
              memcpy(nas_cached_info.cell_location_info,
                     &get_cell_location_info_resp,
                     sizeof(*nas_cached_info.cell_location_info));
            }
            else
            {
              QCRIL_LOG_INFO("Caching not possible. Memory allocation failed");
            }

            nas_cached_info.cell_location_info_time = timestamp;

            // Send unsol
            qcril_qmi_nas_cell_location_unsol_cl(&get_cell_location_info_resp);
            // Update timer for sweep operation
            qcril_qmi_nas_cell_location_update_timer_cl(QCRIL_CELL_LOCATION_REDUCE_PERIOD);
            // Schedule next poll.
            qcril_qmi_nas_cell_info_schedule_polling_cl();
        }
        else
        {
            qcril_qmi_nas_cell_location_update_timer_cl(QCRIL_CELL_LOCATION_INCREASE_PERIOD);
        }
        NAS_CACHE_UNLOCK();
    }
} // qcril_qmi_nas_poll_cell_info_list

//===========================================================================
// RIL_REQUEST_GET_CELL_INFO_LIST
//===========================================================================
void qcril_qmi_nas_get_cell_info_list_ncl
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  int* req_val;

  nas_get_cell_location_info_resp_msg_v01 get_cell_location_info_resp;
  RIL_CellInfo *results = NULL;
  unsigned num_of_cells = 0;
  uint64_t timestamp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( params_ptr );
  QCRIL_NOTUSED(ret_ptr);

  qmi_client_error = qcril_qmi_nas_get_cell_location_data_sync(&get_cell_location_info_resp, &timestamp);

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &get_cell_location_info_resp.resp );

  if (RIL_E_SUCCESS == ril_req_res)
  {
    NAS_CACHE_LOCK();

    if (!nas_cached_info.cell_location_info)
    {
      nas_cached_info.cell_location_info = qcril_malloc(sizeof(*nas_cached_info.cell_location_info));
    }

    if ( nas_cached_info.cell_location_info )
    {
      memcpy(nas_cached_info.cell_location_info,
              &get_cell_location_info_resp,
              sizeof(nas_cached_info.cell_location_info));
    }
    else
    {
      QCRIL_LOG_INFO("Caching not possible. Memory allocation failed");
    }

    nas_cached_info.cell_location_info_time = timestamp;

    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_convert_cell_location_to_ril_cellinfo(&get_cell_location_info_resp,
                                                        &results,
                                                        &timestamp,
                                                        &num_of_cells);
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if (RIL_E_SUCCESS == ril_req_res)
  {
    resp.resp_pkt = results;
    resp.resp_len = sizeof(*results) * num_of_cells;
  }
  qcril_send_request_response( &resp );
  qcril_ril_cellinfo_free(results);
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_get_cell_info_list_ncl


//===========================================================================
// RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE
//===========================================================================
void qcril_qmi_nas_set_cell_info_list_rate
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  int* req_val;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );
  if ( params_ptr->datalen > NAS_ZERO && params_ptr->data != NULL )
  {
      req_val = (int * )params_ptr->data;
      NAS_CACHE_LOCK();
      nas_common_info.unsol_cell_info_rate = *req_val;
      nas_common_info.unsol_cell_info_current_rate = *req_val;
      qcril_qmi_nas_cell_info_schedule_polling_cl();
      NAS_CACHE_UNLOCK();
      ril_req_res = RIL_E_SUCCESS;
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_set_cell_info_list_rate


//===========================================================================
//RIL_REQUEST_CDMA_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_request_cdma_subscription
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_get_3gpp2_subscription_info_req_msg_v01 qmi_request;
  nas_get_3gpp2_subscription_info_resp_msg_v01 qmi_response;
  qcril_nas_cdma_subscription_type *ril_response_data = NULL;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  RIL_Errno   prl_fetch_ril_req_res = RIL_E_GENERIC_FAILURE;
  RIL_Errno   sub_info_fetch_ril_req_res = RIL_E_GENERIC_FAILURE;
  qmi_client_error_type qmi_client_error = QMI_INTERNAL_ERR;
  uint16_t       prl_version;
  uint32_t       iter = 0;
  int sid_ptr=0,nid_ptr=0;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  memset(&qmi_request, 0, sizeof(qmi_request));
  memset(&qmi_response, 0, sizeof(qmi_response));
  ril_response_data = qcril_malloc( sizeof( *ril_response_data ) );

  if ( ril_response_data )
  {
      memset( ril_response_data, 0, sizeof( *ril_response_data ) );
      ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_MDN ] = ril_response_data->mob_dir_number;
      ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_H_SID ] = ril_response_data->home_sid;
      ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_H_NID ] = ril_response_data->home_nid;
      ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_MIN ] = ril_response_data->min_s;
      ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_PRL_VER ] = ril_response_data->prl_version;

      prl_fetch_ril_req_res = qcril_qmi_nas_dms_fetch_cur_prl_version( &prl_version );

      if ( RIL_E_SUCCESS == prl_fetch_ril_req_res )
      {
          snprintf( ril_response_data->prl_version, sizeof(ril_response_data->prl_version), "%d", (int)prl_version );

          QCRIL_LOG_INFO("qmi PRL version %s", ril_response_data->prl_version );

          qcril_qmi_dms_save_prl_info(TRUE, prl_version);
      }
      else
      {
          ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_PRL_VER ] = NULL;
          QCRIL_LOG_INFO("fetch current PRL version failed %d", prl_fetch_ril_req_res);
      }


      qmi_request.nam_id = 0xFF; // current NAM
      qmi_request.get_3gpp2_info_mask_valid = TRUE;
      qmi_request.get_3gpp2_info_mask = QMI_NAS_GET_3GPP2_SUBS_INFO_MDN_V01 | QMI_NAS_GET_3GPP2_SUBS_INFO_HOME_SID_IND_V01
                                        | QMI_NAS_GET_3GPP2_SUBS_INFO_MIN_BASED_IMSI_V01;

      qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                 QMI_NAS_GET_3GPP2_SUBSCRIPTION_INFO_REQ_MSG_V01,
                                                 (void*) &qmi_request,
                                                 sizeof( qmi_request ),
                                                 (void*) &qmi_response,
                                                 sizeof( qmi_response ),
                                                 QCRIL_QMI_NAS_GET_3GPP2_INFO_SYNC_TIMEOUT );

      sub_info_fetch_ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result_ex( qmi_client_error, &qmi_response.resp, QCRIL_QMI_ERR_TOLERATE_NOT_FOUND, NULL );

      QCRIL_LOG_INFO("3gpp2_sub  %d, %d, %d", (int)qmi_client_error, (int) sub_info_fetch_ril_req_res, qmi_response.resp.error );

      if( RIL_E_SUCCESS == sub_info_fetch_ril_req_res )
      {
          if( qmi_response.mdn_valid )
          {
              strlcpy(ril_response_data->mob_dir_number,qmi_response.mdn,sizeof(ril_response_data->mob_dir_number));
          }

          if( qmi_response.cdma_sys_id_valid )
          {
              for( iter=0; iter < qmi_response.cdma_sys_id_len; iter++ )
              {
                  sid_ptr += snprintf( &ril_response_data->home_sid[sid_ptr],NAS_SID_NID_ELEMENT_MAX_SIZE+1, "%u,", (unsigned int)qmi_response.cdma_sys_id[iter].sid );
                  nid_ptr += snprintf( &ril_response_data->home_nid[nid_ptr],NAS_SID_NID_ELEMENT_MAX_SIZE+1, "%u,", (unsigned int)qmi_response.cdma_sys_id[iter].nid );
              }
              if( sid_ptr > 0 )
              {
              ril_response_data->home_sid[sid_ptr-1]='\0';
              }
              if( nid_ptr > 0 )
              {
              ril_response_data->home_nid[nid_ptr-1]='\0';
              }
          }

          if( qmi_response.min_based_info_valid )
          {
              strlcpy( ril_response_data->min_s, qmi_response.min_based_info.imsi_m_s2, NAS_IMSI_MIN2_LEN_V01 + 1);
              strlcpy( &ril_response_data->min_s[NAS_IMSI_MIN2_LEN_V01], qmi_response.min_based_info.imsi_m_s1, NAS_IMSI_MIN1_LEN_V01 + 1 );
          }

          QCRIL_LOG_INFO("qmi MDN %s", ril_response_data->mob_dir_number);
          QCRIL_LOG_INFO("qmi SID %s", ril_response_data->home_sid);
          QCRIL_LOG_INFO("qmi NID %s", ril_response_data->home_nid);
          QCRIL_LOG_INFO("qmi MIN %s", ril_response_data->min_s);
      }
      else
      {
          ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_MDN ] = NULL;
          ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_H_SID ] = NULL;
          ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_H_NID ] = NULL;
          ril_response_data->cdma_subscription[ NAS_CDMA_SUBSCRIPTION_INFO_MIN ] = NULL;
          QCRIL_LOG_INFO("fetch 3gpp2 sub info failed %d", sub_info_fetch_ril_req_res);
      }
  }
  else
  {
      QCRIL_LOG_ERROR("failed to allocate memory");
  }

  if( RIL_E_SUCCESS == prl_fetch_ril_req_res || RIL_E_SUCCESS == sub_info_fetch_ril_req_res )
  {
      ril_req_res = RIL_E_SUCCESS;
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = (void*)ril_response_data->cdma_subscription;
      resp.resp_len = sizeof( ril_response_data->cdma_subscription );
  }
  qcril_send_request_response( &resp );

  if ( ril_response_data )
  {
      qcril_free( ril_response_data );
  }

  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_request_cdma_subscription

//===========================================================================
//QCRIL_EVT_HOOK_SET_CDMA_SUB_SRC_WITH_SPC
//===========================================================================
void qcril_qmi_nas_set_subscription_source_with_spc
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_qmi_nas_set_subscription_source_generic(params_ptr, TRUE, ret_ptr);
}

//===========================================================================
//RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE
//===========================================================================
void qcril_qmi_nas_set_subscription_source
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  NAS_CACHE_LOCK();
  qcril_qmi_nas_set_subscription_source_generic(params_ptr, FALSE, ret_ptr);
  NAS_CACHE_UNLOCK();
}

static void qcril_qmi_nas_set_subscription_source_generic
(
  const qcril_request_params_type *const params_ptr,
  int spc_present,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_set_rtre_config_req_v01 qmi_request;
  nas_set_rtre_config_resp_v01 qmi_response;

  qmi_client_error_type qmi_client_error;

  int *in_data_ptr;
  char *data_ptr;
  boolean result = FALSE;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  dms_operating_mode_enum_v01 operating_mode;
  int                         operating_mode_valid;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_LOG_INFO("spc_present %d", spc_present);

  QCRIL_NOTUSED( ret_ptr );


  memset( &qmi_request, 0, sizeof( qmi_request ) );

  if ( params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
      NAS_CACHE_LOCK();
      operating_mode          = nas_dms_cached_info.operating_mode;
      operating_mode_valid    = nas_dms_cached_info.operating_mode_valid;
      NAS_CACHE_UNLOCK();

      if ( !(qmi_ril_is_multi_sim_feature_supported() ||
             qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA2 )) ||
           ( operating_mode_valid && DMS_OP_MODE_ONLINE_V01 == operating_mode ) )
      {

          if ( spc_present == TRUE )
          {
              // SPC is prsent. This is OEM_HOOK request with SPC information.
              data_ptr = (char *)params_ptr->data;
              QCRIL_LOG_INFO("subscription source value %d", (int) (data_ptr[0]));

              switch ( (oem_hook_cdma_subscription_source_e_type)(data_ptr[0]) )
              {
                  case SUBSCRIPTION_SOURCE_RUIM_SIM:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  case SUBSCRIPTION_SOURCE_NV:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  case SUBSCRIPTION_SOURCE_RUIM_IF_AVAIL:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_IF_AVAIL_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  default: // invalid or unsupported value
                      QCRIL_LOG_ERROR("Invalid source value %d", (int) (data_ptr[0]));
                      break;
              }

              if ( ril_req_res == RIL_E_SUCCESS )
              {
                  if ((params_ptr->datalen - 1) > NAS_SPC_MAX_V01 ||
                      (params_ptr->datalen - 1) < 1 )
                  {
                      QCRIL_LOG_ERROR("Invalid SPC len %d", params_ptr->datalen - 1);
                      ril_req_res = RIL_E_GENERIC_FAILURE;
                  }
                  else
                  {
                      qmi_request.spc_valid = TRUE;
                      memcpy(qmi_request.spc, &data_ptr[1], params_ptr->datalen - 1);
                  }
              }
          }
          else
          {
              // SPC is not prsent. This is normal RIL request with out SPC information.
              in_data_ptr = (int *)params_ptr->data;
              switch ( (RIL_CdmaSubscriptionSource)(*in_data_ptr) )
              {
                  case CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_RUIM_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  case CDMA_SUBSCRIPTION_SOURCE_NV:
                      qmi_request.rtre_cfg_pref = NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01;
                      ril_req_res = RIL_E_SUCCESS;
                      break;

                  default: // invalid or unsupported value
                      break;
              }
          }
      }
      else
      { // modem not ONLINE, failing request
          ril_req_res = RIL_E_GENERIC_FAILURE;
      }
  }
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                         QMI_NAS_SET_RTRE_CONFIG_REQ_MSG_V01,
                                                         (void*) &qmi_request,
                                                         sizeof( qmi_request ),
                                                         (void*) &qmi_response,
                                                         sizeof( qmi_response ),
                                                         QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
      QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);

      if ( (spc_present == TRUE) && (ril_req_res == RIL_E_SUCCESS) )
      {
          result = TRUE;
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( spc_present == TRUE )
  {
      // This is QCRIL_EVT_HOOK_SET_CDMA_SUB_SRC_WITH_SPC request. Need to send result.
      resp.resp_pkt = &result;
      resp.resp_len = sizeof(result);
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_set_subscription_source

//===========================================================================
//RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE
//===========================================================================
void qcril_qmi_nas_get_subscription_source
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  qmi_client_error_type qmi_client_error;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_get_rtre_config_resp_v01 qmi_response;
  RIL_CdmaSubscriptionSource res_val;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );

  memset(&qmi_response,0,sizeof(qmi_response));
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                     QMI_NAS_GET_RTRE_CONFIG_REQ_MSG_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );
  QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);

  if( RIL_E_SUCCESS == ril_req_res )
  {
      if ( qmi_response.rtre_cfg_valid )
      {
          switch ( qmi_response.rtre_cfg )
          {
              case NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01:
                  res_val = CDMA_SUBSCRIPTION_SOURCE_NV;
                  break;

              case NAS_RTRE_CFG_RUIM_ONLY_V01:
                  res_val = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
                  break;

              default: // unsupported value
                  ril_req_res = RIL_E_GENERIC_FAILURE;
                  res_val = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM; // as value will be logged
                  break;
          }
          QCRIL_LOG_INFO("rtre_cfg = %d", (int) res_val);
      }
      else
      {
          ril_req_res = RIL_E_GENERIC_FAILURE;
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = (void*)&res_val;
      resp.resp_len = sizeof( res_val );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_get_subscription_source

//===========================================================================
//RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY
//===========================================================================
void qcril_qmi_nas_cdma_validate_and_write_key
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  nas_update_akey_req_msg_v01 akey_req_msg;
  nas_update_akey_resp_msg_v01 akey_resp_msg;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED( ret_ptr );


  if(  params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
  memset(&akey_req_msg, 0, sizeof(akey_req_msg));
  memset(&akey_resp_msg, 0, sizeof(akey_resp_msg));

  strlcpy((char*) akey_req_msg.akey, (const char*) params_ptr->data, sizeof(akey_req_msg.akey));

  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                     QMI_NAS_UPDATE_AKEY_REQ_MSG_V01,
                                                     &akey_req_msg,
                                                     sizeof(akey_req_msg),
                                                     &akey_resp_msg,
                                                     sizeof( akey_resp_msg ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &akey_resp_msg.resp );

  QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_cdma_validate_and_write_key

//===========================================================================
//RIL_REQUEST_DEVICE_IDENTITY
//===========================================================================
void qcril_qmi_nas_dms_request_device_identity
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  dms_get_device_serial_numbers_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_nas_dms_device_identity_type ril_response_data;

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  memset( &ril_response_data, 0, sizeof( ril_response_data ) );
  memset( &qmi_response, 0, sizeof( qmi_response ) );

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_DEVICE_SERIAL_NUMBERS_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO("ril_req_res %d, qmi_client_error %d", (int) ril_req_res, qmi_client_error);

  // ** prepare response
  if ( RIL_E_SUCCESS == ril_req_res )
  {

      ril_response_data.device_identity[NAS_DMS_DEVICE_ID_IMEI] = ril_response_data.imei;
      ril_response_data.device_identity[ NAS_DMS_DEVICE_ID_IMEISV ] = ril_response_data.imeisv;
      ril_response_data.device_identity[NAS_DMS_DEVICE_ID_ESN] = ril_response_data.esn;
      ril_response_data.device_identity[NAS_DMS_DEVICE_ID_MEID] = ril_response_data.meid;

      QCRIL_SNPRINTF( ril_response_data.imei, NAS_DMS_IMEI_MAX_STR_SIZE, "%d", 0 );
      QCRIL_SNPRINTF( ril_response_data.imeisv, NAS_DMS_IMEISV_MAX_STR_SIZE, "%02d", 0 );
      QCRIL_SNPRINTF( ril_response_data.esn, NAS_DMS_ESN_MAX_STR_SIZE, "%08lx", (unsigned long)0 );
      QCRIL_SNPRINTF( ril_response_data.meid, NAS_DMS_MEID_MAX_STR_SIZE, "%014lx", (unsigned long)0 );

      if ( qmi_response.imei_valid )
      {
          memcpy(ril_response_data.imei,qmi_response.imei,NAS_DMS_IMEI_MAX_STR_SIZE-1);
      }
      if( qmi_response.imeisv_svn_valid && (strlen(qmi_response.imeisv_svn)<NAS_DMS_IMEISV_MAX_STR_SIZE))
      {
          memcpy(&ril_response_data.imeisv[NAS_DMS_IMEISV_MAX_STR_SIZE-1-strlen(qmi_response.imeisv_svn)],qmi_response.imeisv_svn
                 ,strlen(qmi_response.imeisv_svn));
      }
      if ( qmi_response.esn_valid && (strlen(qmi_response.esn)<NAS_DMS_ESN_MAX_STR_SIZE))
      {
          memcpy(&ril_response_data.esn[NAS_DMS_ESN_MAX_STR_SIZE-1-strlen(qmi_response.esn)],qmi_response.esn
                 ,strlen(qmi_response.esn));
      }
      if ( qmi_response.meid_valid && (strlen(qmi_response.meid)<NAS_DMS_MEID_MAX_STR_SIZE) )
      {
          memcpy(&ril_response_data.meid[NAS_DMS_MEID_MAX_STR_SIZE-1-strlen(qmi_response.meid)],qmi_response.meid
                 ,strlen(qmi_response.meid));
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = (void*)ril_response_data.device_identity;
      resp.resp_len = sizeof( ril_response_data.device_identity );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_device_identity

//===========================================================================
//RIL_REQUEST_BASEBAND_VERSION
//===========================================================================
void qcril_qmi_nas_dms_request_baseband_version
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  dms_get_sw_version_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  memset(&qmi_response,0,sizeof(qmi_response));
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_SW_VERSION_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO("qmi %d, %d", (int) ril_req_res, qmi_client_error);

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = (void*)qmi_response.sw_version;
      resp.resp_len = sizeof( qmi_response.sw_version );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_baseband_version

//===========================================================================
// qcril_qmi_nas_check_power_save_and_screen_off_status
//===========================================================================
int  qcril_qmi_nas_check_power_save_and_screen_off_status()
{
  int ret;

  QCRIL_LOG_FUNC_ENTRY();
  ret = ( TRUE == qcril_qmi_ril_domestic_service_is_screen_off() && TRUE == qcril_qmi_ril_domestic_service_is_power_save_enabled() );
  QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
  return ret;
} //qcril_qmi_nas_check_power_save_and_screen_off_status

//===========================================================================
// qcril_qmi_ril_domestic_service_is_screen_off
//===========================================================================
int qcril_qmi_ril_domestic_service_is_screen_off()
{
    int res;

    NAS_CACHE_LOCK();
    res = nas_common_info.is_screen_off;
    NAS_CACHE_UNLOCK();

    return res;
} // qcril_qmi_ril_domestic_service_is_screen_off

//===========================================================================
// qcril_qmi_ril_domestic_service_is_power_save_enabled
//===========================================================================
int qcril_qmi_ril_domestic_service_is_power_save_enabled()
{
    return nas_common_info.add_power_save_enabled;
} // qcril_qmi_ril_domestic_service_is_power_save_enabled

//===========================================================================
// QCRIL_EVT_CM_UPDATE_FDN_STATUS
//===========================================================================
void qcril_qmi_nas_dms_event_update_fdn_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr /*!< Output parameter */
)
{
  qcril_instance_id_e_type instance_id;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_NOTUSED(ret_ptr);
  QCRIL_NOTUSED(params_ptr);

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_event_update_fdn_status

//===========================================================================
// qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch
//===========================================================================
void qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch
(
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_card_status_e_type card_status
)
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_qmi_nas_dms_update_card_status(instance_id, slot, pwr_oprt_in_progress, card_status);
  qcril_qmi_nas_dms_initiate_prl_ver_fetch_attenpt_if_needed();

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dms_update_card_status_initiate_prl_fetch

//===========================================================================
// qcril_qmi_nas_dms_update_card_status
//===========================================================================
void qcril_qmi_nas_dms_update_card_status
(
  qcril_instance_id_e_type instance_id,
  uint8 slot,
  boolean pwr_oprt_in_progress,
  qcril_card_status_e_type card_status
)
{
    qcril_unsol_resp_params_type unsol_resp_params;
    int                          subs_status;
    int                          must_post_dsds_local_deactivate;

    QCRIL_LOG_FUNC_ENTRY();

    must_post_dsds_local_deactivate = FALSE;
    NAS_CACHE_LOCK();

    nas_common_info.card_info[ slot ].pwr_oprt_in_progress = pwr_oprt_in_progress;

    if ( ( card_status != QCRIL_CARD_STATUS_POWERUP_FAILED ) && ( card_status != QCRIL_CARD_STATUS_POWERDOWN_FAILED ) )
    {
        nas_common_info.card_info[ slot ].status = card_status;
        switch ( card_status )
        {
            case QCRIL_CARD_STATUS_DOWN:
            case QCRIL_CARD_STATUS_UP:
            case QCRIL_CARD_STATUS_REFRESH:
                nas_common_info.card_info[ slot ].card_ever_present = TRUE;
                break;

            case QCRIL_CARD_STATUS_ABSENT:
                QCRIL_LOG_INFO( " card absent DSDS check: dsds status valid %d, dsds act_status %d, dsds is active %d/%d",
                                 nas_common_info.dsds.valid,
                                 (int)nas_common_info.dsds.cur_info.act_status,
                                 nas_cached_info.dsds_is_active_valid,
                                 nas_cached_info.dsds_is_active );
                // Unsol sub deactivated status shall be sent when SUBS indication is received.
                break;

            default:
                break;
        }
    }

    QCRIL_LOG_INFO( " qmi_ril: RID %d Slot %d, Pwr oprt in progress %d, Card status %s[%d]",
                     instance_id, slot, nas_common_info.card_info[ slot ].pwr_oprt_in_progress,
                     card_status_name[ nas_common_info.card_info[ slot ].status ], nas_common_info.card_info[ slot ].status );
    NAS_CACHE_UNLOCK();

    if ( must_post_dsds_local_deactivate )
    {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp_params );
        subs_status = QMI_RIL_NAS_SUBSCRIPTION_DEACTIVATED;
        unsol_resp_params.resp_pkt = (void *)&subs_status;
        unsol_resp_params.resp_len = sizeof(subs_status);
        qcril_send_unsol_response( &unsol_resp_params );
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_dms_update_card_status

//===========================================================================
// qcril_qmi_nas_dms_card_status_reported
//===========================================================================
int qcril_qmi_nas_dms_card_status_reported()
{
    int res;
    NAS_CACHE_LOCK();
    res = (nas_common_info.card_info[ QCRIL_DEFAULT_INSTANCE_ID ].status != QCRIL_CARD_STATUS_UNKNOWN);
    NAS_CACHE_UNLOCK();
    return res;
} // qcril_qmi_nas_dms_card_status_reported


//===========================================================================
// qcril_qmi_nas_cleanup
//===========================================================================
void qcril_qmi_nas_cleanup()
{
    NAS_CACHE_LOCK();
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.service_provider_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.operator_plmn_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_network_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.serving_system);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.data_capabilities);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.current_plmn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_system_id);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_base_station_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.roaming_indicator_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nas_3gpp_time_zone);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rf_band_info_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.registration_reject_reason);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.signal_strength_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rssi);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.ecio);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.error_rate);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rsrq);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.def_roam_ind);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roaming_indicator);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.call_barring_status);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.mnc_includes_pcs_digit);

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info3);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info3);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_cell_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_support_on_lte);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_embms_coverage);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.embms_coverage_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sim_rej_info);


    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_dms_cached_info.operating_mode);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.hs_call_status);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_bit_err_rate);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_block_err_rate);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.rscp);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tdscdma_block_err_rate);

    if ( NULL != nas_cached_info.cell_location_info)
    {
        qcril_free(nas_cached_info.cell_location_info);
    }
    nas_cached_info.cell_location_info = NULL;
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.reported_data_reg_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.reported_data_technology);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.reported_pref_data_technology);
    nas_cached_info.is_calculated_vrte_used = 0;

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dsds_is_active);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.dsds_is_priority_subs);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_system_id);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_voice_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sms_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_disable_cause);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.rat_disabled_mask);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_csg_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_csg_info);

    nas_common_info.prev_srv_domain_valid = FALSE;
    nas_common_info.prev_srv_domain = SYS_SRV_DOMAIN_NO_SRV_V01;

    NAS_CACHE_UNLOCK();

    qmi_ril_nwr_set_eme_cbm(QMI_RIL_EME_CBM_NOT_ACTIVE);

    qcril_qmi_nas_data_control_deregister_for_call_activity();
    nas_cached_info.voice_roam_status_reported = FALSE;

    qcril_qmi_nas_reset_data_snapshot_cache_and_timer();
    qcril_qmi_arb_reset_pref_data_snapshot();

    if( TRUE == nas_common_info.custom_emergency_numbers_enabled )
    {
        qcril_qmi_nas_cleanup_custom_emergency_numbers();
    }

} // qcril_qmi_nas_cleanup
//===========================================================================
//QCRIL_EVT_HOOK_GET_MODEM_CAPABILITY
//===========================================================================
void qcril_qmi_nas_get_modem_capability
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_request_resp_params_type resp;
  qcril_modem_id_e_type modem_id = params_ptr->modem_id;
  RIL_Errno   ril_req_res = RIL_E_SUCCESS;
  uint8_t * modem_capability = NULL;
  int len = 0;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  if ( nas_dms_cached_info.current_sub_capability_valid != TRUE )
  {
      ril_req_res = qcril_qmi_nas_get_device_capability(FALSE, TRUE);
  }
  if ( ril_req_res == RIL_E_SUCCESS )
  {
      modem_capability = qcril_malloc(sizeof(uint32)+3);
      if ( modem_capability != NULL)
      {
        memset(modem_capability,0,sizeof(uint32)+3);
        if ( nas_dms_cached_info.current_sub_capability_valid == TRUE )
        {
          len = qcril_qmi_dms_construct_modem_cap_response(modem_capability);
          qcril_qmi_nas_update_embms_status();
          qcril_qmi_nas_embms_send_embms_status(qcril_qmi_nas_get_embms_status());
          QCRIL_LOG_DEBUG( "len %d", len);
        }
        else
        {
          ril_req_res = RIL_E_GENERIC_FAILURE;
        }
      }
      else
      {
        ril_req_res = RIL_E_GENERIC_FAILURE;
      }
  }
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( ril_req_res == RIL_E_SUCCESS )
  {
      resp.resp_pkt = (void *) modem_capability;
      resp.resp_len = len;
  }
  qcril_send_request_response( &resp );

  if (modem_capability)
  {
    qcril_free(modem_capability);
  }

  QCRIL_LOG_FUNC_RETURN();
}

int qcril_qmi_dms_construct_modem_cap_response
(
uint8_t * resp_byte_stream
)
{
  int len = 0;
  uint8_t * resp_ptr = NULL;
  resp_ptr = resp_byte_stream;
  uint32_t sub_capability;
  uint8_t sub_voice_data_capability = 0, max_active_data_subs = 1;
  uint8_t modem_stack_id = (uint8_t) qcril_qmi_nas_get_modem_stack_id();

  QCRIL_LOG_FUNC_ENTRY();

  if ( resp_byte_stream != NULL )
  {
    sub_capability = qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();
    QCRIL_LOG_DEBUG( "[MSIM] Sub capability %x", sub_capability);
    QCRIL_LOG_DEBUG( "[MSIM] Modem stack id %d", (int) modem_stack_id);

    // Modem stack id -  1 byte
    memcpy(resp_ptr, &modem_stack_id, sizeof(uint8_t));
    resp_ptr = resp_ptr + sizeof(uint8_t);
    len = sizeof(uint8_t);

    // Stack RAT capability - 4 bytes
    memcpy(resp_ptr, &sub_capability, sizeof(uint32));
    resp_ptr = resp_ptr + sizeof(uint32);
    len += sizeof(uint32);

    // Stack voice data capability -  1 byte
    if (nas_dms_cached_info.subs_voice_data_capability_valid)
    {
      sub_voice_data_capability = nas_dms_cached_info.subs_voice_data_capability;
      QCRIL_LOG_DEBUG( "[MSIM] sub_voice_data_capability %d", (int) sub_voice_data_capability);
    }
    memcpy(resp_ptr, &sub_voice_data_capability, sizeof(uint8_t));
    len += sizeof(uint8_t);
    resp_ptr += sizeof(uint8_t);

    // Max active data subs supported - 1 byte
    if (nas_dms_cached_info.max_active_data_subs_valid)
    {
      max_active_data_subs = nas_dms_cached_info.max_active_data_subs;
      QCRIL_LOG_DEBUG( "[MSIM] max_active_data_subs %d", (int) max_active_data_subs);
    }
    memcpy(resp_ptr, &max_active_data_subs, sizeof(uint8_t));
    len += sizeof(uint8_t);
    resp_ptr += sizeof(uint8_t);
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET(len);
  return len;
}

uint32_t qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech()
{
    uint32_t sub_capability = 0;

    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_dms_cached_info.current_sub_capability_valid == TRUE )
    {
        QCRIL_LOG_DEBUG( "[MSIM] Current sub capability %x", nas_dms_cached_info.current_sub_capability);
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_CDMA_V01 )
        {
            sub_capability = (1 << RADIO_TECH_1xRTT);
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_HDR_V01 )
        {
            sub_capability = sub_capability | (1 << RADIO_TECH_EVDO_A);
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_GSM_V01 )
        {
            sub_capability = sub_capability | (1 << RADIO_TECH_GSM);
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_WCDMA_V01 )
        {
            sub_capability = sub_capability | (1 << RADIO_TECH_UMTS);
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_LTE_V01 )
        {
            sub_capability = sub_capability | (1 << RADIO_TECH_LTE);
        }
        if ( nas_dms_cached_info.current_sub_capability & DMS_SUBS_CAPABILITY_TDS_V01 )
        {
            sub_capability = sub_capability | (1 << RADIO_TECH_TD_SCDMA);
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(sub_capability);
    return sub_capability;
}

void qcril_qmi_nas_send_unsol_modem_capability()
{
  int len = 0;
  uint8_t * modem_capability = NULL;
  modem_capability = qcril_malloc(sizeof(uint32)+3);
  if ( modem_capability != NULL)
  {
    memset(modem_capability,0,sizeof(uint32)+3);
    len = qcril_qmi_dms_construct_modem_cap_response(modem_capability);
    qcril_qmi_nas_update_embms_status();
    qcril_qmi_nas_embms_send_embms_status(qcril_qmi_nas_get_embms_status());
    QCRIL_LOG_DEBUG("[MSIM] len %d", len);
    if ( len > 0 )
    {
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_MODEM_CAPABILITY, (void*)modem_capability, len);
    }
  }
  if ( modem_capability )
  {
    qcril_free(modem_capability);
  }
}

void qcril_qmi_nas_update_sub_binding
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  qcril_request_resp_params_type resp;
  uint8_t * bind_info;
  uint8_t stack_id = 0, bind_enable = 1;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  uint8_t curr_stack_id = (uint8_t) qcril_qmi_nas_get_modem_stack_id();

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  if (!qmi_ril_is_multi_sim_feature_supported())
  {
    ril_req_res = RIL_E_SUCCESS;
  }
  else if(  params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
    bind_info = (uint8_t *) params_ptr->data;
    qcril_modem_stack_id_e_type stack_id = (qcril_modem_stack_id_e_type) bind_info[0];
    bind_enable = bind_info[1];
    QCRIL_LOG_DEBUG("[MSIM] Stack id %d bind enable %d", stack_id, bind_enable);
    if ( bind_enable == TRUE )
    {
      if ( stack_id != qcril_qmi_nas_get_modem_stack_id() )
      {
        ril_req_res = qcril_qmi_client_dsds_bind_to_subscription(stack_id);
        // Get and send modem capability as we are using static rat capability
        qcril_qmi_nas_get_device_capability(FALSE, TRUE);
        qcril_qmi_nas_send_unsol_modem_capability();
      }
      else
      {
        QCRIL_LOG_DEBUG("[MSIM] Already bound to stack %d", stack_id);
        ril_req_res = RIL_E_SUCCESS;
      }
      if ( ril_req_res == RIL_E_SUCCESS )
      {
        qmi_ril_set_operational_status( QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING);
        qcril_qmi_client_dsds_cri_client_reinit(stack_id);
        qcril_data_process_stack_switch(curr_stack_id, stack_id, qmi_ril_get_process_instance_id());
        qcril_qmi_nas_get_subscription_info();
#ifndef QMI_RIL_UTF
        qcril_am_set_vsid(QCRIL_AM_VS_VOICE, nas_cached_info.voice_system_id);
#endif
      }
    }
    else
    {
      qcril_qmi_client_dsds_cri_client_reset();
      qmi_ril_set_operational_status( QMI_RIL_GEN_OPERATIONAL_STATUS_UNBIND);
      ril_req_res = RIL_E_SUCCESS;
    }

    if ( bind_enable == FALSE )
    {
      // invalidate cache
      NAS_CACHE_LOCK();
      qcril_qmi_nas_drop_nw_info_cache();
      qcril_qmi_drop_sig_info_cache();
      NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.prev_mode_pref );
      NAS_CACHE_INVALIDATE_TINY_ENTRY( nas_cached_info.mode_pref );
      NAS_CACHE_UNLOCK();
      // Clear pending requests in case of UNBIND
      QCRIL_LOG_DEBUG("[MSIM] Cleanup pending requests as we are unbinding!");
      qmi_ril_fw_android_request_flow_control_drop_legacy_book_records( FALSE, TRUE );
      qmi_ril_fw_android_request_flow_control_abandon_all_requests_main_thrd( RIL_E_CANCELLED, TRUE );
    }
  }

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  qcril_send_request_response( &resp );
}

//===========================================================================
//RIL_REQUEST_SET_UICC_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_set_uicc_subscription
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;
  qcril_evt_e_type pending_event_id;
  qcril_req_state_e_type pending_state;
  qcril_reqlist_u_type u_info;
  RIL_SelectUiccSub * select_uicc_sub_ptr;
  qcril_reqlist_public_type reqlist_entry;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_nas_type *req_info_ptr;
  qmi_client_error_type qmi_client_error;
  qcril_uicc_subs_info_type subs_info;
  IxErrnoType err_no;

  qcril_subs_mode_pref mode_pref;

  nas_get_mode_pref_resp_msg_v01  qmi_mode_pref_resp;


  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_NOTUSED( ret_ptr );

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;
  memset(&qmi_mode_pref_resp, 0, sizeof(qmi_mode_pref_resp));

  if ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA2 ) )
  {
    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );
  }
  else
  {
    if(  params_ptr->datalen > 0 && params_ptr->data != NULL )
    {
        select_uicc_sub_ptr = (RIL_SelectUiccSub *) params_ptr->data;
        // Update sub id as stack id to handle cross mapping scenario.
        // UIM requires stack-id to activate the subscription as pri or sec.
        // In case of straight mapping stack id = sub id.
        select_uicc_sub_ptr->sub_type = qcril_qmi_nas_get_modem_stack_id();

        QCRIL_LOG_INFO( "entry %d", select_uicc_sub_ptr->act_status );

        if ( select_uicc_sub_ptr->act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE )
        {
          QCRIL_LOG_DEBUG( "RID %d Activate sub: slot %d app_index %d", instance_id, select_uicc_sub_ptr->slot,
                           select_uicc_sub_ptr->app_index );
          pending_event_id = QCRIL_EVT_CM_ACTIVATE_PROVISION_STATUS;
          pending_state = QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS;
        }
        else
        {
          QCRIL_LOG_DEBUG( "RID %d Deactivate sub: slot %d app_index %d", instance_id, select_uicc_sub_ptr->slot,
                           select_uicc_sub_ptr->app_index );
          pending_event_id = QCRIL_EVT_CM_DEACTIVATE_PROVISION_STATUS;
          pending_state = QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS;
        }

        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_GET_MODE_PREF_REQ_MSG_V01,
                                                           NULL,
                                                           NAS_NIL,  // empty request payload
                                                           (void*) &qmi_mode_pref_resp,
                                                           sizeof( qmi_mode_pref_resp ),
                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_mode_pref_resp.resp );

        QCRIL_LOG_INFO( ".. mode pref r %d, 0mpv %d, 0mp %d, 1mpv %d, 1mp %d, 2mpv %d, 2mp %d",
                        (int) ril_req_res,
                        (int) qmi_mode_pref_resp.idx0_mode_pref_valid,
                        (int) qmi_mode_pref_resp.idx0_mode_pref,
                        (int) qmi_mode_pref_resp.idx1_mode_pref_valid,
                        (int) qmi_mode_pref_resp.idx1_mode_pref,
                        (int) qmi_mode_pref_resp.idx2_mode_pref_valid,
                        (int) qmi_mode_pref_resp.idx2_mode_pref
                         );

        if ( RIL_E_SUCCESS == ril_req_res )
        {
            if ( RIL_SUBSCRIPTION_1 == select_uicc_sub_ptr->sub_type )
            {
                mode_pref = qcril_qmi_nas_conv_nas_mode_pref_to_qcril(qmi_mode_pref_resp.idx0_mode_pref_valid, qmi_mode_pref_resp.idx0_mode_pref, select_uicc_sub_ptr  );
            }
            else if ( RIL_SUBSCRIPTION_2 == select_uicc_sub_ptr->sub_type )
            {
                mode_pref = qcril_qmi_nas_conv_nas_mode_pref_to_qcril(qmi_mode_pref_resp.idx1_mode_pref_valid, qmi_mode_pref_resp.idx1_mode_pref, select_uicc_sub_ptr  );
            }
            else
            {
                 mode_pref = qcril_qmi_nas_conv_nas_mode_pref_to_qcril(qmi_mode_pref_resp.idx2_mode_pref_valid,
                             qmi_mode_pref_resp.idx2_mode_pref, select_uicc_sub_ptr  );
            }
            QCRIL_LOG_INFO( ".. mode pref-cnv param %d, cnved %d", (int) select_uicc_sub_ptr->sub_type, (int) mode_pref);

            req_info_ptr = &u_info.nas;
            memcpy( &req_info_ptr->select_uicc_sub, select_uicc_sub_ptr, sizeof( RIL_SelectUiccSub ) );

            qcril_reqlist_default_entry( params_ptr->t,
                                         params_ptr->event_id,
                                         modem_id,
                                         pending_state,
                                         pending_event_id,
                                         &u_info,
                                         &reqlist_entry );

            if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
            {
                QCRIL_LOG_INFO( ".. reqlist outstanding new ok, instance id %d", (int) instance_id);

                memset( &subs_info, 0, sizeof(subs_info) );
                memcpy( &subs_info.uicc_subs_info, select_uicc_sub_ptr, sizeof( RIL_SelectUiccSub ) );
                subs_info.subs_mode_pref = mode_pref;


                if ( select_uicc_sub_ptr->act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE )
                {
                  QCRIL_LOG_DEBUG( "Request QCRIL(UIM) to activate slot %d aid %d", select_uicc_sub_ptr->slot, select_uicc_sub_ptr->app_index );
                  err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_ACTIVATE_SUBS,
                                                (void *) &subs_info, sizeof( qcril_uicc_subs_info_type ),
                                                (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
                  QCRIL_LOG_INFO( ".. QCRIL_EVT_INTERNAL_MMGSDI_ACTIVATE_SUBS res %d", (int) err_no );
                }
                else
                {
                  QCRIL_LOG_DEBUG( "Request QCRIL(UIM) to deactivate slot %d aid %d", select_uicc_sub_ptr->slot,
                                   select_uicc_sub_ptr->app_index );
                  err_no = qcril_process_event( instance_id, modem_id, QCRIL_EVT_INTERNAL_MMGSDI_DEACTIVATE_SUBS,
                                                (void *) &subs_info, sizeof( qcril_uicc_subs_info_type ),
                                                (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
                  QCRIL_LOG_INFO( ".. QCRIL_EVT_INTERNAL_MMGSDI_DEACTIVATE_SUBS res %d", (int) err_no );
                }
            }
            else
            {
                QCRIL_LOG_INFO( ".. reqlist oustanding new fail");
                ril_req_res = RIL_E_GENERIC_FAILURE;
            }
        }
    }

    // ** respond only if we got a failure
    if ( RIL_E_SUCCESS != ril_req_res )
    {
        qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
        qcril_send_request_response( &resp );
    }
  }
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_set_uicc_subscription

//===========================================================================
//qcril_qmi_nas_conv_nas_mode_pref_to_qcril
//===========================================================================
qcril_subs_mode_pref qcril_qmi_nas_conv_nas_mode_pref_to_qcril(uint8_t info_valid,
                                                               uint16_t qmi_nas_mode_pref,
                                                               RIL_SelectUiccSub* master_request_ref )
{
    RIL_CardStatus_v6    ril_card_status;
    qcril_subs_mode_pref res;
    RIL_AppType          card_app_type;

    if ( info_valid )
    {
        switch ( qmi_nas_mode_pref )
        {
            case QMI_NAS_RAT_MODE_PREF_CDMA:
            case QMI_NAS_RAT_MODE_PREF_HRPD:
            case QMI_NAS_RAT_MODE_PREF_CDMA_HRPD:
                res = QCRIL_SUBS_MODE_1X;
                break;

            case QMI_NAS_RAT_MODE_PREF_GSM:
            case QMI_NAS_RAT_MODE_PREF_UMTS:
            case QMI_NAS_RAT_MODE_PREF_TDSCDMA:
            case QMI_NAS_RAT_MODE_PREF_GSM_UMTS:
            case QMI_NAS_RAT_MODE_PREF_GSM_UMTS_TDSCDMA:
            default:
                res = QCRIL_SUBS_MODE_GW;
                break;
        }
    }
    else
    {
        QCRIL_LOG_INFO( "invalid mode pref");
        res = QCRIL_SUBS_MODE_GW;
    }

    if ( RIL_E_SUCCESS == qcril_uim_direct_get_card_status( qmi_ril_get_process_instance_id(), &ril_card_status ) &&
         (RIL_CARD_MAX_APPS > master_request_ref->app_index) &&
         (master_request_ref->app_index >= 0) )
    {
        card_app_type = ril_card_status.applications[ master_request_ref->app_index ].app_type;
        QCRIL_LOG_INFO( ".. card app type %d", (int)card_app_type );
        switch ( card_app_type )
        {
            case RIL_APPTYPE_SIM:
            case RIL_APPTYPE_USIM:
                if ( QCRIL_SUBS_MODE_1X == res )
                {
                    res = QCRIL_SUBS_MODE_GW;
                    QCRIL_LOG_INFO( "changed sub mode pref to GW as card app is 3ggp");
                }
                break;

            case RIL_APPTYPE_RUIM:
            case RIL_APPTYPE_CSIM:
                if ( QCRIL_SUBS_MODE_GW == res )
                {
                    res = QCRIL_SUBS_MODE_1X;
                    QCRIL_LOG_INFO( "changed sub mode pref to 1x as card app is 3ggp");
                }
                break;

            default:
                // no change
                break;
        }
    }

    return res;
} // qcril_qmi_nas_conv_nas_mode_pref_to_qcril
//===========================================================================
//QCRIL_EVT_CM_ACTIVATE_PROVISION_STATUS
//===========================================================================
void qcril_qmi_nas_event_activate_provision_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_provision_info_type *provision_info_ptr;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  provision_info_ptr = ( qcril_provision_info_type *) params_ptr->data;

  if( provision_info_ptr != NULL )
  {
    qcril_event_queue( instance_id,
                        modem_id,
                        QCRIL_DATA_ON_STACK,
                        QCRIL_EVT_QMI_NAS_DSDS_SUBS_FOLLOWUP,
                        params_ptr->data,
                        params_ptr->datalen,
                        (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
  }
  else
  {
      QCRIL_LOG_FATAL("CHECK FAILED");
  }

  QCRIL_LOG_FUNC_RETURN();

}  // qcril_qmi_nas_event_activate_provision_status
//===========================================================================
//QCRIL_EVT_QMI_NAS_DSDS_SUBS_FOLLOWUP
//===========================================================================
void qcril_qmi_nas_event_subs_followup
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_provision_info_type *provision_info_ptr;
  qcril_reqlist_public_type req_info;
  qcril_request_resp_params_type resp;
  RIL_Errno bind_res = RIL_E_SUCCESS;
  IxErrnoType err_no;

  qcril_nas_dsds_activate_repost_params activate_report_params;
  qmi_ril_gen_operational_status_type op_status;
  qcril_unsol_resp_params_type unsol_resp_params;
  int                          subs_status;
  RIL_SubscriptionType sub_num;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  provision_info_ptr = ( qcril_provision_info_type *) params_ptr->data;

  if( provision_info_ptr != NULL )
  {
  if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_ACTIVATE_PROVISION_STATUS, &req_info ) == E_SUCCESS )
  { // event pending
    if ( ( req_info.request == RIL_REQUEST_SET_UICC_SUBSCRIPTION ) &&
         ( req_info.sub.nas.select_uicc_sub.act_status == RIL_UICC_SUBSCRIPTION_ACTIVATE ) )
    {
      // provision failure
      if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_FAILURE )
      {

        NAS_CACHE_LOCK();
        QCRIL_LOG_DEBUG( "RID %d, UIM activate subscription failure, slot %d, app_index %d, error_code =%d, prev dsds info valid %d, prev act_status %d",
                         instance_id,
                         req_info.sub.nas.select_uicc_sub.slot,
                         req_info.sub.nas.select_uicc_sub.app_index,
                         provision_info_ptr->err_code,
                         (int)nas_common_info.dsds.valid,
                         (int)nas_common_info.dsds.cur_info.act_status );

        NAS_CACHE_UNLOCK();

        if ( provision_info_ptr->err_code == RIL_E_SUBSCRIPTION_NOT_SUPPORTED )
        {
          QCRIL_LOG_ERROR( "Incompatible mode preference selected via QMI_NAS_GET_MODE_PREF_REQ " );
        }

        qcril_default_request_resp_params( instance_id,
                                           req_info.t,
                                           req_info.request,
                                           provision_info_ptr->err_code,
                                           &resp );

        qcril_send_request_response( &resp );
      }
      else if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_IN_PROGRESS )
      {
        QCRIL_LOG_DEBUG( "RID %d, UIM activate subscription in progress, slot %d, app_index %d, session_type %d",
                         instance_id,
                         req_info.sub.nas.select_uicc_sub.slot,
                         req_info.sub.nas.select_uicc_sub.app_index,
                         provision_info_ptr->session_type );
        // update session type
        err_no = qcril_reqlist_update_sub_id( instance_id,
                                              req_info.t,
                                              provision_info_ptr->session_type );
        QCRIL_LOG_INFO( ".. qcril_reqlist_update_sub_id res %d", (int) err_no );
      }
      else
      { // provision success
        NAS_CACHE_LOCK();
        QCRIL_LOG_DEBUG( "[MSIM] RID %d, UIM activate subscription success, slot %d, app_index %d, session_type %d, prev dsds info valid %d, prev act_status %d",
                         instance_id,
                         req_info.sub.nas.select_uicc_sub.slot,
                         req_info.sub.nas.select_uicc_sub.app_index,
                         provision_info_ptr->session_type,
                         (int)nas_common_info.dsds.valid,
                         (int)nas_common_info.dsds.cur_info.act_status  );
        NAS_CACHE_UNLOCK();


        memset(&activate_report_params, 0, sizeof( activate_report_params ));
        activate_report_params.repost_event_id = params_ptr->event_id;
        activate_report_params.provision_info  = *provision_info_ptr;

        switch ( activate_report_params.provision_info.session_type )
        {
          case QMI_UIM_SESSION_TYPE_TER_GW_PROV:
          case QMI_UIM_SESSION_TYPE_TER_1X_PROV:
          case QMI_UIM_SESSION_TYPE_NON_PROV_SLOT_3:
          case QMI_UIM_SESSION_TYPE_CARD_SLOT_3:
              sub_num = RIL_SUBSCRIPTION_3;
              break;

          case QMI_UIM_SESSION_TYPE_SEC_GW_PROV:
          case QMI_UIM_SESSION_TYPE_SEC_1X_PROV:
          case QMI_UIM_SESSION_TYPE_NON_PROV_SLOT_2:
          case QMI_UIM_SESSION_TYPE_CARD_SLOT_2:
              sub_num = RIL_SUBSCRIPTION_2;
              break;

          case QMI_UIM_SESSION_TYPE_PRI_GW_PROV:
          case QMI_UIM_SESSION_TYPE_PRI_1X_PROV:
          case QMI_UIM_SESSION_TYPE_NON_PROV_SLOT_1:
          case QMI_UIM_SESSION_TYPE_CARD_SLOT_1:
          default:
              sub_num = RIL_SUBSCRIPTION_1;
              break;
        }
        // enable RIL
        op_status = qmi_ril_get_operational_status();
        QCRIL_LOG_INFO( ".. op status %d", (int) op_status );
        if ( (QMI_RIL_GEN_OPERATIONAL_STATUS_INIT_ONGOING == op_status || QMI_RIL_GEN_OPERATIONAL_STATUS_RESUMING == op_status )
           && (qmi_ril_is_multi_sim_feature_supported()  ||
              qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA2 ) ))
        { // *** important *** - second phase QMI RIL init
          QCRIL_LOG_INFO( "!QMI RIL! 2nd phase init for MULTI SIM" );
          qmi_ril_set_operational_status( QMI_RIL_GEN_OPERATIONAL_STATUS_UNRESTRICTED );
          qcril_qmi_sms_report_unsol_ims_state_change();
        }

        NAS_CACHE_LOCK();
        nas_common_info.dsds.cur_info.app_index         = req_info.sub.nas.select_uicc_sub.app_index;
        nas_common_info.dsds.cur_info.slot              = req_info.sub.nas.select_uicc_sub.slot;
        nas_common_info.dsds.cur_info.sub_type           = sub_num;
        nas_common_info.dsds.cur_info.act_status        = RIL_UICC_SUBSCRIPTION_ACTIVATE;
        nas_common_info.dsds.valid                      = TRUE;
        NAS_CACHE_UNLOCK();

        qcril_qmi_fetch_system_selection_preference();
        // Check and update voice rte if required.
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                       QCRIL_DEFAULT_MODEM_ID, QCRIL_DATA_ON_STACK,
                       QCRIL_EVT_QMI_RIL_POST_VOICE_RTE_CHANGE_IND,
                       NULL, NAS_NIL, (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

        // respond
        QCRIL_LOG_INFO( ".. responding to RIL_REQUEST_SET_UICC_SUBSCRIPTION  with %d", (int) bind_res );
        qcril_default_request_resp_params( instance_id,
                                         req_info.t,
                                         req_info.request,
                                         bind_res,
                                         &resp );
        qcril_send_request_response( &resp );

        qcril_qmi_nas_get_subscription_info();
        if ( nas_cached_info.dsds_is_active_valid && nas_cached_info.dsds_is_active )
        {
          // Subscription is already active. Send UNSOL_SUBSCRIPTION_STATUS_CHANGED.
          qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp_params );
          subs_status = QMI_RIL_NAS_SUBSCRIPTION_ACTIVATED;
          QCRIL_LOG_INFO( "[MSIM] Send unsol sub status %d", (int)subs_status );
          unsol_resp_params.resp_pkt = (void *)&subs_status;
          unsol_resp_params.resp_len = sizeof(subs_status);
          qcril_send_unsol_response( &unsol_resp_params );

          // SMS 2nd phase init for DSDS
          if ( QMI_RIL_SMS_SVC_INIT_PENDING == qmi_ril_get_sms_svc_status() )
          {
             QCRIL_LOG_INFO( "!QMI RIL! 2nd phase SMS init for DSDS" );

             qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_DATA_ON_STACK,
                         QCRIL_EVT_SMS_PERFORM_INITIAL_CONFIGURATION,
                         NULL,
                         NAS_NIL,
                         (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
                    qmi_ril_set_sms_svc_status( QMI_RIL_SMS_SVC_FULLY_OPERATIONAL );
          }
        }
      }
    }
  }
  }
  else
  {
      QCRIL_LOG_FATAL("CHECK FAILED");
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_event_subs_followup
//===========================================================================
//QCRIL_EVT_CM_DEACTIVATE_PROVISION_STATUS
//===========================================================================
void qcril_qmi_nas_event_deactivate_provision_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_provision_info_type *provision_info_ptr;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    modem_id = params_ptr->modem_id;

    provision_info_ptr = ( qcril_provision_info_type *) params_ptr->data;

    if( provision_info_ptr != NULL )
    {
        qcril_event_queue( instance_id,
                           modem_id,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_NAS_DSDS_SUBS_DEACTIVATE_FOLLOWUP,
                           params_ptr->data,
                           params_ptr->datalen,
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_event_deactivate_provision_status
//===========================================================================
//QCRIL_EVT_QMI_NAS_DSDS_SUBS_DEACTIVATE_FOLLOWUP
//===========================================================================
void qcril_qmi_nas_event_subs_deactivate_followup
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_provision_info_type *provision_info_ptr;
    qcril_reqlist_public_type req_info;
    qcril_request_resp_params_type resp;
    IxErrnoType err_no;
    qcril_unsol_resp_params_type unsol_resp_params;
    int                          subs_status;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    modem_id = params_ptr->modem_id;

    provision_info_ptr = ( qcril_provision_info_type *) params_ptr->data;

    if( provision_info_ptr != NULL )
    {
    if ( qcril_reqlist_query_by_event( instance_id, modem_id, QCRIL_EVT_CM_DEACTIVATE_PROVISION_STATUS, &req_info ) == E_SUCCESS )
    {  // event pending
        if ( ( req_info.request == RIL_REQUEST_SET_UICC_SUBSCRIPTION ) &&
             ( req_info.sub.nas.select_uicc_sub.act_status == RIL_UICC_SUBSCRIPTION_DEACTIVATE ) )
        {
          if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_FAILURE )
          {  // provision failure

            NAS_CACHE_LOCK();
            QCRIL_LOG_DEBUG( "RID %d, UIM deactivate subscription failure, slot %d, app_index %d, prev dsds info valid %d, prev act_status %d",
                             instance_id,
                             req_info.sub.nas.select_uicc_sub.slot,
                             req_info.sub.nas.select_uicc_sub.app_index,
                             (int)nas_common_info.dsds.valid,
                             (int)nas_common_info.dsds.cur_info.act_status );
            NAS_CACHE_UNLOCK();

            qcril_default_request_resp_params( instance_id,
                                               req_info.t,
                                               req_info.request,
                                               RIL_E_GENERIC_FAILURE,
                                               &resp );
            qcril_send_request_response( &resp );
          }
          else if ( provision_info_ptr->status == QCRIL_PROVISION_STATUS_SUCCESS )
          {  // provision success
            NAS_CACHE_LOCK();
            QCRIL_LOG_DEBUG( "[MSIM] RID %d, UIM deactivate subscription success, slot %d, app_index %d, session_type %d, prev dsds info valid %d, prev act_status %d",
                             instance_id,
                             req_info.sub.nas.select_uicc_sub.slot,
                             req_info.sub.nas.select_uicc_sub.app_index,
                             provision_info_ptr->session_type,
                             (int)nas_common_info.dsds.valid,
                             (int)nas_common_info.dsds.cur_info.act_status  );

            nas_common_info.dsds.cur_info.app_index         = req_info.sub.nas.select_uicc_sub.app_index;
            nas_common_info.dsds.cur_info.slot              = req_info.sub.nas.select_uicc_sub.slot;
            nas_common_info.dsds.cur_info.sub_type           = RIL_SUBSCRIPTION_1;
            nas_common_info.dsds.cur_info.act_status        = RIL_UICC_SUBSCRIPTION_DEACTIVATE;
            nas_common_info.dsds.valid                      = TRUE;
            NAS_CACHE_UNLOCK();

            qcril_default_request_resp_params( instance_id, req_info.t, req_info.request, RIL_E_SUCCESS, &resp );
            qcril_send_request_response( &resp );

            qcril_qmi_nas_get_subscription_info();
            if ( nas_cached_info.dsds_is_active_valid && !nas_cached_info.dsds_is_active )
            {
                // Send UNSOL_SUBSCRIPTION_STATUS_CHANGED.
                qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp_params );
                subs_status = QMI_RIL_NAS_SUBSCRIPTION_DEACTIVATED;
                QCRIL_LOG_INFO( "[MSIM] Send unsol sub status %d", (int)subs_status );
                unsol_resp_params.resp_pkt = (void *)&subs_status;
                unsol_resp_params.resp_len = sizeof(subs_status);
                qcril_send_unsol_response( &unsol_resp_params );
            }
          }
        }
    }
    else
    {
        QCRIL_LOG_DEBUG( "Late Deactivate provision status event" );
    }
    }
    else
    {
        QCRIL_LOG_FATAL("CHECK FAILED");
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_event_deactivate_provision_status

//===========================================================================
//qcril_qmi_nas_dsds_dual_standby_pref_ind_handler
//===========================================================================
void qcril_qmi_nas_dsds_dual_standby_pref_ind_handler( nas_dual_standby_pref_ind_msg_v01* ind_msg )
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_standby_pref, ind_msg->standby_pref  );
    QCRIL_LOG_INFO( ".. valid %d", ind_msg->standby_pref_valid );
    if ( ind_msg->standby_pref_valid )
    {
        QCRIL_LOG_INFO( ".. standby pref %d", ind_msg->standby_pref.standby_pref );
        QCRIL_LOG_INFO( ".. priority subs %d", ind_msg->standby_pref.priority_subs );
        QCRIL_LOG_INFO( ".. active subs %d", ind_msg->standby_pref.active_subs );
        QCRIL_LOG_INFO( ".. default data subs %d", ind_msg->standby_pref.default_data_subs );

        // TODO_TSTS: Check if need to add TSTS related tune away emums after NAS
        // team adds them to IDL.
        if( ( ind_msg->standby_pref.standby_pref == NAS_DUAL_STANDBY_WITH_TUNE_AWAY_V01 ) ||
            ( ind_msg->standby_pref.standby_pref == NAS_AUTOMATIC_WITH_TUNE_AWAY_V01 ) )
        {
           nas_common_info.dsds.is_tune_away = TRUE;
           QCRIL_LOG_INFO( ".. tuneaway = %d", ind_msg->standby_pref.standby_pref );
        }
        nas_common_info.dsds.paging_priority = ind_msg->standby_pref.priority_subs;
        nas_common_info.dsds.standby_pref = ind_msg->standby_pref.standby_pref;
        nas_common_info.dsds.default_data_sub = ind_msg->standby_pref.default_data_subs;
    }
    if ( ind_msg->default_voice_subs_valid)
    {
        QCRIL_LOG_INFO( ".. default voice subs %d", ind_msg->default_voice_subs );
        nas_common_info.dsds.default_voice_sub = ind_msg->default_voice_subs;
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dsds_dual_standby_pref_ind_handler

//===========================================================================
//qcril_qmi_nas_subscription_info_ind_handler
//===========================================================================
void qcril_qmi_nas_subscription_info_ind_handler( nas_subscription_info_ind_msg_v01* ind_msg )
{
    uint32 vsid = 0;

    QCRIL_LOG_FUNC_ENTRY();

    if ( ind_msg->voice_system_id_valid )
    {
        vsid = ind_msg->voice_system_id;
        QCRIL_LOG_DEBUG ("Voice System ID %x\n", vsid);
        // make sure low layer will not send vsid as 0 before update
        if ( vsid )
        {
            NAS_CACHE_LOCK();
            NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.voice_system_id, ind_msg->voice_system_id );
            NAS_CACHE_UNLOCK();
            // Send QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID response
            qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_VOICE_SYSTEM_ID, &vsid, sizeof(vsid));
#ifndef QMI_RIL_UTF
            qcril_am_set_vsid(QCRIL_AM_VS_VOICE, vsid);
#endif
        }
    }

    if ( ind_msg->lte_voice_system_id_valid )
    {
        vsid = ind_msg->lte_voice_system_id;
        QCRIL_LOG_DEBUG ("LTE Voice System ID %x\n", vsid);
#ifndef QMI_RIL_UTF
        if ( vsid )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS, vsid);
        }
#endif
    }

    if ( ind_msg->wlan_voice_system_id_valid )
    {
        vsid = ind_msg->wlan_voice_system_id;
        QCRIL_LOG_DEBUG ("WLAN Voice System ID %x\n", vsid);
#ifndef QMI_RIL_UTF
        if ( vsid )
        {
            qcril_am_set_vsid(QCRIL_AM_VS_IMS_WLAN, vsid);
        }
#endif
    }

    if ( qmi_ril_is_multi_sim_feature_supported() )
    {
        qcril_qmi_nas_dsds_subscription_info_ind_handle_helper(ind_msg);
    }
}

//===========================================================================
//qcril_qmi_nas_dsds_subscription_info_ind_handle_helper
//===========================================================================
void qcril_qmi_nas_dsds_subscription_info_ind_handle_helper( nas_subscription_info_ind_msg_v01* ind_msg )
{
    qcril_unsol_resp_params_type unsol_resp_params;
    int                          subs_status;
    int                          was_active_valid;
    int                          was_active;
    int                          operating_mode_valid;
    dms_operating_mode_enum_v01  operating_mode;
    int                          dsds_status_valid;
    int                          dsds_act_status;
    qcril_card_status_e_type     card_status;
    int                          card_ever_present;
    uint32_t                     slot = 0;
    int                          send_unsol_sub_status = TRUE;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();

    was_active_valid       = (int)nas_cached_info.dsds_is_active_valid;
    was_active             = (int)nas_cached_info.dsds_is_active;
    operating_mode         = (int)nas_dms_cached_info.operating_mode;
    operating_mode_valid   = (int)nas_dms_cached_info.operating_mode_valid;
    dsds_act_status        = (int)nas_common_info.dsds.cur_info.act_status;
    dsds_status_valid      = (int)nas_common_info.dsds.valid;

    slot               = qmi_ril_get_sim_slot();
    card_status        = nas_common_info.card_info[slot].status;
    card_ever_present  = nas_common_info.card_info[slot].card_ever_present;

    if (ind_msg->is_priority_subs_valid)
    {
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_priority_subs, ind_msg->is_priority_subs  );
    }

    if (ind_msg->is_active_valid)
    {
      NAS_CACHE_STORE_TINY_ENTRY( nas_cached_info.dsds_is_active, ind_msg->is_active  );

      if ( !ind_msg->is_active )
      {
        nas_common_info.dsds.cur_info.act_status = RIL_UICC_SUBSCRIPTION_DEACTIVATE;
        subs_status = QMI_RIL_NAS_SUBSCRIPTION_DEACTIVATED;
      }
      // Send unsol sub status only after first SET_UICC activate request.
      else if ( ind_msg->is_active && dsds_status_valid )
      {
        subs_status = QMI_RIL_NAS_SUBSCRIPTION_ACTIVATED;
      }
      // Do not send unsol sub status for first activated ind without SET_UICC request.
      else
      {
        send_unsol_sub_status = FALSE;
      }
      if ( send_unsol_sub_status == TRUE )
      {
        qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, &unsol_resp_params );
        QCRIL_LOG_INFO( "[MSIM] Send unsol sub status %d", (int)subs_status );
        unsol_resp_params.resp_pkt = (void *)&subs_status;
        unsol_resp_params.resp_len = sizeof(subs_status);
        qcril_send_unsol_response( &unsol_resp_params );
      }
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_INFO( ".. priority subs %d / %d", (int)ind_msg->is_priority_subs_valid, (int)ind_msg->is_priority_subs );
    QCRIL_LOG_INFO( "[MSIM] .. is active subs %d / %d, was active %d / %d, oprt %d / %d, dsds valid %d, act_status %d, card status %d, card ever present %d",
                            (int)ind_msg->is_active_valid,
                            (int)ind_msg->is_active,
                                 was_active_valid,
                                 was_active,
                                 operating_mode_valid,
                                 operating_mode,
                                 dsds_status_valid,
                                 dsds_act_status,
                            (int)card_status,
                                 card_ever_present);


    QCRIL_LOG_INFO( ".. sms svc status %d", (int) qmi_ril_get_sms_svc_status() );

    if ( dsds_status_valid  && ind_msg->is_active_valid )
    {

      if ( QMI_RIL_SMS_SVC_INIT_PENDING == qmi_ril_get_sms_svc_status() && ind_msg->is_active )
      {
          QCRIL_LOG_INFO( "!QMI RIL! 2nd phase SMS init for DSDS" );

          qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_DATA_ON_STACK,
                         QCRIL_EVT_SMS_PERFORM_INITIAL_CONFIGURATION,
                         NULL,
                         NAS_NIL,
                         (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
          qmi_ril_set_sms_svc_status( QMI_RIL_SMS_SVC_FULLY_OPERATIONAL );
      }

    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_dsds_subscription_info_ind_handler

//===========================================================================
//qcril_qmi_nas_network_time_ind_conv_qmi2ril
//===========================================================================
static void qcril_qmi_nas_network_time_ind_conv_qmi2ril
(
    nas_network_time_ind_msg_v01* ind_msg,
    char *ril_nitz_time_msg,
    int *nitz_updated
)
{
    QCRIL_LOG_FUNC_ENTRY();

    int sib16_support;
    uint8 sib16_acquired;
    uint8 sntp_available;
    int ret_code;
    time_genoff_info_type time_set;

    ret_code = 0;
    memset(&time_set, 0, sizeof(time_set));

    NAS_CACHE_LOCK();
    sib16_support = nas_common_info.sib16_support;
    sib16_acquired = (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired) &&
                     (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired));
    sntp_available = (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.sntp_available) &&
                     (TRUE == nas_cached_info.sntp_available));

    QCRIL_LOG_INFO("sib16 support %d, acquired %d, sntp available %d",
                   sib16_support,
                   sib16_acquired,
                   sntp_available);

    if (!sib16_support || !sib16_acquired)
    {
       int time_zone=0, time_zone_west=FALSE, daylight=0;
       if (ind_msg->time_zone_valid)
       {
           time_zone = ind_msg->time_zone;
           if (0 > time_zone)
           {
               time_zone *= -1;
               time_zone_west = TRUE;
           }
       }
       if (ind_msg->daylt_sav_adj_valid)
       {
           daylight=ind_msg->daylt_sav_adj;
       }

       // accroding to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
       QCRIL_SNPRINTF( ril_nitz_time_msg, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                       (int) ind_msg->universal_time.year%100,
                       (int) ind_msg->universal_time.month,
                       (int) ind_msg->universal_time.day,
                       (int) ind_msg->universal_time.hour,
                       (int) ind_msg->universal_time.minute,
                       (int) ind_msg->universal_time.second,
                       time_zone_west ? '-' : '+',
                       (int) time_zone,
                       (int) daylight);
       *nitz_updated = TRUE;
       QCRIL_LOG_INFO( "ril_nitz_time_msg is: %s", ril_nitz_time_msg);

       if(FALSE == sib16_acquired)
       {
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

          if(FALSE == sntp_available)
          {
             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                        ind_msg->daylt_sav_adj);
             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                        ind_msg->time_zone);

             uint64_t abs_time = qcril_qmi_nas_convert_julian_time_to_abs_time( ind_msg->universal_time.year,
                                                                                ind_msg->universal_time.month,
                                                                                ind_msg->universal_time.day,
                                                                                ind_msg->universal_time.hour,
                                                                                ind_msg->universal_time.minute,
                                                                                ind_msg->universal_time.second,
                                                                                0
                                                                              );
             if(sib16_support)
             {
                 time_set.base = ATS_UTC;
                 time_set.unit = TIME_MSEC;
                 time_set.operation = T_SET;
                 time_set.ts_val = &abs_time;
                 ret_code = time_genoff_operation(&time_set);
                 if(!ret_code)
                 {
                     QCRIL_LOG_INFO("set UTC successfully using 3gpp nw time, abs time (%x, %x)",
                                    (uint32) (abs_time >> 32),
                                    (uint32) abs_time);
                 }
                 else
                 {
                     QCRIL_LOG_INFO("unable to set UTC using 3gpp nw time, error %d",
                                    ret_code);
                 }
             }

             memset(&time_set, 0, sizeof(time_set));
             time_set.base = ATS_MODEM;
             time_set.unit = TIME_MSEC;
             time_set.operation = T_SET;
             time_set.ts_val = &abs_time;
             ret_code = time_genoff_operation(&time_set);
             if(!ret_code)
             {
                 QCRIL_LOG_INFO("set MODEM successfully using 3gpp nw time, abs time (%x, %x)",
                                (uint32) (abs_time >> 32),
                                (uint32) abs_time);
             }
             else
             {
                 QCRIL_LOG_INFO("unable to set MODEM using 3gpp nw time, error %d",
                                ret_code);
             }
          }
       }
    }
    else
    {
       QCRIL_LOG_INFO("ignore nas_network_time_ind_msg_v01 as sib16_support is set and we are in sib16 coverage");
    }

    NAS_CACHE_UNLOCK();

} //qcril_qmi_nas_network_time_ind_conv_qmi2ril

//===========================================================================
//qcril_qmi_nas_rtre_config_ind_conv_qmi2ril
//===========================================================================
void qcril_qmi_nas_rtre_config_ind_conv_qmi2ril
(
    nas_rtre_cfg_ind_msg_v01* ind_msg,
    RIL_CdmaSubscriptionSource *sub_source,
    int *sub_source_updated
)
{
    QCRIL_LOG_FUNC_ENTRY();

    if( ind_msg->rtre_cfg_valid )
    {
        QCRIL_LOG_INFO( "nas rtre cfg %d", ind_msg->rtre_cfg);
        switch ( ind_msg->rtre_cfg )
        {
            case NAS_RTRE_CFG_INTERNAL_SETTINGS_ONLY_V01:
                *sub_source_updated = TRUE;
                *sub_source = CDMA_SUBSCRIPTION_SOURCE_NV;
                break;

            case NAS_RTRE_CFG_RUIM_ONLY_V01:
                *sub_source_updated = TRUE;
                *sub_source = CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
                break;

            default: // unsupported value
                *sub_source_updated = FALSE;
                break;
        }

        NAS_CACHE_LOCK();
        nas_common_info.nas_rtre_cfg = ind_msg->rtre_cfg;
        NAS_CACHE_UNLOCK();
    }
    else
    {
        QCRIL_LOG_INFO( "NO change in nas rtre cfg");
        *sub_source_updated = FALSE;
    }

    QCRIL_LOG_INFO( "sub_source updated %d", *sub_source_updated);
    if( *sub_source_updated )
    {
        QCRIL_LOG_INFO( "sub_source %d", *sub_source);
    }
} //qcril_qmi_nas_rtre_config_ind_conv_qmi2ril

//===========================================================================
//RIL_REQUEST_GET_UICC_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_dsds_request_get_uicc_subscription
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  RIL_Errno ril_err;
  RIL_SelectUiccSub ril_resp;
  qcril_request_resp_params_type resp;

  qcril_instance_id_e_type instance_id;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.valid )
  {
    QCRIL_LOG_DEBUG("Reply for RIL_REQUEST_GET_CURRENT_CALLS");
    QCRIL_LOG_DEBUG( "Reply to RIL --> slot %d app_index %d act_status %d",
                     nas_common_info.dsds.cur_info.slot,
                     nas_common_info.dsds.cur_info.app_index,
                     nas_common_info.dsds.cur_info.act_status );

    ril_err  = RIL_E_SUCCESS;
    ril_resp = nas_common_info.dsds.cur_info;
  }
  else
  {
      ril_err = RIL_E_SUBSCRIPTION_NOT_SUPPORTED;
  }
  NAS_CACHE_UNLOCK();

  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_err, &resp );
  if ( RIL_E_SUCCESS == ril_err )
  {
      resp.resp_pkt = (void *) &ril_resp;
      resp.resp_len = sizeof( ril_resp );
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "complete with %d", (int) ril_err );

} // qcril_qmi_nas_dsds_request_get_uicc_subscription

//===========================================================================
//qcril_qmi_nas_dsds_fillini_default_standby_pref
//===========================================================================
void qcril_qmi_nas_dsds_fillini_default_standby_pref(nas_standby_pref_enum_v01 standby_pref, nas_set_dual_standby_pref_req_msg_v01* req_msg)
{
    nas_subs_type_enum_v01 default_val;

    if ( NULL != req_msg )
    {
        req_msg->standby_pref_valid = TRUE;
        req_msg->standby_pref = standby_pref;
        NAS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.dsds_standby_pref ) )
        {
            req_msg->priority_subs_valid= TRUE;
            req_msg->priority_subs = nas_cached_info.dsds_standby_pref.priority_subs;
            req_msg->default_data_subs_valid= TRUE;
            req_msg->default_data_subs   = nas_cached_info.dsds_standby_pref.default_data_subs;
        }
        else
        {   // default values
            if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id() )
            {
                default_val = NAS_PRIMARY_SUBSCRIPTION_V01;
            }
            else if (QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id() )
            {
                default_val = NAS_SECONDARY_SUBSCRIPTION_V01;
            }
            else
            {
                default_val = NAS_TERTIARY_SUBSCRIPTION_V01;
            }
            req_msg->priority_subs_valid= TRUE;
            req_msg->priority_subs = default_val;
            req_msg->default_data_subs_valid = TRUE;
            req_msg->default_data_subs = default_val;
        }
        NAS_CACHE_UNLOCK();
    } // if ( NULL != req_msg )
} // qcril_qmi_nas_dsds_fillini_default_standby_pref
//===========================================================================
//qcril_qmi_nas_dsds_util_request_set_subscription_mode
//===========================================================================
RIL_Errno qcril_qmi_nas_dsds_util_request_set_subscription_mode( nas_standby_pref_enum_v01 *standby_pref,
                                                                 nas_subs_type_enum_v01 * data_subs,
                                                                 nas_subs_type_enum_v01 *priority_subs,
                                                                 nas_subs_type_enum_v01 *voice_subs,
                                                                 qcril_qmi_cb_func_ptr  standby_pref_res_cb )
{
    RIL_Errno res = RIL_E_GENERIC_FAILURE;

    nas_set_dual_standby_pref_req_msg_v01 qmi_req_msg;
    nas_set_dual_standby_pref_resp_msg_v01 * qmi_resp_msg = NULL;

    qmi_resp_msg = qcril_malloc( sizeof(nas_set_dual_standby_pref_resp_msg_v01) );

    if ( qmi_resp_msg )
    {
        memset( &qmi_req_msg, 0, sizeof( qmi_req_msg ) );
        if( standby_pref )
        {
            qmi_req_msg.standby_pref_valid = TRUE;
            qmi_req_msg.standby_pref = *standby_pref;
        }
        if ( data_subs )
        {
            qmi_req_msg.default_data_subs_valid = TRUE;
            qmi_req_msg.default_data_subs = *data_subs;
        }
        if ( priority_subs )
        {
            qmi_req_msg.priority_subs_valid = TRUE;
            qmi_req_msg.priority_subs = *priority_subs;
        }
        if ( voice_subs )
        {
            qmi_req_msg.default_voice_subs_valid = TRUE;
            qmi_req_msg.default_voice_subs = *voice_subs;
        }

        QCRIL_LOG_INFO( "preps:" );
        QCRIL_LOG_INFO( ".. standby_pref %d", (int) qmi_req_msg.standby_pref );
        QCRIL_LOG_INFO( ".. priority_subs %d", (int) qmi_req_msg.priority_subs );
        QCRIL_LOG_INFO( ".. default_data_subs %d", (int) qmi_req_msg.default_data_subs );
        QCRIL_LOG_INFO( ".. default_voice_subs %d", (int) qmi_req_msg.default_voice_subs );
        res = qcril_qmi_client_send_msg_async_ex(
                                      QCRIL_QMI_CLIENT_NAS,
                                      QMI_NAS_DUAL_STANDBY_PREF_REQ_MSG_V01,
                                      &qmi_req_msg,
                                      sizeof(qmi_req_msg),
                                      qmi_resp_msg,
                                      sizeof(*qmi_resp_msg),
                                      (void*)standby_pref_res_cb );
        if( RIL_E_SUCCESS != res )
        {
            qcril_free( qmi_resp_msg );
        }
    }

    return res;
} // qcril_qmi_nas_dsds_util_request_set_subscription_mode

//===========================================================================
//RIL_REQUEST_SET_DATA_SUBSCRIPTION
//===========================================================================
void qcril_qmi_nas_dsds_request_set_data_subscription
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  QCRIL_LOG_FUNC_ENTRY();

  if( params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
    NAS_CACHE_LOCK();
    nas_common_info.dsds.default_data_instance_id = *((int*)params_ptr->data);
    nas_common_info.dsds.is_default_data_set = TRUE;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_DEBUG("Default Data Sub = %d", (int) nas_common_info.dsds.default_data_instance_id);
    ril_req_res = RIL_E_SUCCESS;
  }

  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );
  qcril_send_request_response( &resp );
  qcril_qmi_nas_update_embms_status();
  qcril_qmi_nas_embms_send_embms_status(qcril_qmi_nas_get_embms_status());
}

RIL_Errno qcril_qmi_nas_send_data_subscription_request()
{
  RIL_Errno ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_standby_pref_enum_v01 param_standby_pref;
  nas_subs_type_enum_v01 data_pref;

  QCRIL_LOG_FUNC_ENTRY();

  NAS_CACHE_LOCK();

  if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id() )
  { // primary
    data_pref = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id() )
  { // secondary
    data_pref = NAS_SECONDARY_SUBSCRIPTION_V01;
  }
  else
  { // tertiary
    data_pref = NAS_TERTIARY_SUBSCRIPTION_V01;
  }

  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO( ".. data_pref %d", (int)data_pref );

  ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( NULL,
                                                                         &data_pref,
                                                                         NULL,
                                                                         NULL,
                                                                         qcril_qmi_dsds_set_pref_ril_req_cb );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

  return ril_req_res;
}// qcril_qmi_nas_send_data_subscription_request


//===========================================================================
//RIL_REQUEST_SET_SUBSCRIPTION_MODE
//===========================================================================
void qcril_qmi_nas_dsds_request_set_subscription_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  int *subscription_mode_ptr;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  nas_standby_pref_enum_v01 param_standby_pref;
  nas_set_dual_standby_pref_req_msg_v01 qmi_req_msg;
  nas_set_dual_standby_pref_resp_msg_v01 * qmi_resp_msg;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );
  if( params_ptr->datalen > 0 && params_ptr->data != NULL )
  {
      subscription_mode_ptr = (int *) params_ptr->data;
      QCRIL_LOG_INFO( "pre-entry %p", subscription_mode_ptr );
      ril_req_res = RIL_E_SUCCESS;
      QCRIL_LOG_INFO( "entry %d", (int) *subscription_mode_ptr );
  }

  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

}// qcril_qmi_nas_dsds_request_set_subscription_mode

//===========================================================================
//QCRIL_EVT_HOOK_SET_TUNE_AWAY
//===========================================================================
void qcril_qmi_nas_dsds_request_set_tune_away
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  boolean     tune_away;
  nas_standby_pref_enum_v01 param_standby_pref;
  nas_set_dual_standby_pref_req_msg_v01 qmi_req_msg;
  nas_set_dual_standby_pref_resp_msg_v01 * qmi_resp_msg;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  do
  {
  memcpy(&tune_away, params_ptr->data, sizeof(tune_away));
  QCRIL_LOG_INFO( "tune_away: %d", (int) tune_away );

  if( (tune_away != TRUE) && (tune_away != FALSE) )
  {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );
      break;
  }

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.is_tune_away == tune_away )
  {
    ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_DEBUG( "RID %d, is already in requested tune_away settings i.e. %d", instance_id, tune_away);
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );

    NAS_CACHE_UNLOCK();
        break;
  }
  NAS_CACHE_UNLOCK();

  if ( tune_away )
  {
    param_standby_pref = NAS_AUTOMATIC_WITH_TUNE_AWAY_V01;
  }
  else
  {
    param_standby_pref = NAS_AUTOMATIC_WITHOUT_TUNE_AWAY_V01;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               modem_id,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                               NULL,
                               &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
  {
      ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( &param_standby_pref, NULL, NULL, NULL, qcril_qmi_dsds_set_pref_ril_req_cb );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {  // rollback
      qcril_default_request_resp_params( instance_id,
                                         reqlist_entry.t,
                                         reqlist_entry.request,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );

  }
  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
  }while(0);

}// qcril_qmi_nas_dsds_request_set_tune_away

//===========================================================================
//QCRIL_EVT_HOOK_GET_TUNE_AWAY
//===========================================================================
void qcril_qmi_nas_dsds_request_get_tune_away
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  boolean tune_away;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;


  NAS_CACHE_LOCK();
  tune_away = nas_common_info.dsds.is_tune_away;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_DEBUG( "RID %d stored tune away preferences = %d", instance_id, tune_away);

  if( nas_common_info.dsds.is_tune_away != NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE )
  {
    ril_req_res = RIL_E_SUCCESS;
  }

  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );

  if( ril_req_res == RIL_E_SUCCESS )
  {
    resp.resp_pkt = &tune_away;
    resp.resp_len = sizeof(tune_away);
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

}// qcril_qmi_nas_dsds_request_set_tune_away

//===========================================================================
//QCRIL_EVT_HOOK_SET_PAGING_PRIORITY
//===========================================================================
void qcril_qmi_nas_dsds_request_set_paging_priority
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int paging_priority = 0;
  nas_subs_type_enum_v01 param_paging_priority;
  nas_set_dual_standby_pref_req_msg_v01 qmi_req_msg;
  nas_set_dual_standby_pref_resp_msg_v01 * qmi_resp_msg;



  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  do
  {
  memcpy(&paging_priority, params_ptr->data, sizeof(paging_priority));
  QCRIL_LOG_INFO( "paging_priority: %d", (int) paging_priority );

  if( (paging_priority < RIL_SUBSCRIPTION_1) || (paging_priority > RIL_SUBSCRIPTION_3) )
  {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );
      break;
  }

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.paging_priority == qcril_qmi_nas_get_modem_stack_id() )
  {
    ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_DEBUG( "RID %d, is already in requested paging_priority settings i.e. %d", instance_id, paging_priority);
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );

    NAS_CACHE_UNLOCK();
    break;
  }
  NAS_CACHE_UNLOCK();

  if ( QCRIL_MODEM_PRIMARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id() )
  {
    param_paging_priority = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else if ( QCRIL_MODEM_SECONDARY_STACK_ID == qcril_qmi_nas_get_modem_stack_id() )
  {
    param_paging_priority = NAS_SECONDARY_SUBSCRIPTION_V01;
  }
  else
  {
    param_paging_priority = NAS_TERTIARY_SUBSCRIPTION_V01;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               modem_id,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                               NULL,
                               &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
  {
      ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( NULL, NULL, &param_paging_priority, NULL, qcril_qmi_dsds_set_pref_ril_req_cb );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {  // rollback
      qcril_default_request_resp_params( instance_id,
                                         reqlist_entry.t,
                                         reqlist_entry.request,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );

  }
  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
  }while(0);

}// qcril_qmi_nas_dsds_request_set_paging_priority

//===========================================================================
//QCRIL_EVT_HOOK_GET_PAGING_PRIORITY
//===========================================================================
void qcril_qmi_nas_dsds_request_get_paging_priority
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  boolean paging_priority;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(ret_ptr);


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;

  modem_id = params_ptr->modem_id;


  NAS_CACHE_LOCK();
  paging_priority = nas_common_info.dsds.paging_priority;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_DEBUG( "RID %d stored paging priority preferences = %d", instance_id, paging_priority);

  if( paging_priority != NAS_DSDS_TUNEAWAY_STANDBY_PREF_INITIAL_VALUE )
  {
      ril_req_res = RIL_E_SUCCESS;
  }
  qcril_default_request_resp_params( instance_id,
                                     params_ptr->t,
                                     params_ptr->event_id,
                                     ril_req_res,
                                     &resp );

  if( ril_req_res == RIL_E_SUCCESS )
  {
      resp.resp_pkt = &paging_priority;
      resp.resp_len = sizeof(paging_priority);
  }
  qcril_send_request_response( &resp );

  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );

}// qcril_qmi_nas_dsds_request_get_paging_priority

//===========================================================================
//QCRIL_EVT_HOOK_SET_DEFAULT_VOICE_SUB
//===========================================================================
void qcril_qmi_nas_dsds_request_set_default_voice_sub
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_reqlist_public_type reqlist_entry;
  qcril_request_resp_params_type resp;
  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
  int default_voice_sub = 0;
  nas_subs_type_enum_v01 param_default_voice_subs;
  nas_set_dual_standby_pref_req_msg_v01 qmi_req_msg;
  nas_set_dual_standby_pref_resp_msg_v01 * qmi_resp_msg;

  QCRIL_LOG_FUNC_ENTRY();

  instance_id = QCRIL_DEFAULT_INSTANCE_ID;
  modem_id = params_ptr->modem_id;

  QCRIL_NOTUSED( ret_ptr );

  do
  {
  memcpy(&default_voice_sub, params_ptr->data, params_ptr->datalen);
  QCRIL_LOG_INFO( "default_voice_sub: %d", (int) default_voice_sub );

  if( (default_voice_sub < RIL_SUBSCRIPTION_1) || (default_voice_sub > RIL_SUBSCRIPTION_3) )
  {
      qcril_default_request_resp_params( instance_id,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );
      break;
  }

  NAS_CACHE_LOCK();
  if ( nas_common_info.dsds.default_voice_sub == default_voice_sub )
  {
    ril_req_res = RIL_E_SUCCESS;

    QCRIL_LOG_DEBUG( "RID %d, is already in requested default_voice_sub settings i.e. %d", instance_id, default_voice_sub);
    qcril_default_request_resp_params( instance_id,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    qcril_send_request_response( &resp );

    NAS_CACHE_UNLOCK();
    break;
  }
  NAS_CACHE_UNLOCK();

  if ( default_voice_sub == RIL_SUBSCRIPTION_1 )
  {
    param_default_voice_subs = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else if ( default_voice_sub == RIL_SUBSCRIPTION_2 )
  {
    param_default_voice_subs = NAS_PRIMARY_SUBSCRIPTION_V01;
  }
  else
  {
    param_default_voice_subs = NAS_TERTIARY_SUBSCRIPTION_V01;
  }

  qcril_reqlist_default_entry( params_ptr->t,
                               params_ptr->event_id,
                               modem_id,
                               QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                               QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                               NULL,
                               &reqlist_entry );

  if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
  {
      ril_req_res = qcril_qmi_nas_dsds_util_request_set_subscription_mode( NULL, NULL, NULL, &param_default_voice_subs, qcril_qmi_dsds_set_pref_ril_req_cb );
  }

  if ( RIL_E_SUCCESS != ril_req_res )
  {  // rollback
      qcril_default_request_resp_params( instance_id,
                                         reqlist_entry.t,
                                         reqlist_entry.request,
                                         ril_req_res,
                                         &resp );
      qcril_send_request_response( &resp );

  }
  QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
  }while(0);

  QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_dsds_request_set_default_voice_sub

//===========================================================================
//qcril_qmi_dsds_set_pref_ril_req_cb
//===========================================================================
void qcril_qmi_dsds_set_pref_ril_req_cb ( RIL_Errno resp_res )
{
    int found_qcril_request;
    qcril_reqlist_public_type             qcril_req_info;
    qcril_request_resp_params_type        resp;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;
    int send_resp_to_atel = TRUE;

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                          QCRIL_DEFAULT_MODEM_ID,
                                                          QCRIL_EVT_QMI_REQUEST_SET_SUBS_MODE,
                                                          &qcril_req_info );

    QCRIL_LOG_INFO("res %d, fnd %d ", (int) resp_res, (int) found_qcril_request );

    if ( E_SUCCESS == found_qcril_request )
    {

        if( qcril_req_info.request == QCRIL_EVT_HOOK_SET_TUNE_AWAY )
        {
           nas_common_info.dsds.is_tune_away = ( !nas_common_info.dsds.is_tune_away ) ;

           moniker = (int)qmi_ril_get_process_instance_id();
           snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_TUNE_AWAY, moniker );
           snprintf( property_value, sizeof(property_value), "%d", nas_common_info.dsds.is_tune_away);
           if ( property_set( property_name, property_value ) != E_SUCCESS )
           {
               QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_TUNE_AWAY );
           }
        }

        if( qcril_req_info.request == QCRIL_EVT_HOOK_SET_PAGING_PRIORITY )
        {
           nas_common_info.dsds.paging_priority = ( !nas_common_info.dsds.paging_priority ) ;

           moniker = (int)qmi_ril_get_process_instance_id();
           snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_PAGING_PRIORITY, moniker );
           snprintf( property_value, sizeof(property_value), "%d", (int) nas_common_info.dsds.paging_priority );
           if ( property_set( property_name, property_value ) != E_SUCCESS )
           {
               QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_PAGING_PRIORITY );
           }
        }
    }
    else
    {
      // Send resp to ALLOW_DATA request right away if failure
      // Else, wait for PS attach to be successful.
      found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                          QCRIL_DEFAULT_MODEM_ID,
                                                          QCRIL_EVT_QMI_REQUEST_ALLOW_DATA,
                                                          &qcril_req_info );

      QCRIL_LOG_INFO("Default data sub request fnd %d res %d", found_qcril_request, (int)resp_res);

      if ( found_qcril_request == E_SUCCESS )
      {
        qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
        send_resp_to_atel = TRUE;
      }
    }
    if ( found_qcril_request == E_SUCCESS && send_resp_to_atel == TRUE )
    {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           resp_res ,
                                           &resp );

      qcril_send_request_response( &resp );
    }
} // qcril_qmi_dsds_set_pref_ril_req_cb

//===========================================================================
//QCRIL_EVT_HOOK_SET_LTE_TUNE_AWAY
//===========================================================================
void qcril_qmi_nas_dsds_request_set_lte_tune_away
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type *const ret_ptr
)
{
    qcril_instance_id_e_type instance_id;
    qcril_modem_id_e_type modem_id;
    qcril_reqlist_public_type reqlist_entry;
    qcril_request_resp_params_type resp;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    boolean     lte_tune_away;
    nas_avoid_tuneaway_req_msg_v01 qmi_req_msg;
    nas_avoid_tuneaway_resp_msg_v01 * qmi_resp_msg = NULL;

    instance_id = QCRIL_DEFAULT_INSTANCE_ID;

    modem_id = params_ptr->modem_id;

    QCRIL_NOTUSED( ret_ptr );

    do
    {
        memcpy(&lte_tune_away, params_ptr->data, sizeof(lte_tune_away));
        QCRIL_LOG_INFO( "lte_tune_away: %d", (int) lte_tune_away );

        if( (lte_tune_away != TRUE) && (lte_tune_away != FALSE) )
        {
            qcril_default_request_resp_params( instance_id,
                                        params_ptr->t,
                                        params_ptr->event_id,
                                        ril_req_res,
                                        &resp );
            qcril_send_request_response( &resp );
            break;
        }

        if ( nas_common_info.dsds.is_lte_tune_away == lte_tune_away )
        {
            ril_req_res = RIL_E_SUCCESS;

            QCRIL_LOG_DEBUG( "RID %d, is already in requested lte_tune_away settings i.e. %d", instance_id, lte_tune_away);
            qcril_default_request_resp_params( instance_id,
                                        params_ptr->t,
                                        params_ptr->event_id,
                                        ril_req_res,
                                        &resp );
            qcril_send_request_response( &resp );
            break;
        }

        if ( lte_tune_away )
        {
            qmi_req_msg.trm_priority = 1;
        }
        else
        {
            qmi_req_msg.trm_priority = 0;
        }

        qcril_reqlist_default_entry( params_ptr->t,
                                params_ptr->event_id,
                                modem_id,
                                QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                QCRIL_EVT_QMI_REQUEST_SET_LTE_TUNE_AWAY_MODE,
                                NULL,
                                &reqlist_entry );

        if ( qcril_reqlist_new( instance_id, &reqlist_entry ) == E_SUCCESS )
        {
            qmi_resp_msg = qcril_malloc( sizeof(nas_avoid_tuneaway_resp_msg_v01) );
            if(qmi_resp_msg != NULL)
            {
                ril_req_res = qcril_qmi_client_send_msg_async_ex(
                                    QCRIL_QMI_CLIENT_NAS,
                                    QMI_NAS_AVOID_TUNEAWAY_REQ_MSG_V01,
                                    &qmi_req_msg,
                                    sizeof(qmi_req_msg),
                                    qmi_resp_msg,
                                    sizeof(*qmi_resp_msg),
                                    &qcril_qmi_dsds_lte_tune_away_cb );
            }
        }

        if ( RIL_E_SUCCESS != ril_req_res )
        {  // rollback
            qcril_default_request_resp_params( instance_id,
                                        reqlist_entry.t,
                                        reqlist_entry.request,
                                        ril_req_res,
                                        &resp );
            qcril_send_request_response( &resp );

            if(qmi_resp_msg != NULL)
            {
                qcril_free( qmi_resp_msg );
            }
        }
        QCRIL_LOG_INFO( "completed with %d", (int) ril_req_res );
    }while(0);

}// qcril_qmi_nas_dsds_request_set_lte_tune_away

//===========================================================================
//qcril_qmi_dsds_lte_tune_away_cb
//===========================================================================
void qcril_qmi_dsds_lte_tune_away_cb ( RIL_Errno resp_res )
{
    int found_qcril_request;
    qcril_reqlist_public_type             qcril_req_info;
    qcril_request_resp_params_type        resp;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int moniker;

    found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                        QCRIL_DEFAULT_MODEM_ID,
                                                        QCRIL_EVT_QMI_REQUEST_SET_LTE_TUNE_AWAY_MODE,
                                                        &qcril_req_info );

    QCRIL_LOG_INFO("res %d, fnd %d ", (int) resp_res, (int) found_qcril_request );

    if ( E_SUCCESS == found_qcril_request )
    {
        nas_common_info.dsds.is_lte_tune_away = ( !nas_common_info.dsds.is_lte_tune_away ) ;
        moniker = (int)qmi_ril_get_process_instance_id();
        snprintf( property_name, sizeof(property_name), "%s%d", QMI_RIL_LTE_TUNE_AWAY, moniker );
        snprintf( property_value, sizeof(property_value), "%d", nas_common_info.dsds.is_lte_tune_away);

        if ( property_set( property_name, property_value ) != E_SUCCESS )
        {
            QCRIL_LOG_ERROR( "fail to save %s to system property", QMI_RIL_LTE_TUNE_AWAY );
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           qcril_req_info.t,
                                           qcril_req_info.request,
                                           resp_res ,
                                           &resp );

        qcril_send_request_response( &resp );
    }

} // qcril_qmi_dsds_lte_tune_away_cb

//
//===========================================================================
//qcril_qmi_nas_minority_command_cb
//===========================================================================
void qcril_qmi_nas_minority_command_cb
(
  qmi_client_type              user_handle,
  unsigned int                 msg_id,
  void                        *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    RIL_Errno                                ril_req_res = RIL_E_GENERIC_FAILURE;
    qmi_resp_callback_type                   qmi_resp_callback;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&qmi_resp_callback,0,sizeof(qmi_resp_callback));
    qmi_resp_callback.user_handle = user_handle;
    qmi_resp_callback.msg_id = msg_id;
    qmi_resp_callback.data_buf = (void*) resp_c_struct;
    qmi_resp_callback.data_buf_len = resp_c_struct_len;
    qmi_resp_callback.cb_data = resp_cb_data;
    qmi_resp_callback.transp_err = transp_err;

    QCRIL_LOG_INFO( "entered msg %d, transp_err %d", (int) msg_id, (int) transp_err);

    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_NAS_HANDLE_ASYNC_CB,
                   (void*) &qmi_resp_callback,
                   sizeof(qmi_resp_callback),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );

    QCRIL_LOG_FUNC_RETURN();

} //qcril_qmi_nas_minority_command_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_async_cb_helper

===========================================================================*/
/*!
    @brief
    Handle QCRIL_EVT_QMI_NAS_HANDLE_ASYNC_CB

    @return
    None.
*/
/*=========================================================================*/
void qcril_qmi_nas_async_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno                               ril_req_res = RIL_E_GENERIC_FAILURE;
    qmi_resp_callback_type                  *qmi_resp = (qmi_resp_callback_type*) params_ptr->data;
    unsigned long                           msg_id;
    nas_avoid_tuneaway_resp_msg_v01         *tune_away_resp;
    nas_set_dual_standby_pref_resp_msg_v01  *dual_standby_resp;
    qcril_qmi_cb_func_ptr                   async_cb_func_ptr;

    QCRIL_LOG_FUNC_ENTRY();

    if ( qmi_resp )
    {
        msg_id = qmi_resp->msg_id;
        async_cb_func_ptr = (qcril_qmi_cb_func_ptr)qmi_resp->cb_data;

        switch(msg_id)
        {
            case QMI_NAS_DUAL_STANDBY_PREF_RESP_MSG_V01:
                dual_standby_resp = (nas_set_dual_standby_pref_resp_msg_v01*)qmi_resp->data_buf;
                ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_resp->transp_err, &dual_standby_resp->resp );
                if( async_cb_func_ptr )
                {
                    (async_cb_func_ptr)(ril_req_res);
                }
                break;

            case QMI_NAS_AVOID_TUNEAWAY_RESP_MSG_V01:
	        tune_away_resp = (nas_avoid_tuneaway_resp_msg_v01*)qmi_resp->data_buf;
	        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_resp->transp_err, &tune_away_resp->resp );
	        if( async_cb_func_ptr )
	        {
	            (async_cb_func_ptr)(ril_req_res);
	        }
	        break;
            default:
                QCRIL_LOG_INFO( ".. msg not handled" );
                break;
        }

        if ( qmi_resp->data_buf )
        {
            qcril_free(qmi_resp->data_buf);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_drop_nw_info_cache
//===========================================================================
void qcril_qmi_nas_drop_nw_info_cache(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.service_provider_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.operator_plmn_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_network_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nitz_information);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.plmn_id);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.spn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.short_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.long_name);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.serving_system);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.data_capabilities);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.current_plmn);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_system_id);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_base_station_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.roaming_indicator_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.nas_3gpp_time_zone);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rf_band_info_list);
    //NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.registration_reject_reason); - as currently there is no method to refetch reg reject cause
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.signal_strength_list);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rssi);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.ecio);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.rsrq);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.detailed_service_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.hdr_personality);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_system_id_ext);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_dms_cached_info.band_capability);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tac);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roaming_indicator);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.cdma_sys_id);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.roam_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.is_sys_prl_match);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.def_roam_ind);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.call_barring_status);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.mnc_includes_pcs_digit);




    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_srv_status_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.tdscdma_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sys_info2);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.gsm_sys_info3);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sys_info3);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_cell_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.voice_support_on_lte);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_embms_coverage);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.embms_coverage_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.hs_call_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sim_rej_info);

    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_bit_err_rate);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.wcdma_block_err_rate);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.rscp);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.tdscdma_block_err_rate);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_voice_status);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.lte_sms_status);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_csg_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_csg_info);

    nas_cached_info.voice_roam_status_reported = FALSE;

    nas_cached_info.voice_rte = NAS_NIL;
    nas_cached_info.data_rte = NAS_NIL;

    nas_cached_info.voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;
    nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_UNKNOWN;

    nas_cached_info.sglte_current_eons_rte = QMI_RIL_RTE_NONE;

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_drop_nw_info_cache

//===========================================================================
//qcril_qmi_drop_sig_info_cache
//===========================================================================
void qcril_qmi_drop_sig_info_cache(void)
{
    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.wcdma_sig_info);
    NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.gsm_sig_info);

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.cdma_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.hdr_sig_info);
    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.lte_sig_info);

    NAS_CACHE_INVALIDATE_ENTRY(nas_cached_info.error_rate);
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_drop_sig_info_cache

//===========================================================================
//qmi_ril_nw_reg_data_pref_changed_action
//===========================================================================
void qmi_ril_nw_reg_data_pref_changed_action()
{
  QCRIL_LOG_FUNC_ENTRY();

  qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                          QCRIL_DEFAULT_MODEM_ID,
                          qmi_ril_nw_reg_refresh_cache_main_thrd,
                          NULL,  // immediate
                          NULL );

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_data_pref_changed_action

//===========================================================================
// qmi_ril_nw_reg_refresh_cache_main_thrd
//===========================================================================
void qmi_ril_nw_reg_refresh_cache_main_thrd(void * param)
{
    qcril_modem_restart_con_type outcome;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.data_reg_roaming_status_latest      = NAS_NIL;
    nas_cached_info.data_reg_roaming_status_latest_val  = FALSE;

    qcril_qmi_nas_drop_nw_info_cache();
    qcril_qmi_nas_fetch_system_info_helper();
    qcril_qmi_nas_send_known_signal_strength();
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nw_reg_refresh_cache_main_thrd


//===========================================================================
//qcril_qmi_sys_info_roll_details
//===========================================================================
void qcril_qmi_sys_info_roll_details(int * rte_reg_status,
                                     int is_data,
                                     qcril_qmi_nas_srv_status_convertion_extra_results_type* extra_results_vector_param )
{
    nas_sys_info_helper_type sys_info_helper;
    int data_mask = is_data ? NAS_SYS_INFO_IS_DATA : NAS_SYS_INFO_IS_EMPTY;

    QCRIL_LOG_INFO( " .. prep CDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_1x ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_1x ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep GSM" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_GSM ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep WCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_WCDMA ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_WCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep TDSCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_TDSCDMA ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep LTE" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_SUB_LTE ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep EVDO" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
        sys_info_helper.hdr_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->hdr_specific_sys_info : NULL;
        sys_info_helper.extra_results = extra_results_vector_param ? &extra_results_vector_param[ QMI_RIL_RTE_SUB_DO ] : NULL;
        rte_reg_status[ QMI_RIL_RTE_SUB_DO ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(data_mask | NAS_SYS_INFO_IS_HDR,
                                                                                                             &sys_info_helper);
    }
} // qcril_qmi_sys_info_roll_details
//===========================================================================
//qcril_qmi_nas_is_considered_registered
//===========================================================================
int qcril_qmi_nas_is_considered_registered
(
    qmi_ril_nw_reg_rte_type registered_rtes[QMI_RIL_RTE_LAST]
)
{
    int                     rte_reg_status[ QMI_RIL_RTE_CAP ];
    qmi_ril_nw_reg_rte_type idx_rte;

    int                     res                = FALSE;
    qmi_ril_nw_reg_rte_type registered_rte_idx = 0;
    qmi_ril_nw_reg_rte_type reg_rte            = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rte_type tmp_registered_rtes[QMI_RIL_RTE_LAST] = {QMI_RIL_RTE_NONE};

    QCRIL_LOG_FUNC_ENTRY();
    if ( !qmi_ril_is_qmi_sys_info_available() )
    {
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) &&
             ( (NAS_VAL_REGISTERED == nas_cached_info.serving_system->registration_state)  &&
               ((NAS_VAL_CS_ATTACH_ATTACHED == nas_cached_info.serving_system->cs_attach_state) ||
                (NAS_VAL_DATA_ATTACH_ATTACHED == nas_cached_info.serving_system->ps_attach_state)) )
           )
        {
            res = TRUE;
        }
    }
    else
    {
        QCRIL_LOG_INFO( ".. cache valid %d", nas_cached_info.is_considered_registered_cached_result_valid );
        if ( nas_cached_info.is_considered_registered_cached_result_valid )
        {
            res = nas_cached_info.is_considered_registered_cached_result;
            if (registered_rtes)
            {
                memcpy(registered_rtes,
                       nas_cached_info.registered_cached_rtes,
                       sizeof(nas_cached_info.registered_cached_rtes));
            }
        }
        else
        {
            memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
            qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );

            QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
            QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
            QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
            QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
            QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
            QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

            for ( idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST; idx_rte++)
            {
                if ( RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ idx_rte ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ idx_rte ] )
                {
                    res = TRUE;
                    tmp_registered_rtes[registered_rte_idx] = idx_rte;
                    registered_rte_idx++;
                }
            }

            // check if data only reg
            memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
            qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );

            QCRIL_LOG_INFO( ".. 1x reg data %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
            QCRIL_LOG_INFO( ".. gsm reg data %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
            QCRIL_LOG_INFO( ".. wcdma reg data %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
            QCRIL_LOG_INFO( ".. tdscdma reg data %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
            QCRIL_LOG_INFO( ".. lte reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
            QCRIL_LOG_INFO( ".. hdr reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

            for ( idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST; idx_rte++)
            {
                if ( RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ idx_rte ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ idx_rte ] )
                {
                    res = TRUE;
                    tmp_registered_rtes[registered_rte_idx] = idx_rte;
                    registered_rte_idx++;
                }
            }

            nas_cached_info.is_considered_registered_cached_result       = res;
            nas_cached_info.is_considered_registered_cached_result_valid = TRUE;
            memcpy(nas_cached_info.registered_cached_rtes,
                   tmp_registered_rtes,
                   sizeof(nas_cached_info.registered_cached_rtes));

            if (registered_rtes)
            {
                memcpy(registered_rtes,
                       tmp_registered_rtes,
                       sizeof(tmp_registered_rtes));
            }

        }
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);
    return res;
} // qcril_qmi_nas_is_considered_registered

/*===========================================================================

  FUNCTION  qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name

===========================================================================*/
/*!
    @brief
    check if in full service and retrieve rte satisfying the filter.

    @return
    true is in full service.
    false if not in full service
*/
/*=========================================================================*/
qmi_ril_nw_reg_rte_type qcril_qmi_nas_choose_rte_to_retrieve_3gpp_operator_name_info
(
    qmi_ril_nw_reg_rte_type  registered_rtes[QMI_RIL_RTE_LAST]
)
{

    qmi_ril_nw_reg_rte_type chosen_registered_rte = QMI_RIL_RTE_NONE;
    qmi_ril_nw_reg_rte_type idx_rte;

    QCRIL_LOG_FUNC_ENTRY();

    do {

        if ( (qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) ||
             qcril_qmi_nas_is_sglte3() ||
             qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SVLTE2 )) &&
             !qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ))
        {
            qcril_qmi_nas_evaluate_sglte_current_eons_rte();
            chosen_registered_rte = nas_cached_info.sglte_current_eons_rte;
            QCRIL_LOG_INFO("choosing SGLTE rte");
            break;
        }

        if (!registered_rtes)
        {
            QCRIL_LOG_INFO("invalid input");
            break;
        }


        for (idx_rte = 0;
                ((idx_rte < QMI_RIL_RTE_LAST) &&
                (registered_rtes[idx_rte] != QMI_RIL_RTE_NONE) &&
                (chosen_registered_rte == QMI_RIL_RTE_NONE));
                 idx_rte++)
        {
            QCRIL_LOG_INFO("..rte %d", (int) registered_rtes[idx_rte]);
            switch (registered_rtes[idx_rte])
            {
                case QMI_RIL_RTE_GSM:
                case QMI_RIL_RTE_WCDMA:
                case QMI_RIL_RTE_TDSCDMA:
                case QMI_RIL_RTE_SUB_LTE:
                {
                    chosen_registered_rte = registered_rtes[idx_rte];
                    break;
                }

                default:
                {
                    break;
                }
            }
        }
    } while(0);

    QCRIL_LOG_INFO("completed with %d", (int) chosen_registered_rte);
    return chosen_registered_rte;
}

//===========================================================================
//RIL_REQUEST_GET_IMEI
//===========================================================================
void qcril_qmi_nas_dms_request_imei
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;

  dms_get_device_serial_numbers_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  char ril_resp_data_imei[NAS_DMS_IMEI_MAX_STR_SIZE];

  qmi_client_error_type qmi_client_error;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  memset(ril_resp_data_imei,0,sizeof(ril_resp_data_imei));
  memset(&qmi_response, 0, sizeof(qmi_response));

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_DEVICE_SERIAL_NUMBERS_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO(".. qmi %d, %d", (int) ril_req_res, qmi_client_error);

  // ** prepare response
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_SNPRINTF( ril_resp_data_imei, NAS_DMS_IMEI_MAX_STR_SIZE, "%d", 0 );

      if ( qmi_response.imei_valid )
      {
          memcpy(ril_resp_data_imei,qmi_response.imei,NAS_DMS_IMEI_MAX_STR_SIZE-1);
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = ril_resp_data_imei;
      resp.resp_len = sizeof( ril_resp_data_imei );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_imei

//===========================================================================
//RIL_REQUEST_GET_IMEISV
//===========================================================================
void qcril_qmi_nas_dms_request_imeisv
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_request_resp_params_type resp;
  int error;

  dms_get_device_serial_numbers_resp_msg_v01 qmi_response;

  RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;

  char ril_resp_data_imeisv[NAS_DMS_IMEISV_MAX_STR_SIZE];

  qmi_client_error_type qmi_client_error;

  int imeisv_value;


  instance_id = QCRIL_DEFAULT_INSTANCE_ID;


  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );

  memset(ril_resp_data_imeisv,0,sizeof(ril_resp_data_imeisv));
  memset(&qmi_response, 0, sizeof(qmi_response));

  // ** fetch data
  qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_DMS ),
                                                     QMI_DMS_GET_DEVICE_SERIAL_NUMBERS_REQ_V01,
                                                     NULL,
                                                     NAS_NIL,  // empty request payload
                                                     (void*) &qmi_response,
                                                     sizeof( qmi_response ),
                                                     QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


  ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response.resp );

  QCRIL_LOG_INFO(".. qmi %d, %d", (int) ril_req_res, qmi_client_error);

  // ** prepare response
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      QCRIL_SNPRINTF( ril_resp_data_imeisv, NAS_DMS_IMEISV_MAX_STR_SIZE, "%02d", 0 );
      if( qmi_response.imeisv_svn_valid && (strlen(qmi_response.imeisv_svn)<NAS_DMS_IMEISV_MAX_STR_SIZE))
      {
          error = qcril_other_hex_to_int(qmi_response.imeisv_svn, &imeisv_value);
          if( NAS_NIL == error && imeisv_value <= QMI_DMS_IMEISV_MAX_VALUE )
          {
              QCRIL_SNPRINTF( ril_resp_data_imeisv, NAS_DMS_IMEISV_MAX_STR_SIZE, "%02d", imeisv_value );
          }
          else
          {
            ril_req_res = RIL_E_GENERIC_FAILURE;
          }
      }
  }

  // ** respond
  qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, ril_req_res, &resp );
  if ( RIL_E_SUCCESS == ril_req_res )
  {
      resp.resp_pkt = ril_resp_data_imeisv;
      resp.resp_len = sizeof( ril_resp_data_imeisv );
  }
  qcril_send_request_response( &resp );
  QCRIL_LOG_INFO("completed with %d", (int) ril_req_res);
} // qcril_qmi_nas_dms_request_imeisv

//===========================================================================
//qmi_ril_is_qmi_sys_info_available
//===========================================================================
int qmi_ril_is_qmi_sys_info_available(void)
{
    int res;
    res = qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SVLTE2 ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_FUSION_CSFB ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8960 ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_7627A ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8974 ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8226 ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8610) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8916) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8994) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8909) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_8084) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDS ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_TSTS ) ||
          qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SRLTE );
    return res;
} // qmi_ril_is_qmi_sys_info_available


//===========================================================================
//qmi_ril_is_rat_tlv_support_available
//===========================================================================
int qmi_ril_is_rat_tlv_support_available(void)
{
    // return TRUE as all latest PLs support this.
    return TRUE;
} // qmi_ril_is_rat_tlv_support_available

//===========================================================================
//qcril_qmi_nas_update_voice_rte
//===========================================================================
void qcril_qmi_nas_update_voice_rte(void)
{
    int voice_rtes_reg_status[ QMI_RIL_RTE_CAP ];
    nas_sys_info_helper_type sys_info_helper;
    qmi_ril_nw_reg_rat_confidence_tag_type updated_voice_rte_confidence_tag;
    qmi_ril_nw_reg_rat_confidence_tag_type prev_voice_rte_confidence_tag;
    qmi_ril_nw_reg_rte_type updated_voice_rte;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &voice_rtes_reg_status, 0, sizeof( voice_rtes_reg_status ) );

    QCRIL_LOG_INFO( " .. prep CDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_1x ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_EMPTY,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep GSM" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep WCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep TDSCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep LTE" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
        voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_LTE,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( ".. 1x reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg %d", voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] );

    if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] )
    {
        updated_voice_rte = QMI_RIL_RTE_1x;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTERED_HOME_NET == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] && TRUE == nas_common_info.consider_lte_ltd_srv_vrte_update )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] && TRUE == nas_common_info.consider_lte_ltd_srv_vrte_update )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (  RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if (  RIL_VAL_REG_REGISTRATION_DENIED == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] && TRUE == nas_common_info.consider_lte_ltd_srv_vrte_update )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] )
    {
        updated_voice_rte = QMI_RIL_RTE_1x;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_WCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
    {
        updated_voice_rte = QMI_RIL_RTE_TDSCDMA;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
    {
        updated_voice_rte = QMI_RIL_RTE_GSM;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_1x ] )
    {
        updated_voice_rte = QMI_RIL_RTE_1x;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == voice_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
    {
        updated_voice_rte = QMI_RIL_RTE_SUB_LTE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }
    else
    {
        updated_voice_rte = QMI_RIL_RTE_NONE;
        updated_voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }

    prev_voice_rte_confidence_tag = nas_cached_info.voice_rte_confidence_tag;
    // update nas cached info
    nas_cached_info.voice_rte = updated_voice_rte;
    nas_cached_info.voice_rte_confidence_tag = updated_voice_rte_confidence_tag;
    QCRIL_LOG_INFO( "completed, new vrte %d with confidence %d", (int) nas_cached_info.voice_rte, (int) nas_cached_info.voice_rte_confidence_tag );

    // if service state changed between NO_SVC, FULL, LIMITTED, re-evaluate ecc list
    if ( updated_voice_rte_confidence_tag != prev_voice_rte_confidence_tag )
    {
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                QCRIL_DEFAULT_MODEM_ID,
                QCRIL_DATA_ON_STACK,
                QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                NULL,
                QMI_RIL_ZERO,
                (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    }
} // qcril_qmi_nas_update_voice_rte

//===========================================================================
//qcril_qmi_nas_update_data_rte
//===========================================================================
void qcril_qmi_nas_update_data_rte(void)
{
    int data_rtes_reg_status[ QMI_RIL_RTE_CAP ];
    qcril_arb_pref_data_tech_e_type pref_data_tech;
    qcril_arb_pref_data_type pref_data;
    int is_current;
    int is_data_rte_calculated;
    nas_sys_info_helper_type sys_info_helper;
    QCRIL_LOG_FUNC_ENTRY();

    memset( &data_rtes_reg_status, 0, sizeof( data_rtes_reg_status ) );
    memset( &pref_data, 0, sizeof( pref_data ) );
    is_data_rte_calculated = FALSE;

    qcril_qmi_get_pref_data_tech(&pref_data);
    qmi_ril_nw_reg_extend_pref_data_tech_cl( &pref_data, NULL, NULL );

    pref_data_tech = pref_data.pref_data_tech;
    is_current = pref_data.is_current;
    QCRIL_LOG_INFO(".. pref data tech %s, is current %d", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech), is_current );

    QCRIL_LOG_INFO( " .. prep CDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.cdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.cdma_sys_info ) ? &nas_cached_info.cdma_sys_info->common_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_1x ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep GSM" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.gsm_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) ? &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_GSM ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep WCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.wcdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) ? &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep TDSCDMA" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.tdscdma_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) ? &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep LTE" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp_srv_status = nas_cached_info.lte_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->common_sys_info : NULL;
        sys_info_helper.threegpp_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) ? &nas_cached_info.lte_sys_info->threegpp_specific_sys_info : NULL;
        sys_info_helper.voice_support_on_lte = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.voice_support_on_lte ) ? &nas_cached_info.voice_support_on_lte : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_3GPP | NAS_SYS_INFO_IS_DATA | NAS_SYS_INFO_IS_LTE,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( " .. prep EVDO" );
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_srv_status_info ) )
    {
        memset(&sys_info_helper, 0 ,sizeof(sys_info_helper));
        sys_info_helper.threegpp2_srv_status = nas_cached_info.hdr_srv_status_info;
        sys_info_helper.common_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->common_sys_info : NULL;
        sys_info_helper.hdr_only_sys_info = NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.hdr_sys_info ) ? &nas_cached_info.hdr_sys_info->hdr_specific_sys_info : NULL;
        data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] = qcril_qmi_nas_util_convert_nas_srv_status_to_ril_reg_status(NAS_SYS_INFO_IS_HDR | NAS_SYS_INFO_IS_DATA,
                                                                                                             &sys_info_helper);
    }

    QCRIL_LOG_INFO( ".. 1x reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO( ".. hdr reg data %d", data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] );

    if( QCRIL_ARB_PREF_DATA_TECH_INVALID != pref_data_tech ) //preferred data system indication availability; Reset all technologies except the pref tech system
    {
        QCRIL_LOG_INFO("CnE module available");
        if( TRUE == is_current )
        {
          QCRIL_LOG_INFO("with current status");
          if( QCRIL_ARB_PREF_DATA_TECH_UNKNOWN != pref_data_tech )
          {
            nas_cached_info.data_rte = qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(pref_data_tech);
            nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;

            is_data_rte_calculated = TRUE;
            QCRIL_LOG_INFO("data rte calculated");
          }
        }
        else
        {
          QCRIL_LOG_INFO("with legacy status");
        }

        QCRIL_LOG_INFO("preferred data tech available %s", qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech) );
        if( QCRIL_ARB_PREF_DATA_TECH_CDMA != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_1x ] )
        {
            QCRIL_LOG_INFO("resetting CDMA data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
            data_rtes_reg_status[ QMI_RIL_RTE_1x ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
        }
        if( QCRIL_ARB_PREF_DATA_TECH_EVDO != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
        {
            QCRIL_LOG_INFO("resetting EVDO data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
            data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
        }

        //Do not reset in case if the 3GPP limited service flag is set
        if( TRUE != nas_common_info.consider_3gpp_ltd_srv_drte_update )
        {
            if( QCRIL_ARB_PREF_DATA_TECH_GSM != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
            {
                QCRIL_LOG_INFO("resetting GSM data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_GSM ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
            if( QCRIL_ARB_PREF_DATA_TECH_UMTS != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
            {
                QCRIL_LOG_INFO("resetting UMTS data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
            if( QCRIL_ARB_PREF_DATA_TECH_TDSCDMA != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
            {
                QCRIL_LOG_INFO("resetting TDSCDMA data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
            if( QCRIL_ARB_PREF_DATA_TECH_LTE != pref_data_tech && RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING != data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
            {
                QCRIL_LOG_INFO("resetting LTE data reg status to RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING");
                data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] = RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING;
            }
        }
    }

    if( FALSE == is_data_rte_calculated )
    {
      if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_LTE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_DO;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_WCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_TDSCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_GSM;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTERED_HOME_NET == data_rtes_reg_status[ QMI_RIL_RTE_1x ] || RIL_VAL_REG_REGISTERED_ROAMING == data_rtes_reg_status[ QMI_RIL_RTE_1x ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_1x;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_LTE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_WCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_TDSCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] || RIL_VAL_REG_REGISTRATION_DENIED == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_GSM;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_LTE ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_LTE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_SUB_DO ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_SUB_DO;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_WCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_WCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_TDSCDMA ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_TDSCDMA;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_GSM ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_GSM;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else if ( RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV == data_rtes_reg_status[ QMI_RIL_RTE_1x ] )
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_1x;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
      }
      else
      {
          nas_cached_info.data_rte = QMI_RIL_RTE_NONE;
          nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
      }
    }

    QCRIL_LOG_DEBUG( "completed, new drte %d with confidence %d", (int) nas_cached_info.data_rte, (int) nas_cached_info.data_rte_confidence_tag  );

} // qcril_qmi_nas_update_data_rte

//===========================================================================
// qcril_qmi_nas_get_embms_status
//===========================================================================
uint8_t qcril_qmi_nas_get_embms_status(void)
{
    uint8_t is_available;

    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_LOCK();
    is_available = nas_cached_info.is_embms_available;
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET(is_available);
    return is_available;
}

//===========================================================================
// qcril_qmi_nas_update_embms_status
//===========================================================================
void qcril_qmi_nas_update_embms_status(void)
{
    uint8_t is_available = 0;
    uint32_t sub_capability = 0;
    int      instance_id = qmi_ril_get_process_instance_id();;

    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_LOCK();
    sub_capability = qcril_qmi_dms_convert_sub_capability_to_ril_radio_tech();

    if (sub_capability & (1 << RADIO_TECH_LTE))
    {
      is_available = 1;
    }

    if (is_available && (nas_common_info.dsds.is_default_data_set == TRUE) &&
         (nas_common_info.dsds.default_data_instance_id != instance_id))
    {
      is_available = 0;
    }

    nas_cached_info.is_embms_available = is_available;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_DEBUG("is_available %d", is_available);
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
//qcril_qmi_nas_update_ims_rte
//===========================================================================
void qcril_qmi_nas_update_ims_rte(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_cached_info.is_registered_on_ims )
    {
        nas_cached_info.ims_rte = QMI_RIL_RTE_WCDMA;
        nas_cached_info.ims_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_FULL_SVC;
    }
    else
    {
        nas_cached_info.ims_rte = QMI_RIL_RTE_NONE;
        nas_cached_info.ims_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_NO_SVC;
    }

    QCRIL_LOG_INFO( "completed, new irte %d with confidence %d", (int) nas_cached_info.ims_rte, (int) nas_cached_info.ims_rte_confidence_tag );

} // qcril_qmi_nas_update_ims_rte

//===========================================================================
//qcril_qmi_nas_util_map_pref_data_tech_to_data_rte
//===========================================================================
qmi_ril_nw_reg_rte_type qcril_qmi_nas_util_map_pref_data_tech_to_data_rte(qcril_arb_pref_data_tech_e_type pref_data_tech)
{
    qmi_ril_nw_reg_rte_type drte;

    QCRIL_LOG_INFO("entered, pref data tech is %s",qcril_qmi_util_retrieve_pref_data_tech_name(pref_data_tech));

    switch( pref_data_tech )
    {
      case QCRIL_ARB_PREF_DATA_TECH_CDMA:
        drte = QMI_RIL_RTE_1x;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_EVDO:
      case QCRIL_ARB_PREF_DATA_TECH_EHRPD:
        drte = QMI_RIL_RTE_SUB_DO;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_GSM:
        drte = QMI_RIL_RTE_GSM;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_UMTS:
        drte = QMI_RIL_RTE_WCDMA;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_TDSCDMA:
        drte = QMI_RIL_RTE_TDSCDMA;
        break;

      case QCRIL_ARB_PREF_DATA_TECH_LTE:
        drte = QMI_RIL_RTE_SUB_LTE;
        break;

      default:
        drte = QMI_RIL_RTE_NONE;
        break;
    }

    QCRIL_LOG_INFO( "completed, data rte is %d", drte );
    return drte;
} // qcril_qmi_nas_util_map_pref_data_tech_to_data_rte

//===========================================================================
//qmi_ril_nwr_get_eme_cbm
//===========================================================================
qmi_ril_emergency_callback_mode_state_type qmi_ril_nwr_get_eme_cbm()
{
    qmi_ril_emergency_callback_mode_state_type res;

    NAS_CACHE_LOCK();
    res = nas_cached_info.eme_cbm;
    NAS_CACHE_UNLOCK();

    return res;
} // qmi_ril_nwr_get_eme_cbm
//===========================================================================
//qmi_ril_nwr_set_eme_cbm
//===========================================================================
void qmi_ril_nwr_set_eme_cbm(qmi_ril_emergency_callback_mode_state_type new_mode)
{
    qmi_ril_emergency_callback_mode_state_type cur;
    qmi_ril_emergency_callback_mode_state_type rule;
    int go_on;
    int evt;
    qcril_unsol_resp_params_type          unsol_resp_params;

    QCRIL_LOG_INFO( "entered, mode requested %d", (int) new_mode );

    NAS_CACHE_LOCK();
    cur = nas_cached_info.eme_cbm;
    NAS_CACHE_UNLOCK();
    rule = cur;
    QCRIL_LOG_INFO( ".. cur %d", (int) cur );

    evt = NAS_NIL;
    if ( new_mode != cur )
    {
        switch ( new_mode )
        {
            case QMI_RIL_EME_CBM_NOT_ACTIVE:
                rule    = QMI_RIL_EME_CBM_NOT_ACTIVE;
                go_on   = TRUE;
                if ( QMI_RIL_EME_CBM_ACTIVE == cur )
                {
                    evt     = RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE;
                }
                break;

            case QMI_RIL_EME_CBM_ACTIVE:
                rule    = QMI_RIL_EME_CBM_ACTIVE;
                go_on   = TRUE;
                evt     = RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE;
                break;

            default:
                go_on = FALSE;
                break;
        }
    }
    else
    {
        go_on = FALSE;
    }

    QCRIL_LOG_INFO( ".. go_on, rule %d, %d", (int) go_on, (int) rule );
    if ( go_on )
    {
        boolean is_eme_ip;
        NAS_CACHE_LOCK();
        nas_cached_info.eme_cbm = rule;
        is_eme_ip = nas_cached_info.is_eme_ip_call;
        NAS_CACHE_UNLOCK();
        if ( NAS_NIL != evt )
        {
            if (!is_eme_ip || !qcril_qmi_voice_get_jbims())
            {
                qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, evt, &unsol_resp_params );
                qcril_send_unsol_response( &unsol_resp_params );
            }
            else
            {
                Ims__MsgId msg_id;
                if (RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE == evt)
                {
                    msg_id = IMS__MSG_ID__UNSOL_EXIT_EMERGENCY_CALLBACK_MODE;
                }
                else
                {
                    msg_id = IMS__MSG_ID__UNSOL_ENTER_EMERGENCY_CALLBACK_MODE;
                }
                qcril_qmi_ims_socket_send_empty_payload_unsol_resp(msg_id);
            }
        }

        if( RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE == evt)
        {
            qcril_sms_clearing_cdma_ack();
            if ( !qcril_qmi_voice_nas_control_is_any_calls_present() )
            {
                qcril_setup_timed_callback (QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally,
                                            NULL,
                                            NULL);
            }
        }
    }

    QCRIL_LOG_INFO( "completed, new mode %d", (int) rule );
} // qmi_ril_nwr_set_eme_cbm
//===========================================================================
//qmi_ril_nwr_update_reg_rej_from_sys_info
//===========================================================================
void qmi_ril_nwr_update_reg_rej_from_sys_info(void)
{
    int rte_reg_status[ QMI_RIL_RTE_CAP ];
    qmi_ril_nw_reg_rte_type rte_idx;
    nas_3gpp_only_sys_info_type_v01*  sys_info_3gpp_only;
    nas_3gpp_srv_status_info_type_v01 *srv_status_3gpp;
    qcril_qmi_nas_srv_status_convertion_extra_results_type rte_srv_status_extras[ QMI_RIL_RTE_CAP ];
    int nof_cs_reg_reject;
    int do_switch_rte;

    QCRIL_LOG_FUNC_ENTRY();

    // voice
    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
    memset( &rte_srv_status_extras, 0, sizeof(rte_srv_status_extras) );
    qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, rte_srv_status_extras );
    QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

    nof_cs_reg_reject = NAS_NIL;
    for ( rte_idx = QMI_RIL_RTE_FIRST; rte_idx < QMI_RIL_RTE_CAP; rte_idx++ )
    {
      if ( nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected )
      {
        nof_cs_reg_reject++;
      }
    }
    QCRIL_LOG_INFO( ".. nof cs reg reject %d, cs reg reject for direct inj %d",
                    nof_cs_reg_reject,
                    nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected );
    if ( nof_cs_reg_reject > QMI_RIL_SINGLE &&
         nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected &&
         nas_cached_info.reg_reject_sys_info [ QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION ].cs_rejected_assumed
         )
    {
      QCRIL_LOG_INFO( ".. clear assumed");
      qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_NW_REG_RAT_DIRECT_REG_REJECT_INJECTION, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED );
    }

    for ( rte_idx = QMI_RIL_RTE_FIRST; rte_idx < QMI_RIL_RTE_CAP; rte_idx++ )
    {
        sys_info_3gpp_only = NULL;
        srv_status_3gpp    = NULL;
        switch ( rte_idx )
        {
            case QMI_RIL_RTE_GSM:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.gsm_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_WCDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.wcdma_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_TDSCDMA:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.tdscdma_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                }
                break;

            case QMI_RIL_RTE_SUB_LTE:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_srv_status_info ) )
                {
                    srv_status_3gpp = nas_cached_info.lte_srv_status_info;
                }
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                {
                    sys_info_3gpp_only             = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                }
                break;

            default:
                // nothing for 3gpp2
                break;
        }

        QCRIL_LOG_INFO( ".. ext info is_reject_case %d, is_managed_roaming %d, reject_cause %d",
                        (int)rte_srv_status_extras[rte_idx].is_reject_case,
                        (int)rte_srv_status_extras[rte_idx].is_managed_roaming,
                        (int)rte_srv_status_extras[rte_idx].reject_cause);
        if ( rte_srv_status_extras[rte_idx].is_reject_case && rte_srv_status_extras[rte_idx].is_managed_roaming )
        {
            qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
            nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause             = rte_srv_status_extras[rte_idx].reject_cause;
            nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected_managed_roaming = TRUE;
            if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
            { // attach mcc/mnc
                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
            }
        }
        else
        {
            switch ( rte_reg_status[rte_idx] )
            {
                case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                case RIL_VAL_REG_REGISTRATION_DENIED:
                    if ( sys_info_3gpp_only && sys_info_3gpp_only->reg_reject_info_valid )
                    {
                        switch ( sys_info_3gpp_only->reg_reject_info.reject_srv_domain )
                        {
                            case SYS_SRV_DOMAIN_CS_ONLY_V01:    // fallthrough
                            case SYS_SRV_DOMAIN_CS_PS_V01:
                                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                                nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause            = sys_info_3gpp_only->reg_reject_info.rej_cause;
                                if ( sys_info_3gpp_only->network_id_valid )
                                { // attach mcc/mnc cause
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                                }
                                break;

                            default:
                                // skip PS etc
                                break;
                        }
                    }
                    break;

                case RIL_VAL_REG_REGISTERED_HOME_NET:
                case RIL_VAL_REG_REGISTERED_ROAMING:
                    if ( !nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected || nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause_relayed )
                    {
                        // reset if full service
                        QCRIL_LOG_INFO( ".. abandoning cs_rejected as full service" );
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
                    }
                    break;

                default:
                    if ( nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected  )
                    {
                        QCRIL_LOG_INFO( ".. cs reject follow up on re-reg to ltd" );
                        do
                        {
                            // mcc/mnc to refetch?
                            if (
                                qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc )
                                ||
                                qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc )
                                )
                            {
                                QCRIL_LOG_INFO( ".. cached mcc/mnc are empty, need re-fetch" );
                                if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
                                {
                                    QCRIL_LOG_INFO( ".. re-fetching" );
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                    memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                                    qmi_ril_nwr_util_log_mccmnc_str(".. refetched mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc);
                                    qmi_ril_nwr_util_log_mccmnc_str(".. refetched mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc);

                                    break;
                                }
                            }

                            // cell changed?
                            if (
                                 sys_info_3gpp_only
                                 &&
                                 sys_info_3gpp_only->network_id_valid
                                 &&
                                 ( NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01 )
                                   ||
                                   NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01 )
                                 )
                                 &&
                                 nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause_relayed
                                )
                            { // jumped to another cell
                                QCRIL_LOG_INFO( ".. abandoning cs_rejected as switched cell" );
                                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                                break;
                            }

                            // no longer in any service
                            if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == rte_reg_status[ rte_idx ] ||
                                 RIL_VAL_REG_UNKNOWN == rte_reg_status[ rte_idx ] ||
                                 RIL_VAL_REG_NOT_REGISTERED_SEARCHING  == rte_reg_status[ rte_idx ] )
                            {
                              QCRIL_LOG_INFO( ".. lost ltd svc on rejected rat cs" );
                              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                              break;
                            }

                            // changed because of full or limited srv on another RAT
                            if ( QMI_RIL_RTE_NONE != nas_cached_info.voice_rte &&
                                 rte_idx != nas_cached_info.voice_rte &&
                                 ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag ||
                                   QMI_RIL_RAT_CONFIDENCE_LTD_SVC  == nas_cached_info.voice_rte_confidence_tag
                                 )
                                )
                            {
                              qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED );
                              QCRIL_LOG_INFO( ".. abandoning because another RAT in full svc (%d) ", (int)nas_cached_info.voice_rte);
                              // no break here
                            }

                            // enforce report
                            if ( QMI_RIL_RTE_NONE != nas_cached_info.voice_rte && nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected )
                            {
                              do_switch_rte = FALSE;
                              if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC != nas_cached_info.voice_rte_confidence_tag )
                              {
                                switch ( rte_reg_status[ nas_cached_info.voice_rte ] )
                                {
                                    case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:
                                    case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:
                                    case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                                    case RIL_VAL_REG_UNKNOWN:
                                        do_switch_rte = TRUE;
                                        break;

                                    default:
                                        // no change
                                        break;
                                }
                                if ( do_switch_rte &&
                                     ( nas_cached_info.voice_rte != rte_idx ) &&
                                     !( rte_idx == QMI_RIL_RTE_SUB_LTE && QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag )
                                    )
                                {
                                  nas_cached_info.voice_rte                = rte_idx;
                                  nas_cached_info.voice_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
                                  QCRIL_LOG_INFO(  ".. adjusted voice rte to %d", (int) nas_cached_info.voice_rte );
                                }
                              }
                            }
                        } while ( FALSE );
                    }
                    break;
            }
        }

        QCRIL_LOG_INFO( ".. rte %d reje CS cs_rejected %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_rejected );
        QCRIL_LOG_INFO( ".. rte %d reje CS cs_reject_cause %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].cs_reject_cause );
        qmi_ril_nwr_util_log_mccmnc_str(".. reje mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mcc);
        qmi_ril_nwr_util_log_mccmnc_str(".. reje mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].org_mnc);

    }

    // data
    memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
    qcril_qmi_sys_info_roll_details( rte_reg_status, TRUE, NULL );
    QCRIL_LOG_INFO( ".. 1x reg data %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
    QCRIL_LOG_INFO( ".. gsm reg data %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
    QCRIL_LOG_INFO( ".. wcdma reg data  %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
    QCRIL_LOG_INFO( ".. tdscdma reg data  %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
    QCRIL_LOG_INFO( ".. lte reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
    QCRIL_LOG_INFO( ".. hdr reg data %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

    for ( rte_idx = QMI_RIL_RTE_FIRST; rte_idx < QMI_RIL_RTE_CAP; rte_idx++ )
    {
        switch ( rte_reg_status[rte_idx] )
        {
            case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
            case RIL_VAL_REG_REGISTRATION_DENIED:
                sys_info_3gpp_only = NULL;
                switch ( rte_idx )
                {
                    case QMI_RIL_RTE_GSM:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.gsm_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.gsm_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_WCDMA:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.wcdma_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.wcdma_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_TDSCDMA:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.tdscdma_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.tdscdma_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    case QMI_RIL_RTE_SUB_LTE:
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.lte_sys_info ) )
                        {
                            sys_info_3gpp_only             = &nas_cached_info.lte_sys_info->threegpp_specific_sys_info;
                        }
                        break;

                    default:
                        // nothing for 3gpp2
                        break;
                }
                if ( sys_info_3gpp_only && sys_info_3gpp_only->reg_reject_info_valid )
                {
                    switch ( sys_info_3gpp_only->reg_reject_info.reject_srv_domain )
                    {
                        case SYS_SRV_DOMAIN_PS_ONLY_V01:    // fallthrough
                        case SYS_SRV_DOMAIN_CS_PS_V01:
                            qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                            nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause            = sys_info_3gpp_only->reg_reject_info.rej_cause;
                            if ( sys_info_3gpp_only->network_id_valid )
                            { // attach mcc/mnc
                                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                            }
                            break;

                        default:
                            // skip PS etc
                            break;
                    }
                }
                break;

            case RIL_VAL_REG_REGISTERED_HOME_NET:
            case RIL_VAL_REG_REGISTERED_ROAMING:
                // reset unconditionally if full service
                QCRIL_LOG_INFO( ".. drop as full svc" );
                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
                break;

            default:
                // reset if relayed
                if ( nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_rejected  )
                {
                    QCRIL_LOG_INFO( ".. ps reject follow up on re-reg to ltd" );
                    do
                    {

                        // re-fetch mcc/mnc
                        if (
                                 qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc )
                                 ||
                                 qmi_ril_nwr_is_mcc_or_mnc_empty( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc )
                            )
                        {
                            QCRIL_LOG_INFO( ".. data cached mcc/mnc are empty, need re-fetch" );
                            if ( sys_info_3gpp_only && sys_info_3gpp_only->network_id_valid )
                            {
                                     QCRIL_LOG_INFO( ".. data re-fetching" );
                                     memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01);
                                     memcpy( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01);
                                     qmi_ril_nwr_util_log_mccmnc_str(".. data refetched mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc);
                                     qmi_ril_nwr_util_log_mccmnc_str(".. data refetched mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc);

                                     break;
                            }
                        }

                        // mcc/mnc changed ?
                        if (
                             sys_info_3gpp_only
                             &&
                             sys_info_3gpp_only->network_id_valid
                             &&
                             ( NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc, sys_info_3gpp_only->network_id.mcc, NAS_MCC_MNC_MAX_V01 )
                               ||
                               NAS_NIL != memcmp( nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc, sys_info_3gpp_only->network_id.mnc, NAS_MCC_MNC_MAX_V01 )
                             )
                             &&
                             nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause_relayed
                            )
                        { // jumped to another cell
                            QCRIL_LOG_INFO( ".. drop as jumped cell" );
                            qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                            break;
                        }

                        // no longer in any service
                        if ( RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING == rte_reg_status[ rte_idx ] ||
                             RIL_VAL_REG_UNKNOWN == rte_reg_status[ rte_idx ] ||
                             RIL_VAL_REG_NOT_REGISTERED_SEARCHING  == rte_reg_status[ rte_idx ] )
                        {
                          QCRIL_LOG_INFO( ".. lost ltd svc on rejected rat ps" );
                          qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

                          break;
                        }

                        // changed because of full or limited srv on another RAT
                        if ( QMI_RIL_RTE_NONE != nas_cached_info.data_rte &&
                             rte_idx != nas_cached_info.data_rte &&
                             ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag ||
                               QMI_RIL_RAT_CONFIDENCE_LTD_SVC  == nas_cached_info.data_rte_confidence_tag
                             )
                            )
                        {
                          qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, rte_idx, QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED );
                          // no break here
                        }

                        // not relayed - shift data RTE if not full service
                        if ( QMI_RIL_RTE_NONE != nas_cached_info.data_rte && nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_rejected )
                        {
                          do_switch_rte = FALSE;
                          if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC != nas_cached_info.data_rte_confidence_tag )
                          {
                            switch ( rte_reg_status[ nas_cached_info.data_rte ] )
                            {
                                case RIL_VAL_REG_NOT_REGISTERED_SEARCHING:
                                case RIL_VAL_REG_NOT_REGISTERED_NOT_SEARCHING:
                                case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                                case RIL_VAL_REG_UNKNOWN:
                                    do_switch_rte = TRUE;
                                    break;

                                default:
                                    // no change
                                    do_switch_rte = FALSE;
                                    break;
                            }
                          }
                          if ( do_switch_rte && ( rte_idx != nas_cached_info.data_rte ) )
                          {
                            nas_cached_info.data_rte                = rte_idx;
                            nas_cached_info.data_rte_confidence_tag = QMI_RIL_RAT_CONFIDENCE_LTD_SVC;
                            QCRIL_LOG_INFO(  ".. adjusted data rte to %d", (int) nas_cached_info.data_rte );
                          }
                        }
                    } while (FALSE);
                }
                break;
        }

        QCRIL_LOG_INFO( ".. rte %d reje PS ps_rejected %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_rejected );
        QCRIL_LOG_INFO( ".. rte %d reje PS ps_reject_cause %d", (int)rte_idx, nas_cached_info.reg_reject_sys_info [ rte_idx ].ps_reject_cause );
        qmi_ril_nwr_util_log_mccmnc_str(".. data reje mcc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mcc);
        qmi_ril_nwr_util_log_mccmnc_str(".. data reje mnc", nas_cached_info.reg_reject_sys_info [ rte_idx ].data_org_mnc);

    }

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_update_reg_rej_from_sys_info
//===========================================================================
//qmi_ril_nwr_update_reg_rej_legacy
//===========================================================================
void qmi_ril_nwr_update_reg_rej_legacy(void)
{
    QCRIL_LOG_FUNC_ENTRY();

    int psc;
    int csc;

    int drifted;

    char * mccmnc_param_str;
    char mcc_mnc_buf[ 2*NAS_MCC_MNC_MAX_V01 + 2];

    if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.serving_system) )
    {
        QCRIL_LOG_INFO( ".. ss srv reg state %d", (int)nas_cached_info.serving_system->registration_state );
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason ) )
        {
            QCRIL_LOG_INFO( ".. ss srv reg reject srv domain, cause  %d, %d", (int)nas_cached_info.registration_reject_reason->service_domain, (int) nas_cached_info.registration_reject_reason->reject_cause );
        }
        switch ( nas_cached_info.serving_system->registration_state  )
        {
            case NAS_VAL_REGISTRATION_DENIED:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.registration_reject_reason ) )
                {
                    switch ( nas_cached_info.registration_reject_reason->service_domain )
                    {
                        case NAS_CIRCUIT_SWITCHED_V01:
                            csc = TRUE;
                            psc = FALSE;
                            break;

                        case NAS_PACKET_SWITCHED_V01:
                            csc = FALSE;
                            psc = TRUE;
                            break;

                        case NAS_CIRCUIT_AND_PACKET_SWITCHED_V01:
                            csc = TRUE;
                            psc = TRUE;
                            break;

                        default:
                            // skip
                            csc = FALSE;
                            psc = FALSE;
                            break;
                    }
                    if ( csc )
                    {
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                        nas_cached_info.reg_reject_legacy.cs_reject_cause           = nas_cached_info.registration_reject_reason->reject_cause;
                    }
                    if ( psc )
                    {
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED );
                        nas_cached_info.reg_reject_legacy.ps_reject_cause           = nas_cached_info.registration_reject_reason->reject_cause;
                    }
                    if ( csc || psc )
                    {
                        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mnc_includes_pcs_digit ) )
                        { // attach mcc/mnc
                            if ( nas_cached_info.mnc_includes_pcs_digit->mnc > 99 || TRUE == nas_cached_info.mnc_includes_pcs_digit->mnc_includes_pcs_digit )
                            {
                                mccmnc_param_str = "%03d%03d";
                            }
                            else
                            {
                                mccmnc_param_str = "%03d%02d";
                            }
                            snprintf( mcc_mnc_buf, sizeof(mcc_mnc_buf), mccmnc_param_str, (int)nas_cached_info.mnc_includes_pcs_digit->mcc, (int)nas_cached_info.mnc_includes_pcs_digit->mnc );
                            memcpy(nas_cached_info.reg_reject_legacy.org_mcc, mcc_mnc_buf, NAS_MCC_MNC_MAX_V01 );
                            memcpy(nas_cached_info.reg_reject_legacy.org_mnc, mcc_mnc_buf + NAS_MCC_MNC_MAX_V01, NAS_MCC_MNC_MAX_V01 );
                        }
                    }
                }
                break;

          case NAS_VAL_REGISTERED:
              if ( !nas_cached_info.reg_reject_legacy.cs_rejected || nas_cached_info.reg_reject_legacy.cs_reject_cause_relayed )
              {
                  qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );

              }
              if ( !nas_cached_info.reg_reject_legacy.ps_rejected || nas_cached_info.reg_reject_legacy.ps_reject_cause_relayed )
              {
                  qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
              }
              break;

          case NAS_NOT_REGISTERED_V01: // lost even limited service
            if ( !nas_cached_info.reg_reject_legacy.ps_rejected || nas_cached_info.reg_reject_legacy.ps_reject_cause_relayed )
            {
                qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
            }
            break;

          default:
                if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.mnc_includes_pcs_digit ) )
                {
                    if ( nas_cached_info.mnc_includes_pcs_digit->mnc > 99 || TRUE == nas_cached_info.mnc_includes_pcs_digit->mnc_includes_pcs_digit )
                    {
                        mccmnc_param_str = "%03d%03d";
                    }
                    else
                    {
                        mccmnc_param_str = "%03d%02d";
                    }
                    snprintf( mcc_mnc_buf, sizeof(mcc_mnc_buf), mccmnc_param_str, (int)nas_cached_info.mnc_includes_pcs_digit->mcc, (int)nas_cached_info.mnc_includes_pcs_digit->mnc );
                    drifted = (
                               NAS_NIL != memcmp( nas_cached_info.reg_reject_legacy.org_mcc, mcc_mnc_buf, NAS_MCC_MNC_MAX_V01 )
                               ||
                               NAS_NIL != memcmp( nas_cached_info.reg_reject_legacy.org_mnc, mcc_mnc_buf + NAS_MCC_MNC_MAX_V01, NAS_MCC_MNC_MAX_V01 )
                              );
                }
                else
                {
                    drifted = FALSE;
                }
                if ( nas_cached_info.reg_reject_legacy.cs_rejected )
                {
                    if ( drifted && nas_cached_info.reg_reject_legacy.cs_reject_cause_relayed )
                    {
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_VOICE, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
                    }
                }
                if ( nas_cached_info.reg_reject_legacy.ps_rejected )
                {
                    if ( drifted && nas_cached_info.reg_reject_legacy.ps_reject_cause_relayed )
                    {
                        qmi_ril_nwr_reg_reject_handle_event_cl( QMI_RIL_RTE_KIND_DATA, QMI_RIL_RTE_NONE, QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED );
                    }
                }
                break;
        }
    }

    QCRIL_LOG_INFO( ".. reje CS cs_rejected %d", nas_cached_info.reg_reject_legacy.cs_rejected );
    QCRIL_LOG_INFO( ".. reje CS cs_reject_cause %d", nas_cached_info.reg_reject_legacy.cs_reject_cause );

    QCRIL_LOG_INFO( ".. reje PS ps_rejected %d", nas_cached_info.reg_reject_legacy.ps_rejected );
    QCRIL_LOG_INFO( ".. reje PS ps_reject_cause %d", nas_cached_info.reg_reject_legacy.ps_reject_cause );

    qmi_ril_nwr_util_log_mccmnc_str(".. reje mcc", nas_cached_info.reg_reject_legacy.org_mcc);
    qmi_ril_nwr_util_log_mccmnc_str(".. reje mnc", nas_cached_info.reg_reject_legacy.org_mnc);

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_update_reg_rej_legacy
//===========================================================================
//qmi_ril_nwr_util_log_mccmnc_str
//===========================================================================
void qmi_ril_nwr_util_log_mccmnc_str(char * ctx, char *mcc_or_mnc_arr)
{
    char mccmnc_str[NAS_MCC_MNC_MAX_V01 + 2];
    char outcome[ QCRIL_MAX_LOG_MSG_SIZE ];

    if ( ctx && mcc_or_mnc_arr)
    {
        memcpy( mccmnc_str, mcc_or_mnc_arr, NAS_MCC_MNC_MAX_V01  );
        mccmnc_str[NAS_MCC_MNC_MAX_V01] = 0;

        snprintf(outcome, sizeof(outcome), "%s - %s", ctx, mccmnc_str );

        QCRIL_LOG_INFO(outcome);
    }
} // qmi_ril_nwr_util_log_mccmnc_str
//=========================================================================
//qmi_ril_nwr_is_mcc_or_mnc_empty
//===========================================================================
int qmi_ril_nwr_is_mcc_or_mnc_empty(char * mcc_or_mnc_str)
{
    int res;

    if (mcc_or_mnc_str)
    {
        res = (NAS_NIL == mcc_or_mnc_str[0] || NAS_NIL == mcc_or_mnc_str[1]);
    }
    else
    {
        res = TRUE;
    }
    return res;
} // qmi_ril_nwr_is_mcc_or_mnc_empty
//=========================================================================
//qmi_ril_nwr_reg_reject_init
//===========================================================================
void qmi_ril_nwr_reg_reject_init(void)
{
  NAS_CACHE_LOCK();

  memset( nas_cached_info.reg_reject_sys_info, 0, sizeof( qmi_ril_reg_reject_cached_summary_type ) * QMI_RIL_RTE_CAP  );
  memset( &nas_cached_info.reg_reject_legacy, 0, sizeof( qmi_ril_reg_reject_cached_summary_type ) );

  memset( &nas_cached_info.reg_reject_expiry_tmr_id, 0, sizeof( uint32 ) * QMI_RIL_RTE_KIND_CAP );

  NAS_CACHE_UNLOCK();
} // qmi_ril_nwr_reg_reject_init
//=========================================================================
//qmi_ril_nwr_reg_reject_handle_event
//===========================================================================
void qmi_ril_nwr_reg_reject_handle_event_cl( qmi_ril_nw_reg_rte_kind_type rte_kind, qmi_ril_nw_reg_rte_type rte, qmi_ril_reg_reject_perception_event_e_type evt ) // cache must be locked
{
  qmi_ril_reg_reject_cached_summary_type * summary;
  int                                      must_clear_tmr;
  int                                      must_clear;
  int                                      must_start_tmr;
  int                                      must_check_for_clear;
  int                                      must_schedule_refresh;
  uint32*                                  tmr_id;
  static const struct timeval              tmr_expity_value = { 1, 0 }; // 1 second
  qmi_ril_reg_reject_tmr_expry_passover_type *
                                           passover;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_LOG_INFO( ".. rte_kind %d, rte %d, evt %d", (int) rte_kind, (int) rte,(int)evt );

  if ( !qmi_ril_is_qmi_sys_info_available() )
  {
    summary = &nas_cached_info.reg_reject_legacy;
  }
  else
  {
    summary = &nas_cached_info.reg_reject_sys_info[ rte ];
  }

  tmr_id = &nas_cached_info.reg_reject_expiry_tmr_id[ rte_kind ];

  must_clear_tmr        = FALSE;
  must_clear            = FALSE;
  must_start_tmr        = FALSE;
  must_check_for_clear  = FALSE;
  must_schedule_refresh = FALSE;

  switch ( evt )
  {
    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_SETTLED:
      switch ( rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:
           if ( !summary->cs_rejected )
           {
              summary->cs_rejected             = TRUE;
              summary->cs_reject_cause_relayed = FALSE;
              memset( summary->org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
              memset( summary->org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
              must_clear_tmr = TRUE;
              must_start_tmr = TRUE;
          }
          break;

        case QMI_RIL_RTE_KIND_DATA:
           if ( !summary->ps_rejected )
           {
              summary->ps_rejected             = TRUE;
              summary->ps_reject_cause_relayed = FALSE;
              memset( summary->data_org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
              memset( summary->data_org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
              must_clear_tmr = TRUE;
              must_start_tmr = TRUE;
           }
          break;

        default: // nothing
          break;
      }
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_RELAYED:
      switch ( rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:
          if ( summary->cs_rejected )
          {
            summary->cs_reject_cause_relayed = TRUE;
          }
          break;

        case QMI_RIL_RTE_KIND_DATA:
          if ( summary->ps_rejected )
          {
            summary->ps_reject_cause_relayed = TRUE;
          }
          break;

        default: // nothing
          break;
      }
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_EXPIRED:
      *tmr_id = NAS_NIL;
      must_schedule_refresh = TRUE;
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_OUTDATED:
      must_clear = TRUE;
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_CLEARED:
      must_clear = TRUE;
      break;

    case QMI_RIL_REG_REJECT_PERCEPTION_EVT_CONSIDER_OUTDATED:
      switch ( rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:
          if ( summary->cs_rejected && summary->cs_reject_cause_relayed && NAS_NIL == *tmr_id )
          {
            must_clear            = TRUE;
          }
          break;

        case QMI_RIL_RTE_KIND_DATA:
          if ( summary->ps_rejected && summary->ps_reject_cause_relayed && NAS_NIL == *tmr_id )
          {
            must_clear            = TRUE;
          }
          break;

        default: // nothing
          break;
      }
      break;

    default:
      break;
  }

  if ( must_check_for_clear )
  {
    switch ( rte_kind )
    {
      case QMI_RIL_RTE_KIND_VOICE:
        if ( summary->cs_rejected && summary->cs_reject_cause_relayed && NAS_NIL == *tmr_id )
        {
          must_clear            = TRUE;
          must_schedule_refresh = TRUE;
        }
        break;

      case QMI_RIL_RTE_KIND_DATA:
        if ( summary->ps_rejected && summary->ps_reject_cause_relayed && NAS_NIL == *tmr_id )
        {
          must_clear            = TRUE;
          must_schedule_refresh = TRUE;
        }
        break;

      default: // nothing
        break;
    }
  }

  if ( must_schedule_refresh )
  {
    passover = qcril_malloc( sizeof( *passover ) );
    if ( NULL != passover )
    {
      passover->rte_kind = rte_kind;
      passover->rte      = rte;

      qcril_setup_timed_callback_ex_params_adv(
                                    QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qmi_ril_nwr_reg_reject_post_refresher,
                                    (void*)passover,
                                    TRUE,
                                    NULL,   // immediate
                                    NULL );
    }
  }

  if ( must_clear )
  {
    switch ( rte_kind )
    {
      case QMI_RIL_RTE_KIND_VOICE:
        summary->cs_rejected             = FALSE;
        summary->cs_reject_cause_relayed = FALSE;
        summary->cs_reject_cause         = NAS_NIL;
        memset( summary->org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
        memset( summary->org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
        break;

      case QMI_RIL_RTE_KIND_DATA:
        summary->ps_rejected = FALSE;
        summary->ps_reject_cause_relayed = FALSE;
        summary->ps_reject_cause         = NAS_NIL;
        memset( summary->data_org_mcc, 0, NAS_MCC_MNC_MAX_V01 );
        memset( summary->data_org_mnc, 0, NAS_MCC_MNC_MAX_V01 );
        break;

      default: // nothing
        break;
    }
    must_clear_tmr = TRUE;
  }

  if ( must_clear_tmr )
  {
    if ( NAS_NIL != *tmr_id )
    {
      qcril_cancel_timed_callback( (void*)(intptr_t)*tmr_id );
      *tmr_id = NAS_NIL;
    }
  }

  if ( must_start_tmr )
  {
    passover = qcril_malloc( sizeof( *passover ) );
    if ( NULL != passover )
    {
      passover->rte_kind = rte_kind;
      passover->rte      = rte;

      qcril_setup_timed_callback_ex_params_adv(
                                    QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qmi_ril_nwr_reg_reject_tmr_expiry,
                                    (void*)passover,
                                    TRUE,
                                    &tmr_expity_value,
                                    tmr_id );

    }
  }

  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// qmi_ril_nwr_reg_reject_tmr_expiry
//===========================================================================
void qmi_ril_nwr_reg_reject_tmr_expiry(qcril_timed_callback_handler_params_type * handler_params)
{
    qmi_ril_reg_reject_tmr_expry_passover_type * passover;
    QCRIL_LOG_FUNC_ENTRY();

    passover = (qmi_ril_reg_reject_tmr_expry_passover_type*) handler_params->custom_param;

    if ( NULL != passover )
    {
      NAS_CACHE_LOCK();

      qmi_ril_nwr_reg_reject_handle_event_cl( passover->rte_kind, passover->rte, QMI_RIL_REG_REJECT_PERCEPTION_EVT_EXPIRED );

      NAS_CACHE_UNLOCK();
    }

    qcril_free( passover );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_reg_reject_tmr_expiry
//===========================================================================
// qmi_ril_nwr_reg_reject_post_refresher
//===========================================================================
void qmi_ril_nwr_reg_reject_post_refresher(qcril_timed_callback_handler_params_type * handler_params)
{
    qmi_ril_reg_reject_tmr_expry_passover_type * passover;
    qcril_unsol_resp_params_type                 unsol_resp;


    QCRIL_LOG_FUNC_ENTRY();
    passover = (qmi_ril_reg_reject_tmr_expry_passover_type*) handler_params->custom_param;

    if ( NULL != passover )
    {
      NAS_CACHE_LOCK();

      switch( passover->rte_kind )
      {
        case QMI_RIL_RTE_KIND_VOICE:        // fallthrough
          case QMI_RIL_RTE_KIND_DATA:
          qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, (int) RIL_UNSOL_RESPONSE_NETWORK_STATE_CHANGED, &unsol_resp );
          qcril_send_unsol_response( &unsol_resp );
          break;

        default: // nothing
          break;
      }

      NAS_CACHE_UNLOCK();
    }

    qcril_free( passover );

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwr_reg_reject_post_refresher


//=========================================================================
//qcril_qmi_nas_managed_roaming_ind_handler
//===========================================================================
void qcril_qmi_nas_managed_roaming_ind_handler(int * reg_report)
{
    QCRIL_LOG_FUNC_ENTRY();
    if ( !qmi_ril_is_qmi_sys_info_available() )
    {
        QCRIL_LOG_INFO( "%s", ".. managed roaming legacy");
        nas_cached_info.reg_reject_legacy.cs_rejected                   = TRUE;
        nas_cached_info.reg_reject_legacy.cs_reject_cause_relayed       = FALSE;
        nas_cached_info.reg_reject_legacy.cs_reject_cause               = RIL_VAL_REG_MANAGED_ROAMING_CAUSE;
        nas_cached_info.reg_reject_legacy.cs_rejected_managed_roaming   = TRUE;

        *reg_report = TRUE;
    }
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_managed_roaming_ind_handler
//=========================================================================
//qmi_ril_nw_reg_get_status_overview
//===========================================================================
uint32_t qmi_ril_nw_reg_get_status_overview( void )
{
    uint32_t res = NAS_NIL;
    int rte_reg_status[ QMI_RIL_RTE_CAP ];
    qmi_ril_nw_reg_rte_type idx_rte;

    QCRIL_LOG_FUNC_ENTRY();

    if ( qmi_ril_is_qmi_sys_info_available() )
    {
        memset( &rte_reg_status, 0, sizeof( rte_reg_status ) );
        NAS_CACHE_LOCK();
        qcril_qmi_sys_info_roll_details( rte_reg_status, FALSE, NULL );
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO( ".. 1x reg %d", rte_reg_status[ QMI_RIL_RTE_1x ] );
        QCRIL_LOG_INFO( ".. gsm reg %d", rte_reg_status[ QMI_RIL_RTE_GSM ] );
        QCRIL_LOG_INFO( ".. wcdma reg %d", rte_reg_status[ QMI_RIL_RTE_WCDMA ] );
        QCRIL_LOG_INFO( ".. tdscdma reg %d", rte_reg_status[ QMI_RIL_RTE_TDSCDMA ] );
        QCRIL_LOG_INFO( ".. lte reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_LTE ] );
        QCRIL_LOG_INFO( ".. hdr reg %d", rte_reg_status[ QMI_RIL_RTE_SUB_DO ] );

        for ( idx_rte = QMI_RIL_RTE_FIRST; idx_rte <= QMI_RIL_RTE_LAST ; idx_rte++)
        {
            switch ( rte_reg_status[ idx_rte ] )
            {
                case RIL_VAL_REG_REGISTERED_HOME_NET:
                case RIL_VAL_REG_REGISTERED_ROAMING:
                    res |= QMI_RIL_NW_REG_FULL_SERVICE;
                    switch ( idx_rte )
                    {
                        case QMI_RIL_RTE_GSM:
                        case QMI_RIL_RTE_WCDMA:
                        case QMI_RIL_RTE_TDSCDMA:
                            res |= QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
                            break;

                        case QMI_RIL_RTE_SUB_LTE:
                            res |= QMI_RIL_NW_REG_VOIP_CALLS_AVAILABLE;
                            break;

                        default:
                            // nothing
                            break;
                    }
                    break;

                case RIL_VAL_REG_NOT_REGISTERED_SEARCHING_LTD_SRV:
                case RIL_VAL_REG_REGISTRATION_DENIED_LTD_SRV:
                    res |= QMI_RIL_NW_REG_LIMITED_SERVICE | QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
                    break;

                deafult:
                    // nothing
                    break;
            }
            if ( RIL_VAL_REG_REGISTERED_HOME_NET == rte_reg_status[ idx_rte ] || RIL_VAL_REG_REGISTERED_ROAMING == rte_reg_status[ idx_rte ] )
            {
                res = TRUE;
            }
        }

    }
    else
    {
        NAS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.serving_system ) )
        {
            switch ( nas_cached_info.serving_system->registration_state )
            {
                case NAS_REGISTERED_V01:
                    res |= QMI_RIL_NW_REG_FULL_SERVICE;
                    break;

                case NAS_NOT_REGISTERED_SEARCHING_V01:
                case NAS_REGISTRATION_DENIED_V01:
                    res |= QMI_RIL_NW_REG_LIMITED_SERVICE;
                    break;

                default:
                    // nothing
                    break;
            }

            switch ( nas_cached_info.serving_system->cs_attach_state )
            {
                case NAS_CS_ATTACHED_V01:
                    res |= QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
                    break;

                default:
                    // nothing
                    break;
            }
        }
        NAS_CACHE_UNLOCK();
    }

    if ( NAS_NIL == res )
    { // voice calls available by default
        res |= QMI_RIL_NW_REG_VOICE_CALLS_AVAILABLE;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
    return res;
}

//=========================================================================
//qmi_ril_nw_reg_get_current_rte_of_kind
//===========================================================================
qmi_ril_nw_reg_rte_type qmi_ril_nw_reg_get_current_rte_of_kind( qmi_ril_nw_reg_rte_kind_type rte_kind )
{
    qmi_ril_nw_reg_rte_type res;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    switch ( rte_kind )
    {
        case QMI_RIL_RTE_KIND_VOICE:
            res = nas_cached_info.voice_rte;
            break;

        case QMI_RIL_RTE_KIND_DATA:
            res = nas_cached_info.data_rte;
            break;

        case QMI_RIL_RTE_KIND_IMS:
            res = nas_cached_info.ims_rte;
            break;

        default:
            res = QMI_RIL_RTE_NONE;
            break;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int)res);
    return res;
} // qmi_ril_nw_reg_get_current_rte_of_kind

//=========================================================================
//qcril_qmi_nas_is_voip_enabled
//===========================================================================
uint8 qcril_qmi_nas_is_voip_enabled()
{
    int res;
    int is_voip_enabled_len;
    unsigned long ret_val;
    char property_name[ 40 ];
    char args[ PROPERTY_VALUE_MAX ];
    char *end_ptr;

    QCRIL_LOG_FUNC_ENTRY();

    res = FALSE;
    QCRIL_SNPRINTF( property_name, sizeof( property_name ), "%s", QCRIL_IS_VOIP_ENABLED );
    property_get( property_name, args, "" );
    is_voip_enabled_len = strlen( args );
    if ( is_voip_enabled_len > 0 )
    {
      ret_val = strtoul( args, &end_ptr, 0 );
      if ( ( errno == ERANGE ) && ( ret_val == ULONG_MAX ) )
      {
        QCRIL_LOG_ERROR( "Fail to convert QCRIL_VOIP_ENABLED %s", args );
      }
      else if ( ret_val > 1 )
      {
        QCRIL_LOG_ERROR( "Invalid saved QCRIL_IS_VOIP_ENABLED %ld, use default", ret_val );
      }
      else
      {
        res = ( uint8 ) ret_val;
      }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(res);

    return res;
} //qcril_qmi_nas_is_voip_enabled

//=========================================================================
//qmi_ril_nw_reg_snapshot_init
//===========================================================================
void qmi_ril_nw_reg_snapshot_init( qmi_ril_nw_reg_rte_snapshot_type* snapshot )
{
    if ( snapshot )
    {
        memset( snapshot, 0, sizeof(*snapshot ) );
    }
} // qmi_ril_nw_reg_snapshot_init

//=========================================================================
//qmi_ril_nw_reg_snapshot_cur_rte
//===========================================================================
void qmi_ril_nw_reg_snapshot_cur_rte( qmi_ril_nw_reg_rte_snapshot_type* snapshot )
{
    if ( snapshot )
    {
        NAS_CACHE_LOCK();
        snapshot->voice_rte     = nas_cached_info.voice_rte;
        snapshot->data_rte      = nas_cached_info.data_rte;
        snapshot->ims_rte       = nas_cached_info.ims_rte;
        snapshot->voice_rte_confidence_tag  = nas_cached_info.voice_rte_confidence_tag;
        snapshot->data_rte_confidence_tag   = nas_cached_info.data_rte_confidence_tag;
        snapshot->ims_rte_confidence_tag    = nas_cached_info.ims_rte_confidence_tag;
        NAS_CACHE_UNLOCK();
    }
} // qmi_ril_nw_reg_snapshot_cur_rte

//=========================================================================
//qmi_ril_nw_reg_snapshot_is_same_as
//===========================================================================
int qmi_ril_nw_reg_snapshot_is_same_as( qmi_ril_nw_reg_rte_snapshot_type* snapshot1, qmi_ril_nw_reg_rte_snapshot_type* snapshot2 )
{
    int res = FALSE;

    if ( NULL != snapshot1 && NULL != snapshot2 )
    {
        res = ( snapshot1->voice_rte                == snapshot2->voice_rte ) &&
              ( snapshot1->data_rte                 == snapshot2->data_rte ) &&
              ( snapshot1->ims_rte                  == snapshot2->ims_rte ) &&
              ( snapshot1->voice_rte_confidence_tag == snapshot2->voice_rte_confidence_tag ) &&
              ( snapshot1->data_rte_confidence_tag  == snapshot2->data_rte_confidence_tag ) &&
              ( snapshot1->ims_rte_confidence_tag   == snapshot2->ims_rte_confidence_tag );
    }

    return res;
} // qmi_ril_nw_reg_snapshot_is_same_as

//=========================================================================
//qmi_ril_nw_reg_snapshot_dump_log
//===========================================================================
void qmi_ril_nw_reg_snapshot_dump_log( qmi_ril_nw_reg_rte_snapshot_type* snapshot )
{
    if ( snapshot )
    {
        QCRIL_LOG_INFO( "in snapshot voice_rte %d, data_rte %d, ims_rte %d", snapshot->voice_rte, snapshot->data_rte, snapshot->ims_rte );
    }
} // qmi_ril_nw_reg_snapshot_dump_log
//qcril_qmi_nas_set_registered_on_ims
//===========================================================================
void qcril_qmi_nas_set_registered_on_ims( int registered )
{
    qmi_ril_nw_reg_rte_snapshot_type old_rte_snapshot;
    qmi_ril_nw_reg_rte_snapshot_type new_rte_snapshot;
    int                              any_rte_change;

    QCRIL_LOG_INFO( "registered: %d", registered );

    if( TRUE == qcril_qmi_nas_is_voip_enabled() )
    {
        qmi_ril_nw_reg_snapshot_init( &new_rte_snapshot );
        qmi_ril_nw_reg_snapshot_cur_rte( &old_rte_snapshot );


        NAS_CACHE_LOCK();
        nas_cached_info.is_registered_on_ims = registered;
        qcril_qmi_nas_update_ims_rte();
        NAS_CACHE_UNLOCK();
        qcril_qmi_voice_technology_updated();
        qcril_qmi_nas_initiate_radio_state_changed_ind();

        qmi_ril_nw_reg_snapshot_cur_rte( &new_rte_snapshot );
        qmi_ril_nw_reg_snapshot_dump_log( &old_rte_snapshot );
        qmi_ril_nw_reg_snapshot_dump_log( &new_rte_snapshot );
        any_rte_change = (FALSE == qmi_ril_nw_reg_snapshot_is_same_as( &new_rte_snapshot, &old_rte_snapshot ));
        QCRIL_LOG_INFO( "any rte change from ims %d", any_rte_change);

        if ( any_rte_change )
        {
            qcril_qmi_nas_initiate_voice_rte_change_propagation();
        }
        qcril_qmi_nas_wave_voice_data_status();
    }
}

//===========================================================================
//qmi_ril_nwreg_mode_pref_is_pending_deferred_enforcement_ncl
//===========================================================================
int qmi_ril_nwreg_mode_pref_is_pending_deferred_enforcement_ncl ( int * android_mode_pref )
{
    int res;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( nas_cached_info.deferred_mode_pref_set_valid )
    {
        res = TRUE;
        if ( NULL != android_mode_pref )
        {
            *android_mode_pref = nas_cached_info.deferred_mode_pref_set_android_param;
        }
    }
    else
    {
        res = FALSE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );
    return res;
} // qmi_ril_nwreg_mode_pref_is_pending_deferred_enforcement_ncl

//===========================================================================
//qmi_ril_nwreg_mode_pref_enforcement_deferred_ncl
//===========================================================================
int qmi_ril_nwreg_mode_pref_enforcement_deferred_ncl( int android_mode_pref )
{
    int res;
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) && DMS_OP_MODE_ONLINE_V01 != nas_dms_cached_info.operating_mode && nas_common_info.dfr_mode_pref_set_until_online )
    { // not online
        nas_cached_info.deferred_mode_pref_set_valid         = TRUE;
        nas_cached_info.deferred_mode_pref_set_android_param = android_mode_pref;
        res = TRUE;
    }
    else
    { // online
        res = FALSE;
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );
    return res;
} // qmi_ril_nwreg_mode_pref_enforcement_deferred_ncl

//===========================================================================
// QCRIL_EVT_QMI_RIL_ENFORCE_DEFERRED_MODE_PREF_SET
//===========================================================================
void qmi_ril_nwreg_mode_pref_enforce_deferred_op_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  int is_valid;
  int deferred_param;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );
  QCRIL_NOTUSED(params_ptr);

  NAS_CACHE_LOCK();
  is_valid       = nas_cached_info.deferred_mode_pref_set_valid;
  deferred_param = nas_cached_info.deferred_mode_pref_set_android_param;
  nas_cached_info.deferred_mode_pref_set_valid         = FALSE;
  nas_cached_info.deferred_mode_pref_set_android_param = NAS_NIL;
  NAS_CACHE_UNLOCK();

  QCRIL_LOG_INFO( "valid %d, deferred param %d", (int)is_valid, (int)deferred_param );
  if ( is_valid )
  {
      qmi_ril_nwreg_request_mode_pref( deferred_param, NULL );
  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_mode_pref_enforce_deferred_op_handler

//===========================================================================
// QCRIL_EVT_QMI_RIL_COMMON_IND_SUBSCRIBE_CONSIDER_ACTION
//===========================================================================
void qmi_ril_nwreg_common_ind_subscribe_consider_action_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  int enable_param;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED( ret_ptr );
  QCRIL_NOTUSED(params_ptr);

  qmi_ril_nwreg_enforce_common_ind_subscription_and_force_nw_search_as_applicable_ncl();

  qmi_ril_nwreg_enforce_data_dormancy_as_applicable_ncl();
  qmi_ril_nwreg_enforce_limited_data_sys_as_applicable_ncl();

  /* Send the screen state to qcril_data for further processing */
  (void) qcril_data_process_screen_state_change(!nas_common_info.is_screen_off);

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_common_ind_subscribe_consider_action_handler

//===========================================================================
// QCRIL_EVT_QMI_RIL_POST_OPRT_ONLINE_ACTION
//===========================================================================
void qmi_ril_nwreg_post_oprt_online_action_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  int                                                   is_currently_online;
  nas_get_system_selection_preference_resp_msg_v01      get_system_sel_pref_resp;
  nas_set_system_selection_preference_req_msg_v01       set_system_sel_pref_req;
  nas_set_system_selection_preference_resp_msg_v01      set_system_sel_pref_resp;
  RIL_Errno                                             ril_err;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);
  QCRIL_NOTUSED(params_ptr);

  if ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE ) && qmi_ril_is_feature_supported( QMI_RIL_FEATURE_SGLTE_CSFB ) )
  {
    is_currently_online = FALSE;
    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode ) )
    {
        is_currently_online  = ( DMS_OP_MODE_ONLINE_V01 == nas_dms_cached_info.operating_mode );
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. currently online %d", is_currently_online );

    if ( is_currently_online )
    {
        do
        {
            ril_err = qcril_qmi_client_send_msg_sync_ex
                            (
                                QCRIL_QMI_CLIENT_NAS,
                                QMI_NAS_GET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                NULL,           // empty req payload
                                NAS_NIL,
                                &get_system_sel_pref_resp,
                                sizeof( get_system_sel_pref_resp ),
                                QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                            );
            if ( RIL_E_SUCCESS != ril_err )
                break;

            QCRIL_LOG_INFO( ".. cur restriction %d/%d", (int) get_system_sel_pref_resp.srv_reg_restriction_valid, (int) get_system_sel_pref_resp.srv_reg_restriction );

            // provision unrestricted
            memset( &set_system_sel_pref_req, 0, sizeof( set_system_sel_pref_req ) );
            set_system_sel_pref_req.srv_reg_restriction_valid = TRUE;
            set_system_sel_pref_req.srv_reg_restriction       = NAS_SRV_REG_RESTRICTION_UNRESTRICTED_V01;

            set_system_sel_pref_req.srv_domain_pref_valid = TRUE;
            set_system_sel_pref_req.srv_domain_pref       = QMI_SRV_DOMAIN_PREF_CS_PS_V01;

            ril_err = qcril_qmi_client_send_msg_sync_ex
                            (
                                QCRIL_QMI_CLIENT_NAS,
                                QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                &set_system_sel_pref_req,
                                sizeof( set_system_sel_pref_req ),
                                &set_system_sel_pref_resp,
                                sizeof( set_system_sel_pref_resp ),
                                QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT
                            );
            QCRIL_LOG_INFO( ".. completion %d", (int) ril_err );

        } while (FALSE);
    }

  }

  QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nwreg_post_oprt_online_action_handler

// qcril_qmi_nas_get_mode_pref
//===========================================================================
uint8_t qcril_qmi_nas_get_mode_pref(uint16_t *mode_pref)
{
    uint8_t ret = FALSE;

    if ( NULL != mode_pref )
    {
        NAS_CACHE_LOCK();
        if ( nas_cached_info.prev_mode_pref_valid )
        {
            *mode_pref = nas_cached_info.prev_mode_pref;
            ret = TRUE;
        }
        else if ( nas_cached_info.mode_pref_valid )
        {
            *mode_pref = nas_cached_info.mode_pref;
            ret = TRUE;
        }
        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_mode_pref

//===========================================================================
// qmi_ril_nas_cache_deferred_acq_order
//===========================================================================
void qmi_ril_nas_cache_deferred_acq_order
(
    uint32_t acq_order_len,
    qcril_qmi_acq_order_e_type acq_order_map,
    nas_radio_if_enum_v01 *acq_order
)
{
    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( acq_order_len > 0 && acq_order_len < NAS_ACQ_ORDER_LIST_MAX_V01 )
    {
        nas_cached_info.deferred_acq_order_valid = TRUE;
        nas_cached_info.deferred_acq_order_len = acq_order_len;
        nas_cached_info.deferred_acq_order_map = acq_order_map;
        memcpy( nas_cached_info.deferred_acq_order, acq_order, acq_order_len*sizeof(nas_radio_if_enum_v01) );
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN();
} // qmi_ril_nas_cache_deferred_acq_order

//===========================================================================
// qmi_ril_nas_get_deferred_acq_order
//===========================================================================
uint8_t qmi_ril_nas_get_deferred_acq_order( uint32_t *acq_order_len, nas_radio_if_enum_v01 *acq_order )
{
    uint8_t ret = FALSE;
    uint32_t len = 0;
    QCRIL_LOG_FUNC_ENTRY();

    if ( NULL != acq_order_len && NULL != acq_order )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.deferred_acq_order_valid;
        *acq_order_len = nas_cached_info.deferred_acq_order_len;

        if ( ret && (*acq_order_len) > 0 && (*acq_order_len) < NAS_ACQ_ORDER_LIST_MAX_V01 )
        {
            memcpy( acq_order, nas_cached_info.deferred_acq_order,
                            (*acq_order_len) * sizeof(nas_radio_if_enum_v01) );
        }

        nas_cached_info.deferred_acq_order_valid = FALSE;
        nas_cached_info.deferred_acq_order_len = 0;
        nas_cached_info.deferred_acq_order_map = QCRIL_QMI_ACQ_ORDER_NONE;
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret;
} // qmi_ril_nas_get_deferred_acq_order

//===========================================================================
// qmi_ril_nas_get_deferred_acq_order_map
//===========================================================================
uint8_t qmi_ril_nas_get_deferred_acq_order_map( qcril_qmi_acq_order_e_type *acq_order_map )
{
    uint8_t ret = FALSE;
    uint32_t len = 0;
    QCRIL_LOG_FUNC_ENTRY();

    if ( NULL != acq_order_map )
    {
        NAS_CACHE_LOCK();
        if ( nas_cached_info.deferred_acq_order_len > 0 &&
             nas_cached_info.deferred_acq_order_len < NAS_ACQ_ORDER_LIST_MAX_V01 )
        {
            *acq_order_map = nas_cached_info.deferred_acq_order_map;
            ret = nas_cached_info.deferred_acq_order_valid;
        }
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret;

} // qmi_ril_nas_get_deferred_acq_order_map

//===========================================================================
// qcril_qmi_nas_get_acq_order
//===========================================================================
uint8_t qcril_qmi_nas_get_acq_order(uint32_t *acq_order_len, nas_radio_if_enum_v01 *acq_order)
{
    uint8_t ret = FALSE;

    if ( NULL != acq_order_len && NULL != acq_order )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.acq_order_valid;
        *acq_order_len = nas_cached_info.acq_order_len;

        if ( ret && (*acq_order_len) > 0 && (*acq_order_len) < NAS_ACQ_ORDER_LIST_MAX_V01 )
        {
            memcpy( acq_order, nas_cached_info.acq_order->arr,
                            NAS_ACQ_ORDER_LIST_MAX_V01*sizeof(nas_radio_if_enum_v01) );
        }

        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_acq_order

//===========================================================================
// qcril_qmi_nas_get_band_pref_map
//===========================================================================
uint8_t qcril_qmi_nas_get_band_pref_map
(
    qcril_qmi_rat_band_e_type band_type,
    qcril_qmi_band_pref_e_type *band_pref_map
)
{
    uint8_t ret = FALSE;

    if ( band_pref_map != NULL)
    {
        if ( band_type == QCRIL_QMI_LTE_BAND )
        {
            NAS_CACHE_LOCK();
            ret = nas_cached_info.deferred_lte_band_pref_valid;
            *band_pref_map = nas_cached_info.deferred_lte_band_pref_map;
            NAS_CACHE_UNLOCK();
        }
    }

    return ret;
} // qcril_qmi_nas_get_band_pref_map

//===========================================================================
// qcril_qmi_nas_get_band_pref
//===========================================================================
uint8_t qcril_qmi_nas_get_band_pref
(
    qcril_qmi_rat_band_e_type band_type,
    uint64_t *band_pref
)
{
    uint8_t ret = FALSE;

    if ( band_pref != NULL)
    {
        if ( band_type == QCRIL_QMI_LTE_BAND )
        {
            NAS_CACHE_LOCK();
            ret = nas_cached_info.deferred_lte_band_pref_valid;
            *band_pref = nas_cached_info.deferred_lte_band_pref;

            // clear, just one shot
            nas_cached_info.deferred_lte_band_pref_valid = FALSE;
            nas_cached_info.deferred_lte_band_pref_map = QCRIL_QMI_BAND_PREF_NONE;
            nas_cached_info.deferred_lte_band_pref = 0;
            NAS_CACHE_UNLOCK();
        }
    }

    return ret;
} // qcril_qmi_nas_get_band_pref

//===========================================================================
// qmi_ril_nas_cache_deferred_band_pref
//===========================================================================
uint8_t qmi_ril_nas_cache_deferred_band_pref
(
    qcril_qmi_rat_band_e_type band_type,
    qcril_qmi_band_pref_e_type band_pref_map
)
{
    uint8_t ret = FALSE;
    uint32_t len = 0;
    QCRIL_LOG_FUNC_ENTRY();

    if (band_type == QCRIL_QMI_LTE_BAND) {
        NAS_CACHE_LOCK();
        if ( nas_common_info.permanent_lte_band_pref_valid )
        {
            ret = TRUE;
            switch ( band_pref_map )
            {
                case QCRIL_QMI_BAND_PREF_LTE_FULL:
                    nas_cached_info.deferred_lte_band_pref =
                        nas_common_info.permanent_lte_band_pref;
                    nas_cached_info.deferred_lte_band_pref_valid = TRUE;
                    nas_cached_info.deferred_lte_band_pref_map = band_pref_map;
                    break;
                case QCRIL_QMI_BAND_PREF_TDD_LTE:
                    // clear bit0 ~ bit31
                    nas_cached_info.deferred_lte_band_pref =
                        nas_common_info.permanent_lte_band_pref & NAS_VAL_TDD_LTE_BAND_MASK;
                    nas_cached_info.deferred_lte_band_pref_map = band_pref_map;
                    nas_cached_info.deferred_lte_band_pref_valid = TRUE;
                    break;
                case QCRIL_QMI_BAND_PREF_FDD_LTE:
                    // clear bit32 ~ bit63
                    nas_cached_info.deferred_lte_band_pref =
                        nas_common_info.permanent_lte_band_pref & NAS_VAL_FDD_LTE_BAND_MASK;
                    nas_cached_info.deferred_lte_band_pref_map = band_pref_map;
                    nas_cached_info.deferred_lte_band_pref_valid = TRUE;
                    break;
                default:
                    ret = FALSE;
                    break;
            }
        }
        NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret;
} // qmi_ril_nas_cache_deferred_band_pref

//===========================================================================
// qcril_qmi_nas_get_gw_acq_order_pref
//===========================================================================
uint8_t qcril_qmi_nas_get_gw_acq_order_pref (uint16_t *gw_acq_order_pref)
{
    uint8_t ret = FALSE;

    if ( NULL != gw_acq_order_pref )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.gw_acq_order_pref_valid;
        *gw_acq_order_pref = nas_cached_info.gw_acq_order_pref;
        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_gw_acq_order_pref

//===========================================================================
// qcril_qmi_nas_get_lte_disable_cause
//===========================================================================
uint8_t qcril_qmi_nas_get_lte_disable_cause(nas_lte_disable_cause_enum_type_v01 *lte_disable_cause)
{
    uint8_t ret = FALSE;

    if ( NULL != lte_disable_cause )
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.lte_disable_cause_valid;
        *lte_disable_cause = nas_cached_info.lte_disable_cause;
        NAS_CACHE_UNLOCK();
    }

    return ret;
} // qcril_qmi_nas_get_lte_disable_cause

//===========================================================================
// qcril_qmi_nas_get_rat_disabled_mask
//===========================================================================
uint8_t qcril_qmi_nas_get_rat_disabled_mask
(
    mode_pref_mask_type_v01 *rat_disabled_mask
)
{
    uint8_t ret = FALSE;

    if (NULL != rat_disabled_mask)
    {
        NAS_CACHE_LOCK();
        ret = nas_cached_info.rat_disabled_mask_valid;
        *rat_disabled_mask = nas_cached_info.rat_disabled_mask;
        NAS_CACHE_UNLOCK();

        if (!ret)
        {
            *rat_disabled_mask = 0;
        }
    }

    return ret;
} // qcril_qmi_nas_get_rat_disabled_mask

//===========================================================================
//qcril_qmi_nas_process_custom_emergency_numbers
//
// function to process properties having prefix
// persist.radio.ecc_hard values and
// store them for further use
//===========================================================================
void qcril_qmi_nas_process_custom_emergency_numbers()
{
    QCRIL_LOG_FUNC_ENTRY();

    //preparing the hardcoded_emergency_numbers_list from persist.radio.ecc_hard value
    //format of the input - "<NUM_1>,<NUM_2>,<NUM_3>,<NUM_4>,<NUM_5>,<NUM_6>,<NUM_7>,<..>,<more numbers>"
    nas_common_info.custom_hardcoded_emergency_numbers_list =
             (char *) qcril_qmi_nas_process_custom_emergency_numbers_helper(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD, NULL);

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_process_custom_emergency_numbers

//===========================================================================
//qcril_qmi_nas_retrieve_number_of_tuples
//
// function to retrieve number of tuples present in a list
// returns number of tuples present in passed emergency_list
//===========================================================================
int qcril_qmi_nas_retrieve_number_of_tuples(char *emergency_list)
{
    int num_of_tuples;
    char *tuple_start_ptr;
    char *tuple_end_ptr;
    char *tuple_iter_ptr;


    QCRIL_LOG_FUNC_ENTRY();

    num_of_tuples = 0;
    tuple_iter_ptr = emergency_list;
    do
    {
        tuple_start_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_START_DELIMITER); //to find the start of a tuple
        tuple_end_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_END_DELIMITER); //to find the end of a tuple
        if( tuple_start_ptr && tuple_end_ptr )
        {
            tuple_iter_ptr = tuple_end_ptr + sizeof(char);
            num_of_tuples++;
        }
    }while( tuple_start_ptr && tuple_end_ptr );

    QCRIL_LOG_FUNC_RETURN_WITH_RET(num_of_tuples);
    return num_of_tuples;
} //qcril_qmi_nas_retrieve_number_of_tuples

//===========================================================================
// qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value
//
// helper function to retrieve the values configured through properties
// having prefixes of one of the following
// persist.radio.custom_ecc_hard_ returns the concatenated list of values of
// all properties configured using a specific property_prefix
//===========================================================================
char* qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value
(
    char *property_prefix
)
{
    char *configured_value_ptr;
    int iter_i;
    int err;
    int properties_count;
    char property_name[ PROPERTY_VALUE_MAX ];
    char property_value[ PROPERTY_VALUE_MAX ];
    int temp_len;
    int temp_properties_value_length;
    char **temp_properties_value_table;

    QCRIL_LOG_FUNC_ENTRY();

    err = FALSE;
    properties_count = 0;
    temp_properties_value_length = 0;
    configured_value_ptr = NULL;

    if( property_prefix )
    {
        snprintf( property_name, sizeof( property_name ), "%s%s", property_prefix, QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_COUNT_PROPERTY_SUFFFIX );
        property_get( property_name, property_value, "" );
        temp_len = strlen( property_value );
        if ( temp_len > 0 )
        {
          properties_count = strtoul( property_value, NULL, 0 );
        }
        QCRIL_LOG_DEBUG( "property_name %s, properties_count %d", property_name, properties_count);

        if( properties_count > NAS_NIL && properties_count <= QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_MAX_COUNT)
        {
            temp_properties_value_table = (char **) qcril_malloc(sizeof(char*) * properties_count);
            if( temp_properties_value_table )
            {
                for( iter_i = 1; iter_i <= properties_count; iter_i++ )
                {
                    memset(property_value, 0, sizeof(property_value));
                    snprintf( property_name, sizeof(property_name), "%s%d", property_prefix, iter_i);
                    property_get( property_name, property_value, "" );
                    temp_len = strlen( property_value );
                    if ( temp_len > 0 )
                    {
                      QCRIL_LOG_DEBUG( "property_name %s, property_value %s", property_name, property_value);
                      temp_properties_value_table[iter_i-1] = (char*) qcril_malloc(sizeof(char) * (temp_len+1));
                      if( temp_properties_value_table[iter_i-1] )
                      {
                          memcpy(temp_properties_value_table[iter_i-1], property_value, temp_len);
                          temp_properties_value_length += temp_len;
                      }
                      else
                      {
                          QCRIL_LOG_FATAL("Fail to allocate memory for a row in temp_properties_value_table");
                          err = TRUE;
                          break;
                      }
                    }
                    else
                    {
                        err = TRUE;
                        break;
                    }
                }

                if( FALSE == err )
                {
                    temp_properties_value_length += properties_count;
                    QCRIL_LOG_INFO("configured_value's length %d", temp_properties_value_length);
                    configured_value_ptr = (char*) qcril_malloc(sizeof(char) * temp_properties_value_length);
                    if( configured_value_ptr )
                    {
                        strlcpy(configured_value_ptr, temp_properties_value_table[NAS_NIL], temp_properties_value_length);
                        for( iter_i = 1; iter_i < properties_count; iter_i++ )
                        {
                            strlcat(configured_value_ptr, QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_PROPERTIES_DELIMITER, temp_properties_value_length);
                            strlcat(configured_value_ptr, temp_properties_value_table[iter_i], temp_properties_value_length);
                        }
                        QCRIL_LOG_ESSENTIAL("configured_value %s", configured_value_ptr);
                    }
                    else
                    {
                        QCRIL_LOG_FATAL("Fail to allocate memory for configured_value_ptr");
                    }
                }

                for( iter_i = 1; iter_i <= properties_count; iter_i++ )
                {
                    if( temp_properties_value_table[iter_i-1] )
                    {
                        qcril_free(temp_properties_value_table[iter_i-1]);
                    }
                    else
                    {
                        break;
                    }
                }
                qcril_free(temp_properties_value_table);
            }
            else
            {
                QCRIL_LOG_FATAL("Fail to allocate memory for temp_properties_value_table");
            }
        }
        else
        {
            QCRIL_LOG_FATAL("Invalid value for properties count %d", properties_count);
        }
    }
    else
    {
        QCRIL_LOG_FATAL("NULL Pointer passed");
    }



    QCRIL_LOG_FUNC_RETURN();
    return configured_value_ptr;
} //qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value

//===========================================================================
//qcril_qmi_nas_process_custom_emergency_numbers_helper
//
// helper function for qcril_qmi_nas_process_custom_emergency_numbers
// returns the pointer to table or list depending on the source
//===========================================================================
void* qcril_qmi_nas_process_custom_emergency_numbers_helper(qmi_ril_custom_emergency_numbers_source_type source, int *number_of_tuples)
{
    char **emergency_numbers_table;
    char *emergency_numbers_list;
    char *property_prefix_to_be_used;
    void *ret_ptr;
    int is_prepare_table;
    int valid_case;
    int temp_len;
    char *tuple_start_ptr;
    char *tuple_end_ptr;
    char *tuple_iter_ptr;
    int err;
    int iter_emergency_numbers_table;
    int temp_num_of_tuples;
    char *complete_configured_value;

    QCRIL_LOG_FUNC_ENTRY();

    iter_emergency_numbers_table = 0;
    emergency_numbers_table = NULL;
    emergency_numbers_list = NULL;
    err = FALSE;
    ret_ptr = NULL;
    is_prepare_table = FALSE;
    valid_case = TRUE;

    switch( source )
    {
        case QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD:
            QCRIL_LOG_INFO("source is HARD");
            property_prefix_to_be_used = QMI_RIL_CUSTOM_HARDCODED_EMERGENCY_NUMBERS_LIST_PREFIX;
            is_prepare_table = FALSE;
            break;

        default:
            QCRIL_LOG_INFO("Invalid scenario");
            valid_case = FALSE;
            break;
    }

    if( valid_case )
    {
        complete_configured_value = qcril_qmi_nas_retrieve_custom_emergency_numbers_configured_value(property_prefix_to_be_used);
        if( complete_configured_value )
        {
            temp_len = strlen( complete_configured_value );
            if(temp_len > 0)
            {
                if( is_prepare_table )
                {
                    temp_num_of_tuples = qcril_qmi_nas_retrieve_number_of_tuples(complete_configured_value);
                    if( number_of_tuples )
                    {
                        *number_of_tuples = temp_num_of_tuples;
                    }

                    emergency_numbers_table = (char **) qcril_malloc(sizeof(char*) * temp_num_of_tuples);
                    if( emergency_numbers_table )
                    {
                        tuple_iter_ptr = complete_configured_value;
                        do
                        {
                            tuple_start_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_START_DELIMITER); //to find the start of a tuple
                            tuple_end_ptr = strchr(tuple_iter_ptr,QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_END_DELIMITER); //to find the end of a tuple
                            if( tuple_start_ptr && tuple_end_ptr )
                            {
                                emergency_numbers_table[iter_emergency_numbers_table] = (char*) qcril_malloc(sizeof(char) * (tuple_end_ptr-tuple_start_ptr));
                                if( emergency_numbers_table[iter_emergency_numbers_table] )
                                {
                                    memcpy(emergency_numbers_table[iter_emergency_numbers_table], (tuple_start_ptr+1), (tuple_end_ptr-tuple_start_ptr-1));

                                    tuple_iter_ptr = tuple_end_ptr + sizeof(char);
                                    iter_emergency_numbers_table++;
                                }
                                else
                                {
                                    err = TRUE;
                                    QCRIL_LOG_FATAL("Fail to allocate memory for emergency_numbers_table_row");
                                }
                            }
                        }while( tuple_start_ptr && tuple_end_ptr && !err);
                    }
                    else
                    {
                        err = TRUE;
                        QCRIL_LOG_FATAL("Fail to allocate memory for emergency_numbers_table");
                    }

                    if( !err )
                    {
                        ret_ptr = (void*) emergency_numbers_table;
                    }
                }
                else
                {
                    emergency_numbers_list = (char*) qcril_malloc(sizeof(char) * (temp_len + 1));
                    if( emergency_numbers_list )
                    {
                        memcpy(emergency_numbers_list, complete_configured_value, temp_len);
                    }
                    else
                    {
                        err = TRUE;
                        QCRIL_LOG_FATAL("Fail to allocate memory for emergency_numbers_list");
                    }

                    if( !err )
                    {
                        ret_ptr = (void*) emergency_numbers_list;
                    }
                }
            }
            qcril_free(complete_configured_value);
        }
    }

    QCRIL_LOG_FUNC_RETURN();
    return ret_ptr;
} //qcril_qmi_nas_process_custom_emergency_numbers_helper

//===========================================================================
//qcril_qmi_nas_cleanup_custom_emergency_numbers
//
//function to cleanup the storage that was
//created in qcril_qmi_nas_process_custom_emergency_numbers()
//===========================================================================
void qcril_qmi_nas_cleanup_custom_emergency_numbers()
{
   QCRIL_LOG_FUNC_ENTRY();

   qcril_qmi_nas_cleanup_custom_emergency_numbers_helper(&nas_common_info.custom_hardcoded_emergency_numbers_list, FALSE, NULL);

   QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_cleanup_custom_emergency_numbers

//===========================================================================
//qcril_qmi_nas_cleanup_custom_emergency_numbers_helper
//
// helper function for qcril_qmi_nas_cleanup_custom_emergency_numbers
//===========================================================================
void qcril_qmi_nas_cleanup_custom_emergency_numbers_helper(void * emergency_numbers, int is_cleanup_table, int *number_of_tuples)
{
    char ***emergency_numbers_table_ptr;
    char **emergency_numbers_list_ptr;
    int iter_i;

    QCRIL_LOG_FUNC_ENTRY();

    if( emergency_numbers )
    {
        if( TRUE == is_cleanup_table )
        {
            if( number_of_tuples )
            {
                emergency_numbers_table_ptr = (char***) emergency_numbers;
                if( *emergency_numbers_table_ptr )
                {
                    for( iter_i = 0; iter_i < *number_of_tuples; iter_i++ )
                    {
                        if( (*emergency_numbers_table_ptr)[iter_i] )
                        {
                            qcril_free((*emergency_numbers_table_ptr)[iter_i]);
                            (*emergency_numbers_table_ptr)[iter_i] = NULL;
                        }
                    }
                    qcril_free(*emergency_numbers_table_ptr);
                    (*emergency_numbers_table_ptr) = NULL;
                    *number_of_tuples = NAS_NIL;
                }
            }
            else
            {
                QCRIL_LOG_FATAL("NULL Pointer passed");
            }
        }
        else
        {
            emergency_numbers_list_ptr = (char**) emergency_numbers;
            if( *emergency_numbers_list_ptr )
            {
                qcril_free(*emergency_numbers_list_ptr);
                (*emergency_numbers_list_ptr) = NULL;
            }
        }
    }
    else
    {
        QCRIL_LOG_FATAL("NULL Pointer passed");
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_cleanup_custom_emergency_numbers_helper

//===========================================================================
//qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers
//
//function to check If the passed number is part of the custom emergency numbers
// persist.radio.ecc_hard_ prefixed properties
//
//tuple_id of -1 indicates that the check is being made for HARD source
//returns TRUE If the number is part of the emergency numbers list
//of the passed source & tuple (tuple_id), FALSE otherwise
//===========================================================================
int qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers
(
    char *number,
    char *mcc,
    qmi_ril_custom_emergency_numbers_source_type source
)
{
    int ret = FALSE;
    char *emer_nums_start_ptr;

    QCRIL_LOG_INFO("number %s", number);

    if( QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD == source  )
    {
        QCRIL_LOG_ESSENTIAL("card absent scenario");
        if(  nas_common_info.custom_hardcoded_emergency_numbers_list )
        {
            ret = qcril_other_is_number_found(number,
                                  nas_common_info.custom_hardcoded_emergency_numbers_list);
        }
    }
    else
    {
        do
        {
            // check for number without any service limitation
            ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(number, mcc, source, "");
            if ( ret )
            {
                QCRIL_LOG_INFO("number = %s matches with source = %d with no service limitation %d", number, source, ret);
                break;
            }

            // if number not available without service limitation, check for full service,limited service
            if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag )
            {
                ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(
                            number, mcc, source, "full");
                QCRIL_LOG_INFO("number = %s matches with source = %d with full service %d", number, source, ret);
            }
            else if ( QMI_RIL_RAT_CONFIDENCE_LTD_SVC == nas_cached_info.voice_rte_confidence_tag )
            {
                ret = qcril_db_is_number_mcc_part_of_emergency_numbers_table_with_service_state(
                            number, mcc, source, "limited");
                QCRIL_LOG_INFO("number = %s matches with source = %d, with limited serivce %d", number, source, ret);
            }
        }while(0);

    }

    QCRIL_LOG_ESSENTIAL("completed with %d", ret);
    return ret;
} //qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers

//===========================================================================
//qcril_qmi_nas_update_ril_ecclist
//
//function to update the ril_ecclist with any missing emergency numbers
//
//source of
//QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC that the update is being made from persist.radio.ecc_mcc_
//QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE that the update is being made from persist.radio.ecc_voice_
//QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC that the update is being made from persist.radio.ecc_hardmcc_
//QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW that the update is being made from persist.radio.ecc_nw_
//QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD that the update is being made from persist.radio.ecc_hard_
//
//tuple_id needs to be >=0 If source is MCC or VOICE or HARD_MCC or NW
//returns TRUE If ril_ecclist has been updated, FALSE otherwise
//===========================================================================
int qcril_qmi_nas_update_ril_ecclist(char *emergency_numbers)
{
    char *emer_nums_start_ptr;
    char *temp_emer_nums;
    char *iter_temp_emer_nums_token;
    char emergency_list_prop_val[ PROPERTY_VALUE_MAX ];
    int match_res;
    int emer_nums_len;
    int is_updated;
    char delimiters[2];

    char prop_name[ PROPERTY_KEY_MAX ];

    // multi-sim support, set ecc.list property
    if (qmi_ril_is_multi_sim_feature_supported())
    {
        get_ecc_property_name(prop_name);
    }
    else
    {
        strlcpy(prop_name,QCRIL_ECC_LIST,sizeof(prop_name));
    }

    // multi-ril support, determine which ecc.list property to manipulate
    if ( qmi_ril_is_feature_supported( QMI_RIL_FEATURE_DSDA ) && QCRIL_SECOND_INSTANCE_ID == qmi_ril_get_process_instance_id() ) {
        // second ril instance
        strlcpy(prop_name,QCRIL_ECC_LIST_1,sizeof(prop_name));
    }

    (void)property_get( prop_name, emergency_list_prop_val, "" );
    QCRIL_LOG_INFO( "current %s = \"%s\"", prop_name, emergency_list_prop_val );

    is_updated = FALSE;
    if (emergency_numbers)
    {
        emer_nums_start_ptr = emergency_numbers;
        emer_nums_len = strlen(emer_nums_start_ptr);
        if( emer_nums_len )
        {
            temp_emer_nums = (char*) qcril_malloc(sizeof(char) * (emer_nums_len + 1));

            if( temp_emer_nums )
            {
                memset(temp_emer_nums, 0, emer_nums_len + 1);
                memcpy(temp_emer_nums, emer_nums_start_ptr, emer_nums_len);
                memset(delimiters,0,sizeof(delimiters));
                temp_emer_nums[emer_nums_len]='\0';
                delimiters[0]= QMI_RIL_CUSTOM_MCC_EMERGENCY_NUMBERS_LIST_TUPLE_INTERNAL_DELIMITER_1;

                iter_temp_emer_nums_token = strtok (temp_emer_nums,delimiters);
                while( iter_temp_emer_nums_token )
                {
                    match_res = qcril_other_is_number_found( iter_temp_emer_nums_token, emergency_list_prop_val );
                    if ( FALSE == match_res ) //missing emergency number - need to update the ril.ecclist
                    {
                        if ( strlen( emergency_list_prop_val ) > 0 )
                        {
                            strlcat( emergency_list_prop_val, ",", PROPERTY_VALUE_MAX );
                        }
                        strlcat( emergency_list_prop_val, iter_temp_emer_nums_token, PROPERTY_VALUE_MAX );

                        is_updated = TRUE; //atleast one missing emergency number has been added to ril.ecclist
                    }
                    iter_temp_emer_nums_token = strtok (NULL,delimiters);
                }
                qcril_free(temp_emer_nums);
            }
            else
            {
                QCRIL_LOG_FATAL("Fail to allocate memory for temp_emer_nums");
            }

            if( is_updated )
            {
                QCRIL_LOG_ESSENTIAL( "updating %s to \"%s\"", prop_name, emergency_list_prop_val );
                (void)property_set( prop_name, emergency_list_prop_val );
            }
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(is_updated);
    return is_updated;
} //qcril_qmi_nas_update_ril_ecclist


//===========================================================================
//qcril_qmi_nas_assess_emergency_number_list_handler - QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY
//===========================================================================
void qcril_qmi_nas_assess_emergency_number_list_handler
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);
    QCRIL_NOTUSED(params_ptr);

    QCRIL_LOG_INFO( "custom emergency numbers enabled %d", nas_common_info.custom_emergency_numbers_enabled );

    if ( nas_common_info.custom_emergency_numbers_enabled )
    {
        QCRIL_LOG_INFO( "for nw %d", nas_common_info.custom_emergency_numbers_enabled_for_nw );
        if( nas_common_info.custom_emergency_numbers_enabled_for_nw )
        {
            qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw();
        }
        else
        {
            qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card();
        }
    }
    else
    {
        /* Set the property directly if custom emergency numbers is disabled
         * In this case, RIL will only append numbers recevied from PBM IND
         */
        qmi_ril_set_ecc_property(NULL);
    }

    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_get_escv_type
//===========================================================================
int qcril_qmi_nas_get_escv_type
(
    char *emergency_number
)
{
    int     escv_type           = 0;
    char   *roam                = NULL;
    char   *mcc_from_iccid_ptr  = NULL;
    char   *iccid               = NULL;

    int     res;
    int     slot;
    int     i;
    char    current_mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char    current_mnc_str[NAS_MCC_MNC_MAX_SIZE];

#define QCRIL_IIN_MIN_LENGTH (4)

    QCRIL_LOG_FUNC_ENTRY();


    QCRIL_LOG_INFO( "custom emergency numbers enabled %d", nas_common_info.custom_emergency_numbers_enabled );
    if ( nas_common_info.custom_emergency_numbers_enabled && emergency_number )
    {
        NAS_CACHE_LOCK();
        res = qcril_qmi_nas_find_current_mcc_mnc(current_mcc_str, current_mnc_str, FALSE, NULL);
        slot = qmi_ril_get_sim_slot();
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO( "slot %d", slot, nas_common_info.card_info[slot].iccid? nas_common_info.card_info[slot].iccid : "null" );
        if (nas_common_info.card_info[slot].iccid_len > 0)
        {
            if (res)
            {

                mcc_from_iccid_ptr = qcril_qmi_nas2_retrieve_mcc_from_iccid(nas_common_info.card_info[slot].iccid);
                if (mcc_from_iccid_ptr)
                {
                    QCRIL_LOG_INFO( "current mcc %s iccid mcc %s",
                                     current_mcc_str, mcc_from_iccid_ptr);
                    if (!strcmp(mcc_from_iccid_ptr, current_mcc_str))
                    {
                        roam = "home";
                    }
                    else
                    {
                        roam = "roam";
                    }
                }
            }
            else
            {
                roam = "roam";
            }

            iccid = malloc(nas_common_info.card_info[slot].iccid_len + 1);

            if(iccid!=NULL)
            {
              strlcpy(iccid, nas_common_info.card_info[slot].iccid,
                             nas_common_info.card_info[slot].iccid_len + 1);
              escv_type = -1;
              for (i = nas_common_info.card_info[slot].iccid_len;
                   (i > QCRIL_IIN_MIN_LENGTH) && (escv_type == -1);
                   i--)
              {
                  iccid[i] = '\0';
                  escv_type = qcril_db_query_escv_type(emergency_number,
                                                       iccid,
                                                       NULL,
                                                       NULL,
                                                       roam);
              }

              /* escv_type is -1 when there is no match from the db */
              if (escv_type == -1)
              {
                  escv_type = 0;
              }
            }
            else
            {
              QCRIL_LOG_ERROR("Malloc failed for iccid");
            }
        }
        else if (res)
        {
            escv_type = qcril_db_query_escv_type(emergency_number,
                                     NULL,
                                     current_mcc_str,
                                     current_mnc_str,
                                     NULL);
        }
    }
    QCRIL_LOG_FUNC_RETURN_WITH_RET(escv_type);
    return escv_type;
}

//===========================================================================
//qcril_check_mcc_part_of_emergency_numbers_table_with_service_state
//===========================================================================
int qcril_check_mcc_part_of_emergency_numbers_table_with_service_state
(
    qmi_ril_custom_emergency_numbers_source_type source,
    char *mcc,
    char *emergency_nums
)
{
    int         ret_val = FALSE;

    NAS_CACHE_LOCK();

    do
    {
        // if it is in APM mode
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode )
            && (nas_dms_cached_info.operating_mode == DMS_OP_MODE_LOW_POWER_V01) )
        {
            ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table(
                            source, mcc, emergency_nums);
            QCRIL_LOG_INFO("source = %d, is matched with APM %d", source, ret_val);
            break;
        }

        // none-APM case 1: check the no service limitation case
        ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table_with_service_state(
                    source, mcc, "", emergency_nums);
        QCRIL_LOG_INFO("source = %d, is matched with no service limit %d", source, ret_val);
        if ( ret_val )
        {
            break;
        }
        // none-APM case 2: check the full service case
        if ( QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag )
        {
            ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table_with_service_state(
                        source, mcc, "full", emergency_nums);
            QCRIL_LOG_INFO("source = %d, is matched with full service %d", source, ret_val);
        }
        // none-APM case 3: check the limit service case
        else if ( QMI_RIL_RAT_CONFIDENCE_LTD_SVC == nas_cached_info.voice_rte_confidence_tag )
        {
            ret_val = qcril_db_is_mcc_part_of_emergency_numbers_table_with_service_state(
                    source, mcc, "limited", emergency_nums);
            QCRIL_LOG_INFO("source = %d, is matched with limited serivce %d", source, ret_val);
        }
    } while (0);

    NAS_CACHE_UNLOCK();

    return ret_val;
}

//===========================================================================
//qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw
//===========================================================================
void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw()
{
    int need_update_cur_status;
    uint32 cur_status;

    QCRIL_LOG_FUNC_ENTRY();

    need_update_cur_status = FALSE;
    char emergency_nums[200] = {0};
    int     res = FALSE;


    NAS_CACHE_LOCK();

    cur_status = nas_cached_info.designated_number_added_for_designated_country_status;

    if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED )
    {
        res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW,
                        nas_cached_info.mcc_from_device_reg,
                        emergency_nums);
        if( res )
        {
            cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH);
            strlcpy(nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                    nas_cached_info.mcc_from_device_reg,
                    NAS_MCC_MNC_MAX_V01 + 1);
        }
    }

    if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED ) )
    {
        if( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
        {
            res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW,
                                nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                emergency_nums);
            if(res)
            {
                cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
                need_update_cur_status = TRUE;
            }
        }
    }

    if ( need_update_cur_status )
    {
        nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
    }

    NAS_CACHE_UNLOCK();
    qmi_ril_set_ecc_property(emergency_nums);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_evaluate_custom_emergency_numbers_for_nw

// this function will allocate memory, need to free after use
static inline uint8_t* qcril_iccid_to_string(uint8_t* raw, uint8_t len)
{
    int i;
    uint8_t *p_str;
    uint8_t ch;

    if ( raw == NULL )
    {
        QCRIL_LOG_ERROR("raw parameter is NULL");
        return NULL;
    }

    p_str = qcril_malloc ( len * 2 + 1);
    if ( p_str == NULL )
    {
        QCRIL_LOG_ERROR("mem alloc failed for iccid string");
        return NULL;
    }

    for ( i = 0; i < len; i++ )
    {
        ch = raw[i] & 0x0f;
        p_str[i*2] = ( ch < 10 ) ? ( ch + '0') : (ch - 10 + 'a');
        ch = raw[i] >> 4;
        p_str[i*2+1] = ( ch < 10 ) ? ( ch + '0') : (ch - 10 + 'a');
    }
    // add '\0' at end
    p_str[len*2] = 0;

    return p_str;
}

//===========================================================================
//qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card
//===========================================================================
void qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card()
{
    char*                               evidence;

    qmi_client_error_type               qmi_transport_error;
    RIL_Errno                           ril_err;
    int                                 need_fetch_home_mcc;
    int                                 home_mcc_available;
    uint32                              cur_status;

    char                                home_mcc_for_consideration[ NAS_MCC_MNC_MAX_V01 + 1 ];
    char                                emergency_nums[200] = {0};
    char                                mcc_emergency_nums[200] = {0};
    char                                voice_emergency_nums[200] = {0};

    uint8_t                             operating_mode_valid;
    dms_operating_mode_enum_v01         operating_mode;

    dms_get_msisdn_resp_msg_v01         get_msisdn_resp;
    dms_uim_get_iccid_resp_msg_v01      get_iccid_resp;
    char                                *mcc_from_iccid_ptr = NULL;
    char                                is_mcc_from_imsi_cache_valid = FALSE;

    qcril_card_status_e_type            card_status;

    int                                 need_update_cur_status;

    char*                               ecc_nums_to_consider;

    char**                              emergency_number_candidate;
    uint32_t                            slot = 0;
    uint8_t                             iccid_raw[ QCRIL_UIM_ICCID_LEN ];
    uint8_t                             iccid_len = QCRIL_UIM_ICCID_LEN;
    uint8_t*                            iccid_str = NULL;

    int                                 update_ecclist = FALSE;
    int                                 res        = FALSE;
    int                                 n = 0;
    qmi_ril_custom_emergency_numbers_source_type source;

    QCRIL_LOG_FUNC_ENTRY();

    if ( nas_common_info.custom_emergency_numbers_enabled )
    {
        NAS_CACHE_LOCK();
        cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
        operating_mode_valid = NAS_CACHE_IS_ENTRY_VALID( nas_dms_cached_info.operating_mode );
        if ( operating_mode_valid )
        {
            operating_mode = nas_dms_cached_info.operating_mode;
        }
        slot = qmi_ril_get_sim_slot();
        card_status = nas_common_info.card_info[slot].status;
        NAS_CACHE_UNLOCK();

        need_update_cur_status = FALSE;


        QCRIL_LOG_ESSENTIAL( "cur_status %d, card_state %d", (int) cur_status, (int) card_status  );


        // card present, check if home PLMN fetch & match could be done
        if ( QCRIL_CARD_STATUS_UP == card_status )
        {
            if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) )
            {
                memset( &get_msisdn_resp, 0, sizeof(get_msisdn_resp) );
                qmi_transport_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_DMS ),
                                                                QMI_DMS_GET_MSISDN_REQ_V01,
                                                                NULL,
                                                                NAS_NIL,
                                                                &get_msisdn_resp,
                                                                sizeof(get_msisdn_resp),
                                                                QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );
                ril_err = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_transport_error, &get_msisdn_resp.resp );

                QCRIL_LOG_ESSENTIAL( "imsi fetch attempt ril %d - res %d / err %d", (int)ril_err, (int)get_msisdn_resp.resp.result, (int)get_msisdn_resp.resp.error );

                if ( RIL_E_SUCCESS == ril_err && get_msisdn_resp.imsi_valid )
                {
                    cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
                    cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
                    need_update_cur_status = TRUE;

                    QCRIL_LOG_ESSENTIAL( "known imsi %s", get_msisdn_resp.imsi );

                    memset( &home_mcc_for_consideration, 0, sizeof( home_mcc_for_consideration ));
                    memcpy( &home_mcc_for_consideration, get_msisdn_resp.imsi, NAS_MCC_MNC_MAX_V01 );
                } // if ( RIL_E_SUCCESS == ril_err && get_msisdn_resp.imsi_valid )
                else
                {
                    NAS_CACHE_LOCK();
                    is_mcc_from_imsi_cache_valid = *nas_cached_info.mcc_from_imsi_cache;
                    NAS_CACHE_UNLOCK();

                    if ( is_mcc_from_imsi_cache_valid ) // cache from GET_IMSI available
                    {
                        NAS_CACHE_LOCK();
                        memset( &home_mcc_for_consideration, 0, sizeof( home_mcc_for_consideration ));
                        memcpy( &home_mcc_for_consideration, nas_cached_info.mcc_from_imsi_cache, NAS_MCC_MNC_MAX_V01 );

                        QCRIL_LOG_ESSENTIAL( "known cached imsi %c%c%c", (char)nas_cached_info.mcc_from_imsi_cache[0],
                                                                         (char)nas_cached_info.mcc_from_imsi_cache[1],
                                                                         (char)nas_cached_info.mcc_from_imsi_cache[2]  );
                        NAS_CACHE_UNLOCK();

                        cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
                        cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
                        cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
                        cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
                        need_update_cur_status = TRUE;
                    }
                    else
                    {
                        slot = qmi_ril_get_sim_slot();
                        ril_err = qcril_uim_read_iccid( slot, iccid_raw, &iccid_len );
                        if ( RIL_E_SUCCESS == ril_err )
                        {
                            iccid_str = qcril_iccid_to_string( iccid_raw, iccid_len );
                        }
                        else
                        {
                            QCRIL_LOG_ERROR("Failed to get iccid through SIM_IO");
                        }
                        if ( iccid_str != NULL )
                        {
                            QCRIL_LOG_ESSENTIAL( "iccid %s", iccid_str );

                            mcc_from_iccid_ptr = qcril_qmi_nas2_retrieve_mcc_from_iccid(iccid_str);
                            if( NULL != mcc_from_iccid_ptr )
                            {
                                cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED;
                                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
                                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
                                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
                                need_update_cur_status = TRUE;

                                QCRIL_LOG_ESSENTIAL( "known mcc %s", mcc_from_iccid_ptr );

                                memset( &home_mcc_for_consideration, 0, sizeof( home_mcc_for_consideration ));
                                memcpy( &home_mcc_for_consideration, mcc_from_iccid_ptr, NAS_MCC_MNC_MAX_V01 );
                            } // if( NULL != mcc_from_iccid_ptr )
                            else
                            {
                                QCRIL_LOG_ESSENTIAL( "Failed to retrieve mcc from iccid" );
                            }

                            qcril_free( iccid_str );
                            iccid_str = NULL;
                        } // if ( RIL_E_SUCCESS == ril_err )
                    }
                } // else branch, consiering local cache from GET_IMSI

                if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED )
                {
                    strlcpy(nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                            home_mcc_for_consideration,
                            NAS_MCC_MNC_MAX_V01 + 1);
                }
            } // if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) ) - fetch consider

            if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED )
            {
                // clear the status related with mcc/voice matched using mcc got from card
                // because we need to re-check this (triggered by card status change or voice service state change)
                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH;
                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH;
                cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED;
                // firstly, check SOURCE_MCC table with voice service state
                res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                                QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                                nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                emergency_nums);
                if ( res )
                {
                    QCRIL_LOG_ESSENTIAL( "matched with source mcc table using IMSI MCC");
                    cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH);
                    need_update_cur_status = TRUE;
                }

                // secondly, check SOURCE_VOICE table with voice service state
                res = qcril_check_mcc_part_of_emergency_numbers_table_with_service_state(
                            QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE,
                            nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                            emergency_nums);
                if ( res )
                {
                    QCRIL_LOG_ESSENTIAL("matched with source voice table using IMSI MCC");
                    cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH);
                    need_update_cur_status = TRUE;
                }

            } // if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED ) - QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH and QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH consider

            if ( cur_status &
                 ( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH
                 )
               )
            {
                cur_status &= ~( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK
                              );
                need_update_cur_status = TRUE;
            }

            // on this iteration, or previously we know if home plmn matches designated plmn, now check if projection of design. number is required
            if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED ) )
            {
                if( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH )
                {
                    res = qcril_db_is_mcc_part_of_emergency_numbers_table(QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                                nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                mcc_emergency_nums);
                    if ( res )
                    {
                        strlcat(emergency_nums,",",QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                        n = strlcat(emergency_nums,mcc_emergency_nums,QCRIL_MAX_EMERGENCY_NUMBERS_LEN);

                        // for print purpose
                        if ( n >=  QCRIL_MAX_EMERGENCY_NUMBERS_LEN )
                        {
                            QCRIL_LOG_WARN("Emergency number string exceeded max len - %d",n);
                        }
                        update_ecclist = TRUE;
                    }
                }
                if( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH )
                {
                    res = qcril_db_is_mcc_part_of_emergency_numbers_table(QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE,
                                nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                voice_emergency_nums);
                    if ( res )
                    {
                        strlcat(emergency_nums,",",QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                        n = strlcat(emergency_nums,voice_emergency_nums,QCRIL_MAX_EMERGENCY_NUMBERS_LEN);

                        // for print purpose
                        if ( n >=  QCRIL_MAX_EMERGENCY_NUMBERS_LEN )
                        {
                            QCRIL_LOG_WARN("Emergency number string exceeded max len - %d",n);
                        }
                        update_ecclist = TRUE;
                    }
                }

                if ( update_ecclist )
                {
                    QCRIL_LOG_ESSENTIAL( "Update ril ecclist");
                    qmi_ril_set_ecc_property(emergency_nums);
                    cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED; // indicate that we injected one of designated number
                    need_update_cur_status = TRUE;
                }

            } // if for mcc match but not projected
        } // if ( QCRIL_CARD_STATUS_UP == card_status )
        else
        { // card absent case
            if ( cur_status &
                 ( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH |
                   QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH
                 )
               )
            {
                cur_status &= ~( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_FETCHED |
                                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH_IDX_MASK
                              );
                need_update_cur_status = TRUE;
            }

            cur_status &= ~QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED;
            if (nas_common_info.custom_hardcoded_emergency_numbers_list)
            {
                strlcpy(emergency_nums, nas_common_info.custom_hardcoded_emergency_numbers_list, QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED;
                need_update_cur_status = TRUE;
            }

            if ( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED )
            {
                res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                    QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC,
                                    nas_cached_info.mcc_from_device_reg, emergency_nums);
                if( res )
                {
                    cur_status |= (QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH);
                    need_update_cur_status = TRUE;
                    strlcpy(nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                            nas_cached_info.mcc_from_device_reg,
                            NAS_MCC_MNC_MAX_V01 + 1);
                }
            }

            if ( !( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED ) )
            {
                if( cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
                {
                    res = qcril_db_is_mcc_part_of_emergency_numbers_table(
                                    QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC,
                                    nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                    mcc_emergency_nums);
                    if ( res )
                    {
                        if (cur_status & QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED)
                        {
                            strlcat(emergency_nums, ",", QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                        }
                        strlcat(emergency_nums, mcc_emergency_nums, QCRIL_MAX_EMERGENCY_NUMBERS_LEN);
                        cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED;
                        need_update_cur_status = TRUE;
                    }
                }
            }
        }

        if ( need_update_cur_status )
        {
            NAS_CACHE_LOCK();
            nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
            NAS_CACHE_UNLOCK();
        }
    }

    qmi_ril_set_ecc_property(emergency_nums);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_evaluate_custom_emergency_numbers_for_card


//===========================================================================
//qmi_ril_nwreg_is_designated_number_enforcable
//===========================================================================
int qmi_ril_nwreg_is_designated_number_enforcable_ncl(char * emergency_number)
{
    int      res = FALSE;
    uint32   match_index;

    NAS_CACHE_LOCK();

    if ( NULL != emergency_number )
    {
        if ( TRUE == nas_common_info.custom_emergency_numbers_enabled_for_nw &&
             (nas_cached_info.designated_number_added_for_designated_country_status &
              QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED) )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
            {
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                        nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_NW);
            }
        }
        else if ( nas_cached_info.designated_number_added_for_designated_country_status &
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
               QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH )
            {
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(
                            emergency_number,
                            nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                            QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC);
            }
        }
        else
        {
            if ( FALSE == nas_common_info.custom_emergency_numbers_enabled_for_nw &&
                     (nas_cached_info.designated_number_added_for_designated_country_status &
                      QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED) )
            {
                if( nas_cached_info.designated_number_added_for_designated_country_status &
                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH )
                {
                    res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                         nas_cached_info.designated_number_mcc[QCRIL_NW_MCC_MATCH_INDEX],
                                         QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD_MCC);
                }
            }

            if ( FALSE == res && (nas_cached_info.designated_number_added_for_designated_country_status &
                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED) )
            { // this is more "formality" for integrity checking as overwrote entire ecc list and we already matched given number against the emergeny number list
                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                         NULL,
                                         QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_HARD);
            }
        }
    }
    NAS_CACHE_UNLOCK();

    QCRIL_LOG_FUNC_RETURN_WITH_RET( res );
    return res;
} // qmi_ril_nwreg_is_designated_number_enforcable

//===========================================================================
//qmi_ril_nwreg_convert_emergency_number_to_ims_address
//===========================================================================
int qmi_ril_nwreg_convert_emergency_number_to_ims_address(char* emergency_number)
{
    char ims_address[QCRIL_MAX_IMS_ADDRESS_LEN];
    int res;

    NAS_CACHE_LOCK();

    memset(ims_address, 0, sizeof(ims_address));
    res = FALSE;

    if ( NULL != emergency_number )
    {
        QCRIL_LOG_INFO("emergency number %s", emergency_number);
        if ( nas_cached_info.designated_number_added_for_designated_country_status &
                QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
               QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_MCC_MATCH )
            {
                res =
                    qcril_db_is_ims_address_for_mcc_emergency_number_part_of_emergency_numbers_table
                    (
                        QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_MCC,
                        nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                        emergency_number,
                        ims_address
                    );

                if(res)
                {
                    strlcpy(emergency_number,
                            ims_address,
                            QCRIL_QMI_VOICE_DIAL_NUMBER_MAX_LEN);
                }
            }
        }

        if(res)
        {
            QCRIL_LOG_INFO("emergency number has been changed to %s", emergency_number);
        }
        else
        {
            QCRIL_LOG_INFO("emergency number is unchanged");
        }
    }
    NAS_CACHE_UNLOCK();

    return res;
} // qmi_ril_nwreg_convert_emergency_number_to_ims_address

//===========================================================================
//qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only
//===========================================================================
int qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only(char * emergency_number)
{
    int      res = FALSE;

    NAS_CACHE_LOCK();

    if ( NULL != emergency_number )
    {
        if ( nas_cached_info.designated_number_added_for_designated_country_status &
             QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED )
        {
            if( nas_cached_info.designated_number_added_for_designated_country_status &
                 QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_IMSI_VOICE_MATCH )
            {

                res = qcril_qmi_nas_is_number_part_of_custom_mcc_emergency_numbers(emergency_number,
                                    nas_cached_info.designated_number_mcc[QCRIL_IMSI_MCC_MATCH_INDEX],
                                    QMI_RIL_CUSTOM_EMERGENCY_NUMBERS_SOURCE_VOICE);
            }
        }
    }

    NAS_CACHE_UNLOCK();

    QCRIL_LOG_ESSENTIAL( "completed with %d", res );
    return res;
} // qmi_ril_nwreg_is_designated_number_emergency_for_display_purposes_only

//===========================================================================
//qmi_ril_nwreg_designated_number_ensure_fresh_check
//===========================================================================
void qmi_ril_nwreg_designated_number_ensure_fresh_check_ncl(void)
{
    NAS_CACHE_LOCK();
    nas_cached_info.designated_number_added_for_designated_country_status &=
       ~ (
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_DESIGNATED_MATCH_HOME_PLMN_NUM_PROJECTED | QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NO_CARD_SPECIFIC_NUMBERS_PROJECTED |
            QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED
         );
    NAS_CACHE_UNLOCK();
} // qmi_ril_nwreg_designated_number_ensure_fresh_check

//===========================================================================
//qcril_common_update_current_imsi
//===========================================================================
void qcril_common_update_current_imsi( char * imsi_str, int is_gwl )
{
    int imsi_str_len;

    if ( NULL != imsi_str )
    {
        QCRIL_LOG_ESSENTIAL( "cur imsi %s, is gwl %d", imsi_str, is_gwl );

        imsi_str_len = strlen( imsi_str );

        if ( imsi_str_len >= NAS_MCC_MNC_MAX_V01 )
        {
            NAS_CACHE_LOCK();
            memcpy( nas_cached_info.mcc_from_imsi_cache, imsi_str, NAS_MCC_MNC_MAX_V01 );
            NAS_CACHE_UNLOCK();

            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                           QCRIL_DEFAULT_MODEM_ID,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                           NULL,
                           QMI_RIL_ZERO,
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        }

    }
} // qcril_common_update_current_imsi

//===========================================================================
//qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc
//===========================================================================
void qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc()
{
    char current_mcc [ NAS_MCC_MNC_MAX_V01 + 1];
    char current_mnc [ NAS_MCC_MNC_MAX_V01 + 1];
    uint32 cur_status;
    int is_mcc_retrieved;
    int is_mcc_changed;
    int is_recalculate;

    QCRIL_LOG_FUNC_ENTRY();

    memset(current_mcc, 0, sizeof(current_mcc));
    memset(current_mnc, 0, sizeof(current_mnc));
    cur_status = nas_cached_info.designated_number_added_for_designated_country_status;
    is_mcc_retrieved = FALSE;
    is_mcc_changed = FALSE;
    is_recalculate = FALSE;

    if ( nas_common_info.custom_emergency_numbers_enabled )
    {
        is_mcc_retrieved = qcril_qmi_nas_find_current_mcc_mnc( current_mcc, current_mnc, FALSE, NULL );
        if( is_mcc_retrieved )
        {
            if( strcmp(current_mcc, nas_cached_info.mcc_from_device_reg) )
            {
                is_mcc_changed = TRUE;
                strlcpy(nas_cached_info.mcc_from_device_reg, current_mcc, sizeof(nas_cached_info.mcc_from_device_reg));
            }

            if ( ((TRUE == nas_common_info.custom_emergency_numbers_enabled_for_nw &&
                 (QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.voice_rte_confidence_tag ||
                 QMI_RIL_RAT_CONFIDENCE_LTD_SVC == nas_cached_info.voice_rte_confidence_tag))
                 ||
                 (FALSE == nas_common_info.custom_emergency_numbers_enabled_for_nw &&
                 QMI_RIL_RAT_CONFIDENCE_LTD_SVC == nas_cached_info.voice_rte_confidence_tag))
                 &&
                 TRUE == is_mcc_changed )
            {
                    is_recalculate = TRUE;
                    cur_status |= QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_FETCHED;
                    cur_status &= ~( QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_NUMBERS_PROJECTED |
                                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH |
                                     QMI_RIL_NWREG_DESIGNATED_NUM_ADDON_STATUS_NW_MCC_MATCH_IDX_MASK
                                  );
            }
        }


        if( is_recalculate )
        {
            nas_cached_info.designated_number_added_for_designated_country_status = cur_status;
            qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                               QCRIL_DEFAULT_MODEM_ID,
                               QCRIL_DATA_ON_STACK,
                               QCRIL_EVT_QMI_RIL_ASSESS_EMRGENCY_NUMBER_LIST_DESIGNATED_COUNTRY,
                               NULL,
                               QMI_RIL_ZERO,
                               (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
        }
    }

    QCRIL_LOG_FUNC_RETURN();

} // qmi_ril_nwreg_update_current_nw_mcc_for_custom_ecc




// ** eMBMS s

//===========================================================================
//qcril_qmi_nas_embms_txn_enable_act
//===========================================================================
void qcril_qmi_nas_embms_txn_enable_act( qmi_ril_embms_op_enable_transaction_command_e_type command, RIL_Errno status, void* extra )
{
    qmi_ril_embms_op_enable_transaction_state_e_type cur_state;
    qmi_ril_embms_op_enable_transaction_state_e_type outcome_state;

    RIL_Errno                                        res = RIL_E_GENERIC_FAILURE;
    int                                              need_conclusion;
    int                                              need_state_transition;
    errno_enum_type                                  found_qcril_request;
    qcril_reqlist_public_type                        qcril_req_info;
    nas_config_embms_req_msg_v01                     nas_enable_req;
    nas_config_embms_resp_msg_v01*                   nas_enable_resp;
    int                                              is_ok;
    int                                              need_post_data_cmd;
    qcril_embms_enable_request_payload_type          data_enable_payload_req;
    qcril_embms_enable_response_payload_type*        data_con_payload;
    int                                              need_abnormal_drop;
    qcril_request_resp_params_type                   resp;
    embms_enable_embms_resp_msg_v01                  tunneled_resp;
    const struct timeval                             enable_timeout = { 30 , 0 }; // 30 seconds
    uint32                                           timeout_timer_id;
    qmi_client_error_type                            qmi_client_error;
    qmi_txn_handle                                   txn_handle;
    uint8_t                                          is_embms_enabled = FALSE;



    QCRIL_LOG_INFO( "command: %d", (int) command );

    NAS_CACHE_LOCK();
    cur_state = nas_cached_info.embms_enable_txn_state;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. cur txn state %d", (int) cur_state );

    outcome_state               = cur_state; // default
    need_conclusion             = FALSE;
    need_state_transition       = FALSE;
    need_abnormal_drop          = FALSE;
    need_post_data_cmd          = FALSE;
    data_con_payload            = NULL;

    switch ( command )
    {
        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_INITIATE:
            // Update nas cache for embms status
            NAS_CACHE_LOCK();
            is_embms_enabled = nas_cached_info.embms_enabled;
            NAS_CACHE_UNLOCK();

            if(is_embms_enabled == FALSE)
            {
                nas_enable_resp = NULL;
                is_ok           = FALSE;
                do
                {
                    if ( cur_state != QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE )
                        break;

                    nas_enable_resp = qcril_malloc( sizeof( *nas_enable_resp ) );
                    if ( NULL == nas_enable_resp )
                    {
                        QCRIL_LOG_ERROR( "%s","mem alloc failed" );
                        break;
                    }

                    memset( &nas_enable_req, 0, sizeof(nas_enable_req) );
                    nas_enable_req.enable = TRUE;
                    nas_enable_req.trace_id_valid = TRUE;
                    NAS_CACHE_LOCK();
                    nas_enable_req.trace_id = nas_cached_info.embms_enable_dbg_trace_id;
                    NAS_CACHE_UNLOCK();

                    qmi_client_error =  qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                       QMI_NAS_CONFIG_EMBMS_REQ_MSG_V01,
                                                                       (void*) &nas_enable_req,
                                                                       sizeof( nas_enable_req ),
                                                                       (void*) nas_enable_resp,
                                                                       sizeof( *nas_enable_resp ),
                                                                       qcril_qmi_nas_embms_set_enable_cmd_cb,
                                                                       NULL,
                                                                       &txn_handle
                                                                        );

                    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

                    if ( RIL_E_SUCCESS != res )
                    {
                        QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)res, (int)qmi_client_error );
                        break;
                    }

                    qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                QCRIL_DEFAULT_MODEM_ID,
                                                qcril_qmi_nas_embms_set_enable_timeout_handler_handler,
                                                &enable_timeout,
                                                &timeout_timer_id );
                    NAS_CACHE_LOCK();
                    nas_cached_info.embms_enable_timeout_timerid = timeout_timer_id;
                    NAS_CACHE_UNLOCK();

                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND;

                    is_ok = TRUE;
                } while (FALSE);

                if ( !is_ok )
                {
                    if( NULL != nas_enable_resp )
                    {
                        qcril_free( nas_enable_resp );
                    }
                    need_abnormal_drop = TRUE;
                }
            }
            else
            {
                //From NAS perspective embms is already enabled.
                //We just need to enable the data here.
                need_post_data_cmd = TRUE;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_CON:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON;
                    }
                    else
                    {
                        need_abnormal_drop = TRUE;
                        res                =  status;
                    }
                    break;

                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_post_data_cmd = TRUE;
                    }
                    else
                    {
                        need_abnormal_drop = TRUE;
                        res                =  status;
                    }
                    break;

                default:
                    // no action
                    break;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_IND:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION;
                    break;

                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON:
                    need_post_data_cmd = TRUE;
                    break;

                default:
                    // no action
                    break;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_DATA_CON:
            data_con_payload = (qcril_embms_enable_response_payload_type*)extra;
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON:
                    need_conclusion             = TRUE;

                    need_state_transition       = TRUE;
                    outcome_state               = QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE;

                    if ( NULL != data_con_payload )
                    {
                        res                      = data_con_payload->cause;
                    }
                    else
                    {
                        res = RIL_E_SUCCESS;
                    }
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT:   // pass through
        case QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_OR_IND:
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_INDICATION_AFTER_CON:
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_NAS_ENABLE_CON_AFTER_INDICATION:
                case QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON:
                    need_abnormal_drop          = TRUE;
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        default:
            break;
    }

    if ( need_post_data_cmd )
    {
        memset( &data_enable_payload_req, 0, sizeof( data_enable_payload_req ) );
        NAS_CACHE_LOCK();
        data_enable_payload_req.dbg_trace_id = nas_cached_info.embms_enable_dbg_trace_id;
        NAS_CACHE_UNLOCK();
        qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                           QCRIL_DEFAULT_MODEM_ID,
                           QCRIL_DATA_ON_STACK,
                           QCRIL_EVT_QMI_RIL_EMBMS_ENABLE_DATA_REQ,
                           (void *) &data_enable_payload_req,
                           sizeof( data_enable_payload_req ),
                           (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );


        need_state_transition = TRUE;
        outcome_state         = QMI_RIL_EMBMS_ENABLE_TXN_STATE_AWAITING_DATA_RIL_CON;
    }

    if ( need_abnormal_drop )
    {
        need_conclusion             = TRUE;
        need_state_transition       = TRUE;
        outcome_state               = QMI_RIL_EMBMS_ENABLE_TXN_STATE_NONE;
    }

    if ( need_state_transition )
    {
        NAS_CACHE_LOCK();
        nas_cached_info.embms_enable_txn_state = outcome_state;
        NAS_CACHE_UNLOCK();
    }
    if ( need_conclusion )
    {
        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                            QCRIL_DEFAULT_MODEM_ID,
                                                            QCRIL_EVT_QMI_REQUEST_EMBMS_ENABLE,
                                                            &qcril_req_info );
        if ( E_SUCCESS == found_qcril_request )
        {
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               res,
                                               &resp );
            memset( &tunneled_resp, 0, sizeof( tunneled_resp ) );

            if ( RIL_E_SUCCESS == res && NULL != data_con_payload )
            {
                tunneled_resp.call_id_valid = TRUE;
                tunneled_resp.call_id       = data_con_payload->call_id;

                tunneled_resp.interface_name_valid = TRUE;
                strlcpy( tunneled_resp.interface_name, data_con_payload->interafce_name, NUMBER_MAX_V01 );

                tunneled_resp.if_index_valid = TRUE;
                tunneled_resp.if_index = data_con_payload->if_index;

                tunneled_resp.dbg_trace_id = data_con_payload->dbg_trace_id;
                tunneled_resp.resp_code = data_con_payload->resp_code;
            }
            else
            {
                NAS_CACHE_LOCK();
                tunneled_resp.dbg_trace_id = nas_cached_info.embms_enable_dbg_trace_id;
                NAS_CACHE_UNLOCK();
                tunneled_resp.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
            }
            resp.resp_pkt = (void *) &tunneled_resp;
            resp.resp_len = sizeof( tunneled_resp );

            qcril_send_request_response( &resp );

            NAS_CACHE_LOCK();
            QCRIL_LOG_INFO("res: %d, data_con_payload: %p, nas_cached_info.embms_enabled: %d", res, data_con_payload, nas_cached_info.embms_enabled);
            if (RIL_E_SUCCESS == res && NULL != data_con_payload && nas_cached_info.embms_enabled)
            {
               nas_cached_info.embms_enable_success_sent_to_atel = TRUE;
               nas_cached_info.embms_cell_id_sent_after_enabled = FALSE;
               nas_cached_info.embms_coverage_sent_after_enabled = FALSE;
            }
            NAS_CACHE_UNLOCK();

            qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(FALSE, 0);
            qcril_qmi_nas_embms_send_cell_info_changed_if_needed(FALSE, NULL);
            qcril_qmi_nas_embms_send_radio_state( ( RADIO_STATE_UNAVAILABLE == qcril_qmi_nas_dms_get_current_power_state(QCRIL_DEFAULT_INSTANCE_ID) )
                                                  ? RADIO_STATE_NOT_AVAILABLE_V01 : RADIO_STATE_AVAILABLE_V01
                                                );
        }
        else
        {
            QCRIL_LOG_ERROR( ".. pending event not found %d", (int) found_qcril_request );
        }

        NAS_CACHE_LOCK();
        timeout_timer_id = nas_cached_info.embms_enable_timeout_timerid;
        NAS_CACHE_UNLOCK();
        if ( QMI_RIL_ZERO != timeout_timer_id )
        {
            qcril_cancel_timed_callback( (void*)(uintptr_t)timeout_timer_id );
        }
        NAS_CACHE_LOCK();
        nas_cached_info.embms_enable_timeout_timerid = QMI_RIL_ZERO;
        NAS_CACHE_UNLOCK();

    }

    QCRIL_LOG_INFO( "completed and cur state is %d", (int) outcome_state );
} // qcril_qmi_nas_embms_txn_enable_act

//===========================================================================
// qcril_qmi_nas_embms_set_enable_timeout_handler_handler
//===========================================================================
void  qcril_qmi_nas_embms_set_enable_timeout_handler_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.embms_enable_timeout_timerid = QMI_RIL_ZERO;
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_enable_timeout_handler_handler

//===========================================================================
// qcril_qmi_nas_embms_set_enable_cmd_cb
//===========================================================================
void qcril_qmi_nas_embms_set_enable_cmd_cb
(
  qmi_client_type              user_handle,
  unsigned int                 message_id,
  void                        *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    QCRIL_LOG_FUNC_ENTRY();

    qcril_qmi_nas_post_event(user_handle,
                             message_id,
                             QCRIL_EVT_QMI_REQUEST_EMBMS_SET_ENABLE,
                             resp_c_struct,
                             resp_c_struct_len,
                             resp_cb_data,
                             transp_err);
    QCRIL_LOG_FUNC_RETURN();
}

//===========================================================================
// qcril_qmi_nas_embms_set_enable_cmd_cb
//===========================================================================
void qcril_qmi_nas_embms_set_enable_cmd_cb_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    void *resp_c_struct = NULL;
    qmi_client_error_type  transp_err;
    qmi_resp_callback_type * qmi_resp_callback = NULL;

    qmi_resp_callback = (qmi_resp_callback_type *) params_ptr->data;
    resp_c_struct = qmi_resp_callback->data_buf;
    transp_err = qmi_resp_callback->transp_err;

    nas_config_embms_resp_msg_v01 * qmi_response   = (nas_config_embms_resp_msg_v01 *) resp_c_struct;
    RIL_Errno                       ril_req_res = RIL_E_GENERIC_FAILURE;


    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &qmi_response->resp );

        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d", (int) ril_req_res, (int)transp_err, (int) qmi_response->resp.error );

        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_CON, ril_req_res, NULL );

        qcril_free( qmi_response );  // we own it
    }
    else
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_set_enable_cmd_cb

//===========================================================================
// qcril_qmi_nas_embms_fetch_embms_status
//===========================================================================
RIL_Errno qcril_qmi_nas_embms_fetch_embms_status()
{
    qmi_client_error_type qmi_client_error;
    RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
    nas_get_embms_status_resp_msg_v01 * qmi_response = NULL;

    qmi_response = qcril_malloc( sizeof( *qmi_response ) );
    if ( qmi_response )
    {

        qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                           QMI_NAS_GET_EMBMS_STATUS_REQ_MSG_V01,
                                                           NULL,
                                                           NAS_NIL,  // empty request payload
                                                           (void*) qmi_response,
                                                           sizeof( *qmi_response ),
                                                           QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );


        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, &qmi_response->resp );


        if ( RIL_E_SUCCESS == ril_req_res )
        {
            NAS_CACHE_LOCK();
            QCRIL_LOG_INFO(".. embms current valid %d value %d, cached value %d",
                           qmi_response->enabled_valid,
                           qmi_response->enabled,
                           nas_cached_info.embms_enabled);

            if( qmi_response->enabled_valid &&
                nas_cached_info.embms_enabled != qmi_response->enabled )
            {
                nas_cached_info.embms_enabled = qmi_response->enabled;
                qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_nas_embms_embms_status_ind_handler_retranslator,
                                            NULL,   // no param
                                            NULL,   // immediate
                                            NULL );
            }
            NAS_CACHE_UNLOCK();
        }

        qcril_free( qmi_response );
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res);

    return ril_req_res;
} // qcril_qmi_nas_embms_fetch_embms_status

//===========================================================================
// qcril_qmi_nas_embms_embms_status_ind_handler
//===========================================================================
void qcril_qmi_nas_embms_embms_status_ind_handler(nas_embms_status_ind_msg_v01* status_ind)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_LOG_INFO( ".. embms enabled %d", status_ind->enabled );
    NAS_CACHE_LOCK();
    nas_cached_info.embms_enabled = status_ind->enabled;
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_embms_embms_status_ind_handler_retranslator(NULL);

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_embms_status_ind_handler

//===========================================================================
// qcril_qmi_nas_embms_embms_status_ind_handler_retranslator
//===========================================================================
void qcril_qmi_nas_embms_embms_status_ind_handler_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    uint8_t enabled;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(handler_params);

    NAS_CACHE_LOCK();
    enabled = nas_cached_info.embms_enabled;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. is embms enabled %d", enabled );

    if ( enabled )
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_NAS_ENABLE_IND, RIL_E_SUCCESS, NULL );
    }
    else
    {
        qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_IND, RIL_E_SUCCESS, NULL );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_embms_status_ind_handler_retranslator

//===========================================================================
// qcril_qmi_nas_embms_enable_error_halt_retranslator
//===========================================================================
void qcril_qmi_nas_embms_enable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    QCRIL_LOG_INFO( "%s", "qcril_qmi_nas_embms_enable_error_halt_retranslator entered" );

    QCRIL_NOTUSED( handler_params );

    qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_enable_error_halt_retranslator


//===========================================================================
// qcril_qmi_nas_embms_enable_data_con_retranslator
//===========================================================================
void qcril_qmi_nas_embms_enable_data_con_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    qcril_embms_enable_response_payload_type* response_payload_copy;

    QCRIL_LOG_FUNC_ENTRY();

    response_payload_copy = (qcril_embms_enable_response_payload_type*)handler_params->custom_param;
    if ( NULL != response_payload_copy )
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_ACK_DATA_CON, RIL_E_SUCCESS, response_payload_copy );

        qcril_free( response_payload_copy );
    }
    else
    {
        qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_enable_data_con_retranslator

//===========================================================================
//QCRIL_EVT_QMI_RIL_EMBMS_ENABLE_DATA_CON
//===========================================================================
void qcril_qmi_nas_embms_enable_data_con
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_embms_enable_response_payload_type* response_payload;
    qcril_embms_enable_response_payload_type* response_payload_copy;

    int is_error;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    is_error = TRUE;

    response_payload = params_ptr->data;
    if ( response_payload != NULL )
    {
        response_payload_copy = qcril_malloc( sizeof( *response_payload_copy ) );
        if ( response_payload_copy )
        {
            *response_payload_copy = *response_payload;
            qcril_setup_timed_callback_ex_params_adv( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qcril_qmi_nas_embms_enable_data_con_retranslator,
                                        (void*)response_payload_copy,
                                        TRUE,
                                        NULL,   // immediate
                                        NULL );
            is_error = FALSE;
        }
        else
        {
            QCRIL_LOG_ERROR( ".. retranslation buf alloc failed" );
        }
    }

    if ( is_error )
    {
        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_enable_error_halt_retranslator,
                                    NULL,   // no param
                                    NULL,   // immediate
                                    NULL );
    }


    QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_embms_enable_data_con


//===========================================================================
//QCRIL_EVT_HOOK_EMBMS_ENABLE
//===========================================================================
void qcril_qmi_nas_embms_requst_enable
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type    resp;
  RIL_Errno                         ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_reqlist_public_type         qcril_req_info_ptr;
  embms_enable_embms_req_msg_v01    *req_payload = params_ptr->data;
  embms_enable_embms_resp_msg_v01   resp_payload;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  NAS_CACHE_LOCK();
  if (nas_cached_info.embms_enabled)
  {
     nas_cached_info.embms_enable_success_sent_to_atel = FALSE;
  }
  NAS_CACHE_UNLOCK();

  do
  {
    if ( NULL != req_payload )
    {
      NAS_CACHE_LOCK();
      nas_cached_info.embms_enable_dbg_trace_id = req_payload->dbg_trace_id;
      NAS_CACHE_UNLOCK();
    }
    else
    {
      QCRIL_LOG_ERROR("invalid NULL parameter for embms disable request");
      break;
    }

    qcril_reqlist_default_entry( params_ptr->t,
                         params_ptr->event_id,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                         QCRIL_EVT_QMI_REQUEST_EMBMS_ENABLE,
                         NULL,
                         &qcril_req_info_ptr );
    if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) )
    {
        break;
    }

    // Update nas cache for embms status
    if ( RIL_E_SUCCESS != qcril_qmi_nas_embms_fetch_embms_status())
    {
        break;
    }

    qcril_qmi_nas_embms_txn_enable_act( QMI_RIL_EMBMS_ENABLE_TXN_SIGNAL_INITIATE, RIL_E_SUCCESS, NULL );
    ril_req_res = RIL_E_SUCCESS;
  } while ( FALSE );


  if (RIL_E_SUCCESS != ril_req_res)
  { // rollback
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      memset( &resp_payload, 0, sizeof( resp_payload ) );

      NAS_CACHE_LOCK();
      resp_payload.dbg_trace_id = nas_cached_info.embms_enable_dbg_trace_id;
      NAS_CACHE_UNLOCK();
      resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

      resp.resp_pkt = (void *) &resp_payload;
      resp.resp_len = sizeof( resp_payload );
      qcril_send_request_response( &resp );
  }

  QCRIL_LOG_INFO( "ril_req_res: %d", (int) ril_req_res );

}// qcril_qmi_nas_embms_requst_enable


//===========================================================================
//qcril_qmi_nas_embms_txn_disable_act
//===========================================================================
void qcril_qmi_nas_embms_txn_disable_act( qmi_ril_embms_op_disable_transaction_command_e_type command, RIL_Errno status, void* extra )
{
    qmi_ril_embms_op_disable_transaction_state_e_type cur_state;
    qmi_ril_embms_op_disable_transaction_state_e_type outcome_state;

    RIL_Errno                                        res = RIL_E_GENERIC_FAILURE;
    int                                              need_conclusion;
    int                                              need_state_transition;
    errno_enum_type                                  found_qcril_request;
    qcril_reqlist_public_type                        qcril_req_info;
    nas_config_embms_req_msg_v01                     nas_disable_req;
    nas_config_embms_resp_msg_v01*                   nas_disable_resp;
    int                                              is_ok;
    qcril_embms_disable_indication_payload_type*     data_ind_payload;
    int                                              need_abnormal_drop;
    int                                              need_normal_drop;
    qcril_request_resp_params_type                   resp;
    embms_disable_embms_resp_msg_v01                 tunneled_resp;
    const struct timeval                             disable_timeout = { 30 , 0 }; // 30 seconds
    uint32                                           timeout_timer_id;
    qmi_client_error_type                            qmi_client_error;
    qmi_txn_handle                                   txn_handle;



    QCRIL_LOG_INFO( "command: %d", (int) command );

    NAS_CACHE_LOCK();
    cur_state = nas_cached_info.embms_disable_txn_state;
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_INFO( ".. cur txn state %d", (int) cur_state );

    outcome_state               = cur_state; // default
    need_conclusion             = FALSE;
    need_state_transition       = FALSE;
    need_abnormal_drop          = FALSE;
    need_normal_drop            = FALSE;
    data_ind_payload            = NULL;

    switch ( command )
    {
        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_INITIATE:
            nas_disable_resp = NULL;
            is_ok            = FALSE;
            do
            {
                if ( cur_state != QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE )
                    break;

                nas_disable_resp = qcril_malloc( sizeof( *nas_disable_resp ) );
                if ( NULL == nas_disable_resp )
                    break;

                memset( &nas_disable_req, 0, sizeof(nas_disable_req) );
                nas_disable_req.enable = FALSE;
                nas_disable_req.trace_id_valid = TRUE;
                NAS_CACHE_LOCK();
                nas_disable_req.trace_id = nas_cached_info.embms_disable_dbg_trace_id;
                NAS_CACHE_UNLOCK();

                qmi_client_error =  qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                                   QMI_NAS_CONFIG_EMBMS_REQ_MSG_V01,
                                                                   (void*) &nas_disable_req,
                                                                   sizeof( nas_disable_req ),
                                                                   (void*) nas_disable_resp,
                                                                   sizeof( *nas_disable_resp ),
                                                                   qcril_qmi_nas_embms_set_disable_cmd_cb,
                                                                   NULL,
                                                                   &txn_handle
                                                                    );

                res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

                if ( RIL_E_SUCCESS != res )
                    break;

                qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                            QCRIL_DEFAULT_MODEM_ID,
                                            qcril_qmi_nas_embms_set_disable_timeout_handler_handler,
                                            &disable_timeout,
                                            &timeout_timer_id );
                NAS_CACHE_LOCK();
                nas_cached_info.embms_disable_timeout_timerid = timeout_timer_id;
                NAS_CACHE_UNLOCK();

                need_state_transition = TRUE;
                outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND;

                is_ok = TRUE;
            } while (FALSE);

            if ( !is_ok )
            {
                if( NULL != nas_disable_resp )
                {
                    qcril_free( nas_disable_resp );
                }
                need_abnormal_drop = TRUE;
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_CON:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_state_transition = TRUE;
                        outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON:
                    if ( RIL_E_SUCCESS == status )
                    {
                        need_normal_drop      = TRUE;
                    }
                    else
                    {
                        need_abnormal_drop    = TRUE;
                    }
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_IND:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND;
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND;
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND:
                    need_state_transition = TRUE;
                    outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON;
                    break;

                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND:
                    need_normal_drop      = TRUE;
                    break;

                default:
                    // break
                    break;
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_DATA_IND:
            if ( RIL_E_SUCCESS != status )
            {
                res                = status;
                need_abnormal_drop = TRUE;
            }
            else
            {
                data_ind_payload = (qcril_embms_disable_indication_payload_type* )extra;
                if ( data_ind_payload )
                {
                    switch ( cur_state )
                    {
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND:
                            NAS_CACHE_LOCK();
                            nas_cached_info.embms_disable_resp_call_id = data_ind_payload->call_id;
                            NAS_CACHE_UNLOCK();
                            break;

                        default:
                            // nothing
                            break;
                    }
                    switch ( cur_state )
                    {
                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:
                            need_state_transition = TRUE;
                            outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND;
                            break;

                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:
                            need_state_transition = TRUE;
                            outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND;
                            break;

                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:
                            need_state_transition = TRUE;
                            outcome_state         = QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON;
                            break;

                        case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND:
                            need_normal_drop      = TRUE;
                            break;

                        default:
                            // nothing
                            break;
                    }
                }
            }
            break;

        case QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT:
            switch ( cur_state )
            {
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND_OR_DATA_IND:       // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND_OR_DATA_IND:              // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_DATA_IND:              // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON_OR_IND:                   // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_CON:                          // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_DATA_IND:                                 // pass through
                case QMI_RIL_EMBMS_DISABLE_TXN_STATE_AWAITING_NAS_DISABLE_IND:                          // pass through
                    need_abnormal_drop = TRUE;
                    break;

                default:
                    // nothing
                    break;
            }
            break;

        default:
            break;
    }


    if ( need_abnormal_drop )
    {
        need_conclusion             = TRUE;
        need_state_transition       = TRUE;
        outcome_state               = QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE;
    }

    if ( need_normal_drop )
    {
        need_conclusion             = TRUE;
        need_state_transition       = TRUE;
        res                         = RIL_E_SUCCESS;
        outcome_state               = QMI_RIL_EMBMS_DISABLE_TXN_STATE_NONE;
    }

    if ( need_state_transition )
    {
        NAS_CACHE_LOCK();
        nas_cached_info.embms_disable_txn_state = outcome_state;
        NAS_CACHE_UNLOCK();
    }
    if ( need_conclusion )
    {
        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                            QCRIL_DEFAULT_MODEM_ID,
                                                            QCRIL_EVT_QMI_REQUEST_EMBMS_DISABLE,
                                                            &qcril_req_info );
        if ( E_SUCCESS == found_qcril_request )
        {
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               res,
                                               &resp );
            memset( &tunneled_resp, 0, sizeof( tunneled_resp ) );

            if ( RIL_E_SUCCESS == res )
            {
                tunneled_resp.call_id_valid = TRUE;
                NAS_CACHE_LOCK();
                tunneled_resp.call_id       = nas_cached_info.embms_disable_resp_call_id;
                tunneled_resp.dbg_trace_id  = nas_cached_info.embms_disable_dbg_trace_id;
                NAS_CACHE_UNLOCK();
                tunneled_resp.resp_code     = QMI_RIL_EMBMS_SUCCESS;
            }
            else
            {
                NAS_CACHE_LOCK();
                tunneled_resp.dbg_trace_id  = nas_cached_info.embms_disable_dbg_trace_id;
                NAS_CACHE_UNLOCK();
                tunneled_resp.resp_code     = QMI_RIL_EMBMS_ERROR_UNKNOWN;
            }
            resp.resp_pkt = (void *) &tunneled_resp;
            resp.resp_len = sizeof( tunneled_resp );

            qcril_send_request_response( &resp );
        }
        else
        {
            QCRIL_LOG_ERROR( ".. pending event not found %d", (int) found_qcril_request );
        }

        NAS_CACHE_LOCK();
        timeout_timer_id = nas_cached_info.embms_disable_timeout_timerid;
        NAS_CACHE_UNLOCK();
        if ( QMI_RIL_ZERO != timeout_timer_id )
        {
            qcril_cancel_timed_callback( (void*)(uintptr_t)timeout_timer_id );
        }
        NAS_CACHE_LOCK();
        nas_cached_info.embms_disable_timeout_timerid = QMI_RIL_ZERO;
        NAS_CACHE_UNLOCK();

    }

    QCRIL_LOG_INFO( "completed and cur state is %d", (int) outcome_state );
} // qcril_qmi_nas_embms_txn_disable_act

//===========================================================================
// qcril_qmi_nas_embms_set_disable_cmd_cb
//===========================================================================
void qcril_qmi_nas_embms_set_disable_cmd_cb
(
  qmi_client_type              user_handle,
  unsigned int                 message_id,
  void                        *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    nas_config_embms_resp_msg_v01 * qmi_response   = (nas_config_embms_resp_msg_v01 *) resp_c_struct;
    RIL_Errno                       ril_req_res = RIL_E_GENERIC_FAILURE;


    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(user_handle);
    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);
    QCRIL_NOTUSED(resp_cb_data);

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &qmi_response->resp );

        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d", (int) ril_req_res, (int)transp_err, (int) qmi_response->resp.error );

        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator,
                                    (void*)ril_req_res,
                                    NULL,   // immediate
                                    NULL );


        qcril_free( qmi_response );  // we own it
    }
    else
    {
        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_disable_error_halt_retranslator,
                                    NULL,   // no param
                                    NULL,   // immediate
                                    NULL );
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_set_disable_cmd_cb

//===========================================================================
// qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator
//===========================================================================
void qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    RIL_Errno  ril_req_res;

    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = (RIL_Errno)handler_params->custom_param;
    qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_DISABLE_CON, ril_req_res, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_disable_cmd_cb_retranslator

//===========================================================================
// qcril_qmi_nas_embms_disable_error_halt_retranslator
//===========================================================================
void qcril_qmi_nas_embms_disable_error_halt_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED( handler_params );

    qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_HALT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_disable_error_halt_retranslator

//===========================================================================
//QCRIL_EVT_QMI_RIL_EMBMS_DISABLE_DATA_IND
//===========================================================================
void qcril_qmi_nas_embms_disable_data_ind
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_embms_disable_indication_payload_type* indication_payload;
    qcril_embms_disable_indication_payload_type* indication_payload_copy;
    int is_error;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    is_error = TRUE;
    indication_payload = params_ptr->data;
    if ( indication_payload != NULL )
    {
        indication_payload_copy = qcril_malloc( sizeof( *indication_payload_copy ) );
        if ( indication_payload_copy )
        {
            *indication_payload_copy = *indication_payload;
            qcril_setup_timed_callback_ex_params_adv( QCRIL_DEFAULT_INSTANCE_ID,
                                        QCRIL_DEFAULT_MODEM_ID,
                                        qcril_qmi_nas_embms_disable_data_ind_retranslator,
                                        (void*)indication_payload_copy,
                                        TRUE,
                                        NULL,   // immediate
                                        NULL );
            is_error = FALSE;
        }
        else
        {
            QCRIL_LOG_ERROR( ".. retranslation buf alloc failed" );
        }
    }
    if ( is_error )
    {
        qcril_setup_timed_callback_ex_params( QCRIL_DEFAULT_INSTANCE_ID,
                                    QCRIL_DEFAULT_MODEM_ID,
                                    qcril_qmi_nas_embms_disable_error_halt_retranslator,
                                    NULL,   // no param
                                    NULL,   // immediate
                                    NULL );
    }


    QCRIL_LOG_FUNC_RETURN();

}// qcril_qmi_nas_embms_disable_data_ind

//===========================================================================
// qcril_qmi_nas_embms_disable_data_ind_retranslator
//===========================================================================
void qcril_qmi_nas_embms_disable_data_ind_retranslator(qcril_timed_callback_handler_params_type * handler_params)
{
    qcril_embms_disable_indication_payload_type* indication_payload_copy;

    QCRIL_LOG_FUNC_ENTRY();

    indication_payload_copy = (qcril_embms_disable_indication_payload_type*)handler_params->custom_param;
    if ( NULL != indication_payload_copy )
    {
        qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_DATA_IND, RIL_E_SUCCESS, indication_payload_copy );

        qcril_free( indication_payload_copy );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_disable_data_ind_retranslator

//===========================================================================
// qcril_qmi_nas_embms_set_disable_timeout_handler_handler
//===========================================================================
void  qcril_qmi_nas_embms_set_disable_timeout_handler_handler(void * param)
{
    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED( param );

    NAS_CACHE_LOCK();
    nas_cached_info.embms_disable_timeout_timerid = QMI_RIL_ZERO;
    NAS_CACHE_UNLOCK();

    qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_ACK_NAS_TIMEOUT, RIL_E_SUCCESS, NULL );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_set_disable_timeout_handler_handler

//===========================================================================
//QCRIL_EVT_HOOK_EMBMS_DISABLE
//===========================================================================
void qcril_qmi_nas_embms_requst_disable
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type        resp;
  RIL_Errno                             ril_req_res = RIL_E_GENERIC_FAILURE;

  qcril_reqlist_public_type             qcril_req_info_ptr;
  embms_disable_embms_req_msg_v01   *   req_params;
  embms_disable_embms_resp_msg_v01      resp_payload;

  boolean disable_needed = TRUE;
  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  do
  {
    req_params = params_ptr->data;
    if ( NULL == req_params )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms disable request");
        break;
    }

    QCRIL_LOG_INFO( ".. param call id %d", (int)req_params->call_id );

    NAS_CACHE_LOCK();
    nas_cached_info.embms_disable_dbg_trace_id = req_params->dbg_trace_id;
    NAS_CACHE_UNLOCK();

    qcril_reqlist_default_entry( params_ptr->t,
                         params_ptr->event_id,
                         QCRIL_DEFAULT_MODEM_ID,
                         QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                         QCRIL_EVT_QMI_REQUEST_EMBMS_DISABLE,
                         NULL,
                         &qcril_req_info_ptr );
    if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) )
    {
        break;
    }

    // Update nas cache for embms status
    if ( RIL_E_SUCCESS != qcril_qmi_nas_embms_fetch_embms_status())
    {
        break;
    }

    // If embms already disabled, send RIL resp
    NAS_CACHE_LOCK();
    uint8_t is_embms_enabled = nas_cached_info.embms_enabled;
    NAS_CACHE_UNLOCK();
    if(!is_embms_enabled)
    {
      ril_req_res = RIL_E_SUCCESS;
      disable_needed = FALSE;
      break;
    }
    // else, set ebmbs to "disable"
    else {
      ril_req_res = RIL_E_SUCCESS;
      qcril_qmi_nas_embms_txn_disable_act( QMI_RIL_EMBMS_DISABLE_TXN_SIGNAL_INITIATE, RIL_E_SUCCESS, NULL );
      break;
    }
  } while ( FALSE );


  if ((RIL_E_SUCCESS != ril_req_res) || !disable_needed)
  { // rollback
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      memset( &resp_payload, 0, sizeof( resp_payload ) );

      NAS_CACHE_LOCK();
      resp_payload.dbg_trace_id = nas_cached_info.embms_disable_dbg_trace_id;
      NAS_CACHE_UNLOCK();
      if (RIL_E_SUCCESS != ril_req_res)
      {
        resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
      }

      resp.resp_pkt = (void *) &resp_payload;
      resp.resp_len = sizeof( resp_payload );
      qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN_WITH_RET((int) ril_req_res );

}// qcril_qmi_nas_embms_requst_disable

//===========================================================================
// qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed
//===========================================================================
void qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed(
        uint8_t prev_lte_embms_coverage_status_valid,
        nas_lte_rrc_embms_coverage_status_enum_v01 prev_lte_embms_coverage_status)
{
    embms_unsol_broadcast_coverage_ind_msg_v01 payload;
    int need_update_embms_coverage = FALSE;
    nas_lte_rrc_embms_coverage_status_enum_v01 embms_coverage;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.embms_coverage_status) &&
         nas_cached_info.embms_enabled &&
         nas_cached_info.embms_enable_success_sent_to_atel
       )
    {
       if ( !nas_cached_info.embms_coverage_sent_after_enabled ||
            !prev_lte_embms_coverage_status_valid ||
            prev_lte_embms_coverage_status != nas_cached_info.embms_coverage_status
          )
       {
          need_update_embms_coverage = TRUE;
          embms_coverage = nas_cached_info.embms_coverage_status;
       }
    }
    NAS_CACHE_UNLOCK();

    if ( need_update_embms_coverage )
    {
       memset( &payload, 0, sizeof( payload ) );
       payload.dbg_trace_id = -1;
       QCRIL_LOG_INFO("qmi lte_embms_coverage status %d", embms_coverage);
       payload.broadcast_coverage = qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(embms_coverage);
       qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_UNSOL_COVERAGE, (char*)&payload, sizeof(payload));
       NAS_CACHE_LOCK();
       nas_cached_info.embms_coverage_sent_after_enabled = TRUE;
       NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_send_unsol_embms_coverage_status_if_needed

//===========================================================================
// qcril_qmi_nas_embms_request_get_coverage_state
//===========================================================================
void qcril_qmi_nas_embms_request_get_coverage_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type        resp;
    RIL_Errno                             ril_req_res = RIL_E_GENERIC_FAILURE;
    embms_get_coverage_state_req_msg_v01  *req_payload = (embms_get_coverage_state_req_msg_v01* )params_ptr->data;
    embms_get_coverage_state_resp_msg_v01 resp_payload;

    memset( &resp_payload, 0, sizeof( resp_payload ) );

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    if ( NULL == req_payload )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms get coverage request");
        resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
    }
    else
    {
        resp_payload.dbg_trace_id = req_payload->dbg_trace_id;
        resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

        NAS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.embms_coverage_status) )
        {
            QCRIL_LOG_INFO("coverage_state %d", nas_cached_info.embms_coverage_status);
            resp_payload.coverage_state_valid = TRUE;
            resp_payload.coverage_state = qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(nas_cached_info.embms_coverage_status);
            resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;
            ril_req_res = RIL_E_SUCCESS;
        }
        NAS_CACHE_UNLOCK();
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_request_get_coverage_state

//===========================================================================
// qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage
//===========================================================================
qmi_ril_embms_coverage_state_e_type qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage(
        nas_lte_rrc_embms_coverage_status_enum_v01 qmi_embms_coverage)
{
    qmi_ril_embms_coverage_state_e_type coverage;

    switch (qmi_embms_coverage) {
        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_AVAILABLE_V01:
            coverage = QMI_RIL_EMBMS_IN_COVERAGE;
            break;

        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_UEMODE_V01:
            coverage = QMI_RIL_EMBMS_OUT_OF_COVERAGE_DUE_TO_UEMODE;
            break;

        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAIL_DUE_TO_EMERGENCY_V01:
            coverage = QMI_RIL_EMBMS_OUT_OF_COVERAGE_E911;
            break;

        default: //fall-through
        case NAS_LTE_RRC_EMBMS_COVERAGE_STATUS_NOT_AVAILABLE_V01:
            coverage = QMI_RIL_EMBMS_OUT_OF_COVERAGE;
            break;
    }
    return coverage;
} // qcril_qmi_nas_map_qmi_embms_coverage_to_ril_embms_coverage

//===========================================================================
// qcril_qmi_nas_embms_get_rssi_cb
//===========================================================================
void qcril_qmi_nas_embms_get_rssi_cb
(
  qmi_client_type              user_handle,
  unsigned int                 message_id,
  void                        *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    qcril_request_resp_params_type   resp;
    embms_get_rssi_resp_msg_v01      ril_resp_payload;
    nas_get_embms_sig_ext_resp_msg_v01 *qmi_response = (nas_get_embms_sig_ext_resp_msg_v01 *) resp_c_struct;
    RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type        request_info;

    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(user_handle);
    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);
    QCRIL_NOTUSED(resp_cb_data);

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( transp_err, &qmi_response->resp );
        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d", (int) ril_req_res, (int)transp_err, (int) qmi_response->resp.error );

        if ( E_SUCCESS != qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_GET_RSSI, &request_info) )
        {
            QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_RSSI not found");
        }
        else
        {
            memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );

            if ( qmi_response->trace_id_valid )
            {
                ril_resp_payload.dbg_trace_id = qmi_response->trace_id;
            }
            else
            {
                QCRIL_LOG_ERROR("trace id in qmi_response not valid");
                ril_resp_payload.dbg_trace_id = -1;
            }

            ril_resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;

            if ( RIL_E_SUCCESS == ril_req_res )
            {
                if ( qmi_response->snr_and_tmgi_list_valid )
                {
                   ril_resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;

                   ril_resp_payload.area_id_valid = TRUE;
                   ril_resp_payload.area_id_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.sig_noise_ratio_valid = TRUE;
                   ril_resp_payload.sig_noise_ratio_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.excess_snr_valid = TRUE;
                   ril_resp_payload.excess_snr_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.number_of_tmgi_per_mbsfn_valid = TRUE;
                   ril_resp_payload.number_of_tmgi_per_mbsfn_len = qmi_response->snr_and_tmgi_list_len;

                   ril_resp_payload.active_tgmi_valid = TRUE;

                   uint32_t i;
                   for (i = 0; i < ril_resp_payload.area_id_len; i++)
                   {
                      ril_resp_payload.area_id[i]                  = qmi_response->snr_and_tmgi_list[i].area_id;
                      ril_resp_payload.sig_noise_ratio[i]          = qmi_response->snr_and_tmgi_list[i].snr;
                      ril_resp_payload.excess_snr[i]               = qmi_response->snr_and_tmgi_list[i].excess_snr;
                      ril_resp_payload.number_of_tmgi_per_mbsfn[i] = qmi_response->snr_and_tmgi_list[i].tmgi_info_len;

                      uint32_t j;
                      for (j = 0; j < qmi_response->snr_and_tmgi_list[i].tmgi_info_len; j++)
                      {
                         ril_resp_payload.active_tgmi[j].tmgi_len = NAS_TMGI_IDENTIFIER_LEN_V01;
                         memcpy( ril_resp_payload.active_tgmi[j].tmgi,
                                 qmi_response->snr_and_tmgi_list[i].tmgi_info[j].tmgi_identifier,
                                 NAS_TMGI_IDENTIFIER_LEN_V01);
                      }
                      ril_resp_payload.active_tgmi_len += ril_resp_payload.number_of_tmgi_per_mbsfn[i];
                   }
                }
                else
                {
                   QCRIL_LOG_DEBUG("snr_and_tmgi_list is not valid");
                }
            }

            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               request_info.t,
                                               request_info.request,
                                               ril_req_res,
                                               &resp );
            resp.resp_pkt = (void *) &ril_resp_payload;
            resp.resp_len = sizeof( ril_resp_payload );
            qcril_send_request_response( &resp );
        }

        qcril_free( qmi_response );  // we own it
    }
    else
    {
        QCRIL_LOG_ERROR("qmi_response is NULL");
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_get_rssi_cb

//===========================================================================
// qcril_qmi_nas_embms_get_rssi
//===========================================================================
void qcril_qmi_nas_embms_get_rssi
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type      qcril_req_info_ptr;

    embms_get_rssi_req_msg_v01     *ril_req_payload = (embms_get_rssi_req_msg_v01* )params_ptr->data;
    embms_get_rssi_resp_msg_v01    ril_resp_payload;
    nas_get_embms_sig_ext_req_msg_v01  qmi_req;
    nas_get_embms_sig_ext_resp_msg_v01 *qmi_resp;

    qmi_client_error_type          qmi_client_error;
    qmi_txn_handle                 txn_handle;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    do
    {
        if ( NULL == ril_req_payload )
        {
            QCRIL_LOG_ERROR("invalid NULL parameter for embms get rssi request");
            break;
        }

        qcril_reqlist_default_entry( params_ptr->t,
                                     params_ptr->event_id,
                                     QCRIL_DEFAULT_MODEM_ID,
                                     QCRIL_REQ_AWAITING_CALLBACK,
                                     QCRIL_EVT_NONE,
                                     NULL,
                                     &qcril_req_info_ptr );
        if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr ) )
        {
            QCRIL_LOG_ERROR("failed to create request");
            break;
        }

        qmi_resp = qcril_malloc( sizeof( *qmi_resp ) );
        if ( NULL == qmi_resp )
        {
            QCRIL_LOG_ERROR( "mem alloc failed" );
            break;
        }

        memset( &qmi_req, 0, sizeof( qmi_req ) );
        qmi_req.trace_id_valid = TRUE;
        qmi_req.trace_id = ril_req_payload->dbg_trace_id;

        qmi_client_error =  qmi_client_send_msg_async_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                       QMI_NAS_GET_EMBMS_SIG_EXT_REQ_MSG_V01,
                                                       (void*) &qmi_req,
                                                       sizeof( qmi_req ),
                                                       (void*) qmi_resp,
                                                       sizeof( *qmi_resp ),
                                                       qcril_qmi_nas_embms_get_rssi_cb,
                                                       NULL,
                                                       &txn_handle
                                                     );

        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result( qmi_client_error, NULL );

        if ( RIL_E_SUCCESS != ril_req_res )
        {
            QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d", (int)ril_req_res, (int)qmi_client_error );
            qcril_free( qmi_resp );
        }
    } while ( 0 );

    if ( RIL_E_SUCCESS != ril_req_res )
    {
        if ( NULL != ril_req_payload )
        {
            memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
            ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
            ril_resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        if ( NULL != ril_req_payload )
        {
            resp.resp_pkt = (void *) &ril_resp_payload;
            resp.resp_len = sizeof( ril_resp_payload );
        }
        qcril_send_request_response( &resp );
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_rssi

//===========================================================================
// qcril_qmi_nas_embms_send_cell_info_changed_if_needed
//===========================================================================
void qcril_qmi_nas_embms_send_cell_info_changed_if_needed(boolean prev_lte_sys_info_valid, const nas_lte_sys_info_type_v01* prev_lte_sys_info)
{
    int need_send_unsol_resp = FALSE;
    embms_unsol_cell_info_changed_ind_msg_v01 payload;
    boolean new_lte_sys_info_valid;
    nas_lte_sys_info_type_v01* new_lte_sys_info;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    if ( nas_cached_info.embms_enabled && nas_cached_info.embms_enable_success_sent_to_atel )
    {
        new_lte_sys_info_valid = nas_cached_info.lte_sys_info_valid;
        new_lte_sys_info = nas_cached_info.lte_sys_info;

        if ( new_lte_sys_info_valid && new_lte_sys_info )
        {
            memset( &payload, 0, sizeof( payload ) );
            payload.dbg_trace_id = -1;

            if (new_lte_sys_info->threegpp_specific_sys_info.cell_id_valid)
            {
                if ( !prev_lte_sys_info_valid ||
                     NULL == prev_lte_sys_info ||
                     !prev_lte_sys_info->threegpp_specific_sys_info.cell_id_valid ||
                     prev_lte_sys_info->threegpp_specific_sys_info.cell_id != new_lte_sys_info->threegpp_specific_sys_info.cell_id
                   )
                {
                    need_send_unsol_resp = TRUE;
                }
                payload.cell_id = new_lte_sys_info->threegpp_specific_sys_info.cell_id;
            }
            else if ( prev_lte_sys_info_valid && NULL != prev_lte_sys_info && prev_lte_sys_info->threegpp_specific_sys_info.cell_id_valid )
            {
                payload.cell_id = prev_lte_sys_info->threegpp_specific_sys_info.cell_id;
            }

            if (new_lte_sys_info->threegpp_specific_sys_info.network_id_valid)
            {
                if ( !prev_lte_sys_info_valid ||
                     NULL == prev_lte_sys_info ||
                     !prev_lte_sys_info->threegpp_specific_sys_info.network_id_valid ||
                     memcmp(prev_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, NAS_MCC_MNC_MAX_V01) ||
                     memcmp(prev_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, NAS_MCC_MNC_MAX_V01)
                   )
                {
                    need_send_unsol_resp = TRUE;
                }

                memcpy(payload.mcc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, MCC_MNC_MAX_V01);
                memcpy(payload.mnc, new_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, MCC_MNC_MAX_V01);
            }
            else if ( prev_lte_sys_info_valid && NULL != prev_lte_sys_info && prev_lte_sys_info->threegpp_specific_sys_info.cell_id_valid )
            {
                memcpy(payload.mcc, prev_lte_sys_info->threegpp_specific_sys_info.network_id.mcc, MCC_MNC_MAX_V01);
                memcpy(payload.mnc, prev_lte_sys_info->threegpp_specific_sys_info.network_id.mnc, MCC_MNC_MAX_V01);
            }

            if (!nas_cached_info.embms_cell_id_sent_after_enabled)
            {
               need_send_unsol_resp = TRUE;
            }

            if ( 0xFF == payload.mcc[MCC_MNC_MAX_V01-1])
            {
               payload.mcc[MCC_MNC_MAX_V01-1] = 0;
            }
            if ( 0xFF == payload.mnc[MCC_MNC_MAX_V01-1])
            {
               payload.mnc[MCC_MNC_MAX_V01-1] = 0;
            }
        }
    }
    NAS_CACHE_UNLOCK();

    if ( need_send_unsol_resp )
    {
       QCRIL_LOG_INFO("mcc: %s, mnc: %s, cell_id: %d", payload.mcc, payload.mnc, payload.cell_id);
       qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_UNSOL_CELL_INFO_CHANGED, (char*)&payload, sizeof(payload));

       NAS_CACHE_LOCK();
       nas_cached_info.embms_cell_id_sent_after_enabled = TRUE;
       NAS_CACHE_UNLOCK();
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_send_cell_info_changed_if_needed

void qcril_qmi_nas_embms_send_e911_state_changed_if_needed
(
  uint8_t new_mode_valid,
  uint8_t new_mode
)
{
    uint8_t old_mode_valid;
    uint8_t old_mode;

    QCRIL_LOG_FUNC_ENTRY();

    NAS_CACHE_LOCK();
    old_mode_valid = nas_cached_info.emergency_mode_valid;
    old_mode = nas_cached_info.emergency_mode;
    NAS_CACHE_UNLOCK();

    if (new_mode_valid && (old_mode != new_mode || old_mode_valid != new_mode_valid))
    {
        embms_unsol_e911_state_ind_msg_v01 data;
        int data_len;

        memset(&data, 0, sizeof(data));
        data.dbg_trace_id = 0xffffffff; // Unsols have a trace id of 0xffffffff
        data.e911_state = (new_mode == NAS_CMN_EMERGENCY_MODE_ON) ? EMBMS_E911_MODE_ACTIVE_V01 :
                                                                          EMBMS_E911_MODE_INACTIVE_V01;
        data_len = sizeof(data);
        qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID,
                                   QCRIL_EVT_HOOK_EMBMS_UNSOL_E911_STATE_CHANGED,
                                   (void *)&data,
                                   data_len);
    }

    QCRIL_LOG_FUNC_RETURN();
}

void qcril_qmi_nas_embms_send_embms_status
(
  uint8_t is_available
)
{
    embms_unsol_embms_status_ind_msg_v01 data;
    int data_len;
    QCRIL_LOG_FUNC_ENTRY();

    memset(&data, 0, sizeof(data));
    data.is_available = is_available;

    data_len = sizeof(data);
    qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID,
                               QCRIL_EVT_HOOK_EMBMS_UNSOL_EMBMS_STATUS,
                               (void *)&data,
                               data_len);
    QCRIL_LOG_INFO("Setting is_embms_avaliable to %d", is_available);
    QCRIL_LOG_FUNC_RETURN();
}


//===========================================================================
// qcril_qmi_nas_embms_send_radio_state
//===========================================================================
void qcril_qmi_nas_embms_send_radio_state(radio_state_enum_v01 radio_state)
{
    QCRIL_LOG_FUNC_ENTRY();
    qcril_event_queue( QCRIL_DEFAULT_INSTANCE_ID,
                   QCRIL_DEFAULT_MODEM_ID,
                   QCRIL_DATA_ON_STACK,
                   QCRIL_EVT_QMI_RIL_EMBMS_SEND_UNSOL_RADIO_STATE,
                   &radio_state,
                   sizeof(radio_state),
                   (RIL_Token) QCRIL_TOKEN_ID_INTERNAL );
    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_send_radio_state

//===========================================================================
// qcril_qmi_nas_embms_send_radio_state_helper
//===========================================================================
void qcril_qmi_nas_embms_send_radio_state_helper
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   embms_unsol_radio_state_ind_msg_v01 payload;
   uint8_t embms_enabled;
   uint8_t embms_enable_success_sent_to_atel;
   uint8_t embms_ssr_in_progress;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);

   if (params_ptr && params_ptr->data)
   {
      NAS_CACHE_LOCK();
      embms_enabled = nas_cached_info.embms_enabled;
      embms_enable_success_sent_to_atel = nas_cached_info.embms_enable_success_sent_to_atel;
      embms_ssr_in_progress = nas_cached_info.embms_ssr_in_progress;
      NAS_CACHE_UNLOCK();
      QCRIL_LOG_INFO("embms_enabled: %d, embms_enable_success_sent_to_atel: %d, embms_ssr_in_progress: %d",
                     embms_enabled, embms_enable_success_sent_to_atel, embms_ssr_in_progress);

      if ( (embms_enabled && embms_enable_success_sent_to_atel) || embms_ssr_in_progress )
      {
         memset( &payload, 0, sizeof( payload ) );
         payload.dbg_trace_id = -1;
         payload.radio_state = *((int*) params_ptr->data);
         QCRIL_LOG_INFO("radio_state: %d", payload.radio_state);
         qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_EMBMS_UNSOL_RADIO_STATE_CHANGED, (char*)&payload, sizeof(payload));

         NAS_CACHE_LOCK();
         if ( RADIO_STATE_NOT_AVAILABLE_V01 == payload.radio_state )
         {
            nas_cached_info.embms_ssr_in_progress = TRUE;
         }
         if ( RADIO_STATE_AVAILABLE_V01 == payload.radio_state && nas_cached_info.embms_ssr_in_progress )
         {
            nas_cached_info.embms_ssr_in_progress = FALSE;
         }
         NAS_CACHE_UNLOCK();
      }
   }
   else
   {
      QCRIL_LOG_ERROR("unexpected NULL pointer of params_ptr or params_ptr->data");
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_send_radio_state_helper

//=========================================================================
// qcril_qmi_nas_embms_get_active_log_packet_ids
//===========================================================================
void qcril_qmi_nas_embms_get_active_log_packet_ids
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
#ifndef QMI_RIL_UTF
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;

    embms_get_active_log_packet_ids_req_msg_v01 *req_payload = (embms_get_active_log_packet_ids_req_msg_v01* )params_ptr->data;
    embms_get_active_log_packet_ids_resp_msg_v01 resp_payload;
    memset( &resp_payload, 0, sizeof( resp_payload ) );

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    if ( NULL == req_payload )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms get_active_log_packet_ids request");
        ril_req_res = RIL_E_GENERIC_FAILURE;
    }
    else
    {
        uint32_t i;
        for (i=0; i<req_payload->supported_log_packet_id_list_len; i++)
        {
            boolean is_active_log_packet_id = FALSE;

            int diag_packet_id = req_payload->supported_log_packet_id_list[i] + QMI_RIL_EMBMS_LOG_PACKET_ID_MIN;
            if (diag_packet_id >= QMI_RIL_EMBMS_LOG_PACKET_ID_MIN && diag_packet_id <= QMI_RIL_EMBMS_LOG_PACKET_ID_MAX)
            {
                is_active_log_packet_id = log_status (diag_packet_id);
                QCRIL_LOG_INFO ("packet id %d; is_active_log_packet_id %d", (int) diag_packet_id, (int) is_active_log_packet_id);
            }

            if (is_active_log_packet_id)
            {
                resp_payload.active_log_packet_id_list[resp_payload.active_log_packet_id_list_len] = req_payload->supported_log_packet_id_list[i];
                resp_payload.active_log_packet_id_list_len++;
            }
        }
        resp_payload.dbg_trace_id = req_payload->dbg_trace_id;
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );
#endif
} // qcril_qmi_nas_embms_get_active_log_packet_ids

//=========================================================================
// qcril_qmi_nas_embms_deliver_log_packet
//===========================================================================
void qcril_qmi_nas_embms_deliver_log_packet
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
#ifndef QMI_RIL_UTF
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res = RIL_E_SUCCESS;
    qcril_qmi_nas_embms_log_type *embms_log = NULL;

    embms_deliver_log_packet_req_msg_v01 *req_payload = (embms_deliver_log_packet_req_msg_v01 *) params_ptr->data;
    embms_deliver_log_packet_resp_msg_v01 resp_payload;
    memset( &resp_payload, 0, sizeof( resp_payload ) );

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    if ( NULL == req_payload )
    {
        QCRIL_LOG_ERROR("invalid NULL parameter for embms deliver_log_packet request");
        ril_req_res = RIL_E_GENERIC_FAILURE;
    }
    else
    {
        int diag_packet_id = req_payload->packet_id + QMI_RIL_EMBMS_LOG_PACKET_ID_MIN;
        embms_log = (qcril_qmi_nas_embms_log_type *) log_alloc (diag_packet_id, sizeof (embms_log->hdr) + (req_payload->log_packet_len) * sizeof (int8_t));
        if (NULL != embms_log)
        {
            memcpy (embms_log->log_payload, req_payload->log_packet, (req_payload->log_packet_len) * sizeof (int8_t));
            log_commit (embms_log);
            QCRIL_LOG_INFO ("DIAG log delivered for packet id %d", diag_packet_id);
        }
        else
        {
            QCRIL_LOG_ERROR ("log_alloc failed for packet id %d", diag_packet_id);
            ril_req_res = RIL_E_GENERIC_FAILURE;
        }
        resp_payload.dbg_trace_id = req_payload->dbg_trace_id;
    }

    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                       params_ptr->t,
                                       params_ptr->event_id,
                                       ril_req_res,
                                       &resp );
    resp.resp_pkt = (void *) &resp_payload;
    resp.resp_len = sizeof( resp_payload );
    qcril_send_request_response( &resp );
#endif
} // qcril_qmi_nas_embms_deliver_log_packet


//=========================================================================
//  FUNCTION: is_empty_or_white_space
//===========================================================================
boolean is_operator_name_empty_or_white_space ( char * str, int max_len)
{
  boolean is_empty_or_white_space = TRUE;
  int idx = 0;

  if ( str )
  {
    for ( idx = 0; idx < max_len && str[idx] ; idx++ )
    {
      if ( str[idx] != ' ' )
      {
        is_empty_or_white_space = FALSE;
        break;
      }
    }
  }

  return is_empty_or_white_space;
}
// ** eMBMS e

//===========================================================================
// qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat
//===========================================================================
voice_dial_call_service_type_enum_v02 qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat
(
  uint64_t ela
)
{
    voice_dial_call_service_type_enum_v02 service_type = VOICE_DIAL_CALL_SRV_TYPE_AUTOMATIC_V02;

    boolean ims_voip_in_service = qcril_qmi_imsa_is_ims_voip_in_service();

    NAS_CACHE_LOCK();

    if ( ela & QCRIL_QMI_VOICE_VOIP_CALLINFO_ELA_CS_DOMAIN ) // To verify Call to be dialled on CS
    {
       service_type = VOICE_DIAL_CALL_SRV_TYPE_CS_ONLY_V02;
       if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_GSM) ||
            qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_UMTS) ||
            qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_TDSCDMA)
          )
       {
            service_type = VOICE_DIAL_CALL_SRV_TYPE_GSM_WCDMA_TDSCDMA_V02;
       }
       else if ( qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000) ||
                 qcril_qmi_nas_is_using_radio_if(NAS_RADIO_IF_CDMA2000_HRPD) )
       {
          service_type = VOICE_DIAL_CALL_SRV_TYPE_CDMA_AUTOMATIC_V02;
       }
       // Set service_type to automatic if the IMS VoIP service is not available.
       else if ( qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_SUB_LTE, QMI_RIL_RTE_KIND_VOICE) &&
                 !ims_voip_in_service )
       {
           service_type = VOICE_DIAL_CALL_SRV_TYPE_AUTOMATIC_V02;
       }
    }

    NAS_CACHE_UNLOCK();
    return service_type;
} //qcril_qmi_nas_setting_srv_type_based_on_elaboration_and_rat

//===========================================================================
// qcril_qmi_nas_process_sib16_network_time
//===========================================================================
void qcril_qmi_nas_process_sib16_network_time
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
)
{
   QCRIL_LOG_FUNC_ENTRY();

   if(nas_common_info.sib16_support)
   {
       qcril_qmi_nas_process_sib16_network_time_for_ats_utc( universal_time,
                                                             abs_time,
                                                             time_zone_valid,
                                                             time_zone,
                                                             daylt_sav_adj_valid,
                                                             daylt_sav_adj
                                                             );
   }

   qcril_qmi_nas_process_sib16_network_time_for_ats_modem( abs_time );


   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_process_sib16_network_time

//===========================================================================
// qcril_qmi_nas_process_sib16_network_time_for_ats_utc
//===========================================================================
void qcril_qmi_nas_process_sib16_network_time_for_ats_utc
(
   const nas_lte_sib16_julian_time_type_v01* universal_time,
   uint64_t abs_time,
   uint8_t time_zone_valid,
   int8_t time_zone,
   uint8_t daylt_sav_adj_valid,
   uint8_t daylt_sav_adj
)
{
   QCRIL_LOG_FUNC_ENTRY();

   char ril_nitz_time[NAS_NITZ_STR_BUF_MAX];
   qcril_unsol_resp_params_type unsol_resp_params;
   int ret_code;

   ret_code = 0;

   if (NULL != universal_time)
   {
      int time_zone_west=FALSE;

      if (time_zone_valid)
      {
        if (0 > time_zone)
        {
          time_zone *= -1;
          time_zone_west = TRUE;
        }
      }
      else
      {
        time_zone = 0;
      }

      if (!daylt_sav_adj_valid)
      {
        daylt_sav_adj = 0;
      }

      // accroding to ril.h the NITZ time string is in the form "yy/mm/dd,hh:mm:ss(+/-)tz,dt"
      QCRIL_SNPRINTF( ril_nitz_time, NAS_NITZ_STR_BUF_MAX, "%02d/%02d/%02d,%02d:%02d:%02d%c%02d,%02d",
                       (int) universal_time->year%100,
                       (int) universal_time->month,
                       (int) universal_time->day,
                       (int) universal_time->hour,
                       (int) universal_time->minute,
                       (int) universal_time->second,
                       time_zone_west ? '-' : '+',
                       (int) time_zone,
                       (int) daylt_sav_adj);
       QCRIL_LOG_INFO( "ril_nitz_time_msg is: %s", ril_nitz_time);

       qcril_default_unsol_resp_params( QCRIL_DEFAULT_INSTANCE_ID, RIL_UNSOL_NITZ_TIME_RECEIVED, &unsol_resp_params );
       unsol_resp_params.resp_pkt = ril_nitz_time;;
       unsol_resp_params.resp_len = strlen(ril_nitz_time) + 1;
       qcril_send_unsol_response( &unsol_resp_params );

       time_genoff_info_type time_set;
       time_set.base = ATS_UTC;
       time_set.unit = TIME_MSEC;
       time_set.operation = T_SET;
       // convert the abs_time from an offset of "Jan 6, 1980 00:00:00" to an offset of "Jan 1, 1970 00:00:00"
       abs_time = abs_time + NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_6_1980_IN_MILLI_SEC;
       time_set.ts_val = &abs_time;
       ret_code = time_genoff_operation(&time_set);
       if(!ret_code)
       {
           QCRIL_LOG_INFO("set UTC successfully using sib16 time, abs time (%x, %x)",
                          (uint32) (abs_time >> 32),
                          (uint32) abs_time);
       }
       else
       {
           QCRIL_LOG_INFO("unable to set UTC using sib16 time, error %d",
                          ret_code);
       }
   }
   else
   {
      QCRIL_LOG_ERROR("universal_time is NULL");
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_process_sib16_network_time_for_ats_utc

//===========================================================================
// qcril_qmi_nas_process_sib16_network_time_for_ats_modem
//===========================================================================
void qcril_qmi_nas_process_sib16_network_time_for_ats_modem(uint64_t abs_time)
{
   QCRIL_LOG_FUNC_ENTRY();

   int ret_code;
   time_genoff_info_type time_set;

   ret_code = 0;
   time_set.base = ATS_MODEM;
   time_set.unit = TIME_MSEC;
   time_set.operation = T_SET;
   // convert the abs_time from an offset of "Jan 6, 1980 00:00:00" to an offset of "Jan 1, 1970 00:00:00"
   abs_time = abs_time + NAS_TIME_UNIX_EPOCH_TIME_OFFSET_FOR_JAN_6_1980_IN_MILLI_SEC;
   time_set.ts_val = &abs_time;
   ret_code = time_genoff_operation(&time_set);
   if(!ret_code)
   {
       QCRIL_LOG_INFO("set MODEM successfully using sib16 time, abs time (%x, %x)",
                      (uint32) (abs_time >> 32),
                      (uint32) abs_time);
   }
   else
   {
       QCRIL_LOG_INFO("unable to set MODEM using sib16 time, error %d",
                      ret_code);
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_process_sib16_network_time_for_ats_modem

//===========================================================================
// qcril_qmi_nas_fetch_sib16_network_time
//===========================================================================
void qcril_qmi_nas_fetch_sib16_network_time()
{
   QCRIL_LOG_FUNC_ENTRY();

   RIL_Errno   ril_req_res = RIL_E_GENERIC_FAILURE;
   uint8_t prev_lte_sib16_acquired_valid, prev_lte_sib16_acquired;

   nas_get_lte_sib16_network_time_resp_msg_v01 qmi_response;
   memset(&qmi_response, 0, sizeof(qmi_response));

   errno_enum_type error = qcril_qmi_client_send_msg_sync( QCRIL_QMI_CLIENT_NAS,
                                                           QMI_NAS_GET_LTE_SIB16_NETWORK_TIME_REQ_MSG_V01,
                                                           NULL,
                                                           NAS_NIL,
                                                           (void*) &qmi_response,
                                                           sizeof(qmi_response)
                                                          );

   if (E_SUCCESS != error)
   {
      QCRIL_LOG_ERROR("qcril_qmi_client_send_msg_sync failure: %d", errno);
   }
   else
   {
      if (QMI_RESULT_SUCCESS_V01 != qmi_response.resp.result)
      {
         QCRIL_LOG_ERROR("qmi response error - result: %d, error: %d", qmi_response.resp.result, qmi_response.resp.error);
      }
      else
      {
         NAS_CACHE_LOCK();
         prev_lte_sib16_acquired_valid = nas_cached_info.lte_sib16_acquired_valid;
         prev_lte_sib16_acquired = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
         NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired,
                                    qmi_response.lte_sib16_acquired);

         qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(
             prev_lte_sib16_acquired_valid,
             prev_lte_sib16_acquired,
             nas_cached_info.lte_sib16_acquired_valid,
             NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired );

         if (qmi_response.lte_sib16_acquired_valid && (NAS_TRI_TRUE_V01 == qmi_response.lte_sib16_acquired))
         {
             NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
             NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
             NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
             NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                        qmi_response.daylt_sav_adj);
             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.leap_seconds,
                                        qmi_response.leap_sec);
             NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                        qmi_response.time_zone);

            if ( qmi_response.universal_time_valid && qmi_response.abs_time_valid )
            {
               qcril_qmi_nas_process_sib16_network_time( &qmi_response.universal_time,
                                                         qmi_response.abs_time,
                                                         qmi_response.time_zone_valid,
                                                         qmi_response.time_zone,
                                                         qmi_response.daylt_sav_adj_valid,
                                                         qmi_response.daylt_sav_adj
                                                        );
            }
            else
            {
               QCRIL_LOG_ERROR("ignore the response as it does not contain all the necessary information");
            }
         }
         NAS_CACHE_UNLOCK();
      }
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_fetch_sib16_network_time

//===========================================================================
// qcril_qmi_nas_sib16_network_time_ind_hdlr
//===========================================================================
void qcril_qmi_nas_sib16_network_time_ind_hdlr(const nas_lte_sib16_network_time_ind_msg_v01* decoded_payload)
{
   QCRIL_LOG_FUNC_ENTRY();

   uint8_t prev_lte_sib16_acquired_valid, prev_lte_sib16_acquired;

   if (NULL != decoded_payload)
   {
      NAS_CACHE_LOCK();
      prev_lte_sib16_acquired_valid = nas_cached_info.lte_sib16_acquired_valid;
      prev_lte_sib16_acquired = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
      NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.lte_sib16_acquired, decoded_payload->lte_sib16_acquired);

      qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(
         prev_lte_sib16_acquired_valid,
         prev_lte_sib16_acquired,
         nas_cached_info.lte_sib16_acquired_valid,
         NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired );

      if ( (decoded_payload->lte_sib16_acquired_valid && decoded_payload->lte_sib16_acquired) ||
           (!decoded_payload->lte_sib16_acquired_valid && prev_lte_sib16_acquired_valid && prev_lte_sib16_acquired)
         )
      {
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
         NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

         NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.day_light_saving,
                                    decoded_payload->daylt_sav_adj);
         NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.leap_seconds,
                                    decoded_payload->leap_sec);
         NAS_CACHE_STORE_TINY_ENTRY(nas_cached_info.local_time_offset,
                                    decoded_payload->time_zone);

         if ( decoded_payload->universal_time_valid && decoded_payload->abs_time_valid )
         {
            qcril_qmi_nas_process_sib16_network_time( &(decoded_payload->universal_time),
                                                      decoded_payload->abs_time,
                                                      decoded_payload->time_zone_valid,
                                                      decoded_payload->time_zone,
                                                      decoded_payload->daylt_sav_adj_valid,
                                                      decoded_payload->daylt_sav_adj
                                                     );
         }
         else
         {
            QCRIL_LOG_ERROR("ignore the indication as it does not contain all the necessary information");
         }
      }
      NAS_CACHE_UNLOCK();
   }
   else
   {
      QCRIL_LOG_ERROR("decoded_payload is NULL");
   }

   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_sib16_network_time_ind_hdlr

//===========================================================================
// qcril_qmi_nas_convert_julian_time_to_abs_time
//      convert the julina time to abs_time as an offset of "Jan 1, 1970 00:00:00"
//===========================================================================
uint64_t qcril_qmi_nas_convert_julian_time_to_abs_time(uint16_t year, uint8_t month, uint8_t day,
                                                       uint8_t hour, uint8_t minute, uint8_t second, uint16_t milli_second)
{
   // year
   uint16_t year_offset = year-1970;
   uint days_offset = year_offset * 365;
   days_offset += (year_offset + 1) / 4; // and all the years % 4 == 0 need to add one day (do not consider year 2100 here)

   // month
   uint8_t days_of_month[13] = { 0, 31, 28, 31, 30, 31, 30,
                                    31, 31, 30, 31, 30, 31 };
   uint8_t i;
   for (i=1; i<month; i++)
   {
      days_offset += days_of_month[i];
   }
   if ( month > 2 && (0 == (year_offset + 2) % 4 ) )
   {
      days_offset++;
   }

   // day
   days_offset += day - 1;

   // to milli_second
   uint64_t ret = ((((uint64_t) days_offset * 24 + (uint64_t) hour) * 60 + (uint64_t) minute) * 60 + (uint64_t) second) * 1000 + (uint64_t) milli_second;

   QCRIL_LOG_INFO("return milli_second 0x%x %x", (int)(ret >> 32), (int)ret);

   return ret;
} // qcril_qmi_nas_convert_julian_time_to_abs_time

//===========================================================================
// qcril_qmi_nas_send_unsol_sib16_coverage_if_needed
//===========================================================================
void qcril_qmi_nas_send_unsol_sib16_coverage_if_needed(uint8_t prev_lte_sib16_coverage_valid,
                                                       uint8_t prev_lte_sib16_coverage,
                                                       uint8_t curr_lte_sib16_coverage_valid,
                                                       uint8_t curr_lte_sib16_coverage)
{
    embms_unsol_sib16_coverage_ind_msg_v01 payload;

    QCRIL_LOG_FUNC_ENTRY();

    memset( &payload, 0, sizeof( payload ) );

    if(nas_common_info.sib16_support)
    {
        QCRIL_LOG_INFO("lte sib16 coverage: previous valid %d, value %d, current valid %d, value %d",
                       prev_lte_sib16_coverage_valid,
                       prev_lte_sib16_coverage,
                       curr_lte_sib16_coverage_valid,
                       curr_lte_sib16_coverage);

        if ( TRUE == curr_lte_sib16_coverage_valid &&
             ((FALSE == prev_lte_sib16_coverage_valid) ||
             (prev_lte_sib16_coverage != curr_lte_sib16_coverage))
           )
        {
            payload.in_coverage = curr_lte_sib16_coverage;
            qcril_hook_unsol_response(QCRIL_DEFAULT_INSTANCE_ID,
                                      QCRIL_EVT_HOOK_EMBMS_UNSOL_SIB16_COVERAGE,
                                      (char*)&payload,
                                      sizeof(payload));
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_send_unsol_sib16_coverage_if_needed

//===========================================================================
// qcril_qmi_nas_embms_get_sib16_coverage
//===========================================================================
void qcril_qmi_nas_embms_get_sib16_coverage
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_sib16_coverage_resp_msg_v01 resp_payload;

    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    ril_req_res = RIL_E_SUCCESS;
    memset(&resp_payload,
           0,
           sizeof(resp_payload));


    if(NULL !=params_ptr)
    {
        NAS_CACHE_LOCK();

        QCRIL_LOG_INFO("lte sib16 coverage: valid %d, value %d",
                       NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired),
                       nas_cached_info.lte_sib16_acquired);

        if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired))
        {
            resp_payload.in_coverage = (NAS_TRI_TRUE_V01 == nas_cached_info.lte_sib16_acquired);
        }

        NAS_CACHE_UNLOCK();

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &resp_payload;
        resp.resp_len = sizeof( resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_sib16_coverage

//===========================================================================
// qcril_qmi_nas_embms_set_sntp_time
//===========================================================================
void qcril_qmi_nas_embms_set_sntp_time
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type resp;
  RIL_Errno ril_req_res;
  embms_set_sntp_time_req_msg_v01 req_payload;
  embms_set_sntp_time_resp_msg_v01 resp_payload;
  uint64_t abs_time;
  uint64_t system_time;
  time_genoff_info_type time_set;
  int ret_code;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  ril_req_res = RIL_E_GENERIC_FAILURE;
  memset(&req_payload,
         0,
         sizeof(req_payload));
  memset(&resp_payload,
         0,
         sizeof(resp_payload));
  abs_time = 0;
  system_time = 0;
  memset(&time_set,
         0,
         sizeof(time_set));
  ret_code = 0;

  if (NULL != params_ptr && params_ptr->datalen <= sizeof(req_payload))
  {
      NAS_CACHE_LOCK();

      QCRIL_LOG_INFO("lte sib16 coverage: valid %d, value %d",
                     NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired),
                     nas_cached_info.lte_sib16_acquired);

      if(FALSE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.lte_sib16_acquired) ||
         NAS_TRI_TRUE_V01 != nas_cached_info.lte_sib16_acquired)
      {
          memcpy(&req_payload, params_ptr->data, params_ptr->datalen);
          QCRIL_LOG_INFO("sntp: available %d, time valid %d, value (%x, %x), stamp valid %d, "
                         "value (%x, %x)",
                         req_payload.sntp_available,
                         req_payload.sntp_time_milli_sec_valid,
                         (uint32) (req_payload.sntp_time_milli_sec >> 32),
                         (uint32) req_payload.sntp_time_milli_sec,
                         req_payload.time_stamp_milli_sec_valid,
                         (uint32) (req_payload.time_stamp_milli_sec >> 32),
                         (uint32) req_payload.time_stamp_milli_sec);

          NAS_CACHE_STORE_TINY_ENTRY_VAL(nas_cached_info.sntp_available,
                                         req_payload.sntp_available);
          if(TRUE == req_payload.sntp_available)
          {
              NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.day_light_saving);
              NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.leap_seconds);
              NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.local_time_offset);

              if(TRUE == req_payload.sntp_time_milli_sec_valid)
              {
                  /*
                  SNTP time is already in offset of "Jan 1, 1970 00:00:00"
                  */
                  abs_time = req_payload.sntp_time_milli_sec;

                  if(TRUE == req_payload.time_stamp_milli_sec_valid)
                  {
                      /*
                      Accounting for the delay in receipt of QMI_EMBMS_SET_SNTP_TIME_REQ_V01
                      after it was sent by EMBMS server
                      */

                      system_time = qmi_ril_retrieve_system_time_in_ms();
                      abs_time = abs_time + (system_time - req_payload.time_stamp_milli_sec);
                      QCRIL_LOG_INFO("system time (%x, %x), abs time (%x, %x)",
                                     (uint32) (system_time >> 32),
                                     (uint32) system_time,
                                     (uint32) (abs_time >> 32),
                                     (uint32) abs_time);
                  }

                  if(nas_common_info.sib16_support)
                  {
                      time_set.base = ATS_UTC;
                      time_set.unit = TIME_MSEC;
                      time_set.operation = T_SET;
                      time_set.ts_val = &abs_time;
                      ret_code = time_genoff_operation(&time_set);
                      if(!ret_code)
                      {
                          ril_req_res = RIL_E_SUCCESS;
                          QCRIL_LOG_INFO("set UTC successfully using sntp time, abs time (%x, %x)",
                                         (uint32) (abs_time >> 32),
                                         (uint32) abs_time);
                      }
                      else
                      {
                          QCRIL_LOG_INFO("unable to set UTC using sntp time, error %d",
                                         ret_code);
                      }
                  }

                  time_set.base = ATS_MODEM;
                  time_set.unit = TIME_MSEC;
                  time_set.operation = T_SET;
                  time_set.ts_val = &abs_time;
                  ret_code = time_genoff_operation(&time_set);
                  if(!ret_code)
                  {
                      ril_req_res = RIL_E_SUCCESS;
                      QCRIL_LOG_INFO("set MODEM successfully using sntp time, abs time (%x, %x)",
                                     (uint32) (abs_time >> 32),
                                     (uint32) abs_time);
                  }
                  else
                  {
                      QCRIL_LOG_INFO("unable to set MODEM using sntp time, error %d",
                                     ret_code);
                  }
              }
              else
              {
                  QCRIL_LOG_INFO("sntp time milli sec is needed to set time");
              }
          }
          else
          {
              ril_req_res = RIL_E_SUCCESS;
          }
      }
      else
      {
          ril_req_res = RIL_E_SUCCESS;
          NAS_CACHE_INVALIDATE_TINY_ENTRY(nas_cached_info.sntp_available);
          QCRIL_LOG_INFO("lte sib16 coverage acquired, sntp time ignored");
      }

      NAS_CACHE_UNLOCK();

      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      resp.resp_pkt = (void *) &resp_payload;
      resp.resp_len = sizeof( resp_payload );
      qcril_send_request_response( &resp );
  }
  else
  {
      QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
  }

  QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_embms_set_sntp_time

//===========================================================================
// QCRIL_EVT_HOOK_EMBMS_GET_E911_STATE
//===========================================================================
void qcril_qmi_nas_embms_get_e911_state
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_e911_state_req_msg_v01 *ril_req_payload;
    embms_get_e911_state_resp_msg_v01 ril_resp_payload;
    uint8_t emergency_mode = NAS_CMN_EMERGENCY_MODE_OFF;


    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = RIL_E_GENERIC_FAILURE;


    if (NULL != params_ptr &&
        params_ptr->data &&
        params_ptr->datalen >= sizeof(*ril_req_payload))
    {

        ril_req_payload = (embms_get_e911_state_req_msg_v01 *) params_ptr->data;
        ril_req_res = RIL_E_SUCCESS;
        memset(&ril_resp_payload, 0, sizeof(ril_resp_payload));
        ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
        ril_resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;
        ril_resp_payload.e911_state_valid = TRUE;
        NAS_CACHE_LOCK();
        if ( NAS_CACHE_IS_ENTRY_VALID( nas_cached_info.emergency_mode ))
        {
            emergency_mode = nas_cached_info.emergency_mode;
        }
        NAS_CACHE_UNLOCK();
        if (emergency_mode == NAS_CMN_EMERGENCY_MODE_ON) {
            ril_resp_payload.e911_state = EMBMS_E911_MODE_ACTIVE_V01;
        } else {
            ril_resp_payload.e911_state = EMBMS_E911_MODE_INACTIVE_V01;
        }

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &ril_resp_payload;
        resp.resp_len = sizeof( ril_resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_e911_state

void qcril_qmi_nas_embms_get_sib_plmn_cb
(
  qmi_client_type              user_handle,
  unsigned int                 message_id,
  void                        *resp_c_struct,
  unsigned int                 resp_c_struct_len,
  void                        *resp_cb_data,
  qmi_client_error_type        transp_err
)
{
    qcril_request_resp_params_type   resp;
    embms_get_sib_plmn_resp_msg_v01  ril_resp_payload;
    nas_get_serv_cell_sib_resp_msg_v01 *qmi_response =
      (nas_get_embms_sig_ext_resp_msg_v01*) resp_c_struct;
    RIL_Errno                        ril_req_res = RIL_E_GENERIC_FAILURE;
    qcril_reqlist_public_type        request_info;

    QCRIL_LOG_INFO("transp_err: %d", (int) transp_err);

    QCRIL_NOTUSED(user_handle);
    QCRIL_NOTUSED(message_id);
    QCRIL_NOTUSED(resp_c_struct_len);
    QCRIL_NOTUSED(resp_cb_data);

    memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
    NAS_CACHE_LOCK();
    ril_resp_payload.dbg_trace_id = nas_cached_info.sib_info.dbg_trace_id;
    NAS_CACHE_UNLOCK();

    if ( qmi_response )
    {
        ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(transp_err,
                                                                              &qmi_response->resp);
        QCRIL_LOG_INFO(".. res %d, qmi trasp err %d, qmi det err %d",
                       (int) ril_req_res,
                       (int)transp_err,
                       (int) qmi_response->resp.error );

        if ( E_SUCCESS != qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID,
                                                         QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN,
                                                         &request_info))
        {
            QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN not found");
        }
        else
        {
            // QMI RESP Success, update NAS cache, RIL RESP will be sent by QMI IND
            if ((RIL_E_SUCCESS == ril_req_res) && (qmi_response->total_size_valid))
            {
              // Update nas cache, allocate memory, wait for indication
              NAS_CACHE_LOCK();
              nas_cached_info.sib_info.current_size = 0;
              nas_cached_info.sib_info.sequence = 0;
              nas_cached_info.sib_info.bin_data.len = qmi_response->total_size;
              nas_cached_info.sib_info.bin_data.data = qcril_malloc(qmi_response->total_size);
              NAS_CACHE_UNLOCK();
              QCRIL_LOG_INFO(".. total_size_valid: %d, total_size: %d",
                             qmi_response->total_size_valid,
                             qmi_response->total_size);
            }
            else // QMI RESP Error, send RIL RESP FAIL
            {
              if (!qmi_response->total_size_valid)
              {
                QCRIL_LOG_ERROR("total size not valid");
              }
              qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                                 request_info.t,
                                                 request_info.request,
                                                 ril_req_res,
                                                 &resp );
              resp.resp_pkt = (void *) &ril_resp_payload;
              resp.resp_len = sizeof( ril_resp_payload );
              qcril_send_request_response( &resp );
            }
        }
        qcril_free( qmi_response );
    }
    else
    {
      QCRIL_LOG_ERROR("qmi_response is NULL");
    }

    QCRIL_LOG_FUNC_RETURN();

} // qcril_qmi_nas_embms_get_sib_plmn_cb

//===========================================================================
// QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN
//===========================================================================
void qcril_qmi_nas_embms_get_sib_plmn
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  qcril_request_resp_params_type resp;
  RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;
  qcril_reqlist_public_type      qcril_req_info_ptr;

  embms_get_sib_plmn_req_msg_v01 *ril_req_payload =
    (embms_get_sib_plmn_req_msg_v01*)params_ptr->data;
  embms_get_sib_plmn_resp_msg_v01 ril_resp_payload;
  nas_get_serv_cell_sib_req_msg_v01 qmi_req;
  nas_get_serv_cell_sib_resp_msg_v01 *qmi_resp;

  qcril_reqlist_public_type        request_info;
  qmi_client_error_type          qmi_client_error;
  qmi_txn_handle                 txn_handle;

  QCRIL_LOG_FUNC_ENTRY();
  QCRIL_NOTUSED(ret_ptr);

  do
  {
      // If same request is already there, just ignore this one
      if ( E_SUCCESS == qcril_reqlist_query_by_request(QCRIL_DEFAULT_INSTANCE_ID,
                                                       QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN,
                                                       &request_info))
      {
        QCRIL_LOG_ERROR("QCRIL_EVT_HOOK_EMBMS_GET_SIB_PLMN already present");
        QCRIL_LOG_FUNC_RETURN();
        return;
      }

      if ( NULL == ril_req_payload )
      {
          QCRIL_LOG_ERROR("invalid NULL parameter for embms get sib plmn");
          break;
      }

      qcril_reqlist_default_entry( params_ptr->t,
                                   params_ptr->event_id,
                                   QCRIL_DEFAULT_MODEM_ID,
                                   QCRIL_REQ_AWAITING_CALLBACK,
                                   QCRIL_EVT_NONE,
                                   NULL,
                                   &qcril_req_info_ptr );
      if ( E_SUCCESS != qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info_ptr))
      {
          QCRIL_LOG_ERROR("failed to create request");
          break;
      }

      qmi_resp = qcril_malloc( sizeof( *qmi_resp ) );
      if ( NULL == qmi_resp )
      {
          QCRIL_LOG_ERROR( "mem alloc failed" );
          break;
      }

      memset( &qmi_req, 0, sizeof( qmi_req ) );
      // Hardcode sib_num to 1
      qmi_req.sib_num = 1;

      NAS_CACHE_LOCK();
      memset(&nas_cached_info.sib_info, 0, sizeof(nas_cached_info.sib_info));
      nas_cached_info.sib_info.dbg_trace_id = ril_req_payload->dbg_trace_id;
      NAS_CACHE_UNLOCK();

      qmi_client_error =  qmi_client_send_msg_async_with_shm(
                                 qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                 QMI_NAS_GET_SERV_CELL_SIB_REQ_MSG_V01,
                                 (void*) &qmi_req,
                                 sizeof( qmi_req ),
                                 (void*) qmi_resp,
                                 sizeof( *qmi_resp ),
                                 qcril_qmi_nas_embms_get_sib_plmn_cb,
                                 NULL,
                                 &txn_handle
                                 );

      ril_req_res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_client_error, NULL);

      if ( RIL_E_SUCCESS != ril_req_res )
      {
          QCRIL_LOG_ERROR( ".. qmi msg send failed %d / %d",
                           (int)ril_req_res,
                           (int)qmi_client_error);
          qcril_free( qmi_resp );
      }
  } while ( 0 );

  if ( RIL_E_SUCCESS != ril_req_res )
  {
      qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                         params_ptr->t,
                                         params_ptr->event_id,
                                         ril_req_res,
                                         &resp );
      if ( NULL != ril_req_payload )
      {
          memset( &ril_resp_payload, 0, sizeof( ril_resp_payload ) );
          ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
          resp.resp_pkt = (void *) &ril_resp_payload;
          resp.resp_len = sizeof( ril_resp_payload );
      }
      qcril_send_request_response( &resp );
  }

  QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_sib_plmn

//===========================================================================
// QCRIL_EVT_HOOK_EMBMS_GET_EMBMS_STATUS
//===========================================================================
void qcril_qmi_nas_embms_get_embms_status
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_embms_status_req_msg_v01 *ril_req_payload;
    embms_get_embms_status_resp_msg_v01 ril_resp_payload;

    QCRIL_LOG_FUNC_ENTRY();

    ril_req_res = RIL_E_GENERIC_FAILURE;

    if (NULL != params_ptr &&
        params_ptr->data &&
        params_ptr->datalen >= sizeof(*ril_req_payload))
    {

        ril_req_payload = (embms_get_embms_status_req_msg_v01 *) params_ptr->data;
        ril_req_res = RIL_E_SUCCESS;
        memset(&ril_resp_payload, 0, sizeof(ril_resp_payload));
        ril_resp_payload.dbg_trace_id = ril_req_payload->dbg_trace_id;
        NAS_CACHE_LOCK();
        ril_resp_payload.is_available = nas_cached_info.is_embms_available;
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("is_embms_avaliable = %d", ril_resp_payload.is_available);

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &ril_resp_payload;
        resp.resp_len = sizeof( ril_resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_embms_status

//===========================================================================
// qcril_qmi_nas_embms_get_utc_time
//===========================================================================
void qcril_qmi_nas_embms_get_utc_time
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    RIL_Errno ril_req_res;
    embms_get_utc_time_req_msg_v01  req_payload;
    embms_get_utc_time_resp_msg_v01 resp_payload;
    time_genoff_info_type time_get;
    uint64_t abs_time;
    int ret_code;


    QCRIL_LOG_FUNC_ENTRY();
    QCRIL_NOTUSED(ret_ptr);

    ril_req_res = RIL_E_GENERIC_FAILURE;
    memset(&req_payload,
           0,
           sizeof(req_payload));
    memset(&resp_payload,
           0,
           sizeof(resp_payload));
    memset(&time_get,
           0,
           sizeof(time_get));
    abs_time = 0;
    ret_code = 0;


    if (NULL != params_ptr && params_ptr->datalen <= sizeof(req_payload))
    {
        memcpy(&req_payload, params_ptr->data, params_ptr->datalen);
        QCRIL_LOG_INFO("utc dbg trace id %d",
                       req_payload.dbg_trace_id);

        time_get.base = ATS_UTC;
        time_get.unit = TIME_MSEC;
        time_get.operation = T_GET;
        time_get.ts_val = &abs_time;
        ret_code = time_genoff_operation(&time_get);
        if(!ret_code)
        {
            resp_payload.resp_code = QMI_RIL_EMBMS_SUCCESS;
            ril_req_res = RIL_E_SUCCESS;
            QCRIL_LOG_INFO("retrieved UTC successfully");
        }
        else
        {
            resp_payload.resp_code = QMI_RIL_EMBMS_ERROR_UNKNOWN;
            QCRIL_LOG_INFO("unable to retrieve UTC, error %d",
                           ret_code);
        }

        resp_payload.dbg_trace_id = req_payload.dbg_trace_id;
        if(time_get.ts_val)
        {
            resp_payload.milli_sec = *((uint64_t*) time_get.ts_val);
        }

        NAS_CACHE_LOCK();
        if(TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.day_light_saving))
        {
            resp_payload.day_light_saving_valid = TRUE;
            resp_payload.day_light_saving = nas_cached_info.day_light_saving;
        }
        if(TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.leap_seconds))
        {
            resp_payload.leap_seconds_valid = TRUE;
            resp_payload.leap_seconds = nas_cached_info.leap_seconds;
        }
        if(TRUE == NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.local_time_offset))
        {
            resp_payload.local_time_offset_valid = TRUE;
            resp_payload.local_time_offset = nas_cached_info.local_time_offset;
        }
        NAS_CACHE_UNLOCK();

        QCRIL_LOG_INFO("utc time (%x, %x), daylight valid %d, value %d,"
                       "leap sec valid %d, value %d, offset valid %d value %d",
                       (uint32) (resp_payload.milli_sec >> 32),
                       (uint32) resp_payload.milli_sec,
                       resp_payload.day_light_saving_valid,
                       resp_payload.day_light_saving,
                       resp_payload.leap_seconds_valid,
                       resp_payload.leap_seconds,
                       resp_payload.local_time_offset_valid,
                       resp_payload.local_time_offset);

        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           ril_req_res,
                                           &resp );
        resp.resp_pkt = (void *) &resp_payload;
        resp.resp_len = sizeof( resp_payload );
        qcril_send_request_response( &resp );
    }
    else
    {
        QCRIL_LOG_ERROR("params_ptr is NULL or has invalid data");
    }

    QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_embms_get_utc_time

//===========================================================================
// qcril_qmi_nas_connected_emergency_call_end_hdlr
//===========================================================================
void qcril_qmi_nas_connected_emergency_call_end_hdlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
   boolean need_to_send_unsol = FALSE;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);

   NAS_CACHE_LOCK();

   int *is_eme_ip_call = (int*) params_ptr->data;
   nas_cached_info.is_eme_ip_call = *is_eme_ip_call;
   if (nas_cached_info.nas_enter_ecbm_propagation_pending)
   {
      need_to_send_unsol = TRUE;
      nas_cached_info.nas_enter_ecbm_propagation_pending = FALSE;
   }
   else
   {
      nas_cached_info.eme_call_end_recently = TRUE;

      const struct timeval TIMER = { 3 , 0 }; // 3 seconds
      qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_DEFAULT_MODEM_ID,
                                  qcril_qmi_nas_eme_call_end_recently_timeout_cb,
                                  &TIMER, &nas_cached_info.eme_call_end_recently_tcb_id);

   }
   NAS_CACHE_UNLOCK();

   if (need_to_send_unsol)
   {
      qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_ACTIVE );
   }
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_connected_emergency_call_end_hdlr

//===========================================================================
// qcril_qmi_nas_emergency_mode_on_hdlr
//===========================================================================
void qcril_qmi_nas_emergency_mode_on_hdlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
   boolean need_to_send_unsol = FALSE;

   QCRIL_LOG_FUNC_ENTRY();
   QCRIL_NOTUSED(ret_ptr);
   QCRIL_NOTUSED(params_ptr);

   NAS_CACHE_LOCK();
   if (nas_cached_info.eme_call_end_recently)
   {
      need_to_send_unsol = TRUE;
      nas_cached_info.eme_call_end_recently = FALSE;
      qcril_cancel_timed_callback((void *)(uintptr_t)nas_cached_info.eme_call_end_recently_tcb_id);
   }
   else
   {
      nas_cached_info.nas_enter_ecbm_propagation_pending = TRUE;
   }
   NAS_CACHE_UNLOCK();

   if (need_to_send_unsol)
   {
      qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_ACTIVE );
   }
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_emergency_mode_on_hdlr

//===========================================================================
// qcril_qmi_nas_emergency_mode_off_hdlr
//===========================================================================
void qcril_qmi_nas_emergency_mode_off_hdlr
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(ret_ptr);
   QCRIL_NOTUSED(params_ptr);
   NAS_CACHE_LOCK();
   nas_cached_info.nas_enter_ecbm_propagation_pending = FALSE;
   if (nas_cached_info.eme_call_end_recently)
   {
      nas_cached_info.eme_call_end_recently = FALSE;
      qcril_cancel_timed_callback((void *)(uintptr_t)nas_cached_info.eme_call_end_recently_tcb_id);
   }
   NAS_CACHE_UNLOCK();
   qmi_ril_nwr_set_eme_cbm( QMI_RIL_EME_CBM_NOT_ACTIVE );
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_emergency_mode_off_hdlr

//===========================================================================
// qcril_qmi_nas_eme_call_end_recently_timeout_cb
//===========================================================================
void qcril_qmi_nas_eme_call_end_recently_timeout_cb(void * params)
{
   QCRIL_LOG_FUNC_ENTRY();

   QCRIL_NOTUSED(params);

   NAS_CACHE_LOCK();
   nas_cached_info.eme_call_end_recently = FALSE;
   if ( !qcril_qmi_voice_nas_control_is_any_calls_present() )
   {
      qcril_qmi_nas_voice_move_device_to_lpm_after_emer_call_conditionally();
   }
   NAS_CACHE_UNLOCK();
   QCRIL_LOG_FUNC_RETURN();
} // qcril_qmi_nas_eme_call_end_recently_timeout_cb

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_get_engineer_mode_info_timeout_handler

===========================================================================*/
/*!
    @brief
    Timeout handler when the timer for engineer mode information report expired.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_nas_get_engineer_mode_info_timeout_handler(sigval_t sval)
{
  qcril_unsol_resp_params_type unsol_resp;
  int i;
  struct cdma_ftm_data *cdma_data = NULL;
  struct gsm_ftm_data *gsm_data = NULL;
  struct wcdma_ftm_data *wcdma_data = NULL;

  QCRIL_LOG_FUNC_ENTRY();

  (void)sval;

  do
  {
    if( FTM_SUBSCRIPTION_CDMA == qcril_qmi_nas_get_engineer_mode_info_timer.subs_type)
    {
      cdma_data = qcril_malloc(sizeof(*cdma_data));
      if( NULL == cdma_data)
      {
        QCRIL_LOG_INFO("Memory not allocated for cdma_ftm_data");
        break;
      }

      qcril_qmi_nas_get_field_test_mode_info_for_cdma( cdma_data );
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_ENGINEER_MODE, (void *)cdma_data, sizeof(*cdma_data));
    }
    else if( FTM_SUBSCRIPTION_GSM == qcril_qmi_nas_get_engineer_mode_info_timer.subs_type)
    {
      gsm_data = qcril_malloc(sizeof(*gsm_data));
      if( NULL == gsm_data)
      {
        QCRIL_LOG_INFO("Memory not allocated for gsm_ftm_data");
        break;
      }

      qcril_qmi_nas_get_field_test_mode_info_for_gsm( gsm_data );
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_ENGINEER_MODE, (void *)gsm_data, sizeof(*gsm_data));
    }
    else if( FTM_SUBSCRIPTION_WCDMA == qcril_qmi_nas_get_engineer_mode_info_timer.subs_type)
    {
      wcdma_data = qcril_malloc(sizeof(*wcdma_data));
      if( NULL == wcdma_data)
      {
        QCRIL_LOG_INFO("Memory not allocated for gsm_ftm_data");
        break;
      }

      qcril_qmi_nas_get_field_test_mode_info_for_wcdma( wcdma_data );
      qcril_hook_unsol_response( QCRIL_DEFAULT_INSTANCE_ID, QCRIL_EVT_HOOK_UNSOL_ENGINEER_MODE, (void *)wcdma_data, sizeof(*wcdma_data));
    }

    if( NULL != cdma_data)
    {
      qcril_free( cdma_data );
      cdma_data = NULL;
    }

    if( NULL != gsm_data)
    {
      qcril_free( gsm_data );
      gsm_data = NULL;
    }

    if( NULL != wcdma_data)
    {
      qcril_free( wcdma_data );
      wcdma_data = NULL;
    }
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_start_get_engineer_mode_info_timer

===========================================================================*/
/*!
    @brief
    Start the timer for engineer mode information report.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_nas_start_get_engineer_mode_info_timer(qcril_instance_id_e_type instance_id,
            oem_hook_ftm_subscription_source_e_type subs_type)
{
  struct sigevent sigev;
  struct itimerspec itimers;

  QCRIL_LOG_FUNC_ENTRY();

  do
  {
    if (qcril_qmi_nas_get_engineer_mode_info_timer.timer_started)
    {
      QCRIL_LOG_DEBUG("%s","timer is already started,ignore");
      break;
    }

    qcril_qmi_nas_get_engineer_mode_info_timer.instance_id = instance_id;
    qcril_qmi_nas_get_engineer_mode_info_timer.subs_type = subs_type;
    sigev.sigev_notify = SIGEV_THREAD;
    sigev.sigev_notify_attributes = NULL;
    sigev.sigev_value.sival_ptr = &qcril_qmi_nas_get_engineer_mode_info_timer;
    sigev.sigev_notify_function = qcril_qmi_nas_get_engineer_mode_info_timeout_handler;

    if (timer_create(CLOCK_REALTIME,&sigev,&qcril_qmi_nas_get_engineer_mode_info_timer.timer_id) == -1)
    {
      QCRIL_LOG_ERROR("%s","failed to create no service guard timer");
      break;
    }

    itimers.it_value.tv_sec = 1; // 1sec
    itimers.it_value.tv_nsec = 0;
    itimers.it_interval.tv_sec = 1; // 1sec
    itimers.it_interval.tv_nsec = 0;

    if (timer_settime(qcril_qmi_nas_get_engineer_mode_info_timer.timer_id,0,&itimers,NULL) == -1)
    {
      QCRIL_LOG_ERROR("%s","failed to start timer,delete it");
      timer_delete(qcril_qmi_nas_get_engineer_mode_info_timer.timer_id);
      qcril_qmi_nas_get_engineer_mode_info_timer.timer_id = 0;
      break;
    }

    QCRIL_LOG_DEBUG("TIMER ID %d started",qcril_qmi_nas_get_engineer_mode_info_timer.timer_id);
    qcril_qmi_nas_get_engineer_mode_info_timer.timer_started = TRUE;
  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
}

/*=========================================================================
  FUNCTION:  qcril_qmi_nas_stop_get_engineer_mode_info_timer

===========================================================================*/
/*!
    @brief
    Stop the timer for engineer mode information report.

    @return
    None.
*/
/*=========================================================================*/
static void qcril_qmi_nas_stop_get_engineer_mode_info_timer(qcril_instance_id_e_type instance_id,
            oem_hook_ftm_subscription_source_e_type subs_type)
{
  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(instance_id);

  if ( ( qcril_qmi_nas_get_engineer_mode_info_timer.timer_started )
        && ( qcril_qmi_nas_get_engineer_mode_info_timer.subs_type == subs_type ) )
  {
    QCRIL_LOG_DEBUG("%s","stop the timer for engineer mode information report");
    timer_delete(qcril_qmi_nas_get_engineer_mode_info_timer.timer_id);
    qcril_qmi_nas_get_engineer_mode_info_timer.timer_started = FALSE;
    qcril_qmi_nas_get_engineer_mode_info_timer.timer_id = 0;
    qcril_qmi_nas_get_engineer_mode_info_timer.subs_type = FTM_SUBSCRIPTION_INVALID;
  }
  else
  {
    QCRIL_LOG_DEBUG("%s","timer is already stoped,ignore");
  }

  QCRIL_LOG_FUNC_RETURN();
}
//===========================================================================
// Function: qcril_qmi_nas_get_field_test_mode_info_for_cdma
// To get data for cdma
//===========================================================================
void qcril_qmi_nas_get_field_test_mode_info_for_cdma( struct cdma_ftm_data *cdma_data)
{
    qmi_client_error_type qmi_client_error;
    nas_get_sys_info_resp_msg_v01 get_sys_info_response;
    nas_get_cell_location_info_resp_msg_v01 get_cell_loc_info_response;
    nas_get_sig_info_resp_msg_v01 get_sig_info_response;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];

    QCRIL_LOG_FUNC_ENTRY();

    memset(&get_sys_info_response,0,sizeof(get_sys_info_response));
    memset(&get_cell_loc_info_response,0,sizeof(get_cell_loc_info_response));
    memset(&get_sig_info_response,0,sizeof(get_sig_info_response));
    memset(mcc_str,0,NAS_MCC_MNC_MAX_SIZE);
    memset(mnc_str,0,NAS_MCC_MNC_MAX_SIZE);

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,  // empty request payload
                                                    (void *) &get_sys_info_response,
                                                    sizeof( get_sys_info_response ),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    (void *) &get_cell_loc_info_response,
                                                    sizeof( get_cell_loc_info_response ),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                               QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
                                                               NULL,
                                                               NAS_NIL,
                                                               &get_sig_info_response,
                                                               sizeof( get_sig_info_response ),
                                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    //Copying Service Status and System Mode to the buffer
    if( TRUE == get_sys_info_response.cdma_srv_status_info_valid )
    {
        cdma_data->srv_status = get_sys_info_response.cdma_srv_status_info.srv_status;
        cdma_data->system_mode = FTM_SUBSCRIPTION_CDMA;
    }

    //Copying Service Domain to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.common_sys_info.srv_domain_valid )
      )
    {
        cdma_data->srv_domain = get_sys_info_response.cdma_sys_info.common_sys_info.srv_domain;
    }

    //Copying Roaming Status to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.common_sys_info.roam_status_valid )
      )
    {
        cdma_data->roam_status = get_sys_info_response.cdma_sys_info.common_sys_info.roam_status;
    }

    //Copying MCC to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id.mcc, mcc_str);
        cdma_data->mcc = atoi(mcc_str);
    }

    //Copying MNC to the buffer
    if( ( TRUE == get_sys_info_response.cdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.cdma_sys_info.cdma_specific_sys_info.network_id.mnc, mnc_str);
        cdma_data->mnc = atoi(mnc_str);
    }

    //Copying rssi to the buffer
    if( TRUE == get_sig_info_response.cdma_sig_info_valid )
    {
        cdma_data->rssi = get_sig_info_response.cdma_sig_info.rssi;
    }

    //Copying ecio to the buffer
    if( TRUE == get_sig_info_response.cdma_sig_info_valid )
    {
        cdma_data->ecio = get_sig_info_response.cdma_sig_info.ecio;
    }

    //Copying cdma_1x_rx0_agc to the buffer
    if( TRUE == get_cell_loc_info_response.cdma_rx_power_valid )
    {
        cdma_data->cdma_1x_rx0_agc = get_cell_loc_info_response.cdma_rx_power.rx0_agc;
    }

    //Copying cdma_1x_rx1_agc to the buffer
    if( TRUE == get_cell_loc_info_response.cdma_rx_power_valid )
    {
        cdma_data->cdma_1x_rx1_agc = get_cell_loc_info_response.cdma_rx_power.rx1_agc;
    }

    //Copying cdma_evdo_rx0_agc to the buffer
    if( TRUE == get_cell_loc_info_response.hdr_rx_power_valid ) // Need to discuss from modem team
    {
        cdma_data->cdma_evdo_rx0_agc = get_cell_loc_info_response.hdr_rx_power.rx0_agc;
    }

    //Copying cdma_evdo_rx1_agc to the buffer
    if( TRUE == get_cell_loc_info_response.hdr_rx_power_valid ) // Need to discuss from modem team
    {
        cdma_data->cdma_evdo_rx1_agc = get_cell_loc_info_response.hdr_rx_power.rx1_agc;
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_field_test_mode_info_for_cdma

//===========================================================================
// Function: qcril_qmi_nas_get_field_test_mode_info_for_gsm
// To get data for gsm
//===========================================================================
void qcril_qmi_nas_get_field_test_mode_info_for_gsm( struct gsm_ftm_data *gsm_data)
{
    qmi_client_error_type qmi_client_error;
    nas_get_sys_info_resp_msg_v01 get_sys_info_response;
    nas_get_cell_location_info_resp_msg_v01 get_cell_loc_info_response;
    nas_get_sig_info_resp_msg_v01 get_sig_info_response;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint32_t i = 0;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&get_sys_info_response,0,sizeof(get_sys_info_response));
    memset(&get_cell_loc_info_response,0,sizeof(get_cell_loc_info_response));
    memset(&get_sig_info_response,0,sizeof(get_sig_info_response));
    memset(mcc_str,0,NAS_MCC_MNC_MAX_SIZE);
    memset(mnc_str,0,NAS_MCC_MNC_MAX_SIZE);

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,  // empty request payload
                                                    (void *) &get_sys_info_response,
                                                    sizeof( get_sys_info_response ),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    (void *) &get_cell_loc_info_response,
                                                    sizeof( get_cell_loc_info_response ),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                               QMI_NAS_GET_SIG_INFO_REQ_MSG_V01,
                                                               NULL,
                                                               NAS_NIL,
                                                               &get_sig_info_response,
                                                               sizeof( get_sig_info_response ),
                                                               QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    //Copying Service Status and System Mode to the buffer
    if( TRUE == get_sys_info_response.gsm_srv_status_info_valid )
    {
        gsm_data->srv_status = get_sys_info_response.gsm_srv_status_info.srv_status;
        gsm_data->system_mode = FTM_SUBSCRIPTION_GSM;
    }

    //Copying Service Domain to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.common_sys_info.srv_domain_valid )
      )
    {
        gsm_data->srv_domain = get_sys_info_response.gsm_sys_info.common_sys_info.srv_domain;
    }

    //Copying Roaming Status to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.common_sys_info.roam_status_valid )
      )
    {
        gsm_data->roam_status = get_sys_info_response.gsm_sys_info.common_sys_info.roam_status;
    }

    //Copying MCC to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id.mcc, mcc_str);
        gsm_data->mcc = atoi(mcc_str);
    }

    //Copying MNC to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.network_id.mnc, mnc_str);
        gsm_data->mnc = atoi(mnc_str);
    }

    //Copying LAC to the buffer
    if( ( TRUE == get_sys_info_response.gsm_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.lac_valid )
      )
    {
        gsm_data->lac = get_sys_info_response.gsm_sys_info.threegpp_specific_sys_info.lac;
    }

    //Copying RSSI to the buffer
    if( TRUE == get_sig_info_response.gsm_sig_info_valid )
    {
        gsm_data->rssi = get_sig_info_response.gsm_sig_info;
    }

    //Copying BCCH to the buffer
    if( TRUE == get_cell_loc_info_response.gsm_info_ext_valid )
    {
        gsm_data->bcch = get_cell_loc_info_response.gsm_info_ext.g_bcch;
    }

    //Copying BSIC to the buffer
    if( TRUE == get_cell_loc_info_response.geran_info_valid )
    {
        gsm_data->bsic = get_cell_loc_info_response.geran_info.bsic;
    }

    //Copying RX LEVEL to the buffer
    if( TRUE == get_cell_loc_info_response.geran_info_valid )
    {
        gsm_data->rx_level = get_cell_loc_info_response.geran_info.rx_lev;
    }

    //Copying RX QUALITY FULL to the buffer
    gsm_data->rx_qual_full = 0; //QMI_NAS to confirm

    //Copying RX QUALITY SUB to the buffer
    gsm_data->rx_qual_sub = 0; //QMI_NAS to confirm

    //Copying TA to the buffer
    if( TRUE == get_cell_loc_info_response.gsm_info_ext_valid )
    {
        gsm_data->ta = get_cell_loc_info_response.gsm_info_ext.g_ta;
    }

    //Copying GSM neighbor cells info  to the buffer
    if( TRUE == get_cell_loc_info_response.geran_info_valid )
    {
        gsm_data->no_of_neigh_cell_info_len = get_cell_loc_info_response.geran_info.nmr_cell_info_len;
        for(i=0;i<get_cell_loc_info_response.geran_info.nmr_cell_info_len;i++)
        {
            gsm_data->gsm_neigh_cell[i].cell_id = get_cell_loc_info_response.geran_info.nmr_cell_info[i].nmr_cell_id;
            gsm_data->gsm_neigh_cell[i].bsic = get_cell_loc_info_response.geran_info.nmr_cell_info[i].nmr_bsic;
            gsm_data->gsm_neigh_cell[i].rx_level = get_cell_loc_info_response.geran_info.nmr_cell_info[i].nmr_rx_lev;

            if( TRUE == get_cell_loc_info_response.gncell_bcch_valid )
            {
               gsm_data->gsm_neigh_cell[i].bcch = get_cell_loc_info_response.gncell_bcch[i];
            }
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_field_test_mode_info_for_gsm

//===========================================================================
// Function: qcril_qmi_nas_get_field_test_mode_info_for_wcdma
// To get data for wcdma
//===========================================================================
void qcril_qmi_nas_get_field_test_mode_info_for_wcdma( struct wcdma_ftm_data *wcdma_data)
{
    qmi_client_error_type qmi_client_error;
    nas_get_sys_info_resp_msg_v01 get_sys_info_response;
    nas_get_cell_location_info_resp_msg_v01 get_cell_loc_info_response;
    char mcc_str[NAS_MCC_MNC_MAX_SIZE];
    char mnc_str[NAS_MCC_MNC_MAX_SIZE];
    uint32_t i =0;

    QCRIL_LOG_FUNC_ENTRY();

    memset(&get_sys_info_response,0,sizeof(get_sys_info_response));
    memset(&get_cell_loc_info_response,0,sizeof(get_cell_loc_info_response));
    memset(mcc_str,0,NAS_MCC_MNC_MAX_SIZE);
    memset(mnc_str,0,NAS_MCC_MNC_MAX_SIZE);

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle ( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,  // empty request payload
                                                    (void *) &get_sys_info_response,
                                                    sizeof( get_sys_info_response ),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    qmi_client_error = qmi_client_send_msg_sync_with_shm( qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                    QMI_NAS_GET_CELL_LOCATION_INFO_REQ_MSG_V01,
                                                    NULL,
                                                    NAS_NIL,
                                                    (void *) &get_cell_loc_info_response,
                                                    sizeof( get_cell_loc_info_response ),
                                                    QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    //Copying Service Status and System Mode to the buffer
    if( TRUE == get_sys_info_response.wcdma_srv_status_info_valid )
    {
        wcdma_data->srv_status = get_sys_info_response.wcdma_srv_status_info.srv_status;
        wcdma_data->system_mode = FTM_SUBSCRIPTION_WCDMA;
    }

    //Copying Service Domain to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.common_sys_info.srv_domain_valid )
      )
    {
        wcdma_data->srv_domain = get_sys_info_response.wcdma_sys_info.common_sys_info.srv_domain;
    }

    //Copying Roaming Status to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.common_sys_info.roam_status_valid )
      )
    {
        wcdma_data->roam_status = get_sys_info_response.wcdma_sys_info.common_sys_info.roam_status;
    }

    //Copying MCC to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id.mcc, mcc_str);
        wcdma_data->mcc = atoi(mcc_str);
    }

    //Copying MNC to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id_valid )
      )
    {
        qcril_qmi_nas_fillup_mcc_mnc_helper( get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.network_id.mnc, mnc_str);
        wcdma_data->mnc = atoi(mnc_str);
    }

    //Copying LAC to the buffer
    if( ( TRUE == get_sys_info_response.wcdma_sys_info_valid ) &&
        ( TRUE == get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.lac_valid )
      )
    {
        wcdma_data->lac = get_sys_info_response.wcdma_sys_info.threegpp_specific_sys_info.lac;
    }

    //Copying BLER to the buffer
    if( TRUE == get_cell_loc_info_response.wcdma_info_ext_valid )
    {
        wcdma_data->bler = get_cell_loc_info_response.wcdma_info_ext.w_dl_bler;
    }

    //Copying ECIO to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->ecio = get_cell_loc_info_response.umts_info.ecio;
    }

    //Copying RSCP to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->rscp = get_cell_loc_info_response.umts_info.rscp;
    }

    //Copying RX_AGC to the buffer
    if( TRUE == get_cell_loc_info_response.wcdma_info_ext_valid )
    {
        wcdma_data->rx_agc = get_cell_loc_info_response.wcdma_info_ext.w_agc;
    }

    //Copying TX_AGC to the buffer
    if( TRUE == get_cell_loc_info_response.wcdma_info_ext_valid )
    {
        wcdma_data->tx_agc = get_cell_loc_info_response.wcdma_info_ext.w_txagc;
    }

    //Copying UARFCN to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->uarfcn = get_cell_loc_info_response.umts_info.uarfcn;
    }

    //Copying PSC to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->psc = get_cell_loc_info_response.umts_info.psc;
    }

    //Copying WCDMA neighbor cells info  to the buffer
    if( TRUE == get_cell_loc_info_response.umts_info_valid )
    {
        wcdma_data->no_of_neigh_cell_info_len = get_cell_loc_info_response.umts_info.umts_monitored_cell_len;
        for(i=0;i<get_cell_loc_info_response.umts_info.umts_monitored_cell_len;i++)
        {
            wcdma_data->wcdma_neigh_cell[i].cell_id = 0; // QMI_NAS to confirm
            wcdma_data->wcdma_neigh_cell[i].uarfcn = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_uarfcn;
            wcdma_data->wcdma_neigh_cell[i].psc = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_psc;
            wcdma_data->wcdma_neigh_cell[i].rscp = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_rscp;
            wcdma_data->wcdma_neigh_cell[i].ecio = get_cell_loc_info_response.umts_info.umts_monitored_cell[i].umts_ecio;
        }
    }

    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_get_field_test_mode_info_for_wcdma

//===========================================================================
// Request: QCRIL_EVT_HOOK_ENABLE_ENGINEER_MODE
// Function: qcril_qmi_nas_enable_engineer_mode
//===========================================================================
void qcril_qmi_nas_enable_engineer_mode
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr // Output parameter
)
{
  qcril_instance_id_e_type instance_id;
  qcril_modem_id_e_type modem_id;
  qcril_request_resp_params_type resp;
  struct ftm_subs_status *ftm_subs_data;

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(ret_ptr);

  do
  {
    if ( ( NULL == params_ptr ) )
    {
      break;
    }

    instance_id = params_ptr->instance_id;

    modem_id = params_ptr->modem_id;

    if ( ( params_ptr->data == NULL ) || ( instance_id >= QCRIL_MAX_INSTANCE_ID ) || ( modem_id >= QCRIL_MAX_MODEM_ID ) )
    {
      qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_GENERIC_FAILURE, &resp );
  qcril_send_request_response( &resp );
      break;
    }

    ftm_subs_data = (struct ftm_subs_status *)params_ptr->data;

    if ( TRUE == ftm_subs_data->is_enable )
    {
      qcril_qmi_nas_start_get_engineer_mode_info_timer(instance_id, ftm_subs_data->subs_type);
    }
    else
    {
      qcril_qmi_nas_stop_get_engineer_mode_info_timer(instance_id, ftm_subs_data->subs_type);
    }

    QCRIL_LOG_DEBUG( "qcril_qmi_nas_enable_engineer_mode status = %d", ftm_subs_data->is_enable );

    qcril_default_request_resp_params( instance_id, params_ptr->t, params_ptr->event_id, RIL_E_SUCCESS, &resp );
    qcril_send_request_response( &resp );

  }while(FALSE);

  QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================
 qcril_qmi_nas_get_init_attch_state
============================================================================*/
/*!
    @brief
    Retireves initial attach apn state.

    @return
    initial attach apn state.
*/
/*=========================================================================*/
qmi_ril_nas_init_apn_attch_state_e_type qcril_qmi_nas_get_init_attch_state(void)
{
    qmi_ril_nas_init_apn_attch_state_e_type res;
    NAS_CACHE_LOCK();
    res = nas_cached_info.init_attch_state;
    NAS_CACHE_UNLOCK();
    return res;
}

/*===========================================================================
 qcril_qmi_nas_set_init_attch_state
============================================================================*/
/*!
    @brief
    Sets initial attach apn state.

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_set_init_attch_state
(
    qmi_ril_nas_init_apn_attch_state_e_type init_attch_state
)
{
    NAS_CACHE_LOCK();
    nas_cached_info.init_attch_state = init_attch_state;
    NAS_CACHE_UNLOCK();
}

/*===========================================================================
 qcril_qmi_nas_send_attach_detach_request
============================================================================*/
/*!
    @brief
    Send attach ot detach action down to qmi nas.

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_send_attach_detach_request
(
    nas_srv_domain_pref_enum_type_v01 attach_action
)
{
    nas_set_system_selection_preference_req_msg_v01  qmi_attach_req;
    nas_set_system_selection_preference_resp_msg_v01 qmi_attach_resp;
    qmi_client_error_type                            qmi_attach_error;
    RIL_Errno                                        res;

    QCRIL_LOG_INFO("qcril_qmi_nas_send_attach_detach_request action %d", attach_action);

    memset(&qmi_attach_req,0,sizeof(qmi_attach_req));
    memset(&qmi_attach_resp,0,sizeof(qmi_attach_resp));

    qmi_attach_req.srv_domain_pref_valid    = TRUE;
    qmi_attach_req.srv_domain_pref          = attach_action;

    qmi_attach_req.change_duration_valid    = TRUE;
    qmi_attach_req.change_duration          = NAS_POWER_CYCLE_V01;

    qmi_attach_error = qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle( QCRIL_QMI_CLIENT_NAS ),
                                                QMI_NAS_SET_SYSTEM_SELECTION_PREFERENCE_REQ_MSG_V01,
                                                (void*) &qmi_attach_req,
                                                sizeof(qmi_attach_req),
                                                (void*) &qmi_attach_resp,
                                                sizeof(qmi_attach_resp),
                                                QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT );

    res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_attach_error, &qmi_attach_resp.resp);
    if (res != RIL_E_SUCCESS)
    {
      QCRIL_LOG_ERROR("NAS APN attach/detach failed with error code %d",res);
    }

    return res;
}

/*===========================================================================
 qcril_qmi_nas_initial_attach_timeout_handler
============================================================================*/
/*!
    @brief
    Timie out handler for ss event wait

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_initial_attach_timeout_handler
(
    void *param
)
{
    IxErrnoType                     found_qcril_request;
    qcril_request_resp_params_type  resp;
    qcril_reqlist_public_type       qcril_req_info;
    qmi_ril_nas_init_apn_attch_state_e_type ps_attach_state;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(param);

    ps_attach_state = qcril_qmi_nas_get_init_attch_state();

    if ( QMI_RIL_NAS_INIT_APN_ATTCH_DETACH == ps_attach_state ||
            QMI_RIL_NAS_INIT_APN_ATTCH_ATTACH == ps_attach_state)
    {
      found_qcril_request =
         (E_SUCCESS == qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     QCRIL_EVT_QMI_REQUEST_INIT_ATTACH_APN,
                                                     &qcril_req_info));
    }
    else
    {
      found_qcril_request =
         (E_SUCCESS == qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     QCRIL_EVT_QMI_REQUEST_ALLOW_DATA,
                                                     &qcril_req_info));
    }
    QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );
    if (found_qcril_request)
    {
        if (QMI_RIL_NAS_INIT_APN_ATTCH_DETACH == ps_attach_state ||
            QMI_RIL_NAS_INIT_APN_ATTCH_ATTACH == ps_attach_state ||
            QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ATTACH == ps_attach_state ||
            QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH == ps_attach_state ||
            QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_DETACH == ps_attach_state)
        {
            qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               RIL_E_GENERIC_FAILURE, &resp );
            qcril_send_request_response( &resp );
        }
    }

    NAS_CACHE_LOCK();
    nas_cached_info.init_attch_timeout_watch = NAS_NIL;
    NAS_CACHE_UNLOCK();
}

/*===========================================================================

 qcril_qmi_nas_set_ps_service_domain

============================================================================*/
/*!
    @brief
    Set ps service domain detach or attach and start timer

    @return
    RIL_Errno
*/
/*=========================================================================*/
RIL_Errno qcril_qmi_nas_set_ps_service_domain
(
    qmi_ril_nas_init_apn_attch_state_e_type action
)
{
    RIL_Errno   res;
    uint32      new_timeout_watch = 0;
    int         new_timeout_set_res;

    nas_srv_domain_pref_enum_type_v01 attach_action;

    /*
      See Spec 3GPP TS 24.301 version 11.9.0 Release 11
      75s - The maximum time the UE is going to wait for the detach request response.
      2s - Buffer for communication between RIL and QMI.
    */
    const struct timeval init_apn_timeout = {77 , 0};
    QCRIL_LOG_FUNC_ENTRY();

    if ( (action == QMI_RIL_NAS_INIT_APN_ATTCH_DETACH) ||
         (action == QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_DETACH) )
    {
        attach_action = QMI_SRV_DOMAIN_PREF_PS_DETACH_V01;
    }
    else if (action == QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH)
    {
        attach_action = QMI_SRV_DOMAIN_PREF_ON_DEMAND_PS_ATTACH_V01;
    }
    else
    {
        attach_action = QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01;
    }

    res = qcril_qmi_nas_send_attach_detach_request(attach_action);
    if(res != RIL_E_SUCCESS)
    {
      QCRIL_LOG_ERROR("NAS APN detach failed with error code %d", res);
    }
    else
    {
        // start timer
        new_timeout_set_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                          QCRIL_DEFAULT_MODEM_ID,
                                                          qcril_qmi_nas_initial_attach_timeout_handler,
                                                          &init_apn_timeout, &new_timeout_watch );
        QCRIL_LOG_INFO( ".. set timeout cb res %d ", (int) new_timeout_set_res );

        if ( NAS_NIL == new_timeout_watch || E_SUCCESS != new_timeout_set_res )
        {
            res = RIL_E_GENERIC_FAILURE;

            if (QMI_RIL_NAS_INIT_APN_ATTCH_DETACH == action)
            {
                qcril_qmi_nas_send_attach_detach_request(QMI_SRV_DOMAIN_PREF_PS_ATTACH_V01);
            }
        }
        else
        {
            NAS_CACHE_LOCK();
            nas_cached_info.init_attch_timeout_watch = new_timeout_watch;
            NAS_CACHE_UNLOCK();
        }
    }

    return res;
}

/*===========================================================================
 qcril_qmi_nas_is_lte_ps_attached
============================================================================*/
/*!
    @brief
    Checks if lte is ps attached

    @return
    TRUE  : if lte is ps attached
    FALSE : else
*/
/*=========================================================================*/
int qcril_qmi_nas_is_lte_ps_attached
(
    uint8_t                     lte_sys_info_valid,
    nas_lte_sys_info_type_v01  *lte_sys_info
)
{
    if (lte_sys_info_valid &&
        lte_sys_info &&
        lte_sys_info->common_sys_info.srv_domain_valid &&
        ((lte_sys_info->common_sys_info.srv_domain == SYS_SRV_DOMAIN_PS_ONLY_V01) ||
         (lte_sys_info->common_sys_info.srv_domain == SYS_SRV_DOMAIN_CS_PS_V01)))
    {
        return TRUE;
    }

    return FALSE;
}

/*===========================================================================
qcril_qmi_nas_check_ps_attach_status
===========================================================================*/
void qcril_qmi_nas_check_ps_attach_status()
{
    IxErrnoType                     found_qcril_request;
    RIL_Errno                       ril_req_res = RIL_E_SUCCESS;
    RIL_Errno                       resp_to_tel = RIL_E_SUCCESS;
    int                             send_resp_to_tel = FALSE;
    qcril_request_resp_params_type  resp;
    qcril_reqlist_public_type       qcril_req_info;
    qmi_ril_nas_init_apn_attch_state_e_type cur_init_attach_state;
    int ps_attch_status;

    QCRIL_LOG_FUNC_ENTRY();
    cur_init_attach_state = qcril_qmi_nas_get_init_attch_state();
    found_qcril_request =
         (E_SUCCESS == qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     QCRIL_EVT_QMI_REQUEST_ALLOW_DATA,
                                                     &qcril_req_info));

    ps_attch_status = (QMI_RIL_RAT_CONFIDENCE_FULL_SVC == nas_cached_info.data_rte_confidence_tag);
    QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );
    QCRIL_LOG_INFO( "attach_state %d ps_attch_status %d",
                                                cur_init_attach_state, ps_attch_status);
    if (found_qcril_request)
    {
        if ((QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_DETACH == cur_init_attach_state &&
            ((!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref)) ||
            ( nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 ))) ||
            (((QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ATTACH == cur_init_attach_state) ||
              (QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH == cur_init_attach_state)) &&
             ( ps_attch_status == TRUE )))
        {
            send_resp_to_tel = TRUE;
        }
        else if (QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_WAIT_FOR_RAT_EXP == cur_init_attach_state)
        {
            /* check if it there is any rat expansion, if so wait for dsd indication */
            if (qcril_qmi_nas_did_rat_expansion_occur() || (ps_attch_status != TRUE))
            {
                qcril_qmi_nas_set_init_attch_state(
                                        QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH);
            }
            else
            {
                send_resp_to_tel = TRUE;
            }
        }

        if (send_resp_to_tel)
        {
            NAS_CACHE_LOCK();
            if (nas_cached_info.init_attch_timeout_watch)
            {
                qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.init_attch_timeout_watch);
                nas_cached_info.init_attch_timeout_watch = NAS_NIL;
            }
            NAS_CACHE_UNLOCK();
            qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               RIL_E_SUCCESS, &resp );
            qcril_send_request_response( &resp );
        }
    }
}

/*===========================================================================
  qcril_qmi_nas_did_rat_expansion_occur
============================================================================*/
/*!
    @brief
    Check if rat expansion occured

    @return
    TRUE or FALSE
*/
/*=========================================================================*/
boolean qcril_qmi_nas_did_rat_expansion_occur
(
    void
)
{
    boolean ret = FALSE;
    mode_pref_mask_type_v01 rat_disabled_mask;
    mode_pref_mask_type_v01 stored_rat_disabled_mask;

    if (!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.rat_disabled_mask))
    {
        rat_disabled_mask = 0;
    }
    else
    {
        rat_disabled_mask = nas_cached_info.rat_disabled_mask;
    }

    stored_rat_disabled_mask =
            nas_common_info.rat_disabled_mask_during_on_demand_attach;
    rat_disabled_mask = (stored_rat_disabled_mask & rat_disabled_mask);

    /* rat expansion is considered to be occured if any disabled rat is
     * not more disabled */
    if (stored_rat_disabled_mask > rat_disabled_mask)
    {
        ret = TRUE;
    }

    return ret;
}

/*===========================================================================
  qcril_qmi_nas_check_if_service_domain_has_ps
============================================================================*/
/*!
    @brief
    Check if service domain has PS

    @return
    TRUE or FALSE
*/
/*=========================================================================*/
boolean qcril_qmi_nas_check_if_service_domain_has_ps
(
    void
)
{
    boolean ret = FALSE;

    if (NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref) &&
        ((nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_PS_ONLY_V01) ||
        (nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_PS_V01)))
    {
        ret = TRUE;
    }

    return ret;
}

/*===========================================================================
 qcril_qmi_nas_check_initial_attach_state
============================================================================*/
/*!
    @brief
    Checks if INITIAL_ATTACH_APN request can be responded

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_check_initial_attach_state
(
    uint8_t srv_domain_pref_valid,
    nas_srv_domain_pref_enum_type_v01 srv_domain_pref
)
{
    IxErrnoType                     found_qcril_request;
    RIL_Errno                       ril_req_res = RIL_E_SUCCESS;
    RIL_Errno                       resp_to_tel = RIL_E_SUCCESS;
    int                             send_resp_to_tel = FALSE;
    qcril_request_resp_params_type  resp;
    qcril_reqlist_public_type       qcril_req_info;
    qmi_ril_nas_init_apn_attch_state_e_type cur_init_attach_state;

    QCRIL_LOG_FUNC_ENTRY();
    cur_init_attach_state = qcril_qmi_nas_get_init_attch_state();
    found_qcril_request =
         (E_SUCCESS == qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     QCRIL_EVT_QMI_REQUEST_INIT_ATTACH_APN,
                                                     &qcril_req_info));

    QCRIL_LOG_INFO( ".. found_req %d", (int) found_qcril_request );
    QCRIL_LOG_INFO( "srv_domain_pref %d, initial_attach_state %d",
                     srv_domain_pref, cur_init_attach_state);
    if (found_qcril_request)
    {
        if ( (QMI_RIL_NAS_INIT_APN_ATTCH_DETACH == qcril_qmi_nas_get_init_attch_state()) &&
             ( ( (TRUE == srv_domain_pref_valid) &&
                 (QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 == srv_domain_pref)
               ) || (FALSE == srv_domain_pref_valid)
             )
           )
        {
            NAS_CACHE_LOCK();
            if (nas_cached_info.init_attch_timeout_watch)
            {
                qcril_cancel_timed_callback((void*)(uintptr_t)nas_cached_info.init_attch_timeout_watch);
                nas_cached_info.init_attch_timeout_watch = NAS_NIL;
            }

            NAS_CACHE_UNLOCK();

            qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_ATTACH);
            ril_req_res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_INIT_APN_ATTCH_ATTACH);
            if (ril_req_res != RIL_E_SUCCESS)
            {
                QCRIL_LOG_ERROR("NAS APN attach failed with error code %d", ril_req_res);
            }
        }
        else if ( (QMI_RIL_NAS_INIT_APN_ATTCH_ATTACH == qcril_qmi_nas_get_init_attch_state()) &&
                  ( (TRUE == srv_domain_pref_valid) &&
                    ( (QMI_SRV_DOMAIN_PREF_CS_PS_V01 == srv_domain_pref) ||
                      (QMI_SRV_DOMAIN_PREF_PS_ONLY_V01 == srv_domain_pref)
                    )
                  )
                )
        {
            NAS_CACHE_LOCK();
            if (nas_cached_info.init_attch_timeout_watch)
            {
                qcril_cancel_timed_callback((void*)(uintptr_t)nas_cached_info.init_attch_timeout_watch);
                nas_cached_info.init_attch_timeout_watch = NAS_NIL;
            }
            NAS_CACHE_UNLOCK();

            send_resp_to_tel = TRUE;
        }

        if (ril_req_res != RIL_E_SUCCESS)
        {
            send_resp_to_tel = TRUE;
            resp_to_tel = RIL_E_GENERIC_FAILURE;
        }
        else
        {
            resp_to_tel = RIL_E_SUCCESS;
        }

        if (send_resp_to_tel)
        {
            qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                               qcril_req_info.t,
                                               qcril_req_info.request,
                                               resp_to_tel, &resp );
            qcril_send_request_response( &resp );
        }
    }
}

/*===========================================================================
 qcril_qmi_nas_set_initial_attach_apn
============================================================================*/
/*!
    @brief
    Processes RIL_REQUEST_SET_INITIAL_ATTACH_APN

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_set_initial_attach_apn
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
    RIL_Errno                         res       = RIL_E_GENERIC_FAILURE;
    RIL_Errno                         data_res  = RIL_E_GENERIC_FAILURE;
    RIL_Errno                         resp_to_tel;
    RIL_InitialAttachApn*             InitialAttachApnMsg;
    qcril_request_resp_params_type    resp;
    uint32                            new_timeout_watch = 0;
    int                               new_timeout_set_res;
    qcril_reqlist_public_type         qcril_req_info;
    qmi_client_error_type             qmi_error;

    nas_get_sys_info_resp_msg_v01     qmi_get_sys_info_resp_msg;

    QCRIL_LOG_FUNC_ENTRY();

    QCRIL_NOTUSED(ret_ptr);

    memset (&qmi_get_sys_info_resp_msg, 0, sizeof(qmi_get_sys_info_resp_msg));
    if(NULL != params_ptr->data && params_ptr->datalen > QMI_RIL_ZERO )
    {
        do
        {
            qcril_reqlist_default_entry( params_ptr->t,
                                         params_ptr->event_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                         QCRIL_EVT_QMI_REQUEST_INIT_ATTACH_APN,
                                         NULL,
                                         &qcril_req_info ); // this does not fail
            if (qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info ) != E_SUCCESS)
            {
                break;
            }

            InitialAttachApnMsg = (RIL_InitialAttachApn*) params_ptr->data;
            data_res = qcril_data_request_set_lte_attach_profile(InitialAttachApnMsg);

            if (RIL_E_SKIP_LTE_REATTACH == data_res)
            {
                QCRIL_LOG_INFO("APN already present. Skipping reattach");
                break;
            }
            else if (data_res != RIL_E_SUCCESS)
            {
                QCRIL_LOG_ERROR("Data RIL call for Attach APN failed with Error code %d",res);
                break;
            }

            qmi_error = qmi_client_send_msg_sync_with_shm(qcril_qmi_client_get_user_handle(QCRIL_QMI_CLIENT_NAS),
                                                 QMI_NAS_GET_SYS_INFO_REQ_MSG_V01,
                                                 NULL,
                                                 0,
                                                 (void*) &qmi_get_sys_info_resp_msg,
                                                 sizeof(qmi_get_sys_info_resp_msg),
                                                 QCRIL_QMI_SYNC_REQ_UNRESTRICTED_TIMEOUT);

            res = qcril_qmi_util_convert_qmi_response_codes_to_ril_result(qmi_error, &qmi_get_sys_info_resp_msg.resp);
            if (res != RIL_E_SUCCESS)
            {
                QCRIL_LOG_ERROR("NAS APN detach failed with error code %d",res);
                break;
            }

            if (qcril_qmi_nas_is_lte_ps_attached(qmi_get_sys_info_resp_msg.lte_sys_info_valid,
                                                 &qmi_get_sys_info_resp_msg.lte_sys_info))
            {
                qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_DETACH);
                res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_INIT_APN_ATTCH_DETACH);
                if (res != RIL_E_SUCCESS)
                {
                    QCRIL_LOG_ERROR("NAS APN detach failed with error code %d",res);
                    break;
                }
            }
            else
            {
                QCRIL_LOG_INFO("LTE is not attached yet. Skipping reattach");
                data_res = RIL_E_SKIP_LTE_REATTACH;
            }

        } while(0);

        if (res != RIL_E_SUCCESS)
        {
            if (data_res != RIL_E_SUCCESS)
            {
                if (RIL_E_SKIP_LTE_REATTACH == data_res)
                {
                    resp_to_tel = RIL_E_SUCCESS;
                }
                else
                {
                    resp_to_tel = data_res;
                }
            }
            else
            {
                resp_to_tel = RIL_E_GENERIC_FAILURE;
            }
            qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
        }
        else
        {
            resp_to_tel = RIL_E_SUCCESS;
        }
    }
    else
    {
        //GENERIC_ERROR is sufficient as returned error.
        //RADIO_NOT_AVAILABLE would be returned by
        //the framework when applicable

        resp_to_tel = RIL_E_GENERIC_FAILURE;
    }

    if (resp_to_tel || (data_res == RIL_E_SKIP_LTE_REATTACH))
    {
        qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
        qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           resp_to_tel,
                                           &resp );
        qcril_send_request_response( &resp );
    }
}

/*===========================================================================
  qcril_qmi_nas_sys_sel_pref_setup_timed_callback
============================================================================*/

int qcril_qmi_nas_sys_sel_pref_setup_timed_callback ()
{
    const struct timeval sys_sel_pref_timeout = {60 , 0};
    uint32 sys_sel_pref_tmr = 0;
    int sys_sel_pref_tmr_res = E_FAILURE, ret = E_FAILURE;

    QCRIL_LOG_FUNC_ENTRY();

    sys_sel_pref_tmr_res = qcril_setup_timed_callback( QCRIL_DEFAULT_INSTANCE_ID,
                                                     QCRIL_DEFAULT_MODEM_ID,
                                                     qcril_qmi_nas_sys_sel_pref_validity_tmr_expry_handler,
                                                     &sys_sel_pref_timeout,
                                                     &sys_sel_pref_tmr );
    if ( E_SUCCESS == sys_sel_pref_tmr_res && NAS_NIL != sys_sel_pref_tmr )
    {
        nas_cached_info.sys_sel_pref_tmr = sys_sel_pref_tmr;
        ret = E_SUCCESS;
    }

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}//qcril_qmi_nas_sys_sel_pref_setup_timed_callback

/*===========================================================================
  qcril_qmi_nas_initialize_is_indication_received
============================================================================*/
void qcril_qmi_nas_initialize_is_indication_received()
{
    NAS_CACHE_LOCK();
    nas_cached_info.is_indication_received = FALSE;
    NAS_CACHE_UNLOCK();
} //qcril_qmi_nas_initialize_is_indication_received

/*===========================================================================
  qcril_qmi_nas_check_is_indication_received
============================================================================*/
uint8 qcril_qmi_nas_check_is_indication_received()
{
    uint8 ret;
    ret = nas_cached_info.is_indication_received;
    return ret;
} //qcril_qmi_nas_check_is_indication_received

/*===========================================================================
  qcril_qmi_nas_cancel_sys_sel_pref_tmr
============================================================================*/
void qcril_qmi_nas_cancel_sys_sel_pref_tmr()
{
    qcril_reqlist_public_type             qcril_req_info;
    errno_enum_type                       found_qcril_request;
    qcril_request_resp_params_type        resp;

    QCRIL_LOG_FUNC_ENTRY();
    NAS_CACHE_LOCK();
    if( NAS_ZERO != nas_cached_info.sys_sel_pref_tmr )
    {
        found_qcril_request = qcril_reqlist_query_by_event( QCRIL_DEFAULT_INSTANCE_ID,
                                  QCRIL_DEFAULT_MODEM_ID,
                                  QCRIL_EVT_QMI_REQUEST_SET_SYS_SEL_PREF,
                                  &qcril_req_info );

        if ( ( E_SUCCESS == found_qcril_request ) && ( FALSE == nas_cached_info.is_indication_received ) )
        {
            qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                        qcril_req_info.t,
                                        qcril_req_info.request,
                                        RIL_E_GENERIC_FAILURE,
                                        &resp );

            qcril_send_request_response( &resp );
        }
        qcril_cancel_timed_callback((void *)(intptr_t)nas_cached_info.sys_sel_pref_tmr);
        nas_cached_info.sys_sel_pref_tmr = NAS_ZERO;
    }
    NAS_CACHE_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
} //qcril_qmi_nas_cancel_sys_sel_pref_tmr

/*===========================================================================
  qcril_qmi_nas_mode_pref_request_response_helper
============================================================================*/
RIL_Errno qcril_qmi_nas_mode_pref_request_response_helper(const qcril_request_params_type *const params_ptr, uint8 *is_change)
{
    RIL_Errno ril_req_res = RIL_E_SUCCESS;
    NAS_CACHE_LOCK();
    if( TRUE == qcril_qmi_nas_check_is_indication_received() )
    {
        if( is_change )
        {
            *is_change = FALSE;
        }
    }
    else
    {
        ril_req_res = qcril_qmi_nas2_create_reqlist_setup_timer_helper( params_ptr );
    }
    NAS_CACHE_UNLOCK();
    return ril_req_res;
}

/*=========================================================================
 qcril_qmi_nas_request_allow_data
============================================================================*/
/*!
    @brief
    Processes RIL_REQUEST_ALLOW_DATA

    @return
    None
*/
/*=========================================================================*/
void qcril_qmi_nas_request_allow_data
(
  const qcril_request_params_type *const params_ptr,
  qcril_request_return_type *const ret_ptr
)
{
  RIL_Errno res = RIL_E_SUCCESS;
  qcril_request_resp_params_type    resp;
  qcril_reqlist_public_type             qcril_req_info;
  int do_ps_attach;
  int send_resp_to_atel = FALSE;
  char prop_val[ QMI_RIL_SYS_PROP_LENGTH_MULTI_SIM + 1 ];

  QCRIL_LOG_FUNC_ENTRY();

  QCRIL_NOTUSED(ret_ptr);
  memset(&prop_val, 0 , sizeof(prop_val));
  property_get( QMI_RIL_SYS_PROP_NAME_MULTI_SIM, prop_val, "" );
  QCRIL_LOG_INFO ( "Multisim prop val %s", prop_val );

  if(NULL != params_ptr->data && params_ptr->datalen > QMI_RIL_ZERO )
  {
    do
    {
      qcril_reqlist_default_entry( params_ptr->t,
                                         params_ptr->event_id,
                                         QCRIL_DEFAULT_MODEM_ID,
                                         QCRIL_REQ_AWAITING_MORE_AMSS_EVENTS,
                                         QCRIL_EVT_QMI_REQUEST_ALLOW_DATA,
                                         NULL,
                                         &qcril_req_info );
      if (qcril_reqlist_new( QCRIL_DEFAULT_INSTANCE_ID, &qcril_req_info ) != E_SUCCESS)
      {
        res = RIL_E_GENERIC_FAILURE;
        break;
      }

      do_ps_attach = *((int*)params_ptr->data);

      QCRIL_LOG_INFO("allow_data %d", do_ps_attach);

      if (TRUE == do_ps_attach)
      {
        qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ATTACH);
        qcril_qmi_fetch_system_selection_preference();

        // DDS switch request
        if (qmi_ril_is_multi_sim_feature_supported() &&
              ((nas_common_info.dsds.is_default_data_set == FALSE) ||
               ((nas_common_info.dsds.is_default_data_set == TRUE ) &&
               (nas_common_info.dsds.default_data_instance_id == qmi_ril_get_process_instance_id()))))
        {
          if (qcril_qmi_nas_check_if_service_domain_has_ps())
          {
            qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
          }

          res = qcril_qmi_nas_send_data_subscription_request();
          QCRIL_LOG_ESSENTIAL("Set data subscription request sent.. res %d", res);
        }
        else if( qmi_ril_is_multi_sim_feature_supported() &&
                 (!strncmp(prop_val, "dsds", QMI_RIL_SYS_PROP_LENGTH_MULTI_SIM )) &&
                 (nas_common_info.dsds.is_default_data_set == TRUE ) &&
                 (nas_common_info.dsds.default_data_instance_id != qmi_ril_get_process_instance_id())
               )
        {
            res = qcril_qmi_nas_send_data_subscription_request();
            QCRIL_LOG_ESSENTIAL("DDS change triggered because of MMS in DSDS.. res %d", res);
        }
        // Return SUCCESS for regular PS attach or on demand ps attach request if already attached.
        else if (qcril_qmi_nas_check_if_service_domain_has_ps() &&
                 !qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_DATA))
        {
          QCRIL_LOG_ESSENTIAL("Already PS attached!");
          send_resp_to_atel = TRUE;
          res = RIL_E_SUCCESS;
        }
        else
        {
          //Data+MMS
          if (qmi_ril_is_multi_sim_feature_supported())
          {
            if (qcril_qmi_nas_is_using_rte(QMI_RIL_RTE_1x, QMI_RIL_RTE_KIND_DATA))
            {
              QCRIL_LOG_ESSENTIAL("On demand PS attach with 1x in service!");
              qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_WAIT_FOR_RAT_EXP);
              (void)qcril_qmi_nas_get_rat_disabled_mask(
                   &nas_common_info.rat_disabled_mask_during_on_demand_attach);

            }
            else
            {
              QCRIL_LOG_ESSENTIAL("On demand PS attach!");
              qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH);
            }

            res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ON_DEMAND_ATTACH);
          }
          // SS: Send PS attach request.
          else
          {
            QCRIL_LOG_ESSENTIAL("PS attach!");
            res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_ATTACH);
          }
        }
      }
      else
      {
        if ((!NAS_CACHE_IS_ENTRY_VALID(nas_cached_info.srv_domain_pref)) ||
            ( nas_cached_info.srv_domain_pref == QMI_SRV_DOMAIN_PREF_CS_ONLY_V01 ))
        {
          QCRIL_LOG_ESSENTIAL("Already PS detached!");
          send_resp_to_atel = TRUE;
          res = RIL_E_SUCCESS;
        }
        else
        {
          QCRIL_LOG_ESSENTIAL("PS detach!");
          qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_DETACH);
          res = qcril_qmi_nas_set_ps_service_domain(QMI_RIL_NAS_INIT_ALLOW_DATA_ATTCH_DETACH);
        }
      }
    } while (0);
  }
  else
  {
    res = RIL_E_GENERIC_FAILURE;
  }
  if ((res != RIL_E_SUCCESS) || (send_resp_to_atel == TRUE))
  {
    QCRIL_LOG_ESSENTIAL("PS ATTACH/DETACH resp %d", res);
    qcril_qmi_nas_set_init_attch_state(QMI_RIL_NAS_INIT_APN_ATTCH_NONE);
    qcril_default_request_resp_params( QCRIL_DEFAULT_INSTANCE_ID,
                                           params_ptr->t,
                                           params_ptr->event_id,
                                           res,
                                           &resp );
    qcril_send_request_response( &resp );
  }
}

/*===========================================================================
  qcril_qmi_nas_modem_power_ril_resumed
============================================================================*/
void qcril_qmi_nas_modem_power_ril_resumed()
{
    QCRIL_LOG_FUNC_ENTRY();
    RADIO_POWER_LOCK();
    if (nas_common_info.modem_power_info.radio_power_process_pending)
    {
        RADIO_POWER_SIGNAL();
        nas_common_info.modem_power_info.radio_power_process_pending = FALSE;
        QCRIL_LOG_INFO("Modem power signalled");
    }
    RADIO_POWER_UNLOCK();
    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================
  qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm
============================================================================*/
boolean qcril_qmi_nas_modem_power_is_mdm_shdn_in_apm()
{
    boolean ret = FALSE;
    boolean apm_mdm_not_pwdn = FALSE;
    boolean apm_sim_not_pwdn = FALSE;
    apm_mdm_not_pwdn = nas_common_info.modem_power_info.apm_mdm_not_pwdn;
    apm_sim_not_pwdn = nas_common_info.apm_sim_not_pwdn;
    if (!apm_sim_not_pwdn && !apm_mdm_not_pwdn && qcril_qmi_modem_power_is_voting_feature_supported())
        ret = TRUE;

    QCRIL_LOG_FUNC_RETURN_WITH_RET(ret);
    return ret;
}

/*===========================================================================
  qcril_qmi_nas_modem_power_load_apm_mdm_not_pwdn
============================================================================*/
void qcril_qmi_nas_modem_power_load_apm_mdm_not_pwdn()
{
    nas_common_info.modem_power_info.apm_mdm_not_pwdn = FALSE;
    qmi_ril_get_property_value_from_integer(QCRIL_APM_MDM_NOT_PWDN,
                                            &nas_common_info.modem_power_info.apm_mdm_not_pwdn,
                                            NAS_NIL);
    QCRIL_LOG_INFO ("QCRIL_APM_MDM_NOT_PWDN=%d", nas_common_info.modem_power_info.apm_mdm_not_pwdn);
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_set_is_data_enabled

===========================================================================*/
/*!
    @brief
    set if data is enabled by the user

    @return
    void
*/
/*=========================================================================*/
void qcril_qmi_nas_set_is_data_enabled
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    boolean                        is_data_enabled;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    if ((params_ptr->datalen > 0) && (params_ptr->data != NULL))
    {
        is_data_enabled = *((uint8_t *)params_ptr->data);
        QCRIL_LOG_DEBUG("is data enabled %d", is_data_enabled);
#ifndef QMI_RIL_UTF
      ril_req_res = qcril_data_set_is_data_enabled(is_data_enabled);
#endif
    }

    qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                      params_ptr->t,
                                      params_ptr->event_id,
                                      ril_req_res, &resp);
    qcril_send_request_response(&resp);
    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_set_is_data_roaming_enabled

===========================================================================*/
/*!
    @brief
    set if data roaming is enabled by the user

    @return
    void
*/
/*=========================================================================*/
void qcril_qmi_nas_set_is_data_roaming_enabled
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    boolean                        is_data_roaming_enabled;
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    if ((params_ptr->datalen > 0) && (params_ptr->data != NULL))
    {
        is_data_roaming_enabled = *((uint8_t *)params_ptr->data);
        QCRIL_LOG_DEBUG("is data roaming enabled %d", is_data_roaming_enabled);
#ifndef QMI_RIL_UTF
      ril_req_res = qcril_data_set_is_data_roaming_enabled(is_data_roaming_enabled);
#endif
    }

    qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                      params_ptr->t,
                                      params_ptr->event_id,
                                      ril_req_res, &resp);
    qcril_send_request_response(&resp);
    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

  FUNCTION:  qcril_qmi_nas_set_apn_info

===========================================================================*/
/*!
    @brief
    set apn info

    @return
    void
*/
/*=========================================================================*/
void qcril_qmi_nas_set_apn_info
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_request_resp_params_type resp;
    qcril_qmi_oem_evt_hook_set_set_apn_info_type apn_info = {0};
    RIL_Errno                      ril_req_res = RIL_E_GENERIC_FAILURE;

#define QCRIL_OEM_EVT_APN_INFO_MIN_LEN (3 * sizeof(int32))

    QCRIL_NOTUSED( ret_ptr );

    QCRIL_LOG_FUNC_ENTRY();

    do {
        if ((params_ptr->datalen > QCRIL_OEM_EVT_APN_INFO_MIN_LEN) &&
            (params_ptr->data != NULL))
        {
            /* retrieve apn type length */
            apn_info.apn_type_len = *((uint32_t *)params_ptr->data);

            /* retrieve apn type */
            apn_info.apn_type     = (((uint8_t *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len));
            if (params_ptr->datalen <
                    (QCRIL_OEM_EVT_APN_INFO_MIN_LEN + apn_info.apn_type_len))
            {
                QCRIL_LOG_DEBUG("data len and data does not match;"
                                "datalen: %d, apn_type_len: %d",
                                params_ptr->datalen, apn_info.apn_type_len);
                ril_req_res = RIL_E_GENERIC_FAILURE;
                break;
            }

            /* retrieve apn name length */
            apn_info.apn_name_len = *(uint32_t *)(((uint8_t *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len)+
                                                  apn_info.apn_type_len);

            if (params_ptr->datalen !=
                    (QCRIL_OEM_EVT_APN_INFO_MIN_LEN +
                     apn_info.apn_type_len +
                     apn_info.apn_name_len))
            {
                QCRIL_LOG_DEBUG("data len and data does not match;"
                                "datalen: %d, apn_type_len: %d, apn_name_len: %d",
                                params_ptr->datalen, apn_info.apn_type_len,
                                apn_info.apn_name_len);

                ril_req_res = RIL_E_GENERIC_FAILURE;
                break;
            }

            /* retrieve apn name */
            apn_info.apn_name     = (((uint8_t *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len)+
                                                  apn_info.apn_type_len +
                                                  sizeof(apn_info.apn_name_len));

            apn_info.is_apn_valid = *(uint32_t *)(((uint8_t *)params_ptr->data) +
                                                  sizeof(apn_info.apn_type_len)+
                                                  apn_info.apn_type_len +
                                                  sizeof(apn_info.apn_name_len)+
                                                  apn_info.apn_name_len);
#ifndef QMI_RIL_UTF
            ril_req_res = qcril_data_set_apn_info(apn_info.apn_type,
                                                  apn_info.apn_name,
                                                  apn_info.is_apn_valid);
#endif

        }
    } while(0);

    qcril_default_request_resp_params(QCRIL_DEFAULT_INSTANCE_ID,
                                      params_ptr->t,
                                      params_ptr->event_id,
                                      ril_req_res, &resp);
    qcril_send_request_response(&resp);
    QCRIL_LOG_FUNC_RETURN();
}

/*===========================================================================

    qcril_uim_process_mcc_mnc_info

============================================================================*/
/*!
    @brief
    Process mcc mnc info

    @return
    None
*/
/*=========================================================================*/
void qcril_uim_process_mcc_mnc_info
(
    const qcril_request_params_type *const params_ptr,
    qcril_request_return_type       *const ret_ptr
)
{
    qcril_mcc_mnc_info_type *uim_mcc_mnc_info = NULL;

    QCRIL_LOG_FUNC_ENTRY();

    do {
        if ((params_ptr == NULL) || (ret_ptr == NULL))
        {
            QCRIL_LOG_ERROR("%s", "Invalid input, cannot process request");
            break;
        }

        uim_mcc_mnc_info = (qcril_mcc_mnc_info_type*)params_ptr->data;
        if (uim_mcc_mnc_info == NULL)
        {
            QCRIL_LOG_ERROR("%s", "null uim_mcc_mnc_info");
            break;
        }

        if (uim_mcc_mnc_info->err_code != RIL_E_SUCCESS)
        {
            QCRIL_LOG_ERROR("%s", "uim_mcc_mnc_info error %d", uim_mcc_mnc_info->err_code);
            break;
        }

        QCRIL_LOG_DEBUG("mcc: %s, mnc: %s", uim_mcc_mnc_info->mcc,
                                            uim_mcc_mnc_info->mnc);

        qcril_qmi_nas_update_sim_mcc_mnc(TRUE,
                                         uim_mcc_mnc_info->mcc,
                                         uim_mcc_mnc_info->mnc);

        /* evaluate possibility of voice radio tech change */
        qcril_qmi_nas_initiate_voice_rte_change_propagation();


    } while (0);

    QCRIL_LOG_FUNC_RETURN();
}

RIL_Errno qcril_qmi_nas_embms_parse_mcc_mnc
(
   qcril_binary_data_type bin_data,
   qcril_binary_data_type next_bin_data,
   const char* format,
   char* res
)
{
  int is_mcc = 1;
  char pattern[QMI_RIL_EMBMS_MIN_SIB_MCC_MNC_PARSE_LEN] = "mcc[";
  int ret = 0;
  if (strstr(format, "mnc") != NULL)
  {
    is_mcc = 0;
    strcpy(pattern, "mnc[");
  }
  qcril_binary_data_type tmp = qcril_find_pattern(bin_data, pattern);
  if (qcril_is_binary_data_empty(tmp))
  {
    QCRIL_LOG_ERROR("plmn list doesn't contain any mcc or mnc");
    return RIL_E_GENERIC_FAILURE;
  }
  int i;
  int index;
  char value;
  for (i = 0; i < MCC_MNC_MAX_V01; ++i)
  {
    ret = sscanf((const char*)tmp.data, format, &index, &value);
    if (ret != 2) // two arguments
    {
      QCRIL_LOG_ERROR("cannot find %s%d]", pattern, i);
      return RIL_E_GENERIC_FAILURE;
    }

    if (i != index)
    {
      QCRIL_LOG_ERROR("%s%d] index in wrong order. Expected index %d:, actural index %d", pattern, index, i, index);
      return RIL_E_GENERIC_FAILURE;
    }

    if (!isdigit(value))
    {
      QCRIL_LOG_ERROR("%s%d] value is not digit. Received value: %c", pattern, i, value);
      return RIL_E_GENERIC_FAILURE;
    }
    res[index] = value;

    //move forward the pointer to find the next pattern
    tmp.data += strlen(pattern);
    tmp.len -= strlen(pattern);
    tmp = qcril_find_pattern(tmp, pattern);
    if (qcril_is_binary_data_empty(tmp))
    {
      return RIL_E_SUCCESS;
    }
    // If either mcc or mnc doesn't have 3 digits, we will have the mcc or mnc information for the
    // next plmn_list if it is not empty. In this case we should ignore it.
    if ((tmp.data > next_bin_data.data) && !qcril_is_binary_data_empty(next_bin_data))
    {
      return RIL_E_SUCCESS;
    }
  }
  return RIL_E_SUCCESS;
}

//===========================================================================
// qcril_qmi_nas_embms_parse_embms_plmn
//===========================================================================
RIL_Errno qcril_qmi_nas_embms_parse_embms_plmn(qcril_binary_data_type bin_data, int max_plmn_len, int *plmn_len, embms_plmn_type_v01 plmn[])
{
    RIL_Errno ret = RIL_E_GENERIC_FAILURE;
    if (!bin_data.len || !bin_data.data || !plmn_len || !plmn)
    {
        QCRIL_LOG_ERROR("Invalid bin_data or plmn");
        return ret;
    }
    /****************** bin_data format **********************
     * ...
     * plmn_IdentityList[0] {
     * plmn_Identity {
     * mcc[0] = 0
     * mcc[1] = 1
     * mcc[2] = 2
     * mnc[0] = 3
     * mnc[1] = 4
     * }
     * cellReservedForOperatorUse = notReserved
     * }
     * plmn_IdentityList[1] {
     * plmn_Identity {
     * mcc[0] = 5
     * mcc[1] = 6
     * mcc[2] = 7
     * mnc[0] = 8
     * mnc[1] = 9
     * }
     * cellReservedForOperatorUse = notReserved
     * }
     * ...
     ********************************************************/
    const char* plmn_pattern = "plmn_IdentityList[";
    *plmn_len = 0;
    int plmn_index;
    qcril_binary_data_type current_plmn_bin_data = qcril_find_pattern(bin_data, plmn_pattern);
    if (qcril_is_binary_data_empty(current_plmn_bin_data))
    {
      QCRIL_LOG_ERROR("bin_data doesn't contain any plmn");
      return ret;
    }
    while (*plmn_len < max_plmn_len)
    {
        // move forward the pointer to find the next matching pattern
        qcril_binary_data_type next_plmn_bin_data = current_plmn_bin_data;
        next_plmn_bin_data.data += strlen(plmn_pattern);
        next_plmn_bin_data.len -= strlen(plmn_pattern);
        next_plmn_bin_data = qcril_find_pattern(next_plmn_bin_data, plmn_pattern);

        int result = sscanf((const char*)current_plmn_bin_data.data, "plmn_IdentityList[%d]", &plmn_index);
        // if find a plmn_list, verify if plmnlist index == plmn_len
        if ( result == 1 && plmn_index != *plmn_len)
        {
          ret = RIL_E_GENERIC_FAILURE;
          break;
        }
        ret = qcril_qmi_nas_embms_parse_mcc_mnc(current_plmn_bin_data, next_plmn_bin_data, "mcc[%d] = %c", plmn[*plmn_len].mcc);
        if (ret != RIL_E_SUCCESS)
        {
          QCRIL_LOG_ERROR("cannot get mcc from plmn_list");
          break;
        }
        ret = qcril_qmi_nas_embms_parse_mcc_mnc(current_plmn_bin_data, next_plmn_bin_data, "mnc[%d] = %c", plmn[*plmn_len].mnc);
        if (ret != RIL_E_SUCCESS)
        {
          QCRIL_LOG_ERROR("cannot get mnc from plmn_list");
          break;
        }
        ++(*plmn_len);

        // if cannot find any more pattern, return with success
        if (qcril_is_binary_data_empty(next_plmn_bin_data))
        {
          ret = RIL_E_SUCCESS;
          break;
        }
        current_plmn_bin_data = next_plmn_bin_data;
    }
    return ret;
} // qcril_qmi_nas_embms_parse_embms_plmn
