/*===========================================================================

        I M A G E  P R O C E S S I N G   L I B R A R Y    F I L E

DESCRIPTION
  This file contains the implementation of the IPL APIs.

REFERENCES
  IPL ISOD: XX-XXXXX-XX

Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
===========================================================================*/


/*===========================================================================
                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_efx.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
 2/20/05   babakf  Added LNT team's fix for magnify glass
11/28/05   babakf  Added line pack support to ipl_convolution function
11/28/05   babakf  Use the new HSV <-> YCbCr function in hue, sat, brightness
                   function which requires 1/2 the memory.
11/21/05   babakf  Made sharpen function support multiple kernels/intensities
08/08/05   babakf  Wrote ipl_set_contrast_Nentires
07/21/05   babakf  Wrote ipl_convolution to run any kernel over image
05/18/05   babakf  Wrote rgb565 sketch effect
04/18/05   babakf  Wrote function that would subtract ys
03/22/05   babakf  added ipl_set_contrast_8bit
02/17/05   babakf  added 420 native support to fadein fadeout
01/27/05   babakf  added ipl_watercolor, ipl_image_brightness
01/25/05   babakf  added ipl_emboss, ipl_median_blur
01/17/05   babakf  Fixed bug in ipl_uniform_blur for size==1.
01/14/05   mz      Added ipl_color_change, ipl_corner_fold, and ipl_shear.
                   Added new version of ipl_radial_blur.
12/05/04   babakf  Modified ipl_set_contrast
12/04/04   babakf  Incorporated Suhail's overflow fix to sepia
11/29/04   babakf  Added bayer support to ipl_efx_adaptiveFilter
11/22/04   babakf  Added ipl_efx_adaptiveFilter
11/18/04   mz      Added ipl_pinch.
11/11/04   babakf  Added grid mesh for Y direction
11/06/04   mz      Added new support for arbitrary directional blurring in
                   ipl_motion_blur.
10/30/04   mz      Added ipl_radial_blur.
10/05/04   mz      Updated function APIs. Updated comments to reflect new
                   support for YCbCr 4:2:0 line packed format. Corrected line
                   widths and tab spacings. Removed ipl_image_merge from
                   ipl_efx.h (this belongs in ipl_attic.h). Removed
                   ipl_bad_pixel_correct from ipl_efx.h (this belongs in
                   ipl_util.h).
09/01/04   bf      Created. See ipl_util.c for previous history
===========================================================================*/


/* used for debugging purposes */
#define IPL_EFX_DEBUG 0


/* <EJECT> */
/*===========================================================================
                      INCLUDE FILES FOR MODULE
===========================================================================*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "ipl_types.h"
#include "ipl_helper.h"
#include "ipl_xform.h"
#include "ipl_util.h"
#include "ipl_convert.h"
#include "ipl_attic.h"
#include "ipl_compose.h"
#include "ipl_efx.h"

#ifdef FEATURE_IPL_FUNC_CORNER_FOLD
  #include "ipl_efx_images.h"
#endif

#include "ipl_qvp.h"

//#include "ipl_upSize.h"
//#include "ipl_downSize.h"
//#include "ipl_rotAddCrop.h"


// Turn off some lint warnings
/*lint -save -e578, dont worry about y1 shadowing math.h */
/*lint -save -e504, all shifts are okay */
/*lint -save -e506, constant value boolean is totally okay */
/*lint -save -e508, extra extern is okay */
/*lint -save -e525, dont worry about indentation right now */
/*lint -save -e539, dont worry about indentation right now */
/*lint -save -e534, let me call printf in piece, god */
/*lint -save -e524, going from double to int here is okay */
/*lint -save -e570, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e573, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e574, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e701, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e702, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e703, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e704, all shifts are okay */
/*lint -save -e713, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e715, okay that bip_ptr not used */
/*lint -save -e732, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e737, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e734, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e774, constant value boolean is totally okay */
/*lint -save -e818, lets not worry about const optimization right now */
/*lint -save -e834, this warning is just dumb */
/*lint -save -e831, repeat warning */

/*lint -save -e774, dont worry about if(0) */
/*lint -save -e506, dont worry about if(0) */


// these lint warnings should be looked at. They are supreseed temporarily
/*lint -save -e429 */
/*lint -save -e661 */
/*lint -save -e662 */
/*lint -save -e673 */
/*lint -save -e790 */
/*lint -save -e796 */
/*lint -save -e797 */
/*lint -save -e826, we should look into this someday */


/* <EJECT> */
/*===========================================================================
                            COMMON DATA
===========================================================================*/

/*
 *  If an OEM does not like the Sigmoid Gamma functions we have
 *  assigned to Contrast values 0 through 10, he can simply
 *  modify ipl_set_contrast and assign the contrast value to one of these
 *  ipl_gammaSigmoidX_Y values where X.Y is gamma.
 *
 *  If an OEM does not like any of the gamma tables here, they can
 *  create new tables via ipl_make_gamma_table foud in ipl_util.c
 *
 */




static ipl_curve_type hweights =
  {256,
  {4,4,4,4,4, 4,4,4,4,4,            /*   0 -   9 */   // +40
   4,4,4,4,4, 4,4,4,4,4,            /*  10 -  19 */   // +40
   4,4,4,4,4, 2,2,2,2,2,            /*  20 -  29 */   // +30
   2,2,2,2,2, 2,2,2,2,2,            /*  30 -  39 */   // +20
   2,2,2,2,2, 1,1,1,1,1,            /*  40 -  49 */   // +15
   1,1,1,1,1, 1,1,1,1,1,            /*  50 -  59 */   // +10
   1,1,1,1,1, 0,0,0,0,0,            /*  60 -  69 */   // +5
   0,0,0,0,0, 0,0,0,0,0,            /*  70 -  79 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /*  80 -  89 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /*  90 -  99 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 100 - 109 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 110 - 119 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 120 - 129 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 130 - 139 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 140 - 149 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 150 - 159 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 160 - 169 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 170 - 179 */   // 0
   0,0,0,0,0, 0,0,0,0,0,            /* 180 - 189 */   // 0
   -1,-1,-1,-1,-1, -1,-1,-1,-1,-1,  /* 190 - 199 */   // -10
   -1,-1,-1,-1,-1, -1,-1,-1,-1,-1,  /* 200 - 209 */   // -10
   -2,-2,-2,-2,-2, -2,-2,-2,-2,-2,  /* 210 - 219 */   // -20
   -2,-2,-2,-2,-2, -2,-2,-2,-2,-2,  /* 220 - 229 */   // -20
   -4,-4,-4,-4,-4, -4,-4,-4,-4,-4,  /* 230 - 239 */   // -40
   -4,-4,-4,-4,-4, -4,-4,-4,-4,-4,  /* 240 - 249 */   // -40
   -4,-4,-4,-4,-4  -4}};            /* 250 - 255 */   // -20
                                    // sum:              *0*
                                    //lint !e785


// ======================================
// 8 bit tables

// ======================================
// 8 bit tables
// ======================================
static const uint16 ipl_gammaSigmoid0_5[256] = {
  0,  11,  16,  20,  23,  25,  28,  30,  32,  34,
 36,  37,  39,  41,  42,  44,  45,  47,  48,  49,
 50,  52,  53,  54,  55,  56,  58,  59,  60,  61,
 62,  63,  64,  65,  66,  67,  68,  69,  70,  71,
 71,  72,  73,  74,  75,  76,  77,  77,  78,  79,
 80,  81,  81,  82,  83,  84,  84,  85,  86,  87,
 87,  88,  89,  90,  90,  91,  92,  92,  93,  94,
 94,  95,  96,  96,  97,  98,  98,  99, 100, 100,
101, 102, 102, 103, 103, 104, 105, 105, 106, 107,
107, 108, 108, 109, 109, 110, 111, 111, 112, 112,
113, 113, 114, 115, 115, 116, 116, 117, 117, 118,
118, 119, 119, 120, 121, 121, 122, 122, 123, 123,
124, 124, 125, 125, 126, 126, 127, 127, 128, 128,
129, 129, 130, 130, 131, 131, 132, 132, 133, 133,
134, 134, 135, 136, 136, 137, 137, 138, 138, 139,
139, 140, 140, 141, 142, 142, 143, 143, 144, 144,
145, 146, 146, 147, 147, 148, 148, 149, 150, 150,
151, 152, 152, 153, 153, 154, 155, 155, 156, 157,
157, 158, 159, 159, 160, 161, 161, 162, 163, 163,
164, 165, 165, 166, 167, 168, 168, 169, 170, 171,
171, 172, 173, 174, 174, 175, 176, 177, 178, 178,
179, 180, 181, 182, 183, 184, 184, 185, 186, 187,
188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
199, 200, 201, 202, 203, 205, 206, 207, 208, 210,
211, 213, 214, 216, 218, 219, 221, 223, 225, 227,
230, 232, 235, 239, 244, 255
};

static const uint16 ipl_gammaSigmoid0_6[256] = {
  0,   7,  11,  13,  16,  18,  20,  22,  24,  26,
 28,  29,  31,  32,  34,  35,  37,  38,  39,  41,
 42,  43,  44,  46,  47,  48,  49,  50,  51,  52,
 54,  55,  56,  57,  58,  59,  60,  61,  62,  63,
 64,  65,  65,  66,  67,  68,  69,  70,  71,  72,
 73,  74,  74,  75,  76,  77,  78,  79,  79,  80,
 81,  82,  83,  84,  84,  85,  86,  87,  87,  88,
 89,  90,  90,  91,  92,  93,  93,  94,  95,  96,
 96,  97,  98,  99,  99, 100, 101, 101, 102, 103,
103, 104, 105, 106, 106, 107, 108, 108, 109, 110,
110, 111, 112, 112, 113, 113, 114, 115, 115, 116,
117, 117, 118, 119, 119, 120, 120, 121, 122, 122,
123, 124, 124, 125, 125, 126, 127, 127, 128, 128,
129, 130, 130, 131, 131, 132, 133, 133, 134, 135,
135, 136, 136, 137, 138, 138, 139, 140, 140, 141,
142, 142, 143, 143, 144, 145, 145, 146, 147, 147,
148, 149, 149, 150, 151, 152, 152, 153, 154, 154,
155, 156, 156, 157, 158, 159, 159, 160, 161, 162,
162, 163, 164, 165, 165, 166, 167, 168, 168, 169,
170, 171, 171, 172, 173, 174, 175, 176, 176, 177,
178, 179, 180, 181, 181, 182, 183, 184, 185, 186,
187, 188, 189, 190, 190, 191, 192, 193, 194, 195,
196, 197, 198, 199, 200, 201, 203, 204, 205, 206,
207, 208, 209, 211, 212, 213, 214, 216, 217, 218,
220, 221, 223, 224, 226, 227, 229, 231, 233, 235,
237, 239, 242, 244, 248, 255
};

static const uint16 ipl_gammaSigmoid0_7[256] = {
  0,   4,   7,   9,  11,  13,  15,  17,  18,  20,
 21,  23,  24,  26,  27,  29,  30,  31,  32,  34,
 35,  36,  37,  38,  40,  41,  42,  43,  44,  45,
 46,  47,  48,  50,  51,  52,  53,  54,  55,  56,
 57,  58,  59,  60,  61,  62,  62,  63,  64,  65,
 66,  67,  68,  69,  70,  71,  72,  73,  73,  74,
 75,  76,  77,  78,  79,  80,  80,  81,  82,  83,
 84,  85,  85,  86,  87,  88,  89,  90,  90,  91,
 92,  93,  94,  94,  95,  96,  97,  98,  98,  99,
100, 101, 101, 102, 103, 104, 105, 105, 106, 107,
108, 108, 109, 110, 111, 111, 112, 113, 114, 114,
115, 116, 116, 117, 118, 119, 119, 120, 121, 121,
122, 123, 124, 124, 125, 126, 126, 127, 128, 129,
129, 130, 131, 131, 132, 133, 134, 134, 135, 136,
136, 137, 138, 139, 139, 140, 141, 141, 142, 143,
144, 144, 145, 146, 147, 147, 148, 149, 150, 150,
151, 152, 153, 154, 154, 155, 156, 157, 157, 158,
159, 160, 161, 161, 162, 163, 164, 165, 165, 166,
167, 168, 169, 170, 170, 171, 172, 173, 174, 175,
175, 176, 177, 178, 179, 180, 181, 182, 182, 183,
184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
193, 194, 195, 196, 197, 198, 199, 200, 201, 202,
203, 204, 205, 207, 208, 209, 210, 211, 212, 213,
214, 215, 217, 218, 219, 220, 221, 223, 224, 225,
226, 228, 229, 231, 232, 234, 235, 237, 238, 240,
242, 244, 246, 248, 251, 255
};

static const uint16 ipl_gammaSigmoid0_8[256] = {
  0,   3,   5,   6,   8,  10,  11,  13,  14,  15,
 17,  18,  19,  21,  22,  23,  24,  25,  27,  28,
 29,  30,  31,  32,  34,  35,  36,  37,  38,  39,
 40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
 50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
 70,  71,  72,  73,  73,  74,  75,  76,  77,  78,
 79,  80,  81,  82,  83,  83,  84,  85,  86,  87,
 88,  89,  90,  90,  91,  92,  93,  94,  95,  96,
 96,  97,  98,  99, 100, 101, 102, 102, 103, 104,
105, 106, 107, 107, 108, 109, 110, 111, 112, 112,
113, 114, 115, 116, 117, 117, 118, 119, 120, 121,
121, 122, 123, 124, 125, 125, 126, 127, 128, 129,
130, 130, 131, 132, 133, 134, 134, 135, 136, 137,
138, 138, 139, 140, 141, 142, 143, 143, 144, 145,
146, 147, 148, 148, 149, 150, 151, 152, 153, 153,
154, 155, 156, 157, 158, 159, 159, 160, 161, 162,
163, 164, 165, 165, 166, 167, 168, 169, 170, 171,
172, 172, 173, 174, 175, 176, 177, 178, 179, 180,
181, 182, 182, 183, 184, 185, 186, 187, 188, 189,
190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
220, 221, 223, 224, 225, 226, 227, 228, 230, 231,
232, 233, 234, 236, 237, 238, 240, 241, 242, 244,
245, 247, 249, 250, 252, 255
};

static const uint16 ipl_gammaSigmoid0_9[256] = {
  0,   2,   3,   4,   6,   7,   8,   9,  11,  12,
 13,  14,  15,  16,  17,  19,  20,  21,  22,  23,
 24,  25,  26,  27,  28,  29,  30,  32,  33,  34,
 35,  36,  37,  38,  39,  40,  41,  42,  43,  44,
 45,  46,  47,  48,  49,  50,  51,  52,  53,  54,
 55,  56,  57,  58,  59,  60,  61,  62,  63,  64,
 65,  66,  67,  68,  69,  70,  70,  71,  72,  73,
 74,  75,  76,  77,  78,  79,  80,  81,  82,  83,
 84,  85,  86,  87,  88,  89,  89,  90,  91,  92,
 93,  94,  95,  96,  97,  98,  99, 100, 101, 102,
102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
112, 113, 113, 114, 115, 116, 117, 118, 119, 120,
121, 122, 123, 123, 124, 125, 126, 127, 128, 129,
130, 131, 132, 132, 133, 134, 135, 136, 137, 138,
139, 140, 141, 142, 142, 143, 144, 145, 146, 147,
148, 149, 150, 151, 152, 153, 153, 154, 155, 156,
157, 158, 159, 160, 161, 162, 163, 164, 165, 166,
166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
176, 177, 178, 179, 180, 181, 182, 183, 184, 185,
185, 186, 187, 188, 189, 190, 191, 192, 193, 194,
195, 196, 197, 198, 199, 200, 201, 202, 203, 204,
205, 206, 207, 208, 209, 210, 211, 212, 213, 214,
215, 216, 217, 218, 219, 220, 221, 222, 223, 225,
226, 227, 228, 229, 230, 231, 232, 233, 234, 235,
236, 238, 239, 240, 241, 242, 243, 244, 246, 247,
248, 249, 251, 252, 253, 255
};


const uint16 ipl_gammaSigmoid1_0[256] = {
  0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
 10,  11,  12,  13,  14,  15,  16,  17,  18,  19,
 20,  21,  22,  23,  24,  25,  26,  27,  28,  29,
 30,  31,  32,  33,  34,  35,  36,  37,  38,  39,
 40,  41,  42,  43,  44,  45,  46,  47,  48,  49,
 50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
 60,  61,  62,  63,  64,  65,  66,  67,  68,  69,
 70,  71,  72,  73,  74,  75,  76,  77,  78,  79,
 80,  81,  82,  83,  84,  85,  86,  87,  88,  89,
 90,  91,  92,  93,  94,  95,  96,  97,  98,  99,
100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
120, 121, 122, 123, 124, 125, 126, 127, 128, 129,
130, 131, 132, 133, 134, 135, 136, 137, 138, 139,
140, 141, 142, 143, 144, 145, 146, 147, 148, 149,
150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
170, 171, 172, 173, 174, 175, 176, 177, 178, 179,
180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
190, 191, 192, 193, 194, 195, 196, 197, 198, 199,
200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
210, 211, 212, 213, 214, 215, 216, 217, 218, 219,
220, 221, 222, 223, 224, 225, 226, 227, 228, 229,
230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
240, 241, 242, 243, 244, 245, 246, 247, 248, 249,
250, 251, 252, 253, 254, 255
};


static const uint16 ipl_gammaSigmoid1_2[256] = {
  0,   0,   1,   1,   2,   3,   3,   4,   5,   5,
  6,   7,   7,   8,   9,  10,  11,  11,  12,  13,
 14,  15,  15,  16,  17,  18,  19,  20,  21,  22,
 22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
 32,  33,  34,  35,  36,  37,  38,  38,  39,  40,
 41,  42,  43,  44,  45,  46,  48,  49,  50,  51,
 52,  53,  54,  55,  56,  57,  58,  59,  60,  61,
 62,  63,  64,  65,  66,  67,  69,  70,  71,  72,
 73,  74,  75,  76,  77,  78,  79,  81,  82,  83,
 84,  85,  86,  87,  88,  90,  91,  92,  93,  94,
 95,  96,  98,  99, 100, 101, 102, 103, 104, 106,
107, 108, 109, 110, 111, 113, 114, 115, 116, 117,
119, 120, 121, 122, 123, 125, 126, 127, 128, 129,
130, 132, 133, 134, 135, 136, 138, 139, 140, 141,
142, 144, 145, 146, 147, 148, 149, 151, 152, 153,
154, 155, 156, 157, 159, 160, 161, 162, 163, 164,
165, 167, 168, 169, 170, 171, 172, 173, 174, 176,
177, 178, 179, 180, 181, 182, 183, 184, 185, 186,
188, 189, 190, 191, 192, 193, 194, 195, 196, 197,
198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
209, 210, 211, 212, 213, 214, 215, 216, 217, 217,
218, 219, 220, 221, 222, 223, 224, 225, 226, 227,
228, 229, 230, 231, 232, 233, 233, 234, 235, 236,
237, 238, 239, 240, 240, 241, 242, 243, 244, 244,
245, 246, 247, 248, 248, 249, 250, 250, 251, 252,
252, 253, 254, 254, 255, 255
};


static const uint16 ipl_gammaSigmoid1_5[256] = {
  0,   0,   0,   0,   1,   1,   1,   2,   2,   2,
  3,   3,   4,   4,   5,   5,   6,   6,   7,   7,
  8,   9,   9,  10,  10,  11,  12,  12,  13,  14,
 15,  15,  16,  17,  18,  18,  19,  20,  21,  22,
 22,  23,  24,  25,  26,  27,  28,  29,  29,  30,
 31,  32,  33,  34,  35,  36,  37,  38,  39,  40,
 41,  42,  43,  44,  45,  46,  47,  49,  50,  51,
 52,  53,  54,  55,  56,  58,  59,  60,  61,  62,
 63,  65,  66,  67,  68,  69,  71,  72,  73,  74,
 76,  77,  78,  79,  81,  82,  83,  85,  86,  87,
 89,  90,  91,  93,  94,  95,  97,  98,  99, 101,
102, 104, 105, 106, 108, 109, 111, 112, 114, 115,
116, 118, 119, 121, 122, 124, 125, 127, 128, 130,
131, 133, 134, 136, 137, 139, 140, 141, 143, 144,
146, 147, 149, 150, 151, 153, 154, 156, 157, 158,
160, 161, 162, 164, 165, 166, 168, 169, 170, 172,
173, 174, 176, 177, 178, 179, 181, 182, 183, 184,
186, 187, 188, 189, 190, 192, 193, 194, 195, 196,
197, 199, 200, 201, 202, 203, 204, 205, 206, 208,
209, 210, 211, 212, 213, 214, 215, 216, 217, 218,
219, 220, 221, 222, 223, 224, 225, 226, 226, 227,
228, 229, 230, 231, 232, 233, 233, 234, 235, 236,
237, 237, 238, 239, 240, 240, 241, 242, 243, 243,
244, 245, 245, 246, 246, 247, 248, 248, 249, 249,
250, 250, 251, 251, 252, 252, 253, 253, 253, 254,
254, 254, 255, 255, 255, 255
};


static const uint16 ipl_gammaSigmoid1_8[256] = {
  0,   0,   0,   0,   0,   0,   1,   1,   1,   1,
  1,   2,   2,   2,   2,   3,   3,   3,   4,   4,
  5,   5,   5,   6,   6,   7,   7,   8,   8,   9,
  9,  10,  11,  11,  12,  12,  13,  14,  14,  15,
 16,  17,  17,  18,  19,  20,  20,  21,  22,  23,
 24,  25,  25,  26,  27,  28,  29,  30,  31,  32,
 33,  34,  35,  36,  37,  38,  39,  40,  41,  42,
 43,  44,  46,  47,  48,  49,  50,  51,  53,  54,
 55,  56,  58,  59,  60,  61,  63,  64,  65,  67,
 68,  69,  71,  72,  74,  75,  77,  78,  79,  81,
 82,  84,  85,  87,  88,  90,  91,  93,  95,  96,
 98,  99, 101, 103, 104, 106, 108, 109, 111, 113,
114, 116, 118, 120, 121, 123, 125, 127, 128, 130,
132, 134, 135, 137, 139, 141, 142, 144, 146, 147,
149, 151, 152, 154, 156, 157, 159, 160, 162, 164,
165, 167, 168, 170, 171, 173, 174, 176, 177, 178,
180, 181, 183, 184, 186, 187, 188, 190, 191, 192,
194, 195, 196, 197, 199, 200, 201, 202, 204, 205,
206, 207, 208, 209, 211, 212, 213, 214, 215, 216,
217, 218, 219, 220, 221, 222, 223, 224, 225, 226,
227, 228, 229, 230, 230, 231, 232, 233, 234, 235,
235, 236, 237, 238, 238, 239, 240, 241, 241, 242,
243, 243, 244, 244, 245, 246, 246, 247, 247, 248,
248, 249, 249, 250, 250, 250, 251, 251, 252, 252,
252, 253, 253, 253, 253, 254, 254, 254, 254, 254,
255, 255, 255, 255, 255, 255
};


static const uint16 ipl_gammaSigmoid2_1[256] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  1,   1,   1,   1,   1,   1,   2,   2,   2,   2,
  3,   3,   3,   3,   4,   4,   5,   5,   5,   6,
  6,   7,   7,   7,   8,   8,   9,   9,  10,  11,
 11,  12,  12,  13,  14,  14,  15,  16,  16,  17,
 18,  19,  19,  20,  21,  22,  23,  24,  24,  25,
 26,  27,  28,  29,  30,  31,  32,  33,  34,  35,
 36,  37,  38,  40,  41,  42,  43,  44,  45,  47,
 48,  49,  50,  52,  53,  54,  56,  57,  59,  60,
 61,  63,  64,  66,  67,  69,  70,  72,  73,  75,
 77,  78,  80,  81,  83,  85,  87,  88,  90,  92,
 94,  95,  97,  99, 101, 103, 105, 106, 108, 110,
112, 114, 116, 118, 120, 122, 124, 126, 129, 131,
133, 135, 137, 139, 141, 143, 145, 147, 149, 150,
152, 154, 156, 158, 160, 161, 163, 165, 167, 168,
170, 172, 174, 175, 177, 178, 180, 182, 183, 185,
186, 188, 189, 191, 192, 194, 195, 196, 198, 199,
201, 202, 203, 205, 206, 207, 208, 210, 211, 212,
213, 214, 215, 217, 218, 219, 220, 221, 222, 223,
224, 225, 226, 227, 228, 229, 230, 231, 231, 232,
233, 234, 235, 236, 236, 237, 238, 239, 239, 240,
241, 241, 242, 243, 243, 244, 244, 245, 246, 246,
247, 247, 248, 248, 248, 249, 249, 250, 250, 250,
251, 251, 252, 252, 252, 252, 253, 253, 253, 253,
254, 254, 254, 254, 254, 254, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255
};


static const uint16 ipl_gammaSigmoid2_4[256] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   1,   1,   1,   1,   1,   1,   1,
  1,   2,   2,   2,   2,   3,   3,   3,   3,   4,
  4,   4,   5,   5,   5,   6,   6,   7,   7,   7,
  8,   8,   9,   9,  10,  10,  11,  12,  12,  13,
 13,  14,  15,  16,  16,  17,  18,  18,  19,  20,
 21,  22,  23,  23,  24,  25,  26,  27,  28,  29,
 30,  31,  32,  33,  35,  36,  37,  38,  39,  40,
 42,  43,  44,  46,  47,  48,  50,  51,  52,  54,
 55,  57,  58,  60,  61,  63,  65,  66,  68,  69,
 71,  73,  75,  76,  78,  80,  82,  84,  86,  88,
 89,  91,  93,  95,  97, 100, 102, 104, 106, 108,
110, 112, 115, 117, 119, 122, 124, 126, 129, 131,
133, 136, 138, 140, 143, 145, 147, 149, 151, 153,
155, 158, 160, 162, 164, 166, 167, 169, 171, 173,
175, 177, 179, 180, 182, 184, 186, 187, 189, 190,
192, 194, 195, 197, 198, 200, 201, 203, 204, 205,
207, 208, 209, 211, 212, 213, 215, 216, 217, 218,
219, 220, 222, 223, 224, 225, 226, 227, 228, 229,
230, 231, 232, 232, 233, 234, 235, 236, 237, 237,
238, 239, 239, 240, 241, 242, 242, 243, 243, 244,
245, 245, 246, 246, 247, 247, 248, 248, 248, 249,
249, 250, 250, 250, 251, 251, 251, 252, 252, 252,
252, 253, 253, 253, 253, 254, 254, 254, 254, 254,
254, 254, 254, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255
};




// The commented-out tables have been added for OEM use in case they
// do not like the contrast of the 10, non-commmented out sigmoid curves
// used to adjust contrast
#if 0
const uint16 ipl_gammaSigmoid0_1[256] = {
  0,  79,  84,  88,  90,  92,  94,  95,  97,  98,
 99, 100, 101, 101, 102, 103, 104, 104, 105, 105,
106, 106, 107, 107, 108, 108, 109, 109, 110, 110,
110, 111, 111, 111, 112, 112, 112, 113, 113, 113,
114, 114, 114, 114, 115, 115, 115, 115, 116, 116,
116, 116, 117, 117, 117, 117, 117, 118, 118, 118,
118, 118, 119, 119, 119, 119, 119, 120, 120, 120,
120, 120, 120, 121, 121, 121, 121, 121, 121, 122,
122, 122, 122, 122, 122, 122, 123, 123, 123, 123,
123, 123, 123, 124, 124, 124, 124, 124, 124, 124,
124, 125, 125, 125, 125, 125, 125, 125, 125, 126,
126, 126, 126, 126, 126, 126, 126, 126, 127, 127,
127, 127, 127, 127, 127, 127, 127, 127, 128, 128,
128, 128, 128, 128, 128, 128, 128, 128, 129, 129,
129, 129, 129, 129, 129, 129, 129, 130, 130, 130,
130, 130, 130, 130, 130, 131, 131, 131, 131, 131,
131, 131, 131, 132, 132, 132, 132, 132, 132, 132,
133, 133, 133, 133, 133, 133, 133, 134, 134, 134,
134, 134, 134, 135, 135, 135, 135, 135, 135, 136,
136, 136, 136, 136, 137, 137, 137, 137, 137, 138,
138, 138, 138, 138, 139, 139, 139, 139, 140, 140,
140, 140, 141, 141, 141, 141, 142, 142, 142, 143,
143, 143, 144, 144, 144, 145, 145, 145, 146, 146,
147, 147, 148, 148, 149, 149, 150, 150, 151, 151,
152, 153, 154, 154, 155, 156, 157, 158, 160, 161,
163, 165, 167, 171, 176, 255
};

const uint16 ipl_gammaSigmoid0_2[256] = {
  0,  48,  56,  60,  64,  67,  69,  71,  73,  75,
 77,  78,  79,  81,  82,  83,  84,  85,  86,  87,
 88,  89,  90,  91,  91,  92,  93,  93,  94,  95,
 95,  96,  97,  97,  98,  98,  99, 100, 100, 101,
101, 102, 102, 103, 103, 104, 104, 104, 105, 105,
106, 106, 107, 107, 107, 108, 108, 109, 109, 109,
110, 110, 110, 111, 111, 111, 112, 112, 112, 113,
113, 113, 114, 114, 114, 115, 115, 115, 116, 116,
116, 116, 117, 117, 117, 118, 118, 118, 118, 119,
119, 119, 119, 120, 120, 120, 120, 121, 121, 121,
121, 122, 122, 122, 122, 123, 123, 123, 123, 124,
124, 124, 124, 124, 125, 125, 125, 125, 126, 126,
126, 126, 126, 127, 127, 127, 127, 127, 128, 128,
128, 128, 128, 129, 129, 129, 129, 129, 130, 130,
130, 130, 131, 131, 131, 131, 131, 132, 132, 132,
132, 133, 133, 133, 133, 134, 134, 134, 134, 135,
135, 135, 135, 136, 136, 136, 136, 137, 137, 137,
137, 138, 138, 138, 139, 139, 139, 139, 140, 140,
140, 141, 141, 141, 142, 142, 142, 143, 143, 143,
144, 144, 144, 145, 145, 145, 146, 146, 146, 147,
147, 148, 148, 148, 149, 149, 150, 150, 151, 151,
151, 152, 152, 153, 153, 154, 154, 155, 155, 156,
157, 157, 158, 158, 159, 160, 160, 161, 162, 162,
163, 164, 164, 165, 166, 167, 168, 169, 170, 171,
172, 173, 174, 176, 177, 178, 180, 182, 184, 186,
188, 191, 195, 199, 207, 255
};

const uint16 ipl_gammaSigmoid0_3[256] = {
  0,  30,  37,  41,  45,  48,  51,  53,  56,  58,
 59,  61,  63,  64,  66,  67,  68,  70,  71,  72,
 73,  74,  75,  76,  77,  78,  79,  80,  81,  82,
 83,  83,  84,  85,  86,  87,  87,  88,  89,  89,
 90,  91,  91,  92,  93,  93,  94,  95,  95,  96,
 96,  97,  97,  98,  99,  99, 100, 100, 101, 101,
102, 102, 103, 103, 104, 104, 105, 105, 106, 106,
107, 107, 107, 108, 108, 109, 109, 110, 110, 110,
111, 111, 112, 112, 112, 113, 113, 114, 114, 114,
115, 115, 116, 116, 116, 117, 117, 117, 118, 118,
119, 119, 119, 120, 120, 120, 121, 121, 121, 122,
122, 122, 123, 123, 123, 124, 124, 124, 125, 125,
125, 126, 126, 126, 126, 127, 127, 127, 128, 128,
128, 129, 129, 129, 129, 130, 130, 130, 131, 131,
131, 132, 132, 132, 133, 133, 133, 134, 134, 134,
135, 135, 135, 136, 136, 136, 137, 137, 138, 138,
138, 139, 139, 139, 140, 140, 141, 141, 141, 142,
142, 143, 143, 143, 144, 144, 145, 145, 145, 146,
146, 147, 147, 148, 148, 148, 149, 149, 150, 150,
151, 151, 152, 152, 153, 153, 154, 154, 155, 155,
156, 156, 157, 158, 158, 159, 159, 160, 160, 161,
162, 162, 163, 164, 164, 165, 166, 166, 167, 168,
168, 169, 170, 171, 172, 172, 173, 174, 175, 176,
177, 178, 179, 180, 181, 182, 183, 184, 185, 187,
188, 189, 191, 192, 194, 196, 197, 199, 202, 204,
207, 210, 214, 218, 225, 255
};

const uint16 ipl_gammaSigmoid0_4[256] = {
  0,  18,  24,  28,  32,  35,  38,  40,  42,  44,
 46,  48,  50,  51,  53,  54,  56,  57,  58,  60,
 61,  62,  63,  64,  65,  66,  67,  69,  70,  71,
 71,  72,  73,  74,  75,  76,  77,  78,  79,  79,
 80,  81,  82,  83,  83,  84,  85,  86,  86,  87,
 88,  88,  89,  90,  90,  91,  92,  92,  93,  94,
 94,  95,  96,  96,  97,  97,  98,  99,  99, 100,
100, 101, 101, 102, 103, 103, 104, 104, 105, 105,
106, 106, 107, 107, 108, 108, 109, 109, 110, 110,
111, 111, 112, 112, 113, 113, 114, 114, 115, 115,
116, 116, 117, 117, 118, 118, 118, 119, 119, 120,
120, 121, 121, 121, 122, 122, 123, 123, 124, 124,
124, 125, 125, 126, 126, 126, 127, 127, 128, 128,
129, 129, 129, 130, 130, 131, 131, 131, 132, 132,
133, 133, 134, 134, 134, 135, 135, 136, 136, 137,
137, 137, 138, 138, 139, 139, 140, 140, 141, 141,
142, 142, 143, 143, 144, 144, 145, 145, 146, 146,
147, 147, 148, 148, 149, 149, 150, 150, 151, 151,
152, 152, 153, 154, 154, 155, 155, 156, 156, 157,
158, 158, 159, 159, 160, 161, 161, 162, 163, 163,
164, 165, 165, 166, 167, 167, 168, 169, 169, 170,
171, 172, 172, 173, 174, 175, 176, 176, 177, 178,
179, 180, 181, 182, 183, 184, 184, 185, 186, 188,
189, 190, 191, 192, 193, 194, 195, 197, 198, 199,
201, 202, 204, 205, 207, 209, 211, 213, 215, 217,
220, 223, 227, 231, 237, 255
};



const uint16 ipl_gammaSigmoid1_1[256] = {
  0,   1,   1,   2,   3,   4,   4,   5,   6,   7,
  8,   9,   9,  10,  11,  12,  13,  14,  15,  16,
 17,  18,  18,  19,  20,  21,  22,  23,  24,  25,
 26,  27,  28,  29,  30,  31,  32,  33,  34,  35,
 36,  37,  38,  39,  40,  41,  42,  43,  44,  45,
 46,  47,  48,  49,  50,  51,  52,  53,  54,  55,
 56,  57,  58,  59,  60,  61,  62,  63,  64,  65,
 66,  67,  68,  69,  70,  71,  72,  73,  74,  75,
 76,  77,  78,  80,  81,  82,  83,  84,  85,  86,
 87,  88,  89,  90,  91,  92,  93,  94,  95,  97,
 98,  99, 100, 101, 102, 103, 104, 105, 106, 107,
108, 109, 111, 112, 113, 114, 115, 116, 117, 118,
119, 120, 121, 123, 124, 125, 126, 127, 128, 129,
130, 131, 132, 134, 135, 136, 137, 138, 139, 140,
141, 142, 143, 144, 146, 147, 148, 149, 150, 151,
152, 153, 154, 155, 156, 157, 158, 160, 161, 162,
163, 164, 165, 166, 167, 168, 169, 170, 171, 172,
173, 174, 175, 177, 178, 179, 180, 181, 182, 183,
184, 185, 186, 187, 188, 189, 190, 191, 192, 193,
194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
204, 205, 206, 207, 208, 209, 210, 211, 212, 213,
214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
224, 225, 226, 227, 228, 229, 230, 231, 232, 233,
234, 235, 236, 237, 237, 238, 239, 240, 241, 242,
243, 244, 245, 246, 246, 247, 248, 249, 250, 251,
251, 252, 253, 254, 254, 255
};


const uint16 ipl_gammaSigmoid1_3[256] = {
  0,   0,   1,   1,   1,   2,   2,   3,   3,   4,
  5,   5,   6,   7,   7,   8,   9,   9,  10,  11,
 11,  12,  13,  14,  15,  15,  16,  17,  18,  19,
 19,  20,  21,  22,  23,  24,  25,  26,  26,  27,
 28,  29,  30,  31,  32,  33,  34,  35,  36,  37,
 38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
 48,  49,  50,  51,  52,  53,  54,  55,  56,  57,
 58,  60,  61,  62,  63,  64,  65,  66,  67,  68,
 70,  71,  72,  73,  74,  75,  76,  78,  79,  80,
 81,  82,  83,  85,  86,  87,  88,  89,  91,  92,
 93,  94,  95,  97,  98,  99, 100, 102, 103, 104,
105, 106, 108, 109, 110, 111, 113, 114, 115, 117,
118, 119, 120, 122, 123, 124, 126, 127, 128, 129,
131, 132, 133, 135, 136, 137, 138, 140, 141, 142,
144, 145, 146, 147, 149, 150, 151, 152, 153, 155,
156, 157, 158, 160, 161, 162, 163, 164, 166, 167,
168, 169, 170, 172, 173, 174, 175, 176, 177, 179,
180, 181, 182, 183, 184, 185, 187, 188, 189, 190,
191, 192, 193, 194, 195, 197, 198, 199, 200, 201,
202, 203, 204, 205, 206, 207, 208, 209, 210, 211,
212, 213, 214, 215, 216, 217, 218, 219, 220, 221,
222, 223, 224, 225, 226, 227, 228, 229, 229, 230,
231, 232, 233, 234, 235, 236, 236, 237, 238, 239,
240, 240, 241, 242, 243, 244, 244, 245, 246, 246,
247, 248, 248, 249, 250, 250, 251, 252, 252, 253,
253, 254, 254, 254, 255, 255
};

const uint16 ipl_gammaSigmoid1_4[256] = {
  0,   0,   0,   1,   1,   1,   2,   2,   3,   3,
  4,   4,   5,   5,   6,   6,   7,   8,   8,   9,
 10,  10,  11,  12,  12,  13,  14,  15,  15,  16,
 17,  18,  18,  19,  20,  21,  22,  23,  23,  24,
 25,  26,  27,  28,  29,  30,  31,  32,  32,  33,
 34,  35,  36,  37,  38,  39,  40,  41,  42,  43,
 44,  45,  46,  48,  49,  50,  51,  52,  53,  54,
 55,  56,  57,  58,  60,  61,  62,  63,  64,  65,
 66,  68,  69,  70,  71,  72,  73,  75,  76,  77,
 78,  80,  81,  82,  83,  84,  86,  87,  88,  89,
 91,  92,  93,  95,  96,  97,  98, 100, 101, 102,
104, 105, 106, 108, 109, 110, 112, 113, 114, 116,
117, 118, 120, 121, 123, 124, 125, 127, 128, 130,
131, 132, 134, 135, 137, 138, 139, 141, 142, 143,
145, 146, 147, 149, 150, 151, 153, 154, 155, 157,
158, 159, 160, 162, 163, 164, 166, 167, 168, 169,
171, 172, 173, 174, 175, 177, 178, 179, 180, 182,
183, 184, 185, 186, 187, 189, 190, 191, 192, 193,
194, 195, 197, 198, 199, 200, 201, 202, 203, 204,
205, 206, 207, 209, 210, 211, 212, 213, 214, 215,
216, 217, 218, 219, 220, 221, 222, 223, 223, 224,
225, 226, 227, 228, 229, 230, 231, 232, 232, 233,
234, 235, 236, 237, 237, 238, 239, 240, 240, 241,
242, 243, 243, 244, 245, 245, 246, 247, 247, 248,
249, 249, 250, 250, 251, 251, 252, 252, 253, 253,
254, 254, 254, 255, 255, 255
};


const uint16 ipl_gammaSigmoid1_6[256] = {
  0,   0,   0,   0,   1,   1,   1,   1,   2,   2,
  2,   3,   3,   3,   4,   4,   5,   5,   6,   6,
  7,   7,   8,   8,   9,   9,  10,  11,  11,  12,
 13,  13,  14,  15,  15,  16,  17,  18,  18,  19,
 20,  21,  22,  22,  23,  24,  25,  26,  27,  28,
 29,  29,  30,  31,  32,  33,  34,  35,  36,  37,
 38,  39,  40,  41,  42,  43,  44,  46,  47,  48,
 49,  50,  51,  52,  53,  55,  56,  57,  58,  59,
 60,  62,  63,  64,  65,  67,  68,  69,  70,  72,
 73,  74,  76,  77,  78,  80,  81,  82,  84,  85,
 86,  88,  89,  91,  92,  93,  95,  96,  98,  99,
101, 102, 104, 105, 107, 108, 110, 111, 113, 114,
116, 117, 119, 120, 122, 124, 125, 127, 128, 130,
131, 133, 135, 136, 138, 139, 141, 142, 144, 145,
147, 148, 150, 151, 153, 154, 156, 157, 159, 160,
162, 163, 164, 166, 167, 169, 170, 171, 173, 174,
175, 177, 178, 179, 181, 182, 183, 185, 186, 187,
188, 190, 191, 192, 193, 195, 196, 197, 198, 199,
200, 202, 203, 204, 205, 206, 207, 208, 209, 211,
212, 213, 214, 215, 216, 217, 218, 219, 220, 221,
222, 223, 224, 225, 226, 226, 227, 228, 229, 230,
231, 232, 233, 233, 234, 235, 236, 237, 237, 238,
239, 240, 240, 241, 242, 242, 243, 244, 244, 245,
246, 246, 247, 247, 248, 248, 249, 249, 250, 250,
251, 251, 252, 252, 252, 253, 253, 253, 254, 254,
254, 254, 255, 255, 255, 255
};

const uint16 ipl_gammaSigmoid1_7[256] = {
  0,   0,   0,   0,   0,   1,   1,   1,   1,   1,
  2,   2,   2,   3,   3,   3,   4,   4,   5,   5,
  5,   6,   6,   7,   7,   8,   9,   9,  10,  10,
 11,  12,  12,  13,  13,  14,  15,  16,  16,  17,
 18,  19,  19,  20,  21,  22,  23,  23,  24,  25,
 26,  27,  28,  29,  30,  31,  31,  32,  33,  34,
 35,  36,  37,  38,  40,  41,  42,  43,  44,  45,
 46,  47,  48,  49,  51,  52,  53,  54,  55,  57,
 58,  59,  60,  61,  63,  64,  65,  67,  68,  69,
 71,  72,  73,  75,  76,  77,  79,  80,  82,  83,
 84,  86,  87,  89,  90,  92,  93,  95,  96,  98,
 99, 101, 102, 104, 105, 107, 109, 110, 112, 113,
115, 117, 118, 120, 122, 123, 125, 127, 128, 130,
132, 133, 135, 137, 138, 140, 142, 143, 145, 146,
148, 150, 151, 153, 154, 156, 157, 159, 160, 162,
163, 165, 166, 168, 169, 171, 172, 173, 175, 176,
178, 179, 180, 182, 183, 184, 186, 187, 188, 190,
191, 192, 194, 195, 196, 197, 198, 200, 201, 202,
203, 204, 206, 207, 208, 209, 210, 211, 212, 213,
214, 215, 217, 218, 219, 220, 221, 222, 223, 224,
224, 225, 226, 227, 228, 229, 230, 231, 232, 232,
233, 234, 235, 236, 236, 237, 238, 239, 239, 240,
241, 242, 242, 243, 243, 244, 245, 245, 246, 246,
247, 248, 248, 249, 249, 250, 250, 250, 251, 251,
252, 252, 252, 253, 253, 253, 254, 254, 254, 254,
254, 255, 255, 255, 255, 255
};

const uint16 ipl_gammaSigmoid1_9[256] = {
  0,   0,   0,   0,   0,   0,   0,   1,   1,   1,
  1,   1,   1,   2,   2,   2,   2,   3,   3,   3,
  4,   4,   5,   5,   5,   6,   6,   7,   7,   8,
  8,   9,   9,  10,  10,  11,  12,  12,  13,  13,
 14,  15,  15,  16,  17,  18,  18,  19,  20,  21,
 22,  22,  23,  24,  25,  26,  27,  28,  29,  29,
 30,  31,  32,  33,  34,  35,  36,  38,  39,  40,
 41,  42,  43,  44,  45,  47,  48,  49,  50,  51,
 53,  54,  55,  56,  58,  59,  60,  62,  63,  64,
 66,  67,  69,  70,  71,  73,  74,  76,  77,  79,
 80,  82,  83,  85,  87,  88,  90,  91,  93,  95,
 96,  98, 100, 101, 103, 105, 107, 108, 110, 112,
114, 115, 117, 119, 121, 123, 125, 127, 128, 130,
132, 134, 136, 138, 140, 141, 143, 145, 147, 148,
150, 152, 154, 155, 157, 159, 160, 162, 164, 165,
167, 168, 170, 172, 173, 175, 176, 178, 179, 181,
182, 184, 185, 186, 188, 189, 191, 192, 193, 195,
196, 197, 199, 200, 201, 202, 204, 205, 206, 207,
208, 210, 211, 212, 213, 214, 215, 216, 217, 219,
220, 221, 222, 223, 224, 225, 226, 226, 227, 228,
229, 230, 231, 232, 233, 233, 234, 235, 236, 237,
237, 238, 239, 240, 240, 241, 242, 242, 243, 243,
244, 245, 245, 246, 246, 247, 247, 248, 248, 249,
249, 250, 250, 250, 251, 251, 252, 252, 252, 253,
253, 253, 253, 254, 254, 254, 254, 254, 254, 255,
255, 255, 255, 255, 255, 255
};

const uint16 ipl_gammaSigmoid2_0[256] = {
  0,   0,   0,   0,   0,   0,   0,   0,   1,   1,
  1,   1,   1,   1,   2,   2,   2,   2,   3,   3,
  3,   3,   4,   4,   5,   5,   5,   6,   6,   7,
  7,   8,   8,   9,   9,  10,  10,  11,  11,  12,
 13,  13,  14,  15,  15,  16,  17,  17,  18,  19,
 20,  20,  21,  22,  23,  24,  25,  25,  26,  27,
 28,  29,  30,  31,  32,  33,  34,  35,  36,  37,
 38,  40,  41,  42,  43,  44,  45,  47,  48,  49,
 50,  51,  53,  54,  55,  57,  58,  59,  61,  62,
 64,  65,  66,  68,  69,  71,  72,  74,  75,  77,
 78,  80,  82,  83,  85,  86,  88,  90,  91,  93,
 95,  97,  98, 100, 102, 104, 106, 107, 109, 111,
113, 115, 117, 119, 121, 123, 125, 127, 129, 130,
132, 134, 136, 138, 140, 142, 144, 146, 148, 149,
151, 153, 155, 157, 158, 160, 162, 164, 165, 167,
169, 170, 172, 173, 175, 177, 178, 180, 181, 183,
184, 186, 187, 189, 190, 191, 193, 194, 196, 197,
198, 200, 201, 202, 204, 205, 206, 207, 208, 210,
211, 212, 213, 214, 215, 217, 218, 219, 220, 221,
222, 223, 224, 225, 226, 227, 228, 229, 230, 230,
231, 232, 233, 234, 235, 235, 236, 237, 238, 238,
239, 240, 240, 241, 242, 242, 243, 244, 244, 245,
245, 246, 246, 247, 247, 248, 248, 249, 249, 250,
250, 250, 251, 251, 252, 252, 252, 252, 253, 253,
253, 253, 254, 254, 254, 254, 254, 254, 255, 255,
255, 255, 255, 255, 255, 255
};



const uint16 ipl_gammaSigmoid2_2[256] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   1,   1,   1,   1,   1,   1,   2,   2,   2,
  2,   2,   3,   3,   3,   4,   4,   4,   5,   5,
  5,   6,   6,   7,   7,   7,   8,   8,   9,   9,
 10,  11,  11,  12,  12,  13,  14,  14,  15,  16,
 16,  17,  18,  18,  19,  20,  21,  22,  23,  23,
 24,  25,  26,  27,  28,  29,  30,  31,  32,  33,
 34,  35,  36,  37,  39,  40,  41,  42,  43,  44,
 46,  47,  48,  50,  51,  52,  54,  55,  56,  58,
 59,  61,  62,  64,  65,  67,  68,  70,  71,  73,
 75,  76,  78,  80,  81,  83,  85,  87,  88,  90,
 92,  94,  96,  98, 100, 102, 104, 106, 108, 110,
112, 114, 116, 118, 120, 122, 124, 126, 129, 131,
133, 135, 137, 139, 141, 143, 145, 147, 149, 151,
153, 155, 157, 159, 161, 163, 165, 167, 168, 170,
172, 174, 175, 177, 179, 180, 182, 184, 185, 187,
188, 190, 191, 193, 194, 196, 197, 199, 200, 201,
203, 204, 205, 207, 208, 209, 211, 212, 213, 214,
215, 216, 218, 219, 220, 221, 222, 223, 224, 225,
226, 227, 228, 229, 230, 231, 232, 232, 233, 234,
235, 236, 237, 237, 238, 239, 239, 240, 241, 241,
242, 243, 243, 244, 244, 245, 246, 246, 247, 247,
248, 248, 248, 249, 249, 250, 250, 250, 251, 251,
251, 252, 252, 252, 253, 253, 253, 253, 253, 254,
254, 254, 254, 254, 254, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255
};

const uint16 ipl_gammaSigmoid2_3[256] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   1,   1,   1,   1,   1,   1,   1,   2,
  2,   2,   2,   2,   3,   3,   3,   4,   4,   4,
  5,   5,   5,   6,   6,   7,   7,   7,   8,   8,
  9,   9,  10,  10,  11,  12,  12,  13,  13,  14,
 15,  15,  16,  17,  18,  18,  19,  20,  21,  22,
 23,  23,  24,  25,  26,  27,  28,  29,  30,  31,
 32,  33,  34,  35,  36,  38,  39,  40,  41,  42,
 44,  45,  46,  48,  49,  50,  52,  53,  54,  56,
 57,  59,  60,  62,  63,  65,  66,  68,  70,  71,
 73,  75,  76,  78,  80,  82,  83,  85,  87,  89,
 91,  93,  95,  97,  99, 101, 103, 105, 107, 109,
111, 113, 115, 117, 120, 122, 124, 126, 129, 131,
133, 135, 138, 140, 142, 144, 146, 148, 150, 152,
154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
173, 175, 177, 179, 180, 182, 184, 185, 187, 189,
190, 192, 193, 195, 196, 198, 199, 201, 202, 203,
205, 206, 207, 209, 210, 211, 213, 214, 215, 216,
217, 219, 220, 221, 222, 223, 224, 225, 226, 227,
228, 229, 230, 231, 232, 232, 233, 234, 235, 236,
237, 237, 238, 239, 240, 240, 241, 242, 242, 243,
243, 244, 245, 245, 246, 246, 247, 247, 248, 248,
248, 249, 249, 250, 250, 250, 251, 251, 251, 252,
252, 252, 253, 253, 253, 253, 253, 254, 254, 254,
254, 254, 254, 254, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255
};

const uint16 ipl_gammaSigmoid2_5[256] = {
  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
  0,   0,   0,   0,   1,   1,   1,   1,   1,   1,
  1,   1,   2,   2,   2,   2,   2,   3,   3,   3,
  3,   4,   4,   4,   5,   5,   5,   6,   6,   7,
  7,   7,   8,   8,   9,   9,  10,  11,  11,  12,
 12,  13,  14,  14,  15,  16,  16,  17,  18,  19,
 19,  20,  21,  22,  23,  24,  25,  26,  26,  27,
 28,  30,  31,  32,  33,  34,  35,  36,  37,  39,
 40,  41,  42,  44,  45,  46,  48,  49,  50,  52,
 53,  55,  56,  58,  60,  61,  63,  64,  66,  68,
 69,  71,  73,  75,  77,  78,  80,  82,  84,  86,
 88,  90,  92,  94,  96,  99, 101, 103, 105, 107,
110, 112, 114, 117, 119, 121, 124, 126, 129, 131,
134, 136, 138, 141, 143, 145, 148, 150, 152, 154,
156, 159, 161, 163, 165, 167, 169, 171, 173, 175,
177, 178, 180, 182, 184, 186, 187, 189, 191, 192,
194, 195, 197, 199, 200, 202, 203, 205, 206, 207,
209, 210, 211, 213, 214, 215, 216, 218, 219, 220,
221, 222, 223, 224, 225, 227, 228, 229, 229, 230,
231, 232, 233, 234, 235, 236, 236, 237, 238, 239,
239, 240, 241, 241, 242, 243, 243, 244, 244, 245,
246, 246, 247, 247, 248, 248, 248, 249, 249, 250,
250, 250, 251, 251, 251, 252, 252, 252, 252, 253,
253, 253, 253, 253, 254, 254, 254, 254, 254, 254,
254, 254, 255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255
};
#endif


static int32 hp_filter1[3][3] = {{0,-1,0},  {-1,5,-1},{0,-1,0}};
static int32 hp_filter2[3][3] = {{-1,-1,-1},{-1,9,-1},{-1,-1,-1}};
static int32 hp_filter3[3][3] = {{-1,-2,-1},{-2,13,-2},{-1,-2,-1}};
static int32 hp_filter4[3][3] = {{-2,-2,-2},{-2,17,-2},{-2,-2,-2}};
static int32 hp_filter5[3][3] = {{-2,-3,-2},{-3,21,-3},{-2,-3,-2}};
static int32 hp_filter6[3][3] = {{-3,-3,-3},{-3,25,-3},{-3,-3,-3}};
static int32 * hp_filter;



/*--------------------------------------------------------------------------
 * lookup table which simplifies the conversion from YCBR to RGB565
 * these tables store computationally intensive intermediate
 * functions. Look at ipl_init_lookup_tables for more .
 * Selection of these smaller tables and co-locating them
 * is to aid better cache performance.
 *--------------------------------------------------------------------------*/
//extern int16 ipl2_CrToRTable[];
//extern int16 ipl2_CrToGTable[];
//extern int16 ipl2_CbToGTable[];
//extern int16 ipl2_CbToBTable[];




/*===========================================================================
  **
  **   FUNCTION cliph
  **
  **   DESCRIPTION
  **     This function clips inputs between 0 and 360. The clipped value is
  **     stored in param 'in'.
  **
  **   DEPENDENCIES
  **     None
  **
  **   ARGUMENTS IN/OUT
  **     in         input number
  **
  **   RETURN VALUE
  **     None
  **
  **   SIDE EFFECTS
  **     None
  **
===========================================================================*/
__inline void cliph(int16* in)
{
  if (*in<0) //lint !e613
  {
    *in=0; //lint !e613
  }
  else if (*in > 360) //lint !e613
  {
    *in = 360; //lint !e613
  }
  return;
}



/*===========================================================================
                        FUNCTION DECLARATIONS
===========================================================================*/



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_color_change_rgb565

DESCRIPTION
  This function changes the color scheme of an image. There are 5
  color-change options, each producing a different change in the
  color scheme. The options are number from 0 through 4.

  Both inputs and output must be RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    points to the first input image
  out_img_ptr   points to the output image
  option        color change option

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_color_change_rgb565
(
  ipl_image_type* in_img_ptr,       /* Points to the first input image  */
  ipl_image_type* out_img_ptr,      /* Points to the output image       */
  uint8 option                      /* Color change option              */
)
{
  uint16 *inImgPtr, *outImgPtr;
  uint32 x;
  uint16 out;

  MSG_LOW("ipl_color_change_rgb565 marker_0\n");

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_color_change_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = (uint16*)in_img_ptr->imgPtr;
  outImgPtr = (uint16*)out_img_ptr->imgPtr;

  MSG_LOW("ipl_color_change_rgb565 marker_1\n");

  /* Loop through input image */
  if (option == 0) {
    /* RBG */
    for (x = out_img_ptr->dx*out_img_ptr->dy; x; x--) {
      out = *inImgPtr++;
      *outImgPtr++ = pack_rgb565(((out & 0xF800)>>8),
                                 ((out & 0x001F)<<3),
                                 ((out & 0x07E0)>>3));
    } /* end x loop */
  } else if (option == 1) {
    /* BGR */
    for (x = out_img_ptr->dx*out_img_ptr->dy; x; x--) {
      out = *inImgPtr++;
      *outImgPtr++ = pack_rgb565(((out & 0x001F)<<3),
                                 ((out & 0x07E0)>>3),
                                 ((out & 0xF800)>>8));
    } /* end x loop */
  } else if (option == 2) {
    /* BRG */
    for (x = out_img_ptr->dx*out_img_ptr->dy; x; x--) {
      out = *inImgPtr++;
      *outImgPtr++ = pack_rgb565(((out & 0x001F)<<3),
                                 ((out & 0xF800)>>8),
                                 ((out & 0x07E0)>>3));
    } /* end x loop */
  } else if (option == 3) {
    /* GRB */
    for (x = out_img_ptr->dx*out_img_ptr->dy; x; x--) {
      out = *inImgPtr++;
      *outImgPtr++ = pack_rgb565(((out & 0x07E0)>>3),
                                 ((out & 0xF800)>>8),
                                 ((out & 0x001F)<<3));
    } /* end x loop */
  } else {
    /* GBR */
    for (x = out_img_ptr->dx*out_img_ptr->dy; x; x--) {
      out = *inImgPtr++;
      *outImgPtr++ = pack_rgb565(((out & 0x07E0)>>3),
                                 ((out & 0x001F)<<3),
                                 ((out & 0xF800)>>8));
    } /* end x loop */
  } /* end if */

  MSG_LOW("ipl_color_change_rgb565 marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_color_change_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_color_change_ycbcr

DESCRIPTION
  This function changes the color scheme of an image. There are 5
  color-change options, each producing a different change in the
  color scheme. The options are number from 0 through 4.

  Both inputs and output must be YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    points to the first input image
  out_img_ptr   points to the output image
  option        color change option

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_color_change_ycbcr
(
  ipl_image_type* in_img_ptr,       /* Points to the first input image  */
  ipl_image_type* out_img_ptr,      /* Points to the output image       */
  uint8 option                      /* Color change option              */
)
{
  unsigned char *inImgPtr, *outImgPtr;
  uint32 x;
  int32 cbout, crout, y1out, y2out;
  long rc, gc, bc, r, g, b;
  unsigned char cb, cr, y1, y2, rout, gout, bout;
  /*
  ** YCbCr to RGB conversion array in Q14 Signed. In Q0, the coeffcients are
  ** 4.8828e-4, 1.57489, -0.18744, -0.46826, 1.8554, 7.3242e-4.
  */
  int ycbcr2rgb[6] = {8, 25803, -3071, -7672, 30399, 12};
  /*
  ** RGB to YCbCr conversion array in Q14 Signed. In Q0, the coefficients are
  ** .257, .504, .098, -.148, -.291, .439, .439, -.368, -.071.
  */
  int rgb2ycbcr[9] = {4210,8257,1605,-2424,-4767,7192,7192,-6029,-1163};


  MSG_LOW("ipl_color_change_ycbcr marker_0\n");

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_color_change_ycbcr marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = in_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;

  MSG_LOW("ipl_color_change_ycbcr marker_1\n");

  /* Loop through input image */
  if (option == 0) {
    for (x = (out_img_ptr->dx*out_img_ptr->dy)>>1; x; x--) {
      /* Process 2 pixels at a time */
      cb = *inImgPtr++;
      y1 = *inImgPtr++;
      cr = *inImgPtr++;
      y2 = *inImgPtr++;
      /* Convert YCbCr to RGB */
      rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
      gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
      bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

      /* Pixel 1 */
      r = y1 + (rc>>16);
      g = y1 + (gc>>16);
      b = y1 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)r;
      gout = (unsigned char)b;
      bout = (unsigned char)g;
      /* Convert back to YCbCr */
      y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y1out = (y1out>>16) + 16;
      if (y1out < 0) y1out = 0;
      y1out = (unsigned char)y1out;
      cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
        +0x8000;
      cbout = (cbout>>16) + 128;
      if (cbout < 0) cbout = 0;
      cbout = (unsigned char)cbout;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)cbout;
      *outImgPtr++ = (unsigned char)y1out;

      /* Pixel 2 */
      r = y2 + (rc>>16);
      g = y2 + (gc>>16);
      b = y2 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)r;
      gout = (unsigned char)b;
      bout = (unsigned char)g;
      /* Convert back to YCbCr */
      y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y2out = (y2out>>16) + 16;
      if (y2out < 0) y2out = 0;
      crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
        +0x8000;
      crout = (crout>>16) + 128;
      if (crout < 0) crout = 0;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)crout;
      *outImgPtr++ = (unsigned char)y2out;
    } /* end x loop */
  } else if (option == 1) {
    for (x = (out_img_ptr->dx*out_img_ptr->dy)>>1; x; x--) {
      /* Process 2 pixels at a time */
      cb = *inImgPtr++;
      y1 = *inImgPtr++;
      cr = *inImgPtr++;
      y2 = *inImgPtr++;
      /* Convert YCbCr to RGB */
      rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
      gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
      bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

      /* Pixel 1 */
      r = y1 + (rc>>16);
      g = y1 + (gc>>16);
      b = y1 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)b;
      gout = (unsigned char)g;
      bout = (unsigned char)r;
      /* Convert back to YCbCr */
      y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y1out = (y1out>>16) + 16;
      if (y1out < 0) y1out = 0;
      y1out = (unsigned char)y1out;
      cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
        +0x8000;
      cbout = (cbout>>16) + 128;
      if (cbout < 0) cbout = 0;
      cbout = (unsigned char)cbout;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)cbout;
      *outImgPtr++ = (unsigned char)y1out;

      /* Pixel 2 */
      r = y2 + (rc>>16);
      g = y2 + (gc>>16);
      b = y2 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)b;
      gout = (unsigned char)g;
      bout = (unsigned char)r;
      /* Convert back to YCbCr */
      y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y2out = (y2out>>16) + 16;
      if (y2out < 0) y2out = 0;
      crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
        +0x8000;
      crout = (crout>>16) + 128;
      if (crout < 0) crout = 0;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)crout;
      *outImgPtr++ = (unsigned char)y2out;
    } /* end x loop */
  } else if (option == 2) {
    for (x = (out_img_ptr->dx*out_img_ptr->dy)>>1; x; x--) {
      /* Process 2 pixels at a time */
      cb = *inImgPtr++;
      y1 = *inImgPtr++;
      cr = *inImgPtr++;
      y2 = *inImgPtr++;
      /* Convert YCbCr to RGB */
      rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
      gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
      bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

      /* Pixel 1 */
      r = y1 + (rc>>16);
      g = y1 + (gc>>16);
      b = y1 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)b;
      gout = (unsigned char)r;
      bout = (unsigned char)g;
      /* Convert back to YCbCr */
      y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y1out = (y1out>>16) + 16;
      if (y1out < 0) y1out = 0;
      y1out = (unsigned char)y1out;
      cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
        +0x8000;
      cbout = (cbout>>16) + 128;
      if (cbout < 0) cbout = 0;
      cbout = (unsigned char)cbout;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)cbout;
      *outImgPtr++ = (unsigned char)y1out;

      /* Pixel 2 */
      r = y2 + (rc>>16);
      g = y2 + (gc>>16);
      b = y2 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)b;
      gout = (unsigned char)r;
      bout = (unsigned char)g;
      /* Convert back to YCbCr */
      y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y2out = (y2out>>16) + 16;
      if (y2out < 0) y2out = 0;
      crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
        +0x8000;
      crout = (crout>>16) + 128;
      if (crout < 0) crout = 0;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)crout;
      *outImgPtr++ = (unsigned char)y2out;
    } /* end x loop */
  } else if (option == 3) {
    for (x = (out_img_ptr->dx*out_img_ptr->dy)>>1; x; x--) {
      /* Process 2 pixels at a time */
      cb = *inImgPtr++;
      y1 = *inImgPtr++;
      cr = *inImgPtr++;
      y2 = *inImgPtr++;
      /* Convert YCbCr to RGB */
      rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
      gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
      bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

      /* Pixel 1 */
      r = y1 + (rc>>16);
      g = y1 + (gc>>16);
      b = y1 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)g;
      gout = (unsigned char)r;
      bout = (unsigned char)b;
      /* Convert back to YCbCr */
      y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y1out = (y1out>>16) + 16;
      if (y1out < 0) y1out = 0;
      y1out = (unsigned char)y1out;
      cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
        +0x8000;
      cbout = (cbout>>16) + 128;
      if (cbout < 0) cbout = 0;
      cbout = (unsigned char)cbout;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)cbout;
      *outImgPtr++ = (unsigned char)y1out;

      /* Pixel 2 */
      r = y2 + (rc>>16);
      g = y2 + (gc>>16);
      b = y2 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)g;
      gout = (unsigned char)r;
      bout = (unsigned char)b;
      /* Convert back to YCbCr */
      y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y2out = (y2out>>16) + 16;
      if (y2out < 0) y2out = 0;
      crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
        +0x8000;
      crout = (crout>>16) + 128;
      if (crout < 0) crout = 0;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)crout;
      *outImgPtr++ = (unsigned char)y2out;
    } /* end x loop */
  } else {
    for (x = (out_img_ptr->dx*out_img_ptr->dy)>>1; x; x--) {
      /* Process 2 pixels at a time */
      cb = *inImgPtr++;
      y1 = *inImgPtr++;
      cr = *inImgPtr++;
      y2 = *inImgPtr++;
      /* Convert YCbCr to RGB */
      rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
      gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
      bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

      /* Pixel 1 */
      r = y1 + (rc>>16);
      g = y1 + (gc>>16);
      b = y1 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)g;
      gout = (unsigned char)b;
      bout = (unsigned char)r;
      /* Convert back to YCbCr */
      y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y1out = (y1out>>16) + 16;
      if (y1out < 0) y1out = 0;
      y1out = (unsigned char)y1out;
      cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
        +0x8000;
      cbout = (cbout>>16) + 128;
      if (cbout < 0) cbout = 0;
      cbout = (unsigned char)cbout;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)cbout;
      *outImgPtr++ = (unsigned char)y1out;

      /* Pixel 2 */
      r = y2 + (rc>>16);
      g = y2 + (gc>>16);
      b = y2 + (bc>>16);
      if (r < 0) r = 0;
      if (g < 0) g = 0;
      if (b < 0) b = 0;
      rout = (unsigned char)g;
      gout = (unsigned char)b;
      bout = (unsigned char)r;
      /* Convert back to YCbCr */
      y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
        +0x8000;
      y2out = (y2out>>16) + 16;
      if (y2out < 0) y2out = 0;
      crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
        +0x8000;
      crout = (crout>>16) + 128;
      if (crout < 0) crout = 0;
      /* Assign output value */
      *outImgPtr++ = (unsigned char)crout;
      *outImgPtr++ = (unsigned char)y2out;
    } /* end x loop */
  } /* end if */

  MSG_LOW("ipl_color_change_ycbcr marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_color_change_ycbcr */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_color_change_ycbcr420lp

DESCRIPTION
  This function changes the color scheme of an image. There are 5
  color-change options, each producing a different change in the
  color scheme. The options are number from 0 through 4.

  Both inputs and output must be in YCbCr 4:2:0 line packed format.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    points to the first input image
  out_img_ptr   points to the output image
  option        color change option

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_color_change_ycbcr420lp
(
  ipl_image_type* in_img_ptr,       /* Points to the first input image  */
  ipl_image_type* out_img_ptr,      /* Points to the output image       */
  uint8 option                      /* Color change option              */
)
{
  unsigned char *inImgPtr, *outImgPtr, *inClrPtr, *outClrPtr,
                *in2ImgPtr, *out2ImgPtr;
  uint32 w, w2, x, y;
  int32 cbout, crout, y1out, y2out;
  long rc, gc, bc, r, g, b;
  unsigned char cb, cr, y1, y2, rout, gout, bout;
  /*
  ** YCbCr to RGB conversion array in Q14 Signed. In Q0, the coeffcients are
  ** 4.8828e-4, 1.57489, -0.18744, -0.46826, 1.8554, 7.3242e-4.
  */
  int ycbcr2rgb[6] = {8, 25803, -3071, -7672, 30399, 12};
  /*
  ** RGB to YCbCr conversion array in Q14 Signed. In Q0, the coefficients are
  ** .257, .504, .098, -.148, -.291, .439, .439, -.368, -.071.
  */
  int rgb2ycbcr[9] = {4210,8257,1605,-2424,-4767,7192,7192,-6029,-1163};

  MSG_LOW("ipl_color_change_ycbcr420lp marker_0\n");

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_color_change_ycbcr420lp marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = in_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;
  inClrPtr = in_img_ptr->clrPtr;
  outClrPtr = out_img_ptr->clrPtr;
  w = out_img_ptr->dx;
  w2 = w>>1;
  in2ImgPtr = inImgPtr + w;
  out2ImgPtr = outImgPtr + w;

  MSG_LOW("ipl_color_change_ycbcr420lp marker_1\n");

  /* Loop through input image */
  if (option == 0) {
    for (y = out_img_ptr->dy>>1; y; y--) {
      for (x = w2; x; x--) {
        /* Process 4 pixels at a time */
        /* Chroma values */
        cb = *inClrPtr++;
        cr = *inClrPtr++;
        /* Convert to RGB */
        rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
        gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
        bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

        /* Pixels 1 and 2 */
        y1 = *inImgPtr++;
        y2 = *inImgPtr++;

        /* Pixel 1 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)r;
        gout = (unsigned char)b;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
          +0x8000;
        cbout = (cbout>>16) + 128;
        if (cbout < 0) cbout = 0;
        cbout = (unsigned char)cbout;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)cbout;
        *outImgPtr++ = (unsigned char)y1out;

        /* Pixel 2 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)r;
        gout = (unsigned char)b;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
          +0x8000;
        crout = (crout>>16) + 128;
        if (crout < 0) crout = 0;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)crout;
        *outImgPtr++ = (unsigned char)y2out;

        /* Pixels 3 and 4 */
        y1 = *in2ImgPtr++;
        y2 = *in2ImgPtr++;

        /* Pixel 3 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)r;
        gout = (unsigned char)b;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y1out;

        /* Pixel 4 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)r;
        gout = (unsigned char)b;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y2out;
      } /* end x loop */
      inImgPtr += w;
      in2ImgPtr += w;
      outImgPtr += w;
      out2ImgPtr += w;
    } /* end y loop */
  } else if (option == 1) {
    for (y = out_img_ptr->dy>>1; y; y--) {
      for (x = w2; x; x--) {
        /* Process 4 pixels at a time */
        /* Chroma values */
        cb = *inClrPtr++;
        cr = *inClrPtr++;
        /* Convert to RGB */
        rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
        gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
        bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

        /* Pixels 1 and 2 */
        y1 = *inImgPtr++;
        y2 = *inImgPtr++;

        /* Pixel 1 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)g;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
          +0x8000;
        cbout = (cbout>>16) + 128;
        if (cbout < 0) cbout = 0;
        cbout = (unsigned char)cbout;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)cbout;
        *outImgPtr++ = (unsigned char)y1out;

        /* Pixel 2 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)g;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
          +0x8000;
        crout = (crout>>16) + 128;
        if (crout < 0) crout = 0;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)crout;
        *outImgPtr++ = (unsigned char)y2out;

        /* Pixels 3 and 4 */
        y1 = *in2ImgPtr++;
        y2 = *in2ImgPtr++;

        /* Pixel 3 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)g;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y1out;

        /* Pixel 4 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)g;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y2out;
      } /* end x loop */
      inImgPtr += w;
      in2ImgPtr += w;
      outImgPtr += w;
      out2ImgPtr += w;
    } /* end y loop */
  } else if (option == 2) {
    for (y = out_img_ptr->dy>>1; y; y--) {
      for (x = w2; x; x--) {
        /* Process 4 pixels at a time */
        /* Chroma values */
        cb = *inClrPtr++;
        cr = *inClrPtr++;
        /* Convert to RGB */
        rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
        gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
        bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

        /* Pixels 1 and 2 */
        y1 = *inImgPtr++;
        y2 = *inImgPtr++;

        /* Pixel 1 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)r;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
          +0x8000;
        cbout = (cbout>>16) + 128;
        if (cbout < 0) cbout = 0;
        cbout = (unsigned char)cbout;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)cbout;
        *outImgPtr++ = (unsigned char)y1out;

        /* Pixel 2 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)r;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
          +0x8000;
        crout = (crout>>16) + 128;
        if (crout < 0) crout = 0;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)crout;
        *outImgPtr++ = (unsigned char)y2out;

        /* Pixels 3 and 4 */
        y1 = *in2ImgPtr++;
        y2 = *in2ImgPtr++;

        /* Pixel 3 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)r;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y1out;

        /* Pixel 4 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)b;
        gout = (unsigned char)r;
        bout = (unsigned char)g;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y2out;
      } /* end x loop */
      inImgPtr += w;
      in2ImgPtr += w;
      outImgPtr += w;
      out2ImgPtr += w;
    } /* end y loop */
  } else if (option == 3) {
    for (y = out_img_ptr->dy>>1; y; y--) {
      for (x = w2; x; x--) {
        /* Process 4 pixels at a time */
        /* Chroma values */
        cb = *inClrPtr++;
        cr = *inClrPtr++;
        /* Convert to RGB */
        rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
        gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
        bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

        /* Pixels 1 and 2 */
        y1 = *inImgPtr++;
        y2 = *inImgPtr++;

        /* Pixel 1 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)r;
        bout = (unsigned char)b;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
          +0x8000;
        cbout = (cbout>>16) + 128;
        if (cbout < 0) cbout = 0;
        cbout = (unsigned char)cbout;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)cbout;
        *outImgPtr++ = (unsigned char)y1out;

        /* Pixel 2 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)r;
        bout = (unsigned char)b;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
          +0x8000;
        crout = (crout>>16) + 128;
        if (crout < 0) crout = 0;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)crout;
        *outImgPtr++ = (unsigned char)y2out;

        /* Pixels 3 and 4 */
        y1 = *in2ImgPtr++;
        y2 = *in2ImgPtr++;

        /* Pixel 3 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)r;
        bout = (unsigned char)b;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y1out;

        /* Pixel 4 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)r;
        bout = (unsigned char)b;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y2out;
      } /* end x loop */
      inImgPtr += w;
      in2ImgPtr += w;
      outImgPtr += w;
      out2ImgPtr += w;
    } /* end y loop */
  } else {
    for (y = out_img_ptr->dy>>1; y; y--) {
      for (x = w2; x; x--) {
        /* Process 4 pixels at a time */
        /* Chroma values */
        cb = *inClrPtr++;
        cr = *inClrPtr++;
        /* Convert to RGB */
        rc = (ycbcr2rgb[0]*(cb-128) + ycbcr2rgb[1]*(cr-128))*4+0x8000;
        gc = (ycbcr2rgb[2]*(cb-128) + ycbcr2rgb[3]*(cr-128))*4+0x8000;
        bc = (ycbcr2rgb[4]*(cb-128) + ycbcr2rgb[5]*(cr-128))*4+0x8000;

        /* Pixels 1 and 2 */
        y1 = *inImgPtr++;
        y2 = *inImgPtr++;

        /* Pixel 1 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)b;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        cbout = (rgb2ycbcr[3]*rout+rgb2ycbcr[4]*gout+rgb2ycbcr[5]*bout)*4
          +0x8000;
        cbout = (cbout>>16) + 128;
        if (cbout < 0) cbout = 0;
        cbout = (unsigned char)cbout;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)cbout;
        *outImgPtr++ = (unsigned char)y1out;

        /* Pixel 2 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)b;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        crout = (rgb2ycbcr[6]*rout+rgb2ycbcr[7]*gout+rgb2ycbcr[8]*bout)*4
          +0x8000;
        crout = (crout>>16) + 128;
        if (crout < 0) crout = 0;
        /* Assign output value */
        *outClrPtr++ = (unsigned char)crout;
        *outImgPtr++ = (unsigned char)y2out;

        /* Pixels 3 and 4 */
        y1 = *in2ImgPtr++;
        y2 = *in2ImgPtr++;

        /* Pixel 3 */
        r = y1 + (rc>>16);
        g = y1 + (gc>>16);
        b = y1 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)b;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y1out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y1out = (y1out>>16) + 16;
        if (y1out < 0) y1out = 0;
        y1out = (unsigned char)y1out;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y1out;

        /* Pixel 4 */
        r = y2 + (rc>>16);
        g = y2 + (gc>>16);
        b = y2 + (bc>>16);
        if (r < 0) r = 0;
        if (g < 0) g = 0;
        if (b < 0) b = 0;
        rout = (unsigned char)g;
        gout = (unsigned char)b;
        bout = (unsigned char)r;
        /* Convert back to YCbCr */
        y2out = (rgb2ycbcr[0]*rout+rgb2ycbcr[1]*gout+rgb2ycbcr[2]*bout)*4
          +0x8000;
        y2out = (y2out>>16) + 16;
        if (y2out < 0) y2out = 0;
        /* Assign output value */
        *out2ImgPtr++ = (unsigned char)y2out;
      } /* end x loop */
      inImgPtr += w;
      in2ImgPtr += w;
      outImgPtr += w;
      out2ImgPtr += w;
    } /* end y loop */
  } /* end if */

  MSG_LOW("ipl_color_change_ycbcr420lp marker_100\n");

  return IPL_SUCCESS;
} /* ipl_color_change_ycbcr420lp */



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_change_color

DESCRIPTION
  This function changes the color scheme of an image. There are 5
  color-change options, each producing a different change in the
  color scheme. The options are number from 0 through 4.

  Both inputs and output must have the same color format, which
  can be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr      points to the first input image
  out_img_ptr     points to the output image
  option          color change option

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_color_change
(
  ipl_image_type* in_img_ptr,    /* Points to the first input image  */
  ipl_image_type* out_img_ptr,   /* Points to the output image       */
  uint8 option                   /* Color change option              */
)
{

  MSG_LOW("ipl_color_change marker_0\n");

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_color_change marker_200\n");
    return IPL_FAILURE;
  }

  if (in_img_ptr->cFormat != out_img_ptr->cFormat)
  {
    MSG_LOW("ipl_color_change marker_201\n");
    return IPL_FAILURE;
  }
  if (in_img_ptr->dx != out_img_ptr->dx ||
      in_img_ptr->dy != out_img_ptr->dy)
  {
    MSG_LOW("ipl_color_change marker_202\n");
    return IPL_FAILURE;
  }
  /*
  ** Options are number 0 through 4.
  ** No need to check if option >= 0 since it is unsigned.
  */
  if (option > 4)
  {
    MSG_LOW("ipl_color_change marker_203\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_color_change marker_1\n");

  /* Call the appropriate function */
  if (in_img_ptr->cFormat == IPL_RGB565)
  {
    if (ipl_color_change_rgb565(in_img_ptr, out_img_ptr, option)!= IPL_SUCCESS)
    {
      MSG_LOW("ipl_color_change marker_204\n");
      return IPL_FAILURE;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCbCr)
  {
    if (ipl_color_change_ycbcr(in_img_ptr,out_img_ptr,option) != IPL_SUCCESS)
    {
      MSG_LOW("ipl_color_change marker_205\n");
      return IPL_FAILURE;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
           in_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    if (ipl_color_change_ycbcr420lp(in_img_ptr, out_img_ptr, option)
      != IPL_SUCCESS) {
      MSG_LOW("ipl_color_change marker_206\n");
      return IPL_FAILURE;
    }
  } else {
    MSG_LOW("ipl_color_change marker_207\n");
    /* No other formats supported */
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_color_change marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_color_change */







/* <EJECT> */
/*===========================================================================

FUNCTION ipl_emboss

DESCRIPTION
  This function performs embossing of an image.  If input is YCbCr 4:2:2,
  the function outputs YCbCr 4:2:2 or RGB565. If input is RGB565, the
  function outputs RGB565.

  By nature, the mag most right columns and mag bottom rows cannot be emobossed
  and are hence, left black.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  mag            strengh of operation

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_emboss
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  uint32 mag
)
{
  int32 index;
  int32 luma1=0,luma2=0;
  uint32 row,col;
  ipl_status_type retval = IPL_FAILURE;
  unsigned char * out8_ptr;
  unsigned char * in8_ptr;
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  boolean convert = FALSE;
  register uint16* dataout_ptr;
  register uint16* datain_ptr;
  register uint16 rout16,gout16,bout16;
  int emb;
  uint32 off;
  int tot, tot2;
  uint32 dx;
  uint32 dy;

  MSG_LOW("ipl_emboss marker_0\n");


  // see if we are doing this inplace
  if (o_img_ptr == NULL)
  {
    output_img_ptr = i_img_ptr;
  }
  else
  {
    output_img_ptr = o_img_ptr;
  }
  input_img_ptr = i_img_ptr;


  if (!input_img_ptr || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_emboss marker_200\n");
    return IPL_FAILURE;
  }

  dx = output_img_ptr->dx;
  dy = output_img_ptr->dy;


  if (!((input_img_ptr->dx == dx) && (input_img_ptr->dy == dy)))
  {
    MSG_LOW("ipl_emboss marker_201\n");
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat != input_img_ptr->cFormat &&
      output_img_ptr->cFormat == IPL_RGB565)
    convert = TRUE;
  else
    convert = FALSE;

  MSG_LOW("ipl_emboss marker_1\n");

  if (input_img_ptr->cFormat == IPL_YCbCr)
  {
    /* Now loop through the image once */
    for (row = 0; row < dy - mag; row++)
    {
      /* must make sure off puts on on luma and not cb or cr */
      off = 2*(mag*dx + mag);

      for(col = 0; col < dx - mag; col++)
      {
        index = 2*(col + row*dx);

        luma1 =  input_img_ptr->imgPtr[index+1];  /* byte addressed */
        luma1 -= input_img_ptr->imgPtr[index+1+off];
        luma1 += 128;
        luma1 = CLIPIT(luma1);

        luma2 =  input_img_ptr->imgPtr[index+3];  /* byte addressed */
        luma2 -= input_img_ptr->imgPtr[index+3+off];
        luma2 += 128;
        luma2 = CLIPIT(luma2);

        if (convert)
        {
          *((unsigned short*)(output_img_ptr->imgPtr + index)) =
            pack_rgb565(luma1,luma1,luma1);

          *((unsigned short*)(output_img_ptr->imgPtr + index + 2)) =
            pack_rgb565(luma2,luma2,luma2);
        }
        else
        {
          /* No need for RGB conversion, simply output YCbCr 4:2:2 data */
          output_img_ptr->imgPtr[index] =  128;
          output_img_ptr->imgPtr[index+1] =  (unsigned char) luma1;
          output_img_ptr->imgPtr[index+2] =  128;
          output_img_ptr->imgPtr[index+3] =  (unsigned char) luma2;
        }
      }
    }

    /* if ycbcr, fill bottom row and right colum with black */
    if (!convert)
    {
      /* fill bottom mag rows with black */
      out8_ptr = output_img_ptr->imgPtr + (dy-mag)*2*dx;
      for(col = dx*mag; col; col--)
      {
        *out8_ptr++ = 128;
        *out8_ptr++ = 0;
      }
      /* fill mag right columns with black */
      for(row = 0; row < output_img_ptr->dy; row++)
      {
        out8_ptr = (output_img_ptr->imgPtr+dx*2*row+(dx-mag)*2);
        for(col = mag; col; col--)
        {
          *out8_ptr++ = 128;
          *out8_ptr++ = 0;
        }
      }
    }

    retval = IPL_SUCCESS;
  }
  else if (input_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
           input_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    if (convert)
    {
      retval = IPL_FAILURE;
    }
    else
    {
      /* must make sure off puts on on luma and not cb or cr */
      off = (mag*dx + mag);
      in8_ptr = input_img_ptr->imgPtr;
      out8_ptr = output_img_ptr->imgPtr;

      /* Now loop through the image once */
      for (row = 0; row < dy - mag; row++)
      {
        // do luma
        for(col = 0; col < dx - mag; col++)
        {
          luma1 = *in8_ptr - *(in8_ptr + off);
          luma1 += 128;
          *out8_ptr = CLIPIT(luma1);

          out8_ptr++;
          in8_ptr++;
        }

        out8_ptr += (mag);
        in8_ptr += (mag);
      }

      // chroma
      memset(output_img_ptr->clrPtr, 128, dx*dy/2);

      retval = IPL_SUCCESS;
    }
  }
  else if (input_img_ptr->cFormat == IPL_RGB565)
  {
    dataout_ptr = (uint16*)output_img_ptr->imgPtr;
    datain_ptr = (uint16*)input_img_ptr->imgPtr;

    /* do emboss on green channel only, must faster, great results */
    if (1) //lint !e774 !e506
    {
      off = mag * (dx+1);
      for(row = dy-mag; row; row--)
      {
        for(col = dx-mag; col; col--)
        {
          gout16 = (*datain_ptr&0x07E0)>>3;
          // decides if first green is pushed out or pushed in
          if (1) //lint !e774 !e506
            emb = 128 + gout16 - ((*(datain_ptr+off)&0x07E0)>>3);
          else
            emb = 128 + ((*(datain_ptr+off)&0x07E0)>>3) - gout16;
          datain_ptr++;
          emb = CLIPIT(emb);
          *dataout_ptr++ = pack_rgb565(emb,emb,emb);
        }
        datain_ptr += mag;
        dataout_ptr += mag;
      }
    }
    else
    /* do emboss based on all 3 channels */
    {
      off = mag * (dx+1);
      for(row = 0; row < dy-mag; row++)
      {
        for(col = 0; col < dx-mag; col++)
        {
          rout16 = (*datain_ptr&0xF800)>>8;
          gout16 = (*datain_ptr&0x07E0)>>3;
          bout16 = (*datain_ptr&0x001F)<<3;
          tot = (rout16+gout16+bout16)/3;

          rout16 = ((*(datain_ptr+off)&0xF800)>>8);
          gout16 = ((*(datain_ptr+off)&0x07E0)>>3);
          bout16 = ((*(datain_ptr+off)&0x001F)<<3);
          tot2 = (rout16+gout16+bout16)/3;

          datain_ptr++;

          // decides if first green is pushed out or pushed in
          if (0) //lint !e774 !e506
            tot = 128 + tot2 - tot;
          else
            tot = 128 + tot - tot2;
          tot = (tot > 255)? 255: tot;
          tot = (tot < 0)? 0: tot;

          rout16 = tot;
          gout16 = tot;
          bout16 = tot;

          *dataout_ptr++ = pack_rgb565(rout16,gout16,bout16);
        }

        /* do last pixel in column */
        *dataout_ptr++ = 0x8410;
        datain_ptr++;
      }
    }

    retval = IPL_SUCCESS;
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_emboss marker_100\n");
  else
    MSG_LOW("ipl_emboss marker_204\n");

  return retval;
}


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_sketch

DESCRIPTION
  This function performs sketch effect of an image.  If input is YCbCr 4:2:2,
  the function outputs YCbCr 4:2:2 or RGB565. If input is RGB565, the
  function outputs RGB565.

  By nature, the right most column and bottom row cannot be sketched
  and are hence, left white.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  mag            strengh of operation

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_sketch
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr          /* Points to the output image     */
)
{
  uint32 row,col;
  ipl_status_type retval = IPL_FAILURE;
  uint32 mag = 3;
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  register uint16* dataout_ptr;
  register uint16* datain_ptr;
  register uint16 rout16,gout16,bout16;
  int32 luma1=0;
  int emb;
  uint32 off;
  int tot, tot2;
  uint32 dx;
  uint32 dy;
  unsigned char * out8_ptr;
  unsigned char * in8_ptr;

  MSG_LOW("ipl_sketch marker_0\n");


  // see if we are doing this inplace
  if (o_img_ptr == NULL)
  {
    output_img_ptr = i_img_ptr;
  }
  else
  {
    output_img_ptr = o_img_ptr;
  }
  input_img_ptr = i_img_ptr;


  if (!input_img_ptr || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_sketch marker_200\n");
    return IPL_FAILURE;
  }

  dx = output_img_ptr->dx;
  dy = output_img_ptr->dy;

  if (!((input_img_ptr->dx == dx) && (input_img_ptr->dy == dy)))
  {
    MSG_LOW("ipl_sketch marker_201\n");
    return IPL_FAILURE;
  }


  MSG_LOW("ipl_sketch marker_1\n");
  if (input_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
      input_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    /* must make sure off puts on on luma and not cb or cr */
    off = (mag*dx + mag);

    in8_ptr = input_img_ptr->imgPtr;
    out8_ptr = output_img_ptr->imgPtr;

    /* Now loop through the image once */
    emb = 0;
    for (row = 0; row < dy - mag; row++)
    {
      // do luma
      for(col = 0; col < dx - mag; col++)
      {
        luma1 = abs((*in8_ptr) - (*(in8_ptr + off)));

        /*
        if (row < dy - 10)
        {
          emb = (*in8_ptr) % 2;
          emb = emb + emb*dx;
        }
        else
          emb = 0;
        */


        if (luma1 < 10)
          luma1 *= 5;
        else if (luma1 < 40)
          luma1 *= 4;
        else if (luma1 < 80)
          luma1 *= 2;
        else if (luma1 < 150)
          luma1 *= 2;
        else if (luma1 < 180)
          luma1 = (luma1 * 3 )/2;

        luma1 = 255 - luma1;

        //*(out8_ptr+emb) = CLIPIT(luma1);
        *(out8_ptr) = CLIPIT(luma1);

        out8_ptr++;
        in8_ptr++;
      }

      out8_ptr += (mag);
      in8_ptr += (mag);
    }

    // chroma
    memset(output_img_ptr->clrPtr, 128, dx*dy/2);
    retval = IPL_SUCCESS;
  }
  else if (input_img_ptr->cFormat == IPL_RGB565)
  {
    dataout_ptr = (uint16*)output_img_ptr->imgPtr;
    datain_ptr = (uint16*)input_img_ptr->imgPtr;

    /* do sketch based on higher 8 bits */
    if (1) //lint !e774 !e506
    {
      dx = dx + 1;
      for(row = dy-1; row; row--)
      {
        for(col = dx-2; col; col--)
        {
          //emb = 255 - abs(gout16 - ((*(datain_ptr+off)&0x07E0)>>3));
          //emb = 255 - 4*(abs(*datain_ptr - *(datain_ptr++ + dx)) >> 8);
          //  emb = 255 - 4*((*datain_ptr - *(datain_ptr + dx)) >> 8);

          if (*datain_ptr > *(datain_ptr + dx))
            emb = 255 - ((*datain_ptr - *(datain_ptr + dx)) >> 6);
          else
            emb = 255 - ((*(datain_ptr + dx) - *datain_ptr) >> 6);
          datain_ptr++;
          emb = (emb < 100)? 100 : emb;
          *dataout_ptr++ = pack_rgb565(emb,emb,emb);
        }
        datain_ptr++;
        dataout_ptr++;
      }
    }
    else
    /* do sketch on avg of all 3 channels */
    {
      off = mag * (dx+1);
      for(row = 0; row < dy-mag; row++)
      {
        for(col = 0; col < dx-mag; col++)
        {
          rout16 = (*datain_ptr&0xF800)>>8;
          gout16 = (*datain_ptr&0x07E0)>>3;
          bout16 = (*datain_ptr&0x001F)<<3;
          tot = (rout16+gout16+bout16)/3;

          rout16 = ((*(datain_ptr+off)&0xF800)>>8);
          gout16 = ((*(datain_ptr+off)&0x07E0)>>3);
          bout16 = ((*(datain_ptr+off)&0x001F)<<3);
          tot2 = (rout16+gout16+bout16)/3;

          datain_ptr++;

          // decides if first green is pushed out or pushed in
          tot = 255 - 2*(abs(tot - tot2));
          tot = (tot > 255)? 255: tot;
          tot = (tot < 0)? 0: tot;

          rout16 = tot;
          gout16 = tot;
          bout16 = tot;

          *dataout_ptr++ = pack_rgb565(rout16,gout16,bout16);
        }

        /* do last pixel in column */
        *dataout_ptr++ = 0x8410;
        datain_ptr++;
      }
    }

    retval = IPL_SUCCESS;
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_sketch marker_100\n");
  else
    MSG_LOW("ipl_sketch marker_204\n");

  return retval;
}






/* <EJECT> */
/*===========================================================================

FUNCTION ipl_set_brightness

DESCRIPTION
  This function sets the multiplication coefficients based on
  the desired brightness level. The brightness is multiplicative.
  The delta step is 0.25. The dynamic range is a function of
  max_value - min_value.

DEPENDENCIES
  None

ARGUMENTS IN
  desired_value    desired brightness setting
  min_value        minimum brightness value
  max_value        maximum brightness value
  input_ptr        pointer to the input image

ARGUMENTS OUT
  output_ptr       pointer to the output image

RETURN VALUE
  IPL_SUCCESS      indicates operation was successful
  IPL_FAILURE      otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_set_brightness
(
  int32 desired_value,         /* Desired brightness setting */
  int32 min_value,             /* Minimum brightness value   */
  int32 max_value,             /* Maximum brightness value   */
  uint16 *input_ptr,           /* Points to the input image  */
  uint16 *output_ptr           /* Points to the output image */
)
{
  int32 i = 0,k=0;
  uint16 qfactor = 8;  /* 10Q8 */
  double step;
  double temp;

  MSG_LOW("ipl_set_brightness marker_0\n");

  if (!input_ptr || !output_ptr)
  {
    MSG_LOW("ipl_set_brightness marker_200\n");
    return IPL_FAILURE;
  }

  /*
  ** Range Checking
  */
  if ( (desired_value<min_value) || (desired_value>max_value))
  {
    MSG_LOW("ipl_set_brightness marker_201\n");
    return IPL_FAILURE;
  }

  if (max_value == min_value)
  {
    step = 0;
  }
  else
  {
    step = ((double)(1<<(qfactor+2)) /
            ((double) max_value - (double) min_value));
    temp = (double) (max_value + min_value)/2;
    step = (double) ((double) desired_value - temp) * step;
  }

  i= (int32)(step);
  k = *input_ptr + i;

  /*
  ** Clipping
  */
  if (k<0)
  {
    k=0;
  }
  if (k>0x3FF)
  {
    k=0x3FF;
  }
  *output_ptr = (uint16)k;;

  MSG_LOW("ipl_set_brightness marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_set_brightness */







/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fadein_fadeout_rgb565

DESCRIPTION
  This function performs fade-in/fade-out for a sequence of still images.
  The user specifies the number of image frames in the sequence and the
  width and height of each frame.  Fading in is option 0 and fading out is
  option 1. All images in the sequence must have the same size.  The
  user provides the still image to fade to/from.

  Input and output images must be in RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr    pointer to the input image sequence
  in2_img_ptr    pointer to the still image to fade to/from
  out_img_ptr    pointer to the output image sequence
  numFrames      number of frames to use in the sequence
  in_out         indicator for fade-in (0) or fade-out (1)

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_fadein_fadeout_rgb565
(
  ipl_image_type* in1_img_ptr, /* Points to input image sequence           */
  ipl_image_type* in2_img_ptr, /* Points to still image to fade to/from    */
  ipl_image_type* out_img_ptr, /* Points to output image sequence          */
  uint16 numFrames,            /* Number of image frames in input sequence */
  uint8 in_out                 /* Indicates fade-in(0) or fade-out(1)      */
)
{
  uint16 *in1ImgPtr, *in2ImgPtr, *outImgPtr;
  uint16 outWidth, outHeight, x, y, cnt;
  uint8 r, g, b, rr, gg, bb, rout, gout, bout;
  int32 a, beta, inc;
  uint32 index;

  MSG_LOW("ipl_fadein_fadeout_rgb565 marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_fadein_fadeout_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize the image pointers and local variables */
  in1ImgPtr = (uint16*)in1_img_ptr->imgPtr;
  in2ImgPtr = (uint16*)in2_img_ptr->imgPtr;
  outImgPtr = (uint16*)out_img_ptr->imgPtr;
  outWidth = (uint16)out_img_ptr->dx;
  outHeight = (uint16)out_img_ptr->dy;

#define IPL_TESTING_FADE_RGB 0


  if (IPL_TESTING_FADE_RGB) //lint !e774 !e506
    numFrames = 100;


  /* Initialize starting alpha factor and increment */
  inc = 8192 / (int32)numFrames;
  if (in_out == 0) {
    /* fade in */
    a = 0;
    beta = 8192;
  } else if (in_out == 1) {
    /* fade out */
    a = 8192;
    beta = 0;
    inc = -inc;
  } else {
    MSG_LOW("ipl_fadein_fadeout_rgb565 marker_201\n");
    /* no other options supported */
    return IPL_FAILURE;
  }

  // for testing purposed, comment out when done
  if (IPL_TESTING_FADE_RGB) //lint !e774 !e506
  {
    for (cnt = 0; cnt < 50; cnt++)
    {
      a += inc;
      beta = 8192-a;
    }
    numFrames = 1;
  }

  MSG_LOW("ipl_fadein_fadeout_rgb565 marker_1\n");

  /* Loop through input sequence once */
  for (cnt = 0; cnt < numFrames; cnt++) {
    index = 0;
    for(y = 0; y < outHeight; y++) {
      for(x = 0; x < outWidth; x++) {
        /* unpack input rgb values */
        r = (uint8)((*in1ImgPtr & 0xF800)>>8);
        g = (uint8)((*in1ImgPtr & 0x07E0)>>3);
        b = (uint8)((*in1ImgPtr++ & 0x001F)<<3);
        rr = (uint8)((*((uint16*)(in2ImgPtr+index)) & 0xF800)>>8);
        gg = (uint8)((*((uint16*)(in2ImgPtr+index)) & 0x07E0)>>3);
        bb = (uint8)((*((uint16*)(in2ImgPtr+index++)) & 0x001F)<<3);
        /* find output rgb values */
        rout = (uint8)(((r*a)>>13)+((rr*beta)>>13));
        gout = (uint8)(((g*a)>>13)+((gg*beta)>>13));
        bout = (uint8)(((b*a)>>13)+((bb*beta)>>13));
        *outImgPtr++ = pack_rgb565(rout, gout, bout);
      } /* end x loop */
    } /* end y loop */
    a += inc;
    beta = 8192-a;
  } /* end cnt loop */

  MSG_LOW("ipl_fadein_fadeout_rgb565 marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_fadein_fadeout_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fadein_fadeout_ycbcr

DESCRIPTION
  This function performs fade-in/fade-out for a sequence of still images.
  The user specifies the number of image frames in the sequence and the
  width and height of each frame.  Fading in is option 0 and fading out is
  option 1. All images in the sequence must have the same size.  The
  user provides the still image to fade to/from.

  Input and output images must be in YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr    pointer to the input image sequence
  in2_img_ptr    pointer to the still image to fade to/from
  out_img_ptr    pointer to the output image sequence
  numFrames      number of frames to use in the sequence
  in_out         indicator for fade-in (0) or fade-out (1)

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_fadein_fadeout_ycbcr
(
  ipl_image_type* in1_img_ptr, /* Points to input image sequence           */
  ipl_image_type* in2_img_ptr, /* Points to still image to fade to/from    */
  ipl_image_type* out_img_ptr, /* Points to output image sequence          */
  uint16 numFrames,            /* Number of image frames in input sequence */
  uint8 in_out                 /* Indicates fade-in(0) or fade-out(1)      */
)
{
  unsigned char *in1ImgPtr, *in2ImgPtr, *outImgPtr;
  uint16 endx, endy, x, y, cnt;
  int32 a, beta, inc;
  uint32 index;

  MSG_LOW("ipl_fadein_fadeout_ycbcr marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_fadein_fadeout_ycbcr marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  in1ImgPtr = in1_img_ptr->imgPtr;
  in2ImgPtr = in2_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;
  endx = (uint16)out_img_ptr->dx;
  endy = (uint16)out_img_ptr->dy;

  // turn on when want to test this function with single frame
#define IPL_TESTING_FADE_YCbCr  0


  if (IPL_TESTING_FADE_YCbCr) //lint !e774 !e506
    numFrames = 100;

  /* Initialize starting alpha factor and increment */
  inc = 8192 / (int32)numFrames;
  if (in_out == 0)
  {
    /* fade in */
    a = 0;
    beta = 8192;
  }
  else if (in_out == 1)
  {
    /* fade out */
    a = 8192;
    beta = 0;
    inc = -inc;
  }
  else
  {
    MSG_LOW("ipl_fadein_fadeout_ycbcr marker_201\n");
    /* no other options supported */
    return IPL_FAILURE;
  }

  // for testing purposed, comment out when done
  if (IPL_TESTING_FADE_YCbCr) //lint !e774 !e506
  {
    for (cnt = 0; cnt < 50; cnt++)
    {
      a += inc;
      beta = 8192-a;
    }
    numFrames = 1;
  }

  MSG_LOW("ipl_fadein_fadeout_ycbcr marker_1\n");

  /* Loop through input sequence once */
  for (cnt = 0; cnt < numFrames; cnt++)
  {
    index = 0;
    for(y = 0; y < endy; y++)
    {
      for(x = 0; x < endx; x+=2)
      {
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>13) +
          ((*((unsigned char*)(in2ImgPtr+index++))*beta)>>13));
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>13) +
          ((*((unsigned char*)(in2ImgPtr+index++))*beta)>>13));
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>13) +
          ((*((unsigned char*)(in2ImgPtr+index++))*beta)>>13));
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>13) +
          ((*((unsigned char*)(in2ImgPtr+index++))*beta)>>13));
      }
    }
    a += inc;
    beta = 8192-a;
  }

  MSG_LOW("ipl_fadein_fadeout_ycbcr marker_100\n");

  return IPL_SUCCESS;
}


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fadein_fadeout_ycbcr_lp

DESCRIPTION
  This function performs fade-in/fade-out for a sequence of still images.
  The user specifies the number of image frames in the sequence and the
  width and height of each frame.  Fading in is option 0 and fading out is
  option 1. All images in the sequence must have the same size.  The
  user provides the still image to fade to/from.

  Input and output images must be in YCbCr 4:2:0 line pack.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr    pointer to the input image sequence
  in2_img_ptr    pointer to the still image to fade to/from
  out_img_ptr    pointer to the output image sequence
  numFrames      number of frames to use in the sequence
  in_out         indicator for fade-in (0) or fade-out (1)

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_fadein_fadeout_ycbcr_lp
(
  ipl_image_type* in1_img_ptr, /* Points to input image sequence           */
  ipl_image_type* in2_img_ptr, /* Points to still image to fade to/from    */
  ipl_image_type* out_img_ptr, /* Points to output image sequence          */
  uint16 numFrames,            /* Number of image frames in input sequence */
  uint8 in_out                 /* Indicates fade-in(0) or fade-out(1)      */
)
{
  unsigned char *in1ImgPtr, *in2ImgPtr, *outImgPtr;
  unsigned char *in1ClrPtr, *in2ClrPtr, *outClrPtr;
  uint16 endx, endy, x, y, cnt;
  int32 a, beta, inc;

  MSG_LOW("ipl_fadein_fadeout_ycbcr_lp marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_fadein_fadeout_ycbcr_lp marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  in1ImgPtr = in1_img_ptr->imgPtr;
  in2ImgPtr = in2_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;

  in1ClrPtr = in1_img_ptr->clrPtr;
  in2ClrPtr = in2_img_ptr->clrPtr;
  outClrPtr = out_img_ptr->clrPtr;

  endx = (uint16)out_img_ptr->dx;
  endy = (uint16)out_img_ptr->dy;

  // turn on when want to test this function with single frame
#define IPL_TESTING_FADE_LP  0


  if (IPL_TESTING_FADE_LP) //lint !e774 !e506
    numFrames = 100;

  /* Initialize starting alpha factor and increment */
  inc = 8192 / (int32)numFrames;
  if (in_out == 0)
  {
    /* fade in */
    a = 0;
    beta = 8192;
  }
  else if (in_out == 1)
  {
    /* fade out */
    a = 8192;
    beta = 0;
    inc = -inc;
  }
  else
  {
    MSG_LOW("ipl_fadein_fadeout_ycbcr_lp marker_201\n");
    /* no other options supported */
    return IPL_FAILURE;
  }

  // for testing purposed, comment out when done
  if (IPL_TESTING_FADE_LP) //lint !e774 !e506
  {
    for (cnt = 0; cnt < 50; cnt++)
    {
      a += inc;
      beta = 8192-a;
    }
    numFrames = 1;
  }

  MSG_LOW("ipl_fadein_fadeout_ycbcr_lp marker_1\n");

  /* Loop through input sequence once */
  // for (cnt = 0; cnt < numFrames; cnt++)

  for (cnt = 0; cnt < numFrames; cnt++)
  {
    for(y = endy/2; y ; y--)
    {
      for(x = endx/2; x ; x--)
      {
        *(outImgPtr) = (unsigned char) (((*(in1ImgPtr) * a)>>13) +
                        ((*(in2ImgPtr) * beta)>>13));
        *(outImgPtr+1) = (unsigned char) (((*(in1ImgPtr+1) * a)>>13) +
                          ((*(in2ImgPtr+1) * beta)>>13));
        *(outImgPtr+endx) = (unsigned char) (((*(in1ImgPtr+endx) * a)>>13) +
                             ((*(in2ImgPtr+endx) * beta)>>13));
        *(outImgPtr+endx+1) = (unsigned char) (((*(in1ImgPtr+endx+1) * a)>>13) +
                               ((*(in2ImgPtr+endx+1) * beta)>>13));

        *outClrPtr++ = (unsigned char) (((*in1ClrPtr++*a)>>13) + ((*(in2ClrPtr++)*beta)>>13));
        *outClrPtr++ = (unsigned char) (((*in1ClrPtr++*a)>>13) + ((*(in2ClrPtr++)*beta)>>13));

        outImgPtr += 2;
        in1ImgPtr += 2;
        in2ImgPtr += 2;
      }

      outImgPtr += endx;
      in1ImgPtr += endx;
      in2ImgPtr += endx;
    }

    a += inc;
    beta = 8192-a;
  }

  MSG_LOW("ipl_fadein_fadeout_ycbcr_lp marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_fadein_fadeout_ycbcr */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fadein_fadeout

DESCRIPTION
  This function performs fade-in/fade-out for a sequence of still images.
  The user specifies the number of image frames in the sequence and the
  width and height of each frame.  Fading in is option 0 and fading out is
  option 1. All images in the sequence must have the same size.  The
  user provides the still image to fade to/from.

  Input and output images must have the same color format, which can
  be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr    pointer to the input image sequence
  in2_img_ptr    pointer to the still image to fade to/from
  out_img_ptr    pointer to the output image sequence
  numFrames      number of frames to use in the sequence
  in_out         indicator for fade-in (0) or fade-out (1)

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_fadein_fadeout
(
  ipl_image_type* in1_img_ptr, /* Points to input image sequence           */
  ipl_image_type* in2_img_ptr, /* Points to still image to fade to/from    */
  ipl_image_type* out_img_ptr, /* Points to output image sequence          */
  uint16 numFrames,            /* Number of image frames in input sequence */
  uint8 in_out                 /* Indicates fade-in(0) or fade-out(1)      */
)
{

  MSG_LOW("ipl_fadein_fadeout marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_fadein_fadeout marker_200\n");
    return IPL_FAILURE;
  }

  /* Input and output color formats must be the same */
  if (in1_img_ptr->cFormat != in2_img_ptr->cFormat ||
      in1_img_ptr->cFormat != out_img_ptr->cFormat)
  {
    MSG_LOW("ipl_fadein_fadeout marker_201\n");
    return IPL_FAILURE;
  }
  /* Input and output image sizes must be equal */
  if (in1_img_ptr->dx != in2_img_ptr->dx ||
      in1_img_ptr->dx != out_img_ptr->dx ||
      in1_img_ptr->dy != in2_img_ptr->dy ||
      in1_img_ptr->dy != out_img_ptr->dy)
  {
    MSG_LOW("ipl_fadein_fadeout marker_202\n");
    return IPL_FAILURE;
  }
  /* Number of frames in image sequence must be positive */
  if (numFrames == 0) {
    MSG_LOW("ipl_fadein_fadeout marker_203\n");
    return IPL_FAILURE;
  }
  /* Must be either fade-out (0) or fade-in (1) */
  if (in_out != 0 && in_out != 1)
  {
    MSG_LOW("ipl_fadein_fadeout marker_204\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_fadein_fadeout marker_1\n");

  /* Call the appropriate function */
  if (in1_img_ptr->cFormat == IPL_RGB565)
  {
    if (ipl_fadein_fadeout_rgb565(in1_img_ptr, in2_img_ptr,
        out_img_ptr, numFrames, in_out) != IPL_SUCCESS)
    {
      MSG_LOW("ipl_fadein_fadeout marker_205\n");
      return IPL_FAILURE;
    }
  }
  else if (in1_img_ptr->cFormat == IPL_YCbCr)
  {
    if (ipl_fadein_fadeout_ycbcr(in1_img_ptr, in2_img_ptr,
        out_img_ptr, numFrames, in_out) != IPL_SUCCESS)
    {
      MSG_LOW("ipl_fadein_fadeout marker_206\n");
      return IPL_FAILURE;
    }
  }
  else if((in1_img_ptr->cFormat == IPL_YCbCr420_LINE_PK) ||
          (in1_img_ptr->cFormat == IPL_YCrCb420_LINE_PK))
  {
    if (ipl_fadein_fadeout_ycbcr_lp(in1_img_ptr, in2_img_ptr,
        out_img_ptr, numFrames, in_out) != IPL_SUCCESS)
    {
      MSG_LOW("ipl_fadein_fadeout marker_207\n");
      return IPL_FAILURE;
    }
  }
  else
  {
    MSG_LOW("ipl_fadein_fadeout marker_208\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_fadein_fadeout marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_fadein_fadeout */






/* <EJECT> */
/*===========================================================================

FUNCTION ipl_image_brightness

DESCRIPTION
  This function makes and image brighter or darker.

DEPENDENCIES
  None

ARGUMENTS IN
  input_ptr        pointer to the input image
  mult             value to multiply pixel by
  add              value to add to pixel (before multiply)

ARGUMENTS OUT
  output_ptr       pointer to the output image

RETURN VALUE
  IPL_SUCCESS      indicates operation was successful
  IPL_FAILURE      otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_image_brightness
(
  ipl_image_type *input_img_ptr,  /* Points to the input image  */
  ipl_image_type *output_img_ptr, /* Points to the output image */
  int32 mult,                     /* value to multiply pixel by */
  int32 add                       /* value to add to pixel */
)
{
  int32 i;
  ipl_status_type retval = IPL_FAILURE;
  register uint16* in16_ptr;
  register uint16* out16_ptr;
  register uint8* in8_ptr;
  register uint8* out8_ptr;
  register uint16 rout16,gout16,bout16;

  uint32 dx;
  uint32 dy;

  MSG_LOW("ipl_image_brightness marker_0\n");

  if (!input_img_ptr || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_image_brightness marker_200\n");
    return IPL_FAILURE;
  }

  dx = output_img_ptr->dx;
  dy = output_img_ptr->dy;

  if ((mult<0) || (mult>100))
  {
    MSG_LOW("ipl_image_brightness marker_201\n");
    return IPL_FAILURE;
  }

  if ((add<0) || (add>255))
  {
    MSG_LOW("ipl_image_brightness marker_202\n");
    return IPL_FAILURE;
  }

  /* make Q5 numbers */
  mult = mult << 5;
  mult = mult / 10;
  add = add << 5;

  if (!((input_img_ptr->dx == dx) &&
        (input_img_ptr->dy == dy)))
  {
    MSG_LOW("ipl_image_brightness marker_203\n");
    return IPL_FAILURE;
  }

  if ((input_img_ptr->cFormat != IPL_YCbCr) &&
      (input_img_ptr->cFormat != IPL_RGB565))
  {
    MSG_LOW("ipl_image_brightness marker_204\n");
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat != input_img_ptr->cFormat)
  {
    MSG_LOW("ipl_image_brightness marker_205\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_image_brightness marker_1\n");

  if (input_img_ptr->cFormat == IPL_YCbCr)
  {
    in8_ptr = input_img_ptr->imgPtr;
    out8_ptr = output_img_ptr->imgPtr;
    if (input_img_ptr->cFormat == IPL_YCbCr)
    {
      for(i=dx*dy; i; i--)
      {
        /* copy cb or cr over */
        *out8_ptr++ = *in8_ptr++;
        rout16 = (uint16) (*in8_ptr * mult + add);
        rout16 = rout16 >> 5;            /* undo Q# */
        in8_ptr++;
        *out8_ptr++ = (rout16 > 255)? 255 : rout16;
      }
      retval = IPL_SUCCESS;
    }
  }
  else if (input_img_ptr->cFormat == IPL_RGB565)
  {
    in16_ptr = (uint16*) input_img_ptr->imgPtr;
    out16_ptr = (uint16*) output_img_ptr->imgPtr;
    for(i=dx*dy; i; i--)
    {
      rout16 = (*in16_ptr & 0xF800) >> 8;
      gout16 = (*in16_ptr & 0x07E0) >> 3;
      bout16 = (*in16_ptr & 0x001F) << 3;
      in16_ptr++;

      rout16 = (uint16) (rout16*mult + add);
      gout16 = (uint16) (gout16*mult + add);
      bout16 = (uint16) (bout16*mult + add);

      /* undo Q8 */
      rout16 = rout16 >> 5;
      gout16 = gout16 >> 5;
      bout16 = bout16 >> 5;

      rout16 = (rout16 > 255)? 255 : rout16;
      gout16 = (gout16 > 255)? 255 : gout16;
      bout16 = (bout16 > 255)? 255 : bout16;

      *out16_ptr++ = pack_rgb565(rout16,gout16,bout16);
    }

    retval = IPL_SUCCESS;
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_image_brightness marker_100\n");
  else
    MSG_LOW("ipl_image_brightness marker_206\n");

  return retval;
}




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_filter

DESCRIPTION
  This function performs filtering.  If input is YCbCr 4:2:2, the function
  can perform Blur and Sharpen and also output YCbCr 4:2:2 or RGB565.
  If input is RGB565, the function supports only blurring and output must be
  RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  filter         type of filtering operation

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_filter
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  ipl_filter_type filter_i           /* Type of filtering operation    */
)
{
  int32 index;
  int32 luma1=0,luma2=0,r,g,b,row,col,i,j,luma;
  ipl_status_type retval = IPL_FAILURE;

  ipl_kernel_type kernelSharpen = {{6,6,6,6,80,6,6,6,6}, 3}; //lint !e785
  ipl_kernel_type kernelBlur    = {{1,1,1,1,1, 1,1,1,0}, 3}; //lint !e785

  unsigned short out;
  int32 cb=0,cr=0;
  int32* filter;
  int32 lp_filter[3][3] = {{1,2,2},{2,2,2},{2,2,1}};
  //int32 lp_filter[3][3] = {{1,2,1},{2,4,2},{1,2,1}};
  //int32 lp_filter[3][3] = {{0,0,0},{0,16,0},{0,0,0}};
  //int32 hp_filter[3][3] = {{-1,0,-1},{0,5,0},{-1,0,-1}};  // side
  long rc,gc,bc;
  /* ycbcr_convert is the conversion array of coeffs in Q14 Signed */
  /* In Q0, coeffs are 4.8828e-4 1.57489 -0.18744 -0.46826 1.8554 7.3242e-4 */
  short ycbcr_convert[6] = {8, 25803, -3071, -7672,30399,12};
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  boolean convert = TRUE;
  register uint16* dataout_ptr;
  register uint16* datain_ptr;
  register uint16 rout16=0,gout16=0,bout16=0;

  MSG_LOW("ipl_filter marker_0\n");
  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_filter marker_200\n");
    return IPL_FAILURE;
  }

  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;
  dataout_ptr = (uint16*)output_img_ptr->imgPtr;
  datain_ptr = (uint16*)input_img_ptr->imgPtr;



  if (!((input_img_ptr->dx == output_img_ptr->dx) &&
        (input_img_ptr->dy == output_img_ptr->dy)))
  {
    MSG_LOW("ipl_filter marker_201\n");
    /* Input and Output should be of same dimension */
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat == input_img_ptr->cFormat)
  {
    convert = FALSE;
  }

  MSG_LOW("ipl_filter marker_1\n");

  if (input_img_ptr->cFormat == IPL_YCrCb420_LINE_PK)
  {
    if (filter_i == IPL_SHARP)
      retval=ipl_convolution(input_img_ptr,output_img_ptr,&kernelSharpen,2);
    else
      retval=ipl_convolution(input_img_ptr,output_img_ptr,&kernelBlur,2);
  }
  else if (input_img_ptr->cFormat == IPL_YCbCr)
  {
    /*
    ** Input is YCbCr 4:2:2
    */
    if ((filter_i == IPL_BLUR) ||
        (filter_i == IPL_BLUR_GAUSSIAN) ||
        (filter_i == IPL_BLUR_UNIFORM))
    {
      filter =&lp_filter[0][0];
      /* Now loop through the image once */
      for(row = 0; row < (int32)output_img_ptr->dy; row++)
      {
        for(col = 0; col < (int32)output_img_ptr->dx; col++){
          index = (col + row*output_img_ptr->dx)<<1;  /* byte addressed */
          luma =  input_img_ptr->imgPtr[index+1];  /* byte addressed */
          if ((row>0)&&(row<(int32)output_img_ptr->dy-1)&&
              (col>0)&&(col<(int32)output_img_ptr->dx-1))
          {
            g = 0;
            cr = index-1-(input_img_ptr->dx<<1); /* Points to top left */
            for (i =0;i<3;i++)
            {
              for (j =0;j<3;j++)
              {
                r = cr+((i*output_img_ptr->dx + j)<<1);
                g = g + *(filter+j+i*3)*input_img_ptr->imgPtr[r];
              }
            }
            g = g>>4;
            g = CLIPIT(g);
            luma = g;
          }
          /* First byte is is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
          if (!(col%2)) {
            luma1 =  luma; //Byte addressed
            /* This is Cb */
            cb=input_img_ptr->imgPtr[index];
          } else {
            /* This is Cr */
            cr = input_img_ptr->imgPtr[index];
            /* Next byte is the luma */
            luma2 = luma;
            if (convert)
            {
              /* YCbCr2RGB lags behind by 2 pixels always */
              rc = (ycbcr_convert[0]*(cb-128) + ycbcr_convert[1]*(cr-128))*4
                   + 0x8000;
              gc = (ycbcr_convert[2]*(cb-128) + ycbcr_convert[3]*(cr-128))*4
                   + 0x8000;
              bc = (ycbcr_convert[4]*(cb-128) + ycbcr_convert[5]*(cr-128))*4
                   + 0x8000;
              r = luma1 + (rc>>16);
              g = luma1 + (gc>>16);
              b = luma1 + (bc>>16);
              r=CLIPIT(r);
              g=CLIPIT(g);
              b=CLIPIT(b);
              /*
              ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
              ** Order of the 2 bytes is R5G3 G3B5
              */
              out = pack_rgb565(r,g,b);
              *((unsigned short*)(output_img_ptr->imgPtr + index-2)) =
                (unsigned short)out;
              r = luma2 + (rc>>16);
              g = luma2 + (gc>>16);
              b = luma2 + (bc>>16);
              r=CLIPIT(r);
              g=CLIPIT(g);
              b=CLIPIT(b);
              out = pack_rgb565(r,g,b);
              *((unsigned short*)(output_img_ptr->imgPtr + index)) =
                (unsigned short) out;
            } else {
              /* No need for RGB conversion, simply output YCbCr 4:2:2 data */
              output_img_ptr->imgPtr[index] = (unsigned char) cr;
              output_img_ptr->imgPtr[index+1] = (unsigned char)luma2;
              output_img_ptr->imgPtr[index-2] = (unsigned char) cb;
              output_img_ptr->imgPtr[index-1] = (unsigned char)luma1;
            }
          } /* end of Cb Cr */
        } /* End of col loop */
      } /* End of row loop */
      retval = IPL_SUCCESS;
    }
    else if (filter_i == IPL_SHARP)
    {
      /* Sharpen Filter */
      //filter = &hp_filter[0][0];
      filter = hp_filter;
      /* Now loop through the image once */
      for(row = 0; row < (int32)output_img_ptr->dy; row++){
        for(col = 0; col < (int32)output_img_ptr->dx; col++){
          index = (col + row*output_img_ptr->dx)<<1;  /* byte addressed */
          luma =  input_img_ptr->imgPtr[index+1];  /* byte addressed */
          if ((row>0)&&(row<(int32)output_img_ptr->dy-1)&&
              (col>0)&&(col<(int32)output_img_ptr->dx-1))
          {
            g = 0;
            cr = index-1-(input_img_ptr->dx<<1); /* Points to top left */
            for (i =0;i<3;i++)
            {
              for (j =0;j<3;j++)
              {
                r = cr+((i*output_img_ptr->dx + j)<<1);
                g = g + *(filter+j+i*3)*input_img_ptr->imgPtr[r];
              }
            }
            g = CLIPIT(g);
            luma = g;
          }
          /* First byte is is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
          if (!(col%2))
          {
            luma1 =  luma; //Byte addressed
            /* This is Cb */
            cb=input_img_ptr->imgPtr[index];
          }
          else
          {
            /* This is Cr */
            cr = input_img_ptr->imgPtr[index];

            /* Next byte is the luma */
            luma2 = luma;

            if (convert)
            {
              /* YCbCr2RGB lags behind by 2 pixels always */
              rc = (ycbcr_convert[0]*(cb-128) + ycbcr_convert[1]*(cr-128))*4
                   + 0x8000;
              gc = (ycbcr_convert[2]*(cb-128) + ycbcr_convert[3]*(cr-128))*4
                   + 0x8000;
              bc = (ycbcr_convert[4]*(cb-128) + ycbcr_convert[5]*(cr-128))*4
                   + 0x8000;
              r = luma1 + (rc>>16);
              g = luma1 + (gc>>16);
              b = luma1 + (bc>>16);
              r=CLIPIT(r);
              g=CLIPIT(g);
              b=CLIPIT(b);
              /*
              ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
              ** Order of the 2 bytes is R5G3 G3B5
              */
              out = pack_rgb565(r,g,b);
              *((unsigned short*)(output_img_ptr->imgPtr + index-2)) =
                (unsigned short)out;
              r = luma2 + (rc>>16);
              g = luma2 + (gc>>16);
              b = luma2 + (bc>>16);
              r=CLIPIT(r);
              g=CLIPIT(g);
              b=CLIPIT(b);
              out = pack_rgb565(r,g,b);
              *((unsigned short*)(output_img_ptr->imgPtr + index)) =
                (unsigned short)out;
            }
            else
            {
              /* No need for RGB conversion, simply output YCbCr data */
              output_img_ptr->imgPtr[index] = (unsigned char) cr;
              output_img_ptr->imgPtr[index+1] = (unsigned char)luma2;
              output_img_ptr->imgPtr[index-2] = (unsigned char) cb;
              output_img_ptr->imgPtr[index-1] = (unsigned char)luma1;
            }
          } /* end of Cb Cr */
        } /* End of col loop */
      } /* End of row loop */
      retval = IPL_SUCCESS;
    }
    else
    {
      retval = IPL_FAILURE;
    }
  }
  else if (input_img_ptr->cFormat == IPL_RGB565)
  {
    /*
    ** Input is RGB565
    */
    if ((filter_i == IPL_BLUR) ||
        (filter_i == IPL_BLUR_GAUSSIAN) ||
        (filter_i == IPL_BLUR_UNIFORM))
    {
      dataout_ptr = (uint16*)((uint32)output_img_ptr->imgPtr +
                              input_img_ptr->dx*2 + 2);
      /* Now loop through the image once */
      for(row = 1; row < (int32)output_img_ptr->dy-1; row++)
      {
        for(col = 1; col < (int32)output_img_ptr->dx-1; col++)
        {
          rout16 = (uint16)((*datain_ptr&0xF800)>>8);
          gout16 = (uint16)((*datain_ptr&0x07E0)>>3);
          bout16 = (uint16)((*datain_ptr&0x001F)<<3);
          datain_ptr++;
          rout16 += ((*datain_ptr&0xF800)>>8);
          gout16 += ((*datain_ptr&0x07E0)>>3);
          bout16 += ((*datain_ptr&0x001F)<<3);
          datain_ptr = datain_ptr + input_img_ptr->dx-1;
          rout16 += (uint16)((*datain_ptr&0xF800)>>8);
          gout16 += (uint16)((*datain_ptr&0x07E0)>>3);
          bout16 += (uint16)((*datain_ptr&0x001F)<<3);
          datain_ptr++;
          rout16 += ((*datain_ptr&0xF800)>>8);
          gout16 += ((*datain_ptr&0x07E0)>>3);
          bout16 += ((*datain_ptr&0x001F)<<3);
          rout16 = rout16 >>2;
          gout16 = gout16 >>2;
          bout16 = bout16 >>2;
          *dataout_ptr = pack_rgb565(rout16,gout16,bout16);
          dataout_ptr++;
          datain_ptr = datain_ptr - input_img_ptr->dx;
        } /* End of col loop */
        dataout_ptr = dataout_ptr + 2;
        datain_ptr = datain_ptr + 2;
      } /* End of row loop */

      /*
      ** Now copy over the top border row
      */
      datain_ptr = (uint16*)input_img_ptr->imgPtr;
      dataout_ptr = (uint16*)output_img_ptr->imgPtr;
      for(col = 0; col < (int32)output_img_ptr->dx; col++) {
        *dataout_ptr = *datain_ptr;
        dataout_ptr++;
        datain_ptr++;
      }

      /*
      ** Now copy over the bottom border row
      */
      datain_ptr = (uint16*)((uint32)input_img_ptr->imgPtr +
                   input_img_ptr->dx*(input_img_ptr->dy-1)*2);
      dataout_ptr = (uint16*)((uint32)output_img_ptr->imgPtr +
                    output_img_ptr->dx*(output_img_ptr->dy-1)*2);
      for(col = 0; col < (int32)output_img_ptr->dx; col++) {
        *dataout_ptr = *datain_ptr;
        dataout_ptr++;
        datain_ptr++;
      }

      /*
      ** Now copy over the Left Col
      */
      datain_ptr = (uint16*)input_img_ptr->imgPtr;
      dataout_ptr = (uint16*)output_img_ptr->imgPtr;
      for(col = 0; col < (int32)output_img_ptr->dy; col++) {
        *dataout_ptr = *datain_ptr;
        dataout_ptr+=input_img_ptr->dx;
        datain_ptr+=input_img_ptr->dx;
      }

      /*
      ** Now copy over the Right Col
      */
      datain_ptr = (uint16*)((uint32)input_img_ptr->imgPtr +
                            (input_img_ptr->dx-1)*2);
      dataout_ptr = (uint16*)((uint32)output_img_ptr->imgPtr +
                              (input_img_ptr->dx-1)*2);
      for(col = 0; col < (int32)output_img_ptr->dy; col++) {
        *dataout_ptr = *datain_ptr;
        dataout_ptr+=input_img_ptr->dx;
        datain_ptr+=input_img_ptr->dx;
      }
      retval = IPL_SUCCESS;
    }
    else
    {
      retval = IPL_FAILURE;
    } /* End HPF */
  }
  else if (input_img_ptr->cFormat == IPL_LUMA_ONLY)
  {
    uint8 * ptr8 = output_img_ptr->imgPtr;

    if ((filter_i == IPL_BLUR) ||
        (filter_i == IPL_BLUR_GAUSSIAN) ||
        (filter_i == IPL_BLUR_UNIFORM))
      filter = &lp_filter[0][0];
    else if (filter_i == IPL_SHARP)
    {
      //filter = hp_filter;
      filter = &lp_filter[0][0];
    }
    else
    {
      MSG_LOW("ipl_filter marker_202\n");
      return IPL_FAILURE;
    }
    /* Now loop through the image once */
    for(row = 0; row < (int32)output_img_ptr->dy; row++)
    {
      for(col = 0; col < (int32)output_img_ptr->dx; col++)
      {
        index = (col + row*output_img_ptr->dx);
        luma =  input_img_ptr->imgPtr[index];

        if ((row > 0) && (row < (int32) output_img_ptr->dy-1) &&
            (col > 0) && (col < (int32) output_img_ptr->dx-1))
        {
          g = 0;
          cr = index-1-(input_img_ptr->dx); /* Points to top left */
          for (i = 0; i < 3; i++)
          {
            for (j = 0; j < 3; j++)
            {
              r = cr+((i*output_img_ptr->dx + j));
              g = g + *(filter+j+i*3)*input_img_ptr->imgPtr[r];
            }
          }
          g = g>>4;
          luma = CLIPIT(g);
        }
        *ptr8++ = (uint8) luma;
      }
    }
    retval = IPL_SUCCESS;
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_filter marker_100\n");
  else
    MSG_LOW("ipl_filter marker_203\n");

  return retval;
} /* End ipl_filter */



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_image_grayscale

DESCRIPTION
  This function converts a color YCbCr 4:2:2 or YCbCr 4:2:0 line packed image
  to grayscale by ignoring the chroma component.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr   pointer to the input image
  output_img_ptr  pointer to the output image

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_image_grayscale
(
  ipl_image_type* input_img_ptr,         /* Points to the input image      */
  ipl_image_type* output_img_ptr         /* Points to the output image     */
)
{
  uint32 row, col, index, luma1, luma2, luma3, luma4, w, h, r, g, b;
  unsigned short out1;

  MSG_LOW("ipl_image_grayscale marker_0\n");

  if (!input_img_ptr  || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_image_grayscale marker_200\n");
    return IPL_FAILURE;
  }

  if ((input_img_ptr->dy != output_img_ptr->dy) ||
      (input_img_ptr->dx != output_img_ptr->dx))
  {
    MSG_LOW("ipl_image_grayscale marker_201\n");
    /* Input and output sizes should be equal */
    return IPL_FAILURE;
  }

  luma1 = luma2 = 0;
  w = input_img_ptr->dx;
  h = input_img_ptr->dy;

  MSG_LOW("ipl_image_grayscale marker_1\n");

  if (input_img_ptr->cFormat == IPL_YCbCr)
  {
    if (output_img_ptr->cFormat == IPL_RGB565)
    {
      for(row = 0; row < h; row++)
      {
        for(col = 0; col < w; col++)
        {
          index = (((row*w) + col)<<1)+1;

          if (!(col%2))
          {
            /* This is CbY */
            luma1 = input_img_ptr->imgPtr[index]; /* byte addressed */
          }
          else
          {
            /* This is CrY */
            luma2 = input_img_ptr->imgPtr[index];

            /* Need to convert YCbCr 4:2:2 to RGB565 */
            /* YCbCr2RGB lags behind by 2 pixels always */
            r = luma1;
            g = luma1;
            b = luma1;

            /*
            ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
            ** Order of the 2 bytes is R5G3 G3B5
            */
            out1 = pack_rgb565(r,g,b);
            *((unsigned short *)(output_img_ptr->imgPtr + (col-1+row*w)*2)) =
              (unsigned short)out1;
            r = luma2;
            g = luma2;
            b = luma2;
            out1 = pack_rgb565(r,g,b);
            *((unsigned short*)(output_img_ptr->imgPtr + (col+row*w)*2)) =
              (unsigned short)out1;
          }
        }
      }
    }
    else if (output_img_ptr->cFormat == IPL_YCbCr)
    {
      uint8 * inputImgPtr = input_img_ptr->imgPtr;
      uint8 * outputImgPtr = output_img_ptr->imgPtr;

      for(row = 0; row < h; row++)
      {
        for(col = 0; col < w/2; col++)
        {
          *outputImgPtr++ = 128;
          inputImgPtr++;

          *outputImgPtr++ = *inputImgPtr++;

          *outputImgPtr++ = 128;
          inputImgPtr++;

          *outputImgPtr++ = *inputImgPtr++;
        }
      }
    }
    else
    {
      MSG_LOW("ipl_image_grayscale marker_202\n");
      return IPL_FAILURE;
    }
  }
  else if ((input_img_ptr->cFormat == IPL_YCrCb420_LINE_PK) ||
           (input_img_ptr->cFormat == IPL_YCbCr420_LINE_PK))
  {
    if (output_img_ptr->cFormat == IPL_RGB565)
    {
      uint8 * inputImgPtr = input_img_ptr->imgPtr;
      uint16* outputImgPtr = (uint16 *) output_img_ptr->imgPtr;

      // initialze color tables
      if ( ipl2_init() != IPL_SUCCESS )
        return IPL_FAILURE;

      for(row = 0; row < h/2; row++)
      {
        for(col = 0; col < w/2; col++)
        {
          luma1 = *inputImgPtr;
          luma2 = *(inputImgPtr++ + w);
          luma3 = *inputImgPtr;
          luma4 = *(inputImgPtr++ + w);

          out1 = pack_rgb565(luma1,luma1, luma1);
          *outputImgPtr = out1;

          out1 = pack_rgb565(luma2,luma2, luma2);
          *(outputImgPtr++ + w) = out1;

          out1 = pack_rgb565(luma3,luma3, luma3);
          *(outputImgPtr) = out1;

          out1 = pack_rgb565(luma4,luma4, luma4);
          *(outputImgPtr++ + w) = out1;
        }
        outputImgPtr += w;
        inputImgPtr += w;
      }
    }
    else if ((output_img_ptr->cFormat == IPL_YCrCb420_LINE_PK) ||
             (output_img_ptr->cFormat == IPL_YCbCr420_LINE_PK))
    {
      uint8 * inputImgPtr = input_img_ptr->imgPtr;
      uint8 * outputImgPtr = output_img_ptr->imgPtr;

      // copy over luma
      for(index = 0; index < w*h; index++)
        *outputImgPtr++ = *inputImgPtr++;

      // set chroma to 128
      outputImgPtr = output_img_ptr->clrPtr;
      for(index = 0; index < w*h/2; index++)
        *outputImgPtr++ = 128;
    }
    else
    {
      MSG_LOW("ipl_image_grayscale marker_203\n");
      return IPL_FAILURE;
    }
  }
  MSG_LOW("ipl_image_grayscale marker_100\n");
  return IPL_SUCCESS;
}




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_image_negative

DESCRIPTION
  This function will negate an image.
  The output is in YCbCr format or in RGB 565 format.
  The input is assumed to be in YCbCr format.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_image_negative
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr         /* Points to the output image     */
)
{
  /* Take an image of size of any size and converts it to black and white
  */
  uint32 row,col,index;
  uint32 luma1=0,luma2=0;
  unsigned short out;
  uint32 cb=0,cr=0;
  long rc,gc,bc,r,g,b;
  /* ycbcr_convert is the conversion array of coeffs in Q14 Signed */
  /* In Q0, coeffs are = 4.8828e-4 1.57489 -0.18744 -0.46826 1.8554 7.3242e-4 */
  short ycbcr_convert[6] = {8, 25803, -3071, -7672,30399,12};
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  boolean convert = TRUE;

  MSG_LOW("ipl_image_negative marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_image_negative marker_200\n");
    return IPL_FAILURE;
  }

  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;



  if (input_img_ptr->cFormat != IPL_YCbCr)
  {
    MSG_LOW("ipl_image_negative marker_201\n");
    /* Only YCbCr Input format currently supported */
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat == input_img_ptr->cFormat)
  {
    /* We don't need to color convert */
    convert = FALSE;
  }

  MSG_LOW("ipl_image_negative marker_1\n");

  if (!((input_img_ptr->dy == output_img_ptr->dy) &&
        (input_img_ptr->dx == output_img_ptr->dx)))
  {
    MSG_LOW("ipl_image_negative marker_202\n");
    /* Input and output image should be of same size */
    return IPL_FAILURE;
  } else {
    /* Now loop through the image once */
    for(row = 0; row < input_img_ptr->dy; row++){
      for(col = 0; col < (input_img_ptr->dx); col++){
        index = ((row*input_img_ptr->dx) + col)<<1;
        /* First Byte is is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
        if (!(col%2)) {
          /* This is Cb */
          cb = 255 - input_img_ptr->imgPtr[index];
          index +=1;
          /* Next Byte is the luma */
          luma1 =  255 - input_img_ptr->imgPtr[index]; //Byte addressed
        } else {
          /* This is Cr */
          cr = 255 - input_img_ptr->imgPtr[index];
          index +=1;
          /* Next Byte is the luma */
          luma2 = 255 - input_img_ptr->imgPtr[index];
          if (convert)
          {
            /* YCbCr2RGB lags behind by 2 pixels always */
            rc = (ycbcr_convert[0]*(cb-128) + ycbcr_convert[1]*(cr-128))*4+0x8000;
            gc = (ycbcr_convert[2]*(cb-128) + ycbcr_convert[3]*(cr-128))*4+0x8000;
            bc = (ycbcr_convert[4]*(cb-128) + ycbcr_convert[5]*(cr-128))*4+0x8000;
            r = luma1 + (rc>>16);
            g = luma1 + (gc>>16);
            b = luma1 + (bc>>16);
	          r = CLIPIT(r);
	          g = CLIPIT(g);
	          b = CLIPIT(b);
            /*
            ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
            ** Order of the 2 bytes is R5G3 G3B5
            */
            out = pack_rgb565(r,g,b);
            *((unsigned short *)(output_img_ptr->imgPtr + (col-1+row*(output_img_ptr->dx))*2) )= (unsigned short) out;
            r = luma2 + (rc>>16);
            g = luma2 + (gc>>16);
            b = luma2 + (bc>>16);
	          r = CLIPIT(r);
	          g = CLIPIT(g);
	          b = CLIPIT(b);
            out = pack_rgb565(r,g,b);
            *((unsigned short*)(output_img_ptr->imgPtr + (col+row*(output_img_ptr->dx))*2 ) )= (unsigned short) out;
          } else {
            /* Dont need to RGB conversion, simply output data in YCbCr format */
            output_img_ptr->imgPtr[index] =  (unsigned char)luma2;
            output_img_ptr->imgPtr[index-2] =  (unsigned char)luma1;
            output_img_ptr->imgPtr[index-1] =  (unsigned char)cr;
            output_img_ptr->imgPtr[index-3] =  (unsigned char)cb;
          }
        } /* end of Cb Cr */
      } /* End of col loop */
    } /* End of row loop */
  }
  MSG_LOW("ipl_image_negative marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_image_negative */




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_image_posterize

DESCRIPTION
  This function posterizes an image. The number of quantization levels must
  be within the range [1..255].
  Input must be in YCbCr 4:2:2 or YCbCr 4:2:0 line packed.
  Output must be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr   pointer to the input image
  output_img_ptr  pointer to the output image
  steps           number of quantization levels (range is [1..255])

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_image_posterize
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  uint8 steps                        /* Number of quantization levels  */
)
{
  int32 index, luma1, luma2, cb, cr, rc, gc, bc, r, g, b;
  uint32 row, col, w, h;
  uint16 out;
  uint8 level;
  boolean convert = FALSE;
  uint8* inputImgPtr;
  uint8* outputImgPtr;
  int16 ycbcr_convert[6] = {8, 25803, -3071, -7672, 30399, 12};

  ipl_image_type input422_img;
  ipl_image_type output422_img;

  MSG_LOW("ipl_image_posterize marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_image_posterize marker_200\n");
    return IPL_FAILURE;
  }

  inputImgPtr = i_img_ptr->imgPtr;
  outputImgPtr = o_img_ptr->imgPtr;

  w = o_img_ptr->dx;
  h = o_img_ptr->dy;

  if (i_img_ptr->dy != h && i_img_ptr->dx != w)
  {
    MSG_LOW("ipl_image_posterize marker_201\n");
    return IPL_FAILURE;
  }

  // if steps is 0, then do nothing
  if (steps == 0)
  {
    return(ipl_convert_image(i_img_ptr, o_img_ptr));
  }

  level = 255/steps;


  if (i_img_ptr->cFormat == IPL_YCbCr ||
      i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK ||
      i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK)
      {
        if (o_img_ptr->cFormat == IPL_RGB565)
          convert = TRUE;
        else
          convert = FALSE;
      }
      else
      {
        MSG_LOW("ipl_image_posterize marker_203\n");
        return IPL_FAILURE;
      }

  MSG_LOW("ipl_image_posterize marker_1\n");

  if (i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
      i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    input422_img.cFormat = IPL_YCbCr;
    input422_img.dx = w;
    input422_img.dy = h;
    if (ipl_malloc_img(&input422_img))
    {
      MSG_LOW("ipl_image_posterize marker_204\n");
      return IPL_NO_MEMORY;
    }
    ipl_convert_image(i_img_ptr, &input422_img);


    inputImgPtr = input422_img.imgPtr;

    if (convert)
    {
      outputImgPtr = o_img_ptr->imgPtr;
    }
    else
    {
      /* Convert to YCbCr 4:2:0 line packed format */
      output422_img.dx = w;
      output422_img.dy = h;
      output422_img.cFormat = IPL_YCbCr;
      if (ipl_malloc_img(&output422_img))
      {
        ipl_free_img(&input422_img);
        MSG_LOW("ipl_image_posterize marker_205\n");
        return IPL_NO_MEMORY;
      }
      outputImgPtr = output422_img.imgPtr;
    }
  }
  else
  {
    inputImgPtr = i_img_ptr->imgPtr;
    outputImgPtr = o_img_ptr->imgPtr;
  }


  /* Now loop through the image once */
  for(row = 0; row < h; row++)
  {
    for(col = 0; col < w; col+=2)
    {
      index = (col + row*w)<<1;  /* byte addressed */

      /* First byte is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
      cb = inputImgPtr[index];

      /* Next byte is luma */
      luma1 = inputImgPtr[index+1];

      /* This is Cr */
      cr = inputImgPtr[index+2];

      /* Next byte is luma */
      luma2 = inputImgPtr[index+3];

      /*
      ** Now Posterize
      */
      rc = ((int16)(luma1+(level>>1))/level)*level;
      bc = ((int16)(luma2+(level>>1))/level)*level;
      luma1 = (uint8)rc;
      luma2 = (uint8)bc;

      if (convert)
      {
        /* Input is YCbCr 4:2:2, Output is RGB */
        /* Convert input to RGB and write output */
        rc = (ycbcr_convert[0]*(cb-128)+ycbcr_convert[1]*(cr-128))*4+0x8000;
        gc = (ycbcr_convert[2]*(cb-128)+ycbcr_convert[3]*(cr-128))*4+0x8000;
        bc = (ycbcr_convert[4]*(cb-128)+ycbcr_convert[5]*(cr-128))*4+0x8000;
        r = luma1 + (rc>>16);
        g = luma1 + (gc>>16);
        b = luma1 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);

        /*
        ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
        ** Order of the 2 bytes is R5G3 G3B5
        */
        out = pack_rgb565(r,g,b);
        *((unsigned short*)(outputImgPtr + index)) = (unsigned short)out;
        r = luma2 + (rc>>16);
        g = luma2 + (gc>>16);
        b = luma2 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);
        out = pack_rgb565(r,g,b);
        *((unsigned short*)(outputImgPtr + index+2))= (unsigned short)out;
      }
      else
      {
        /* Input is YCbCr 4:2:2, Output is YCbCr 4:2:2 */
        outputImgPtr[index] = (unsigned char) cb;
        outputImgPtr[index+1] = (unsigned char)luma1;
        outputImgPtr[index+2] = (unsigned char) cr;
        outputImgPtr[index+3] = (unsigned char)luma2;
      }
    } /* End of col loop */
  } /* End of row loop */

  if (o_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
      o_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    ipl_convert_image(&output422_img, o_img_ptr);
  }

  if (i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
      i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    /* The input422_img is allocated only for 420 line packed formats */
    ipl_free_img(&input422_img);

    /* The output422_img is allocated only when convert is false */
    if (!convert)
      ipl_free_img(&output422_img);
  }

  MSG_LOW("ipl_image_posterize marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_image_posterize */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_image_solarize

DESCRIPTION
  This function solarizes an image. The threshold value for solarization
  must be in the range [0..255].
  Input must be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.
  Output must be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr    pointer to the input image
  output_img_ptr   pointer to the output image
  thresh           threshold value used for inversion (range is [0..255])
                   128 is a good default.

RETURN VALUE
  IPL_SUCCESS      indicates operation was successful
  IPL_FAILURE      otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_image_solarize
(
  ipl_image_type* input_img_ptr,         /* Points to the input image      */
  ipl_image_type* output_img_ptr,         /* Points to the output image     */
  uint8 thresh                       /* Threshold to use for inversion */
)
{
  int32 index, luma1, luma2, cb, cr, rc, gc, bc, r, g, b, r2, g2, b2;
  uint32 row, col, w, h;
  uint16 out, out2;
  uint8 r8, g8, b8;

  uint8* inputImgPtr = NULL;
  uint8* outputImgPtr = NULL;
  uint8* iclrPtr;
  uint8* oclrPtr;

  uint16* in16_ptr;
  uint16* out16_ptr;
  ipl_image_type *o_img_ptr;
  ipl_image_type *i_img_ptr;


  /* ycbcr_convert is the conversion array of coeffs in Q14 Signed */
  /* In Q0, coeffs are 4.8828e-4 1.57489 -0.18744 -0.46826 1.8554 7.3242e-4 */
  int16 ycbcr_convert[6] = {8, 25803, -3071, -7672, 30399, 12};
  int16 rgb2ycbcr_convert[9] =
  {4210,8257,1605,-2424,-4767,7192,7192,-6029,-1163};

  MSG_LOW("ipl_image_solarize marker_0\n");


  // see if we are doing this inplace
  if (output_img_ptr == NULL)
  {
    o_img_ptr = input_img_ptr;
  }
  else
  {
    o_img_ptr = output_img_ptr;
  }
  i_img_ptr = input_img_ptr;


  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_sketch marker_200\n");
    return IPL_FAILURE;
  }

  w = o_img_ptr->dx;
  h = o_img_ptr->dy;

  if (!((i_img_ptr->dx == w) && (i_img_ptr->dy == h)))
  {
    MSG_LOW("ipl_sketch marker_201\n");
    return IPL_FAILURE;
  }


  MSG_LOW("ipl_image_solarize marker_1\n");

  // if threshold is 0, then do nothing
  if (thresh == 0)
  {
    return(ipl_convert_image(i_img_ptr, o_img_ptr));
  }


  if (i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
      i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    if (o_img_ptr->cFormat == IPL_RGB565)
      return IPL_FAILURE;

    /* Now loop through the image once */
    iclrPtr = i_img_ptr->clrPtr;
    oclrPtr = o_img_ptr->clrPtr;
    inputImgPtr  = i_img_ptr->imgPtr;
    outputImgPtr = o_img_ptr->imgPtr;

    for(row = 0; row < h; row += 2)
    {
      for(col = 0; col < w; col +=2)
      {
        cr = *iclrPtr++;
        cb = *iclrPtr++;

        // first pixel
        luma1 = *inputImgPtr;

        /* Convert input to RGB and write output */
        rc = (ycbcr_convert[0]*(cb-128)+ycbcr_convert[1]*(cr-128))*4+0x8000;
        gc = (ycbcr_convert[2]*(cb-128)+ycbcr_convert[3]*(cr-128))*4+0x8000;
        bc = (ycbcr_convert[4]*(cb-128)+ycbcr_convert[5]*(cr-128))*4+0x8000;
        r = luma1 + (rc>>16);
        g = luma1 + (gc>>16);
        b = luma1 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);

        /*
        ** Now Solarize
        */
        if (r>thresh)
        {
          r = 255 - r;
        }
        if (g>thresh)
        {
          g = 255 - g;
        }
        if (b>thresh)
        {
          b = 255 - b;
        }

        /* Input is YCbCr, Output is YCbCr */
        /* Convert from RGB to YCbCr */
        luma1 = (rgb2ycbcr_convert[0]*r + rgb2ycbcr_convert[1]*g +
                rgb2ycbcr_convert[2]*b)*4+0x8000;
        luma1 = (luma1>>16) + 16;
        luma1 = CLIPIT(luma1);

        // write out first pixel
        *outputImgPtr = luma1;



        // second pixel
        luma1 = *(inputImgPtr+1);

        /* Convert input to RGB and write output */
        rc = (ycbcr_convert[0]*(cb-128)+ycbcr_convert[1]*(cr-128))*4+0x8000;
        gc = (ycbcr_convert[2]*(cb-128)+ycbcr_convert[3]*(cr-128))*4+0x8000;
        bc = (ycbcr_convert[4]*(cb-128)+ycbcr_convert[5]*(cr-128))*4+0x8000;
        r = luma1 + (rc>>16);
        g = luma1 + (gc>>16);
        b = luma1 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);

        /*
        ** Now Solarize
        */
        if (r>thresh)
        {
          r = 255 - r;
        }
        if (g>thresh)
        {
          g = 255 - g;
        }
        if (b>thresh)
        {
          b = 255 - b;
        }

        /* Input is YCbCr, Output is YCbCr */
        /* Convert from RGB to YCbCr */
        luma1 = (rgb2ycbcr_convert[0]*r + rgb2ycbcr_convert[1]*g +
                rgb2ycbcr_convert[2]*b)*4+0x8000;
        luma1 = (luma1>>16) + 16;
        luma1 = CLIPIT(luma1);

        // write out second pixel
        *(outputImgPtr + 1) = luma1;





        // third pixel
        luma1 = *(inputImgPtr+w);

        /* Convert input to RGB and write output */
        rc = (ycbcr_convert[0]*(cb-128)+ycbcr_convert[1]*(cr-128))*4+0x8000;
        gc = (ycbcr_convert[2]*(cb-128)+ycbcr_convert[3]*(cr-128))*4+0x8000;
        bc = (ycbcr_convert[4]*(cb-128)+ycbcr_convert[5]*(cr-128))*4+0x8000;
        r = luma1 + (rc>>16);
        g = luma1 + (gc>>16);
        b = luma1 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);

        /*
        ** Now Solarize
        */
        if (r>thresh)
        {
          r = 255 - r;
        }
        if (g>thresh)
        {
          g = 255 - g;
        }
        if (b>thresh)
        {
          b = 255 - b;
        }

        /* Input is YCbCr, Output is YCbCr */
        /* Convert from RGB to YCbCr */
        luma1 = (rgb2ycbcr_convert[0]*r + rgb2ycbcr_convert[1]*g +
                rgb2ycbcr_convert[2]*b)*4+0x8000;
        luma1 = (luma1>>16) + 16;
        luma1 = CLIPIT(luma1);

        // write out third pixel
        *(outputImgPtr + w) = luma1;




        // fourth pixel
        luma1 = *(inputImgPtr+w + 1);

        /* Convert input to RGB and write output */
        rc = (ycbcr_convert[0]*(cb-128)+ycbcr_convert[1]*(cr-128))*4+0x8000;
        gc = (ycbcr_convert[2]*(cb-128)+ycbcr_convert[3]*(cr-128))*4+0x8000;
        bc = (ycbcr_convert[4]*(cb-128)+ycbcr_convert[5]*(cr-128))*4+0x8000;
        r = luma1 + (rc>>16);
        g = luma1 + (gc>>16);
        b = luma1 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);

        /*
        ** Now Solarize
        */
        if (r>thresh)
        {
          r = 255 - r;
        }
        if (g>thresh)
        {
          g = 255 - g;
        }
        if (b>thresh)
        {
          b = 255 - b;
        }

        /* Input is YCbCr, Output is YCbCr */
        /* Convert from RGB to YCbCr */
        luma1 = (rgb2ycbcr_convert[0]*r + rgb2ycbcr_convert[1]*g +
                rgb2ycbcr_convert[2]*b)*4+0x8000;
        luma1 = (luma1>>16) + 16;
        luma1 = CLIPIT(luma1);
        cb = (rgb2ycbcr_convert[3]*r + rgb2ycbcr_convert[4]*g +
              rgb2ycbcr_convert[5]*b)*4+0x8000;
        cb = (cb>>16) + 128;
        cb = CLIPIT(cb);

        cr = (rgb2ycbcr_convert[6]*r + rgb2ycbcr_convert[7]*g +
              rgb2ycbcr_convert[8]*b)*4+0x8000;
        cr = (cr>>16) + 128;

        // write out fourth pixel
        *(outputImgPtr + w + 1) = luma1;


        // increment luma ptrs
        outputImgPtr += 2;
        inputImgPtr += 2;


        // write out and increment chroma values
        *oclrPtr++ = cr;
        *oclrPtr++ = cb;
      }

      inputImgPtr += w;
      outputImgPtr += w;
    }
  }
  else if (i_img_ptr->cFormat == IPL_YCbCr)
  {
    inputImgPtr  = i_img_ptr->imgPtr;
    outputImgPtr = o_img_ptr->imgPtr;

    /* Now loop through the image once */
    for(row = 0; row < h; row++)
    {
      for(col = 0; col < w; col+=2)
      {
        index = (col + row*w)<<1;  /* byte addressed */
        /* First byte is is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
        cb = inputImgPtr[index];
        /* Next Byte is luma */
        luma1 = inputImgPtr[index+1];
        /* This is Cr */
        cr = inputImgPtr[index+2];
        /* Next Byte is luma */
        luma2 = inputImgPtr[index+3];

        /* Convert input to RGB and write output */
        rc = (ycbcr_convert[0]*(cb-128)+ycbcr_convert[1]*(cr-128))*4+0x8000;
        gc = (ycbcr_convert[2]*(cb-128)+ycbcr_convert[3]*(cr-128))*4+0x8000;
        bc = (ycbcr_convert[4]*(cb-128)+ycbcr_convert[5]*(cr-128))*4+0x8000;
        r = luma1 + (rc>>16);
        g = luma1 + (gc>>16);
        b = luma1 + (bc>>16);
        r=CLIPIT(r);
        g=CLIPIT(g);
        b=CLIPIT(b);
        /*
        ** Now Solarize
        */
        if (r>thresh)
        {
          r = 255 - r;
        }
        if (g>thresh)
        {
          g = 255 - g;
        }
        if (b>thresh)
        {
          b = 255 - b;
        }
        /*
        ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
        ** Order of the 2 bytes is R5G3 G3B5
        */
        out = pack_rgb565(r,g,b);
        r2 = luma2 + (rc>>16);
        g2 = luma2 + (gc>>16);
        b2 = luma2 + (bc>>16);
        r2 = CLIPIT(r2);
        g2 = CLIPIT(g2);
        b2 = CLIPIT(b2);
        /*
        ** Now Solarize
        */
        if (r2 > thresh)
        {
          r2 = 255 - r2;
        }
        if (g2 > thresh)
        {
          g2 = 255 - g2;
        }
        if (b2 > thresh)
        {
          b2 = 255 - b2;
        }
        out2 = pack_rgb565(r2,g2,b2);
        if (o_img_ptr->cFormat == IPL_RGB565)
        {
          /* Input is YCbCr, Output is RGB */
          *((unsigned short*)(outputImgPtr + index)) = (unsigned short)out;
          *((unsigned short*)(outputImgPtr + index+2))= (unsigned short)out2;
        }
        else
        {
          /* Input is YCbCr, Output is YCbCr */
          /* Convert from RGB to YCbCr */
          luma1 = (rgb2ycbcr_convert[0]*r + rgb2ycbcr_convert[1]*g +
               rgb2ycbcr_convert[2]*b)*4+0x8000;
          luma1 = (luma1>>16) + 16;
          luma1 = CLIPIT(luma1);
          cb = (rgb2ycbcr_convert[3]*r + rgb2ycbcr_convert[4]*g +
            rgb2ycbcr_convert[5]*b)*4+0x8000;
          cb = (cb>>16) + 128;
          cb = CLIPIT(cb);
          /* 2nd pixel */
          luma2 = (rgb2ycbcr_convert[0]*r2 + rgb2ycbcr_convert[1]*g2 +
               rgb2ycbcr_convert[2]*b2)*4+0x8000;
          luma2 = (luma2>>16) + 16;
          luma2 = CLIPIT(luma2);
          cr = (rgb2ycbcr_convert[6]*r2 + rgb2ycbcr_convert[7]*g2 +
            rgb2ycbcr_convert[8]*b2)*4+0x8000;
          cr = (cr>>16) + 128;
          cr = CLIPIT(cr);
          outputImgPtr[index] = (unsigned char) cb;
          outputImgPtr[index+1] = (unsigned char)luma1;
          outputImgPtr[index+2] = (unsigned char) cr;
          outputImgPtr[index+3] = (unsigned char)luma2;
        }
        } /* End of col loop */
      } /* End of row loop */
  }
  else
  {
    in16_ptr = (uint16*) i_img_ptr->imgPtr;
    out16_ptr = (uint16*) o_img_ptr->imgPtr;

    /*
    ** Input is RGB565. Only RGB565 output is supported.
    */
    /* Now loop through the image once */
    for(row = 0; row < h; row++)
    {
      for(col = 0; col < w; col++)
      {
        unpack_rgb565(*in16_ptr++,&r8,&g8,&b8);
        /*
        ** Now Solarize
        */
        if (r8>thresh)
          r8 = 255 - r8;
        if (g8>thresh)
          g8 = 255 - g8;
        if (b8>thresh)
          b8 = 255 - b8;

        /*
        ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
        ** Order of the 2 bytes is R5G3 G3B5
        */
        out = pack_rgb565(r8,g8,b8);
        *out16_ptr++ = out;
      } /* End of col loop */
    } /* End of row loop */
  }


  MSG_LOW("ipl_image_solarize marker_100\n");

  return IPL_SUCCESS;

}



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_set_contrast_Nentries

DESCRIPTION
  This function warps the gamma table for a particular contrast. Outputs
  8 bit values.

DEPENDENCIES
  None

ARGUMENTS IN
  contrast        decides which Sigmoid LUT to use (must be between 0 and 10)
  ibits           number of bits needed to represent number of table entires
                  (8-bit, 10-bit, etc)
  input_table     input gamma table

ARGUMENTS OUT
  output_table    output gamma table

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_set_contrast_Nentries
(
  int32   contrast,
  int32   ibits,
  uint8*  input_table,               /* Input gamma table             */
  uint8*  output_table               /* Output gamma table            */
)
{
  int i;
  int entries;
  const uint16 * gamma_table;

  //MSG_LOW("ipl_set_contrast_Nentries marker_0\n");

  entries = (1 << ibits);

  /* Apply Sigmoid Gamma Table */
  if (input_table == NULL || output_table == NULL)
  {
    MSG_LOW("ipl_set_contrast_Nentries marker_200\n");
    return IPL_FAILURE;
  }

  switch (contrast)
  {
    case 10:
      gamma_table = ipl_gammaSigmoid2_4;
    break;
    case 9:
      gamma_table = ipl_gammaSigmoid2_1;
    break;
    case 8:
      gamma_table = ipl_gammaSigmoid1_8;
    break;
    case 7:
      gamma_table = ipl_gammaSigmoid1_5;
    break;
    case 6:
      gamma_table = ipl_gammaSigmoid1_2;
    break;
    case 5:
      /* the input and output table are the same */
      for (i = 0;i<entries;i++)
        output_table[i] = input_table[i];
      //MSG_LOW("ipl_set_contrast_Nentries marker_100\n");
      return IPL_SUCCESS;
    case 4:
      gamma_table = ipl_gammaSigmoid0_9;
    break;
    case 3:
      gamma_table = ipl_gammaSigmoid0_8;
    break;
    case 2:
      gamma_table = ipl_gammaSigmoid0_7;
    break;
    case 1:
      gamma_table = ipl_gammaSigmoid0_6;
    break;
    case 0:
      gamma_table = ipl_gammaSigmoid0_5;
    break;
    default:
      MSG_LOW("ipl_set_contrast_Nentries marker_201\n");
      return IPL_FAILURE;
  }

  /* do look up */
  for (i = 0; i < entries; i++)
  {
    output_table[i] = (uint8) gamma_table[input_table[i]];
  }

  MSG_LOW("ipl_set_contrast_Nentries marker_101\n");

  return IPL_SUCCESS;
} /* End ipl_set_contrast */




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_set_contrast

DESCRIPTION
  This function warps the gamma table for a particular contrast.

DEPENDENCIES
  None

ARGUMENTS IN
  contrast        decides which Sigmoid LUT to use (must be between 0 and 10)
  input_table     input gamma table

ARGUMENTS OUT
  output_table    output gamma table

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_set_contrast
(
  int32   contrast,
  uint16* input_table,               /* Input gamma table             */
  uint16* output_table               /* Output gamma table            */
)
{
  int i;
  const uint16 * gamma_table;

  /* Apply Sigmoid Gamma Table */
  if (input_table == NULL || output_table == NULL)
  {
    MSG_LOW("ipl_set_contrast marker_200\n");
    return IPL_FAILURE;
  }

  switch (contrast)
  {
    case 10:
      gamma_table = ipl_gammaSigmoid2_4;
    break;
    case 9:
      gamma_table = ipl_gammaSigmoid2_1;
    break;
    case 8:
      gamma_table = ipl_gammaSigmoid1_8;
    break;
    case 7:
      gamma_table = ipl_gammaSigmoid1_5;
    break;
    case 6:
      gamma_table = ipl_gammaSigmoid1_2;
    break;
    case 5:
      /* the input and output table are the same */
      for (i = 0;i<256;i++)
        output_table[i] = input_table[i];
      return IPL_SUCCESS;
    case 4:
      gamma_table = ipl_gammaSigmoid0_9;
    break;
    case 3:
      gamma_table = ipl_gammaSigmoid0_8;
    break;
    case 2:
      gamma_table = ipl_gammaSigmoid0_7;
    break;
    case 1:
      gamma_table = ipl_gammaSigmoid0_6;
    break;
    case 0:
      gamma_table = ipl_gammaSigmoid0_5;
    break;
    default:
      MSG_LOW("ipl_set_contrast marker_201\n");
      return IPL_FAILURE;
  }

  /* do look up */
  for (i = 0;i<256;i++)
  {
    output_table[i] = gamma_table[input_table[i]];
  }

  MSG_LOW("ipl_set_contrast marker_101\n");

  return IPL_SUCCESS;
} /* End ipl_set_contrast */

/* <EJECT> */
/*===========================================================================

FUNCTION ipl_set_contrast_8bit

DESCRIPTION
  This function warps the gamma table for a particular contrast.

DEPENDENCIES
  None

ARGUMENTS IN
  contrast        decides which Sigmoid LUT to use (must be between 0 and 10)
  input_table     input gamma table

ARGUMENTS OUT
  output_table    output gamma table

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_set_contrast_8bit
(
  int32   contrast,
  uint8* input_table,               /* Input gamma table             */
  uint8* output_table               /* Output gamma table            */
)
{
  int i;
  const uint16 * gamma_table;

  /*MSG_LOW("ipl_set_contrast_8bit marker_0\n");*/

  /* Apply Sigmoid Gamma Table */
  if (input_table == NULL || output_table == NULL)
  {
    MSG_LOW("ipl_set_contrast_8bit marker_200\n");
    return IPL_FAILURE;
  }

  switch (contrast)
  {
    case 10:
      gamma_table = ipl_gammaSigmoid2_4;
    break;
    case 9:
      gamma_table = ipl_gammaSigmoid2_1;
    break;
    case 8:
      gamma_table = ipl_gammaSigmoid1_8;
    break;
    case 7:
      gamma_table = ipl_gammaSigmoid1_5;
    break;
    case 6:
      gamma_table = ipl_gammaSigmoid1_2;
    break;
    case 5:
      /* the input and output table are the same */
      for (i = 0;i<256;i++)
        output_table[i] = input_table[i];
      /*MSG_LOW("ipl_set_contrast_8bit marker_100\n");*/
      return IPL_SUCCESS;
    case 4:
      gamma_table = ipl_gammaSigmoid0_9;
    break;
    case 3:
      gamma_table = ipl_gammaSigmoid0_8;
    break;
    case 2:
      gamma_table = ipl_gammaSigmoid0_7;
    break;
    case 1:
      gamma_table = ipl_gammaSigmoid0_6;
    break;
    case 0:
      gamma_table = ipl_gammaSigmoid0_5;
    break;
    default:
      MSG_LOW("ipl_set_contrast_8bit marker_201\n");
      return IPL_FAILURE;
  }

  /* do look up */
  for (i = 0;i<256;i++)
  {
    output_table[i] = (uint8) gamma_table[input_table[i]];
  }

  MSG_LOW("ipl_set_contrast_8bit marker_101\n");

  return IPL_SUCCESS;
} /* End ipl_set_contrast */




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_DoContrast

DESCRIPTION
  This function modifies contrast for a given input image.


DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image (set to NULL if want inplace)
  curve          how to adjust gamma. 0 = no change. 1-5 mean more contrast
                 -1 to -5 mean less contrast.


RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_DoContrast
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  int32 contrast                     /* how to adjust the gamma        */
)
{
  uint32 row;
  ipl_status_type retval = IPL_FAILURE;
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  register uint16* dataout_ptr;
  register uint16* datain_ptr;
  register uint16 rout16,gout16,bout16;
  uint32 dx;
  uint32 dy;
  const uint16 * gamma_table;

  MSG_LOW("ipl_DoContrast marker_0\n");

  // see if we are doing this inplace
  if (o_img_ptr == NULL)
  {
    output_img_ptr = i_img_ptr;
  }
  else
  {
    output_img_ptr = o_img_ptr;
  }
  input_img_ptr = i_img_ptr;


  if (!input_img_ptr || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_DoContrast marker_200\n");
    return IPL_FAILURE;
  }

  dx = output_img_ptr->dx;
  dy = output_img_ptr->dy;

  if (!((input_img_ptr->dx == dx) && (input_img_ptr->dy == dy)))
  {
    MSG_LOW("ipl_DoContrast marker_201\n");
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat != input_img_ptr->cFormat)
  {
    MSG_LOW("ipl_DoContrast marker_202\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_DoContrast marker_1\n");

  // setup table

  switch (contrast)
  {
    case 5:
      gamma_table = ipl_gammaSigmoid2_4;
    break;
    case 4:
      gamma_table = ipl_gammaSigmoid2_1;
    break;
    case 3:
      gamma_table = ipl_gammaSigmoid1_8;
    break;
    case 2:
      gamma_table = ipl_gammaSigmoid1_5;
    break;
    case 1:
      gamma_table = ipl_gammaSigmoid1_2;
    break;
    case 0:
      gamma_table = ipl_gammaSigmoid1_0;
    break;
    case -1:
      gamma_table = ipl_gammaSigmoid0_9;
    break;
    case -2:
      gamma_table = ipl_gammaSigmoid0_8;
    break;
    case -3:
      gamma_table = ipl_gammaSigmoid0_7;
    break;
    case -4:
      gamma_table = ipl_gammaSigmoid0_6;
    break;
    case -5:
      gamma_table = ipl_gammaSigmoid0_5;
    break;
    default:
      MSG_LOW("ipl_DoContrast marker_203\n");
      return IPL_FAILURE;
  }

  if (input_img_ptr->cFormat == IPL_YCrCb420_LINE_PK)
  {
    unsigned char * out8_ptr;
    unsigned char * in8_ptr;

    // copy chroma from input to output if not doing this inplace
    if (o_img_ptr != NULL)
      memcpy(o_img_ptr->clrPtr, i_img_ptr->clrPtr, dx*dy/2);

    in8_ptr = input_img_ptr->imgPtr;
    out8_ptr = output_img_ptr->imgPtr;

    /* Now loop through luma */
    for (row = 0; row < dx*dy; row++)
    {
      *out8_ptr++ = gamma_table[*in8_ptr++];
    }

    /* Now loop through chroma */
    in8_ptr = input_img_ptr->clrPtr;
    out8_ptr = output_img_ptr->clrPtr;
    for (row = 0; row < dx*dy/2; row++)
    {
      *out8_ptr++ = gamma_table[*in8_ptr++];
    }

    retval = IPL_SUCCESS;
  }
  else if (input_img_ptr->cFormat == IPL_RGB565)
  {
    dataout_ptr = (uint16*)output_img_ptr->imgPtr;
    datain_ptr = (uint16*)input_img_ptr->imgPtr;

    for(row = 0; row < dx*dy; row++)
    {
      rout16 = (*datain_ptr&0xF800)>>8;
      gout16 = (*datain_ptr&0x07E0)>>3;
      bout16 = (*datain_ptr&0x001F)<<3;

      datain_ptr++;

      rout16 = gamma_table[rout16];
      gout16 = gamma_table[gout16];
      bout16 = gamma_table[bout16];

      *dataout_ptr++ = pack_rgb565(rout16,gout16,bout16);
    }

    retval = IPL_SUCCESS;
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_DoContrast marker_100\n");
  else
    MSG_LOW("ipl_DoContrast marker_204\n");

  return retval;
}



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_image_sepia

DESCRIPTION
  This function will convert the image to sepia
  The output is either YCbCr 4:2:2 or RGB565
  The input should be YCbCr 4:2:2

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_image_sepia
(
  ipl_image_type* input_img_ptr,         /* Points to the input image      */
  ipl_image_type* output_img_ptr         /* Points to the output image     */
)
{
  /* Take an image of size of any size and converts it to black and white
  */
  uint32 row,col,index;
  uint32 luma1=0,luma2=0;
  unsigned short out;
  uint32 cb=0,cr=0;
  long rc,gc,bc,r,g,b;
  /* ycbcr_convert is the conversion array of coeffs in Q14 Signed */
  /* In Q0, coeffs are = 4.8828e-4 1.57489 -0.18744 -0.46826 1.8554 7.3242e-4 */
  short ycbcr_convert[6] = {8, 25803, -3071, -7672,30399,12};
  boolean convert = TRUE;

  MSG_LOW("ipl_image_sepia marker_0\n");


#if 0
  MSG_FATAL("ipl_image_supposedly_sepia marker_0\n");
  ipl_fixRedEye(input_img_ptr, NULL, NULL, 0);
  MSG_FATAL("ipl_image_supposedly_sepia marker_1\n");
  ipl_copy_and_paste(input_img_ptr, output_img_ptr, NULL, NULL);
  return IPL_SUCCESS;

#endif

  // for profiling ipl, we hijack sepia, this should always be
  // commented out in customer build

#ifdef IPL_DEBUG_PROFILE
  ipl_profile(input_img_ptr, output_img_ptr, NULL, NULL, NULL, NULL);
  ipl_copy_and_paste(input_img_ptr, output_img_ptr, NULL, NULL);
  return IPL_SUCCESS;
#endif

  if (!input_img_ptr || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_image_sepia marker_200\n");
    return IPL_FAILURE;
  }

  if (input_img_ptr->cFormat != IPL_YCbCr)
  {
    MSG_LOW("ipl_image_sepia marker_201\n");
    /* Only YCbCr Input format currently supported */
    return IPL_FAILURE;
  }

  if (!((output_img_ptr->cFormat == IPL_RGB565) ||
        (output_img_ptr->cFormat == IPL_YCbCr)))
  {
    MSG_LOW("ipl_image_sepia marker_202\n");
    /* Only YCbCr or RGB565 Output format currently supported */
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat == input_img_ptr->cFormat)
  {
    /* We don't need to color convert */
    convert = FALSE;
  }

  MSG_LOW("ipl_image_sepia marker_1\n");

  if (!((input_img_ptr->dy == output_img_ptr->dy) &&
        (input_img_ptr->dx == output_img_ptr->dx)))
  {
    MSG_LOW("ipl_image_sepia marker_203\n");
    /* Input and output image should be of same size */
    return IPL_FAILURE;
  } else {
    /* Now loop through the image once */
    for(row = 0; row < input_img_ptr->dy; row++){
      for(col = 0; col < (input_img_ptr->dx); col++){
        index = ((row*input_img_ptr->dx) + col)<<1;
        /* First Byte is is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
        if (!(col%2)) {
          /* This is Cb */
          cb = 110;
          index +=1;
          /* Next Byte is the luma */
          luma1 =  input_img_ptr->imgPtr[index]; //Byte addressed
        } else {
          /* This is Cr */
          cr = 140;
          index +=1;
          /* Next Byte is the luma */
          luma2 = input_img_ptr->imgPtr[index];
          if (convert)
          {
            /* YCbCr2RGB lags behind by 2 pixels always */
            rc = (ycbcr_convert[0]*(cb-128) + ycbcr_convert[1]*(cr-128))*4+0x8000;
            gc = (ycbcr_convert[2]*(cb-128) + ycbcr_convert[3]*(cr-128))*4+0x8000;
            bc = (ycbcr_convert[4]*(cb-128) + ycbcr_convert[5]*(cr-128))*4+0x8000;
            r = luma1 + (rc>>16);
            g = luma1 + (gc>>16);
            b = luma1 + (bc>>16);
	          r = CLIPIT(r);
	          g = CLIPIT(g);
	          b = CLIPIT(b);
            /*
            ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
            ** Order of the 2 bytes is R5G3 G3B5
            */
            out = pack_rgb565(r,g,b);
            *((unsigned short *)(output_img_ptr->imgPtr + (col-1+row*(output_img_ptr->dx))*2) )= (unsigned short) out;
            r = luma2 + (rc>>16);
            g = luma2 + (gc>>16);
            b = luma2 + (bc>>16);
	          r = CLIPIT(r);
	          g = CLIPIT(g);
	          b = CLIPIT(b);
            out = pack_rgb565(r,g,b);
            *((unsigned short*)(output_img_ptr->imgPtr + (col+row*(output_img_ptr->dx))*2 ) )= (unsigned short) out;
          } else {
            /* Dont need to RGB conversion, simply output data in YCbCr format */
            output_img_ptr->imgPtr[index] =  (unsigned char)luma2;
            output_img_ptr->imgPtr[index-2] =  (unsigned char)luma1;
            output_img_ptr->imgPtr[index-1] =  (unsigned char)cr;
            output_img_ptr->imgPtr[index-3] =  (unsigned char)cb;
          }
        } /* end of Cb Cr */
      } /* End of col loop */
    } /* End of row loop */
  }

  MSG_LOW("ipl_image_sepia marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_image_sepia */





/* <EJECT> */
/*===========================================================================

FUNCTION ipl_smart_flash

DESCRIPTION
  This function performs intensity equalization and color conversion
  if required.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_smart_flash
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr          /* Points to the output image     */
)
{
  int32 index;
  uint32 luma1=0,luma2=0,row,col;
  //uint32 i,j;
  //uint32 BLOCKDIM = 8;
  uint32 grayLEVELS = 256;
  uint32 hist[256];
  //ipl_int_eq_type int_eq = IPL_GHE;
  unsigned short out;
  uint32 cb=0,cr=0;
  long rc,gc,bc,r,g,b;
  /* ycbcr_convert is the conversion array of coeffs in Q14 Signed */
  /* In Q0, coeffs are 4.8828e-4 1.57489 -0.18744 -0.46826 1.8554 7.3242e-4 */
  short ycbcr_convert[6] = {8, 25803, -3071, -7672,30399,12};
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  boolean convert = TRUE;

#if 0
  int BLOCKDIM, i, j;
#endif

  MSG_LOW("ipl_smart_flash marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_smart_flash marker_200\n");
    return IPL_FAILURE;
  }

  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;


  if (!((input_img_ptr->dx == output_img_ptr->dx) &&
        (input_img_ptr->dy == output_img_ptr->dy)))
  {
    MSG_LOW("ipl_smart_flash marker_201\n");
    /* Input and Output should be of same dimension */
    return IPL_FAILURE;
  }

  if (input_img_ptr->cFormat != IPL_YCbCr)
  {
    MSG_LOW("ipl_smart_flash marker_202\n");
    /* Only YCbCr Input format currently supported */
    return IPL_FAILURE;
  }

  if (output_img_ptr->cFormat == input_img_ptr->cFormat)
  {
    /* We don't need to color convert */
    convert = FALSE;
  }

  MSG_LOW("ipl_smart_flash marker_1\n");

#if 1
  if (calc_img_hist(input_img_ptr,hist,grayLEVELS,0,
                    input_img_ptr->dy,input_img_ptr->dx) != IPL_SUCCESS)
  {
    MSG_LOW("ipl_smart_flash marker_203\n");
    /* An error condition has occured */
    return IPL_FAILURE;
  }

  /* Now loop through the image once */
  for(row = 0; row < output_img_ptr->dy; row++)
  {
    for(col = 0; col < (output_img_ptr->dx); col++)
    {
      index = ((row*input_img_ptr->dx) + col)<<1;
      /* First Byte is is either Cb or Cr. CbY CrY CbY CrY CbY CrY */
      if (!(col%2))
      {
        /* This is Cb */
        cb=input_img_ptr->imgPtr[index];
        /* Next Byte is the luma */
        luma1 = hist[input_img_ptr->imgPtr[index+1]]; /* byte addressed */
      }
      else
      {
        /* This is Cr */
        cr = input_img_ptr->imgPtr[index];
        /* Next Byte is the luma */
        luma2 = hist[input_img_ptr->imgPtr[index+1]];
        if (convert)
        {
          /* YCbCr2RGB lags behind by 2 pixels always */
          rc = (ycbcr_convert[0]*(cb-128) + ycbcr_convert[1]*(cr-128))*4
               + 0x8000;
          gc = (ycbcr_convert[2]*(cb-128) + ycbcr_convert[3]*(cr-128))*4
               + 0x8000;
          bc = (ycbcr_convert[4]*(cb-128) + ycbcr_convert[5]*(cr-128))*4
               + 0x8000;
          r = luma1 + (rc>>16);
          g = luma1 + (gc>>16);
          b = luma1 + (bc>>16);
          r=CLIPIT(r);
          g=CLIPIT(g);
          b=CLIPIT(b);
          /*
          ** Masking bits for 5 ==> 0xF8 and 6==> 0xFC
          ** Order of the 2 bytes is R5G3 G3B5
          */
          out = pack_rgb565(r,g,b);
          *((unsigned short*)(output_img_ptr->imgPtr +
            (col-1+row*(output_img_ptr->dx))*2)) = (unsigned short) out;
          r = luma2 + (rc>>16);
          g = luma2 + (gc>>16);
          b = luma2 + (bc>>16);
          r=CLIPIT(r);
          g=CLIPIT(g);
          b=CLIPIT(b);
          out = pack_rgb565(r,g,b);
          *((unsigned short*)(output_img_ptr->imgPtr +
            (col+row*(output_img_ptr->dx))*2)) = (unsigned short) out;
        } else {
          /* No need for RGB conversion, simply output YCbCr data */
          output_img_ptr->imgPtr[(col+row*(output_img_ptr->dx))<<1] =
            (unsigned char) cr;
          output_img_ptr->imgPtr[((col+row*(output_img_ptr->dx))<<1)+1] =
            (unsigned char)luma2;
          output_img_ptr->imgPtr[((col+row*(output_img_ptr->dx))<<1)-2] =
            (unsigned char) cb;
          output_img_ptr->imgPtr[((col+row*(output_img_ptr->dx))<<1)-1] =
            (unsigned char)luma1;
        }
      } /* end of Cb Cr */
    } /* End of col loop */
  } /* End of row loop */

#else
  /* Do Adaptive Histogram Equalization */
  /* The image dimensions must be in integer number of 16 blocks */
  if (!((input_img_ptr->dx%BLOCKDIM == 0) &&
        (input_img_ptr->dy%BLOCKDIM == 0)))
  {
    MSG_LOW("ipl_smart_flash marker_204\n");
    /*
    ** Do adaptive histogram equalization for images that have an integer
    ** number of blocks
    */
    return IPL_FAILURE;
  }

  /* Now loop through the image once */
  for(row = 0; row < (output_img_ptr->dy/BLOCKDIM); row++){
    for(col = 0; col < (output_img_ptr->dx/BLOCKDIM); col++){
      /* Figure out top left corner of block */
      index = ((row*BLOCKDIM*input_img_ptr->dx) + col*BLOCKDIM)<<1;
      if (calc_img_hist(input_img_ptr,hist,grayLEVELS,
                        index,BLOCKDIM,BLOCKDIM) != IPL_SUCCESS){
        MSG_LOW("ipl_smart_flash marker_205\n");

        return IPL_FAILURE;
      }
      /* Now Process that block which has been equalized */
      for (i =0; i<BLOCKDIM;i++)
      {
        for (j =0; j<BLOCKDIM;j++)
        {
          index = ((row*BLOCKDIM*input_img_ptr->dx) + col*BLOCKDIM +
                   i*input_img_ptr->dx + j)<<1;
          if (!(j%2)) {
            /* This is Cb */
            cb=input_img_ptr->imgPtr[index];
            /* Next Byte is the luma */
            luma1 =  hist[input_img_ptr->imgPtr[index+1]]; //Byte addressed
          } else {
            /* This is Cr */
            cr = input_img_ptr->imgPtr[index];
            /* Next Byte is the luma */
            luma2 = hist[input_img_ptr->imgPtr[index+1]];
            if (convert)
            {
              /* YCbCr2RGB lags behind by 2 pixels always */
              rc = (ycbcr_convert[0]*(cb-128) + ycbcr_convert[1]*(cr-128))*4
                   + 0x8000;
              gc = (ycbcr_convert[2]*(cb-128) + ycbcr_convert[3]*(cr-128))*4
                   + 0x8000;
              bc = (ycbcr_convert[4]*(cb-128) + ycbcr_convert[5]*(cr-128))*4
                   + 0x8000;
              r = luma1 + (rc>>16);
              g = luma1 + (gc>>16);
              b = luma1 + (bc>>16);
              r=CLIPIT(r);
              g=CLIPIT(g);
              b=CLIPIT(b);
              /*
              ** Masking bits for 5 ==> 0xF8 and 6 ==> 0xFC
              ** Order of the 2 bytes is R5G3 G3B5
              */
              out = pack_rgb565(r,g,b);
              *((unsigned short*)(output_img_ptr->imgPtr + index-2)) =
                (unsigned short)out;
              r = luma2 + (rc>>16);
              g = luma2 + (gc>>16);
              b = luma2 + (bc>>16);
              r=CLIPIT(r);
              g=CLIPIT(g);
              b=CLIPIT(b);
              out = pack_rgb565(r,g,b);
              *((unsigned short*)(output_img_ptr->imgPtr + index)) =
                (unsigned short) out;
            } else {
              /* No need for RGB conversion, simply output YCbCr data */
              output_img_ptr->imgPtr[index] = (unsigned char)cr;
              output_img_ptr->imgPtr[(index)+1] = (unsigned char)luma2;
              output_img_ptr->imgPtr[(index)-2] = (unsigned char)cb;
              output_img_ptr->imgPtr[(index)-1] = (unsigned char)luma1;
            } /* End of conversion loop */
          } /* end of Cb Cr */
        } /* End of j-loop intra-macroblock inner loop */
      }  /* End of i-loop intra-macroblock outer loop */
    }  /* End of col loop Macroblock loop */
  }  /* End of row loop Macroblock Loop */
#endif

  MSG_LOW("ipl_smart_flash marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_smart_flash */




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_efx_adaptiveFilter

DESCRIPTION

  This function processes Y channel data only. It sharpens the edges while
  reducing noise if noise is detected.

  Input and output images must have the same color format, which can
  be YCbCr 4:2:2 packed format with Y starting on second byte.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_efx_adaptiveFilter
(
  ipl_image_type* iptr,    /* Points to the input image  */
  ipl_image_type* optr     /* Points to the output image */
)
{
  int i,j;
  long ind;
  long ave;
  long av1, av2, av3, av4;
  int width, height;
  unsigned char * s;
  unsigned char * d;

  MSG_LOW("ipl_efx_adaptiveFilter marker_0\n");

  if (!iptr  || !iptr->imgPtr ||
      !optr || !optr->imgPtr)
  {
    MSG_LOW("ipl_efx_adaptiveFilter marker_200\n");
    return IPL_FAILURE;
  }

  /* Threshold used to determine if low pass, high pass, or no filtering is
   * done. Change these values to increase/decrease where high pass and low
   * pass and noop are done. The lower the number, the greater the chnace
   * of each. The greater the difference, the greater the difference of noop */
#define LP_EPSILON 20
#define HP_EPSILON 30

  /* When doing high pass filter, these numbers constitute center weight
   * and div factor. Change BOTH number to increase/decrease amount of
   * sharpening when hp filtering is done
   *
   * -1 -1 -1
   * -1  ? -1
   * -1 -1 -1
   *
   * where ? is IPL_AF_SHARPEN_KERNEL_3x3_4. When changing this value, make
   * sure you change IPL_AF_SHARPEN_KERNEL_NORM_SHIFT too to designate number
   * of shift. If IPL_AF_SHARPEN_KERNEL_3x3_4 is 24, and the other 8 places
   * are -1, therefor the weight is 16, so we must shift by 4 to normalize.
   * */
#define IPL_AF_SHARPEN_KERNEL_3x3_4       24
#define IPL_AF_SHARPEN_KERNEL_NORM_SHIFT   4

  /* Input and output color formats must be the same */
  if (iptr->cFormat != optr->cFormat)
  {
    MSG_LOW("ipl_efx_adaptiveFilter marker_201\n");
    return IPL_FAILURE;
  }
  /* Input and output images must be the same size */
  if (iptr->dx != optr->dx || iptr->dy != optr->dy)
  {
    MSG_LOW("ipl_efx_adaptiveFilter marker_202\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_efx_adaptiveFilter marker_1\n");

  if (iptr->cFormat == IPL_YCbCr)
  {
    width = iptr->dx*2;
    height = iptr->dy;

    //for (i = height-1; i; i--)
    for (i = 1; i < height-1; i++)
    {
      // ind = (i+1) * width - 2;
      ind = i * width + 3;

      // for (j = width - 2; j; j -= 2)
      for (j = 3; j < width - 2; j += 2)
      {
        // horizontal edge
        // -1 -1 -1
        // 1   1  1
        // 0   0  0
        //av1=abs(roi[3]+roi[4]+roi[5]- roi[0]-roi[1]-roi[2]);
        av1= (iptr->imgPtr[(ind-2)] +
              iptr->imgPtr[(ind)] +
              iptr->imgPtr[(ind+2)] -
              iptr->imgPtr[(ind-width-2)] -
              iptr->imgPtr[(ind-width)] -
              iptr->imgPtr[(ind-width+2)]);
        if (av1 < 0) av1 = -av1;

        // vertical edge
        // -1 1 0
        // -1 1 0
        // -1 1 0
        //av2=abs(roi[1]+roi[4]+roi[7] - roi[0]-roi[3]-roi[6]);
        av2=(iptr->imgPtr[(ind-width)] +
             iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind+width)] -
             iptr->imgPtr[(ind-width-2)] -
             iptr->imgPtr[(ind-2)] -
             iptr->imgPtr[(ind+width-2)]);
        if (av2 < 0) av2 = -av2;

        // NE to SW
        //av3=abs(roi[4]+roi[6]+roi[2] - roi[0]-roi[1]-roi[3]);
        av3=(iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind+width-2)] +
             iptr->imgPtr[(ind-width+2)] -
             iptr->imgPtr[(ind-width-2)] -
             iptr->imgPtr[(ind-width)] -
             iptr->imgPtr[(ind-2)]);
        if (av3 < 0) av3 = -av3;

        // NW to SE
        // av4=abs(roi[4]+roi[0]+roi[8]- roi[1]-roi[2]-roi[5]);
        av4=(iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind-width-2)] +
             iptr->imgPtr[(ind+width+2)] -
             iptr->imgPtr[(ind-width)] -
             iptr->imgPtr[(ind-width+2)] -
             iptr->imgPtr[(ind+2)]);
        if (av4 < 0) av4 = -av4;

        // second, the ROI goes through filtering
        /* if all the av's are less than lp, then do low pass filter */
        if (av1<LP_EPSILON && av2<LP_EPSILON &&
            av3<LP_EPSILON && av4<LP_EPSILON)
        {
          // do low pass filtering (3x3 convolution)
          ave =  (iptr->imgPtr[(ind-width-2)] +
                  iptr->imgPtr[(ind-width)] +
                  iptr->imgPtr[(ind-width+2)] +
                  iptr->imgPtr[(ind-2)] +
                  iptr->imgPtr[(ind)] +
                  iptr->imgPtr[(ind+2)] +
                  iptr->imgPtr[(ind+width-2)] +
                  iptr->imgPtr[(ind+width)]);
          ave = ave >> 3;

          /* do clipping */
          if (ave > 255)
            optr->imgPtr[ind] = 255;
          else
            optr->imgPtr[ind] = (unsigned char) ave;

          if (IPL_EFX_DEBUG)  //lint !e774 !e506
            optr->imgPtr[ind] = 128;
        }

        /* if any of av's is above hp, then do high pass filter */
        else if (av1>HP_EPSILON || av2>HP_EPSILON ||
                 av3>HP_EPSILON || av4>HP_EPSILON)
        {
          // do high pass filtering, (3x3 convolution)
          ave = (-iptr->imgPtr[(ind-width-2)] -
                  iptr->imgPtr[(ind-width)] -
                  iptr->imgPtr[(ind-width+2)] -
                  iptr->imgPtr[(ind-2)] -
                  iptr->imgPtr[(ind+2)] -
                  iptr->imgPtr[(ind+width-2)] -
                  iptr->imgPtr[(ind+width)] -
                  iptr->imgPtr[(ind+width+2)]);
          ave +=  ( IPL_AF_SHARPEN_KERNEL_3x3_4 * iptr->imgPtr[ind]);
          ave = ave >> IPL_AF_SHARPEN_KERNEL_NORM_SHIFT;

          /* do clipping and such */
          if (ave>255)
            optr->imgPtr[ind]=255;
          else if (ave<0)
            optr->imgPtr[ind]=0;
          else
            optr->imgPtr[ind]=(unsigned char) ave;

          if (IPL_EFX_DEBUG)  //lint !e774 !e506
            optr->imgPtr[ind] = 255;
        }
        else
        {
          optr->imgPtr[ind]=iptr->imgPtr[ind];
          if (IPL_EFX_DEBUG)  //lint !e774 !e506
            optr->imgPtr[ind] = 0;
        }

        /* copy Cb or Cr over too */
        optr->imgPtr[ind-1]=iptr->imgPtr[ind-1];

        // ind -= 2;
        ind += 2;
      }
    }

    /* now copy top row, bottom row, 2 right and left most column to output */
    /* do top row first */
    s = iptr->imgPtr;
    d = optr->imgPtr;
    for (i = 0; i < width ; i++)
      d[i]=s[i];

    /* do bottom row next */
    s = &iptr->imgPtr[(height-1)*width];
    d = &optr->imgPtr[(height-1)*width];
    for (i = 0; i < width ; i++)
      d[i]=s[i];

    /* do 2 left most columns (CbY) */
    s = iptr->imgPtr;
    d = optr->imgPtr;
    for (i = 0; i < width*height; i+=width)
    {
      d[i]=s[i];
      d[i+1]=s[i+1];
    }

    /* do 2 right most columns (CrY) */
    s = &iptr->imgPtr[width-1];
    d = &optr->imgPtr[width-1];
    for (i = 0; i < width*height; i += width)
    {
      d[i]=s[i];
      d[i-1]=s[i-1];
    }

    MSG_LOW("ipl_efx_adaptiveFilter marker_100\n");

    return IPL_SUCCESS;
  }
  else if (iptr->cFormat == IPL_BAYER_BGGR || iptr->cFormat == IPL_BAYER_RGGB)
  {
    uint16 cols, rows;

    width = iptr->dx;
    height = iptr->dy;

    /*
    memcpy(optr->imgPtr, iptr->imgPtr, width*height);
    */


    // do low pass filtering (3x3 convolution)
#define LOW_PASS_FILTER() \
          ave =  (iptr->imgPtr[(ind-2*width)] + \
                  iptr->imgPtr[(ind-width+1)] + \
                  iptr->imgPtr[(ind+2)] + \
                  iptr->imgPtr[(ind-width-1)] + \
                  iptr->imgPtr[(ind)] + \
                  iptr->imgPtr[(ind+width+1)] + \
                  iptr->imgPtr[(ind-2)] +  \
                  iptr->imgPtr[(ind+width-1)]);\
          ave = ave >> 3;\
          if (ave > 255) \
            optr->imgPtr[ind] = 255; \
          else \
            optr->imgPtr[ind] = (unsigned char) ave;

    // do high pass filtering (3x3 convolution)
#define HIGH_PASS_FILTER() \
          ave = (-iptr->imgPtr[(ind-2*width)] - \
                  iptr->imgPtr[(ind-width+1)] - \
                  iptr->imgPtr[(ind+2)] - \
                  iptr->imgPtr[(ind-width-1)] - \
                  iptr->imgPtr[(ind+width+1)] - \
                  iptr->imgPtr[(ind-2)] -  \
                  iptr->imgPtr[(ind+width-1)] -  \
                  iptr->imgPtr[(ind+2*width)]);\
          ave +=  ( IPL_AF_SHARPEN_KERNEL_3x3_4 * iptr->imgPtr[ind]); \
          ave = ave >> IPL_AF_SHARPEN_KERNEL_NORM_SHIFT; \
          if (ave>255) \
            optr->imgPtr[ind]=255; \
          else if (ave<0)  \
            optr->imgPtr[ind]=0; \
          else \
            optr->imgPtr[ind]=(unsigned char) ave;

    width = iptr->dx;
    height = iptr->dy;

    cols = (width-4) >> 1;
    rows = (height-4) >> 1;

    ind = 3 * width + 2;
    for (j=0; j < rows; j++)
    {
      /* lets do some loop unrooling, lets to two lines as a time */
      /* do odd line */
      for (i=0; i < cols; i++)
      {
        // Normal kernel ids if on Y data
        //
        // 0 1 2
        // 3 4 5
        // 6 7 8
        //
        // Kernel numbering when on G data
        //
        //     0
        //   3   1
        // 6   4   2
        //   7   5
        //     8
        //


        // \ edge
        //
        //     -
        //   +   -
        // 0   +   -
        //   0   +
        //     0
        //
        //av1=abs(roi[3]+roi[4]+roi[5]- roi[0]-roi[1]-roi[2]);
        av1= (iptr->imgPtr[(ind-width-1)] +
              iptr->imgPtr[(ind)] +
              iptr->imgPtr[(ind+width+1)] -
              iptr->imgPtr[(ind-2*width)] -
              iptr->imgPtr[(ind-width+1)] -
              iptr->imgPtr[(ind+2)]);
        if (av1 < 0) av1 = -av1;

        // / edge
        //
        //     -
        //   -   +
        // -   +   0
        //   +   0
        //     0
        //
        //av2=abs(roi[1]+roi[4]+roi[7] - roi[0]-roi[3]-roi[6]);
        av2=(iptr->imgPtr[(ind-width+1)] +
             iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind+width-1)] -
             iptr->imgPtr[(ind-2*width)] -
             iptr->imgPtr[(ind-width-1)] -
             iptr->imgPtr[(ind-2)]);
        if (av2 < 0) av2 = -av2;

        // Horizontal edge
        //     -
        //   -   -
        // +   +   +
        //   0   0
        //     0
        //
        //av3=abs(roi[4]+roi[6]+roi[2] - roi[0]-roi[1]-roi[3]);
        av3=(iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind-2)] +
             iptr->imgPtr[(ind+2)] -
             iptr->imgPtr[(ind-2*width)] -
             iptr->imgPtr[(ind-width+1)] -
             iptr->imgPtr[(ind-width-1)]);
        if (av3 < 0) av3 = -av3;


        // Vertical edge
        //
        //     +
        //   0   -
        // 0   +   -
        //   0   -
        //     +
        //
        // av4=abs(roi[4]+roi[0]+roi[8]- roi[1]-roi[2]-roi[5]);
        av4=(iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind-2*width)] +
             iptr->imgPtr[(ind+2*width)] -
             iptr->imgPtr[(ind-width+1)] -
             iptr->imgPtr[(ind+2)] -
             iptr->imgPtr[(ind+width+1)]);
        if (av4 < 0) av4 = -av4;

        // second, the ROI goes through filtering
        /* if all the av's are less than lp, then do low pass filter */
        if (av1<LP_EPSILON && av2<LP_EPSILON &&
            av3<LP_EPSILON && av4<LP_EPSILON)
        {
          LOW_PASS_FILTER();
        }
        /* if any of av's is above  hp, then do high pass filter */
        else if (av1>HP_EPSILON || av2>HP_EPSILON ||
                 av3>HP_EPSILON || av4>HP_EPSILON)
        {
          HIGH_PASS_FILTER();
        }
        else
        {
          /* copy over the pixel untouched */
          optr->imgPtr[ind] = iptr->imgPtr[ind];
        }

        /* now copy over your B or R pixel you skip */
        optr->imgPtr[ind-1] = iptr->imgPtr[ind-1];

        ind += 2;
      }

      /* now copy over the last pixel you skipped and current one */
      optr->imgPtr[ind-1] = iptr->imgPtr[ind-1];
      optr->imgPtr[ind] = iptr->imgPtr[ind];


      /* now copy over the 4 pixels you are going to skip when on odd row */
      ind++;
      optr->imgPtr[ind] = iptr->imgPtr[ind];
      ind++;
      optr->imgPtr[ind] = iptr->imgPtr[ind];
      ind++;
      optr->imgPtr[ind] = iptr->imgPtr[ind];
      ind++;
      optr->imgPtr[ind] = iptr->imgPtr[ind];
      ind++;

      // ind += 5;


      /* do even line line */
      for (i=0; i < cols; i++)
      {
        // Normal kernel ids if on Y data
        //
        // 0 1 2
        // 3 4 5
        // 6 7 8
        //
        // Kernel numbering when on G data
        //
        //     0
        //   3   1
        // 6   4   2
        //   7   5
        //     8
        //


        // \ edge
        //
        //     -
        //   +   -
        // 0   +   -
        //   0   +
        //     0
        //
        //av1=abs(roi[3]+roi[4]+roi[5]- roi[0]-roi[1]-roi[2]);
        av1= (iptr->imgPtr[(ind-width-1)] +
              iptr->imgPtr[(ind)] +
              iptr->imgPtr[(ind+width+1)] -
              iptr->imgPtr[(ind-2*width)] -
              iptr->imgPtr[(ind-width+1)] -
              iptr->imgPtr[(ind+2)]);
        if (av1 < 0) av1 = -av1;

        // / edge
        //
        //     -
        //   -   +
        // -   +   0
        //   +   0
        //     0
        //
        //av2=abs(roi[1]+roi[4]+roi[7] - roi[0]-roi[3]-roi[6]);
        av2=(iptr->imgPtr[(ind-width+1)] +
             iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind+width-1)] -
             iptr->imgPtr[(ind-2*width)] -
             iptr->imgPtr[(ind-width-1)] -
             iptr->imgPtr[(ind-2)]);
        if (av2 < 0) av2 = -av2;

        // Horizontal edge
        //     -
        //   -   -
        // +   +   +
        //   0   0
        //     0
        //
        //av3=abs(roi[4]+roi[6]+roi[2] - roi[0]-roi[1]-roi[3]);
        av3=(iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind-2)] +
             iptr->imgPtr[(ind+2)] -
             iptr->imgPtr[(ind-2*width)] -
             iptr->imgPtr[(ind-width+1)] -
             iptr->imgPtr[(ind-width-1)]);
        if (av3 < 0) av3 = -av3;


        // Vertical edge
        //
        //     +
        //   0   -
        // 0   +   -
        //   0   -
        //     +
        //
        // av4=abs(roi[4]+roi[0]+roi[8]- roi[1]-roi[2]-roi[5]);
        av4=(iptr->imgPtr[(ind)] +
             iptr->imgPtr[(ind-2*width)] +
             iptr->imgPtr[(ind+2*width)] -
             iptr->imgPtr[(ind-width+1)] -
             iptr->imgPtr[(ind+2)] -
             iptr->imgPtr[(ind+width+1)]);
        if (av4 < 0) av4 = -av4;

        // second, the ROI goes through filtering
        /* if all the av's are less than lp, then do low pass filter */
        if (av1<LP_EPSILON && av2<LP_EPSILON &&
            av3<LP_EPSILON && av4<LP_EPSILON)
        {
          LOW_PASS_FILTER();
        }
        /* if any of av's is above  hp, then do high pass filter */
        else if (av1>HP_EPSILON || av2>HP_EPSILON ||
                 av3>HP_EPSILON || av4>HP_EPSILON)
        {
          HIGH_PASS_FILTER();
        }
        else
        {
          /* copy over the pixel untouched */
          optr->imgPtr[ind] = iptr->imgPtr[ind];
        }

        /* now copy over your B or R pixel you skip */
        optr->imgPtr[ind-1] = iptr->imgPtr[ind-1];

        ind += 2;
      }
      /* now copy over the last pixel you skipped and current one */
      optr->imgPtr[ind-1] = iptr->imgPtr[ind-1];
      optr->imgPtr[ind] = iptr->imgPtr[ind];

      /* now copy over the two pixels you skip */
      ind++;
      optr->imgPtr[ind] = iptr->imgPtr[ind];
      ind++;
      optr->imgPtr[ind] = iptr->imgPtr[ind];
      ind++;

      // ind += 3;
    }


    /* now you need to copy over the top line, bottom line */
    /* do top row first */
    s = iptr->imgPtr;
    d = optr->imgPtr;
    for (i = 0; i < width*3 ; i++)
      d[i]=s[i];

    /* do bottom row next */
    s = &iptr->imgPtr[(height-2)*width];
    d = &optr->imgPtr[(height-2)*width];
    for (i = 0; i < width*2 ; i++)
      d[i]=s[i];


    MSG_LOW("ipl_efx_adaptiveFilter marker_101\n");
    return IPL_SUCCESS;
  }
  else
  {
    MSG_LOW("ipl_efx_adaptiveFilter marker_203\n");
    return IPL_FAILURE;
  }
}







/*===========================================================================

FUNCTION    ipl_test_and_set_block

DESCRIPTION

  This function modifies blodkcDx*blockDy blocks of an image based on some
  rules. Most often, if avg color of block does not match desired, block is
  turned white or black.

DEPENDENCIES
  None

ARGUMENTS IN
  in          input image
  in2
  out         output
  crop        area in question
  operation 0 if at least one pixel holds value a1 within delta of a2, then set
              to white, else, set to black;
  operation 1 if at least one pixel holds value a1 within delta of a2, then set
              to white, else do nothing
  operation 2 compute high freqency of each block, and winner gets put in output
  blockDx     dx size of block
  blockDy     dy size of block
  a1          misc
  a2          misc
  a3          misc

ARGUMENTS IN/OUT

  Returns average Y,Cb,Cr packed as 24 bits into uint32

RETURN VALUE

  Returns average Y,Cb,Cr packed as 24 bits into uint32

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type
ipl_test_and_set_block(ipl_image_type *in, ipl_image_type *in2,
                       ipl_image_type *out,
                       ipl_rect_type * crop, int operation, int blockDx,
                       int blockDy, uint32 a1, uint32 a2, uint32 a3, uint32 a4)
{
  int x, y;
  unsigned char * pin;
  unsigned char * pout;

  unsigned int index;
  ipl_rect_type incrop;
  unsigned char ty, tcb, tcr;
  int delta = a2;
  int goodBlock;
  int nbx, nby, w, bx, by;

  unsigned char good_y, good_cb, good_cr;
  unsigned char bad_y, bad_cb, bad_cr;

  MSG_LOW("ipl_test_and_set_block marker_0\n");

  if (!in  || !in->imgPtr)
  {
    MSG_LOW("ipl_test_and_set_block marker_200\n");
    return IPL_FAILURE;
  }
  // crop not supported right now
  // output

  if (crop == NULL)
  {
    incrop.x = 0;
    incrop.y = 0;
    incrop.dx = in->dx;
    incrop.dy = in->dy;
    crop = &incrop;
  }

  nbx = in->dx / blockDx;
  nby = in->dy / blockDy;

  if (IPL_EFX_DEBUG) //lint !e774 !e506
    printf("nbx %d nby %d\n", nbx, nby);

  // see there is anything to do...
  if (nbx < 1 || nby < 1)
  {
    MSG_LOW("ipl_test_and_set_block marker_201\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_test_and_set_block marker_1\n");
  // test and set
  if (operation == 0)
  {
    if (in->cFormat == IPL_YCbCr)
    {
      unpack_ycbcr(a1, &ty, &tcb, &tcr);
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("test y %d cb %d cr %d\n", ty, tcb, tcr);

      unpack_ycbcr(a3, &good_y, &good_cb, &good_cr);
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("good y %d cb %d cr %d\n", good_y, good_cb, good_cr);

      unpack_ycbcr(a4, &bad_y, &bad_cb, &bad_cr);
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("bad y %d cb %d cr %d\n", bad_y, bad_cb, bad_cr);

      w = in->dx*2;
      pin = in->imgPtr;

      if (out == NULL)
        pout = in->imgPtr;
      else
        pout = out->imgPtr;

      if (in->cFormat == IPL_YCbCr)
      {
        for (by = 0; by < nby; by++)
        {
        for (bx = 0; bx < nbx; bx++)
        {
          goodBlock = 0;
          for (y = 0; y < blockDy; y++)
          {
            if (!goodBlock)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                //index = ((2*crop->x + crop->y*2*in->dx) + (x + y*2*in->dx));
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);

                if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                  printf("(%d,%d) Read CbYCrY for %d,%d,%d,%d\n",
                 bx*blockDx+x, by*blockDy+y, pin[index],
                 pin[index+ 1], pin[index+2], pin[index+3]);

                if ((pin[index]   < tcb + delta) &&
                    (pin[index]   > tcb - delta) &&
                    (pin[index+1] < ty  + delta) &&
                    (pin[index+1] > ty  - delta) &&
                    (pin[index+2] < tcr + delta) &&
                    (pin[index+2] > tcr - delta) &&
                    (pin[index+3] < ty  + delta) &&
                    (pin[index+3] > ty  - delta))
                    {
                      if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                        printf("(%d,%d) has a pixel that matches avg %d %d %d %d.  STOP!\n", bx*blockDx+x, by*blockDy+y,tcb,ty,tcr,ty);

                      goodBlock = 1;
                      break;
                    }
              }
            }
            else
              break;
          }


          // color block specified color
          if (goodBlock)
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is good\n", bx, by);
            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);
                pout[index] = good_cb;
                pout[index+1] = good_y;
                pout[index+2] = good_cr;
                pout[index+3] = good_y;
              }
            }
          }
          else
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is bad\n", bx, by);
            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);
                pout[index] = bad_cb;
                pout[index+1] = bad_y;
                pout[index+2] = bad_cr;
                pout[index+3] = bad_y;
              }
            }
          }
        }
        }
      }
      else if (in->cFormat == IPL_LUMA_ONLY)
      {
        for (by = 0; by < nby; by++)
        {
        for (bx = 0; bx < nbx; bx++)
        {
          goodBlock = 0;
          for (y = 0; y < blockDy; y++)
          {
            if (!goodBlock)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                //index = ((2*crop->x + crop->y*2*in->dx) + (x + y*2*in->dx));
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);

                if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                  printf("(%d,%d) Read CbYCrY for %d,%d,%d,%d\n",
                 bx*blockDx+x, by*blockDy+y, pin[index],
                 pin[index+ 1], pin[index+2], pin[index+3]);

                if ((pin[index]   < tcb + delta) &&
                    (pin[index]   > tcb - delta) &&
                    (pin[index+1] < ty  + delta) &&
                    (pin[index+1] > ty  - delta) &&
                    (pin[index+2] < tcr + delta) &&
                    (pin[index+2] > tcr - delta) &&
                    (pin[index+3] < ty  + delta) &&
                    (pin[index+3] > ty  - delta))
                    {
                      if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                        printf("(%d,%d) has a pixel that matches avg %d %d %d %d.  STOP!\n", bx*blockDx+x, by*blockDy+y,tcb,ty,tcr,ty);

                      goodBlock = 1;
                      break;
                    }
              }
            }
            else
              break;
          }


          // color block specified color
          if (goodBlock)
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is good do nothing\n", bx, by);

            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x++)
              {
                index = (bx*blockDx + by*blockDy*in->dx + x+y*in->dx);
                pout[index] = good_y;
              }
            }
          }
          else
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is bad\n", bx, by);

            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x++)
              {
                index = (bx*blockDx + by*blockDy*in->dx + x+y*in->dx);
                pout[index] = bad_y;
              }
            }
          }
        }
        }
      }
      else
      {
        MSG_LOW("ipl_test_and_set_block marker_202\n");
        return IPL_FAILURE;
      }
    }
    else
    {
      MSG_LOW("ipl_test_and_set_block marker_203\n");
      return IPL_FAILURE;
    }
  }
  // test and do nothing if good
  else if (operation == 1)
  {
    if (in->cFormat == IPL_YCbCr)
    {
      unpack_ycbcr(a1, &ty, &tcb, &tcr);
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("test y %d cb %d cr %d\n", ty, tcb, tcr);

      unpack_ycbcr(a3, &good_y, &good_cb, &good_cr);
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("good y %d cb %d cr %d\n", good_y, good_cb, good_cr);

      unpack_ycbcr(a4, &bad_y, &bad_cb, &bad_cr);
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("bad y %d cb %d cr %d\n", bad_y, bad_cb, bad_cr);

      w = in->dx*2;
      pin = in->imgPtr;

      if (out == NULL)
        pout = in->imgPtr;
      else
        pout = out->imgPtr;

      if (in->cFormat == IPL_YCbCr)
      {
        for (by = 0; by < nby; by++)
        {
        for (bx = 0; bx < nbx; bx++)
        {
          goodBlock = 0;
          for (y = 0; y < blockDy; y++)
          {
            if (!goodBlock)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                //index = ((2*crop->x + crop->y*2*in->dx) + (x + y*2*in->dx));
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);

                if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                  printf("(%d,%d) Read CbYCrY for %d,%d,%d,%d\n",
                 bx*blockDx+x, by*blockDy+y, pin[index],
                 pin[index+ 1], pin[index+2], pin[index+3]);

                if ((pin[index]   < tcb + delta) &&
                    (pin[index]   > tcb - delta) &&
                    (pin[index+1] < ty  + delta) &&
                    (pin[index+1] > ty  - delta) &&
                    (pin[index+2] < tcr + delta) &&
                    (pin[index+2] > tcr - delta) &&
                    (pin[index+3] < ty  + delta) &&
                    (pin[index+3] > ty  - delta))
                    {
                      if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                        printf("(%d,%d) has a pixel that matches avg %d %d %d %d.  STOP!\n", bx*blockDx+x, by*blockDy+y,tcb,ty,tcr,ty);

                      goodBlock = 1;
                      break;
                    }
              }
            }
            else
              break;
          }


          // color block specified color
          if (goodBlock)
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is good\n", bx, by);
          }
          else
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is bad\n", bx, by);
            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);
                pout[index] = bad_cb;
                pout[index+1] = bad_y;
                pout[index+2] = bad_cr;
                pout[index+3] = bad_y;
              }
            }
          }
        }
        }
      }
      else if (in->cFormat == IPL_LUMA_ONLY)
      {
        for (by = 0; by < nby; by++)
        {
        for (bx = 0; bx < nbx; bx++)
        {
          goodBlock = 0;
          for (y = 0; y < blockDy; y++)
          {
            if (!goodBlock)
            {
              for (x = 0; x < blockDx; x += 2)
              {
                //index = ((2*crop->x + crop->y*2*in->dx) + (x + y*2*in->dx));
                index = (bx*blockDx*2 + by*blockDy*w + x*2+y*w);

                if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                  printf("(%d,%d) Read CbYCrY for %d,%d,%d,%d\n",
                 bx*blockDx+x, by*blockDy+y, pin[index],
                 pin[index+ 1], pin[index+2], pin[index+3]);

                if ((pin[index]   < tcb + delta) &&
                    (pin[index]   > tcb - delta) &&
                    (pin[index+1] < ty  + delta) &&
                    (pin[index+1] > ty  - delta) &&
                    (pin[index+2] < tcr + delta) &&
                    (pin[index+2] > tcr - delta) &&
                    (pin[index+3] < ty  + delta) &&
                    (pin[index+3] > ty  - delta))
                    {
                      if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
                        printf("(%d,%d) has a pixel that matches avg %d %d %d %d.  STOP!\n", bx*blockDx+x, by*blockDy+y,tcb,ty,tcr,ty);

                      goodBlock = 1;
                      break;
                    }
              }
            }
            else
              break;
          }


          // color block specified color
          if (goodBlock)
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is good do nothing\n", bx, by);

            /*
            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x++)
              {
                index = (bx*blockDx + by*blockDy*in->dx + x+y*in->dx);
                pout[index] = good_y;
              }
            }
            */
          }
          else
          {
            if (IPL_EFX_DEBUG && 0) //lint !e774 !e506
              printf("Block %d,%d is bad\n", bx, by);

            for (y = 0; y < blockDy; y++)
            {
              for (x = 0; x < blockDx; x++)
              {
                index = (bx*blockDx + by*blockDy*in->dx + x+y*in->dx);
                pout[index] = bad_y;
              }
            }
          }
        }
        }
      }
      else
      {
        MSG_LOW("ipl_test_and_set_block marker_204\n");
        return IPL_FAILURE;
      }
    }
    else
    {
      MSG_LOW("ipl_test_and_set_block marker_205\n");
      return IPL_FAILURE;
    }
  }
  else
  {
    MSG_LOW("ipl_test_and_set_block marker_208\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_test_and_set_block marker_100\n");
  return IPL_SUCCESS;
}




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_convolution

DESCRIPTION
  This function performs a convolution of the input kernel on the input
  and stores the output in the output image. If output image is NULL, the
  proces happens inplace. numCycles notes how many times to repeat the
  process.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  kernel         kernel to be used.
  numCycles      the number of times to run the kernel on the image

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_convolution
(
  ipl_image_type* i_img_ptr,     /* Points to the input image      */
  ipl_image_type* o_img_ptr,     /* Points to the output image     */
  ipl_kernel_type *kernel,       /* kernel to use */
  int numCycles                  /* number of times to run kernel  */
)
{
  register uint16 rout16,gout16,bout16;
  register int* k;
  uint32 row,col;
  ipl_status_type retval = IPL_FAILURE;
  uint32 dx, dy, dx2, dx3;
  int32 normal;
  int32 cycles;

  MSG_LOW("ipl_convolution marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr || !kernel)
  {
    MSG_LOW("ipl_convolution marker_200\n");
    return IPL_FAILURE;
  }

  dx = i_img_ptr->dx;
  dy = i_img_ptr->dy;
  dx2 = 2*dx;
  dx3 = 3*dx;
  k = &kernel->k[0];

  /* Input and Output should be of same dimension */
  if (o_img_ptr != NULL)
  {
    if ((i_img_ptr->dx != o_img_ptr->dx) ||
        (i_img_ptr->dy != o_img_ptr->dy))
    {
      MSG_LOW("ipl_convolution marker_201\n");
      return IPL_FAILURE;
    }
    /* Input and Output should be of same image type */
    if (i_img_ptr->cFormat != o_img_ptr->cFormat)
    {
      MSG_LOW("ipl_convolution marker_202\n");
      return IPL_FAILURE;
    }

    // copy the input to the output since the kernel does not run on the
    // first/last row/column
    if (i_img_ptr->cFormat == IPL_RGB565)
    {
      memcpy(o_img_ptr->imgPtr, i_img_ptr->imgPtr, dx*dy*2);
    }
    else if ((i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK) ||
             (i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK))
    {
      memcpy(o_img_ptr->imgPtr, i_img_ptr->imgPtr, dx*dy);
      memcpy(o_img_ptr->clrPtr, i_img_ptr->clrPtr, dx*dy/2);
    }
  }

  // make sure kernel values are Q-based
  normal = 0;
  for (row = 0; row < kernel->size*kernel->size; row++)
    normal += kernel->k[row];

  // make sure out input kernel values are multiple of two so division
  // can be made into a shift
  IPL_IS_QNUMBER(normal);

  if (normal == -1)
  {
    MSG_LOW("ipl_convolution marker_203\n");

    IPL2_MSG_HIGH("Cannot do convolution with kernel whose sum is not \
                  power of 2\n");
    return IPL_FAILURE;
  }

  // if user gave us bad numCycles, assume we are to run it at least once
  if (numCycles < 1)
    numCycles = 1;

  MSG_LOW("ipl_convolution marker_1\n");

  // only support 565 right now
  // NOTE: We tries unpacking the rgb565 data to rgb888 temp buffer, and
  // filtering that to another rgb 888 data numCycle times and the finally
  // packing it back to rgb565. We tried this so we dont have to unpack
  // each input pixel 9! times. However, this method proved slower it requires
  // 3 reads (rgb) vs. just one 16bit read, and read are so expensive, that it
  // outwieghed the benefit of not having to & and >>.
  if (i_img_ptr->cFormat == IPL_RGB888 ||
      i_img_ptr->cFormat == IPL_YCbCr444)
  {
    register uint8* dataout_ptr;
    register uint8* datain_ptr;

    if (o_img_ptr != NULL) {
      datain_ptr =  (uint8*) (i_img_ptr->imgPtr + dx3 + 3);
      dataout_ptr = (uint8*) (o_img_ptr->imgPtr + dx3 + 3);

        for(row = 0; row < dy - 1; row++)
        {
          for(col = 0; col < dx-1; col++)
          {
#if 1
            // order we read pixels (x denotes whose value we are computing)
            //
            // 0  1  2
            // 3  4x 5
            // 6  7  8

            rout16 =  k[0] * (*(datain_ptr - dx3 - 3));
            gout16 =  k[0] * (*(datain_ptr - dx3 - 2));
            bout16 =  k[0] * (*(datain_ptr - dx3 - 1));

            rout16 += k[1] * (*(datain_ptr - dx3 - 0));
            gout16 += k[1] * (*(datain_ptr - dx3 + 1));
            bout16 += k[1] * (*(datain_ptr - dx3 + 2));

            rout16 += k[2] * (*(datain_ptr - dx3 + 3));
            gout16 += k[2] * (*(datain_ptr - dx3 + 4));
            bout16 += k[2] * (*(datain_ptr - dx3 + 5));

            rout16 += k[3] * (*(datain_ptr - 3));
            gout16 += k[3] * (*(datain_ptr - 2));
            bout16 += k[3] * (*(datain_ptr - 1));

            rout16 += k[4] * (*(datain_ptr));
            gout16 += k[4] * (*(datain_ptr+1));
            bout16 += k[4] * (*(datain_ptr+2));

            rout16 += k[5] * (*(datain_ptr + 3));
            gout16 += k[5] * (*(datain_ptr + 4));
            bout16 += k[5] * (*(datain_ptr + 5));

            rout16 += k[6] * (*(datain_ptr + dx3 - 3));
            gout16 += k[6] * (*(datain_ptr + dx3 - 2));
            bout16 += k[6] * (*(datain_ptr + dx3 - 1));

            rout16 += k[7] * (*(datain_ptr + dx3));
            gout16 += k[7] * (*(datain_ptr + dx3 + 1));
            bout16 += k[7] * (*(datain_ptr + dx3 + 2));

            rout16 += k[8] * (*(datain_ptr + dx3 + 3));
            gout16 += k[8] * (*(datain_ptr + dx3 + 4));
            bout16 += k[8] * (*(datain_ptr + dx3 + 5));

            rout16 >>= normal;
            gout16 >>= normal;
            bout16 >>= normal;

            *(dataout_ptr  ) = (uint8) rout16;
            *(dataout_ptr+1) = (uint8) gout16;
            *(dataout_ptr+2) = (uint8) bout16;

#else
            *(dataout_ptr  ) = 0;
            *(dataout_ptr+1) = 0;
            *(dataout_ptr+2) = 0;
#endif

            dataout_ptr += 6;
            datain_ptr  += 6;
          }

          dataout_ptr += 3;
          datain_ptr += 3;
        }
        retval = IPL_SUCCESS;
    }
  }
  else if (i_img_ptr->cFormat == IPL_RGB565)
  {
    register uint16* dataout_ptr;
    register uint16* datain_ptr;

    for (cycles = 0; cycles < numCycles; cycles++)
    {
      // if we are doing cycles 2+, run the kernel on the output image inplace
      if (kernel->size == 3)
      {

        if (o_img_ptr == NULL)
        {
          datain_ptr = (uint16*) (i_img_ptr->imgPtr + dx2 + 2);
          dataout_ptr = (uint16*) (i_img_ptr->imgPtr + dx2 + 2);
        }
        else
        {
          if (cycles > 1)
            datain_ptr = (uint16*) (o_img_ptr->imgPtr + dx2 + 2);
          else
            datain_ptr = (uint16*) (i_img_ptr->imgPtr + dx2 + 2);

          dataout_ptr = (uint16*) (o_img_ptr->imgPtr + dx2 + 2);
        }

        for(row = dy-2; row; row--)
        {
          for(col = dx-2; col; col--)
          {
            // order we read pixels (x denotes whose value we are computing)
            //
            // 0  1  2
            // 3  4x 5
            // 6  7  8
            //
            rout16 =  k[0] * ((*(datain_ptr - dx - 1) & 0xF800) >> 8);
            gout16 =  k[0] * ((*(datain_ptr - dx - 1) & 0x07E0) >> 3);
            bout16 =  k[0] * ((*(datain_ptr - dx - 1) & 0x001F) << 3);

            rout16 += k[1] * ((*(datain_ptr - dx) & 0xF800) >> 8);
            gout16 += k[1] * ((*(datain_ptr - dx) & 0x07E0) >> 3);
            bout16 += k[1] * ((*(datain_ptr - dx) & 0x001F) << 3);

            rout16 += k[2] * ((*(datain_ptr - dx + 1) & 0xF800) >> 8);
            gout16 += k[2] * ((*(datain_ptr - dx + 1) & 0x07E0) >> 3);
            bout16 += k[2] * ((*(datain_ptr - dx + 1) & 0x001F) << 3);

            rout16 += k[3] * ((*(datain_ptr - 1) & 0xF800) >> 8);
            gout16 += k[3] * ((*(datain_ptr - 1) & 0x07E0) >> 3);
            bout16 += k[3] * ((*(datain_ptr - 1) & 0x001F) << 3);

            rout16 += k[4] * ((*(datain_ptr) & 0xF800) >> 8);
            gout16 += k[4] * ((*(datain_ptr) & 0x07E0) >> 3);
            bout16 += k[4] * ((*(datain_ptr) & 0x001F) << 3);

            rout16 += k[5] * ((*(datain_ptr + 1) & 0xF800) >> 8);
            gout16 += k[5] * ((*(datain_ptr + 1) & 0x07E0) >> 3);
            bout16 += k[5] * ((*(datain_ptr + 1) & 0x001F) << 3);

            rout16 += k[6] * ((*(datain_ptr + dx - 1) & 0xF800) >> 8);
            gout16 += k[6] * ((*(datain_ptr + dx - 1) & 0x07E0) >> 3);
            bout16 += k[6] * ((*(datain_ptr + dx - 1) & 0x001F) << 3);

            rout16 += k[7] * ((*(datain_ptr + dx) & 0xF800) >> 8);
            gout16 += k[7] * ((*(datain_ptr + dx) & 0x07E0) >> 3);
            bout16 += k[7] * ((*(datain_ptr + dx) & 0x001F) << 3);

            rout16 += k[8] * ((*(datain_ptr + dx + 1) & 0xF800) >> 8);
            gout16 += k[8] * ((*(datain_ptr + dx + 1) & 0x07E0) >> 3);
            bout16 += k[8] * ((*(datain_ptr + dx + 1) & 0x001F) << 3);

            rout16 >>= normal;
            gout16 >>= normal;
            bout16 >>= normal;

            *dataout_ptr = pack_rgb565(rout16,gout16,bout16);
            dataout_ptr++;
            datain_ptr++;
          }

          dataout_ptr += 2;
          datain_ptr += 2;
        }
        retval = IPL_SUCCESS;
      }
      else
      {
        IPL2_MSG_HIGH("Kernel size other than 3x3 not supported\n");
        retval = IPL_FAILURE;
      }
    }
  }
  else if ((i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK) ||
           (i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK))
  {
    register uint8* datain_ptr;
    register uint8* dataout_ptr;


    for (cycles = 0; cycles < numCycles; cycles++)
    {
      // if we are doing cycles 2+, run the kernel on the output image inplace
      if (kernel->size == 3)
      {

        if (o_img_ptr == NULL)
        {
          // skip first row and first column
          datain_ptr  = (i_img_ptr->imgPtr + dx + 1);
          dataout_ptr = (i_img_ptr->imgPtr + dx + 1);
        }
        else
        {
          if (cycles > 1)
          {
            datain_ptr = (o_img_ptr->imgPtr + dx + 1);
          }
          else
          {
            datain_ptr = (i_img_ptr->imgPtr + dx + 1);
          }

          dataout_ptr = (o_img_ptr->imgPtr + dx + 1);
        }

        for(row = dy-2; row; row--)
        {
          for(col = dx-2; col; col--)
          {
            // order we read pixels (x denotes whose value we are computing)
            //
            // 0  1  2
            // 3  4x 5
            // 6  7  8
            //
            rout16 =   k[0] * (*(datain_ptr - dx - 1));
            rout16 +=  k[1] * (*(datain_ptr - dx));
            rout16 +=  k[2] * (*(datain_ptr - dx + 1));

            rout16 +=  k[3] * (*(datain_ptr - 1));
            rout16 +=  k[4] * (*(datain_ptr));
            rout16 +=  k[5] * (*(datain_ptr + 1));

            rout16 +=  k[6] * (*(datain_ptr + dx - 1));
            rout16 +=  k[7] * (*(datain_ptr + dx));
            rout16 +=  k[8] * (*(datain_ptr + dx + 1));

            rout16 >>= normal;

            *dataout_ptr = (uint8) rout16;
            dataout_ptr++;
            datain_ptr++;
          }

          dataout_ptr += 2;
          datain_ptr += 2;
        }
        retval = IPL_SUCCESS;
      }
      else
      {
        IPL2_MSG_HIGH("Kernel size other than 3x3 not supported\n");
        retval = IPL_FAILURE;
      }
    }
  }
  else if (i_img_ptr->cFormat == IPL_LUMA_ONLY)
  {
    register uint8* datain_ptr;
    register uint8* dataout_ptr;


    for (cycles = 0; cycles < numCycles; cycles++)
    {
      // if we are doing cycles 2+, run the kernel on the output image inplace
      if (kernel->size == 3)
      {

        if (o_img_ptr == NULL)
        {
          // skip first row and first column
          datain_ptr  = (i_img_ptr->imgPtr + dx + 1);
          dataout_ptr = (i_img_ptr->imgPtr + dx + 1);
        }
        else
        {
          if (cycles > 1)
          {
            datain_ptr = (o_img_ptr->imgPtr + dx + 1);
          }
          else
          {
            datain_ptr = (i_img_ptr->imgPtr + dx + 1);
          }

          dataout_ptr = (o_img_ptr->imgPtr + dx + 1);
        }

        for(row = dy-2; row; row--)
        {
          for(col = dx-2; col; col--)
          {
            // order we read pixels (x denotes whose value we are computing)
            //
            // 0  1  2
            // 3  4x 5
            // 6  7  8
            //
            rout16 =   k[0] * (*(datain_ptr - dx - 1));
            rout16 +=  k[1] * (*(datain_ptr - dx));
            rout16 +=  k[2] * (*(datain_ptr - dx + 1));

            rout16 +=  k[3] * (*(datain_ptr - 1));
            rout16 +=  k[4] * (*(datain_ptr));
            rout16 +=  k[5] * (*(datain_ptr + 1));

            rout16 +=  k[6] * (*(datain_ptr + dx - 1));
            rout16 +=  k[7] * (*(datain_ptr + dx));
            rout16 +=  k[8] * (*(datain_ptr + dx + 1));

            rout16 >>= normal;

            *dataout_ptr = (uint8) rout16;
            dataout_ptr++;
            datain_ptr++;
          }

          dataout_ptr += 2;
          datain_ptr += 2;
        }
        retval = IPL_SUCCESS;
      }
      else
      {
        IPL2_MSG_HIGH("Kernel size other than 3x3 not supported\n");
        retval = IPL_FAILURE;
      }
    }
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_convolution marker_100\n");
  else
    MSG_LOW("ipl_convolution marker_204\n");

  return retval;
}






/* <EJECT> */
/*===========================================================================

FUNCTION ipl_filter_image

DESCRIPTION
  This function performs filtering. Two types of filtering are supported,
  Blur and Sharpen.

  BLUR:
  There are three types of blurring filters: (1) Gaussian blur,
  (2) uniform blur, and (3) simple blur. Gaussian and uniform blur support
  arbitrary sizes for the blurring window. The window size must be an odd,
  positive integer in the range 3 <= size <= 1/2 * min(width, height).
  Simple blur supports only a window size of 3.

  Gaussian and uniform blur support inputs that are RGB565, YCbCr 4:2:2,
  or YCbCr 4:2:0 line packed format. Output images are always in the
  same format as inputs.

  Simple blur supports inputs that are RGB565 or YCbCr 4:2:2. Outputs
  can be RGB565 or YCbCr 4:2:2.

  SHARPEN:
  The sharpen filter uses a window size of 3. Input images must be in
  YCbCr 4:2:2. Output can be RGB565 or YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  filter         type of filtering operation

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_filter_image
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  ipl_filter_type filter_i,          /* Type of filtering operation    */
  uint32 val                         /* Size of blurring window        */
)
{
  ipl_image_type temp_img_ptr;

  MSG_LOW("ipl_filter_image marker_0\n");

  // although results of kernel-type operations will not be totally correct
  // if done inplace it is an optimization that is worth doing if the user
  // inisists on it
  if (o_img_ptr == NULL)
  {
    temp_img_ptr.dx = i_img_ptr->dx;
    temp_img_ptr.dy = i_img_ptr->dy;
    temp_img_ptr.cFormat = i_img_ptr->cFormat;
    temp_img_ptr.imgPtr = i_img_ptr->imgPtr;
    temp_img_ptr.clrPtr = i_img_ptr->clrPtr;
  }
  else
  {
    temp_img_ptr.dx = o_img_ptr->dx;
    temp_img_ptr.dy = o_img_ptr->dy;
    temp_img_ptr.cFormat = o_img_ptr->cFormat;
    temp_img_ptr.imgPtr = o_img_ptr->imgPtr;
    temp_img_ptr.clrPtr = o_img_ptr->clrPtr;
  }


  if (filter_i == IPL_ADAPTIVE)
  {
    MSG_LOW("ipl_filter_image marker_100\n");
    return(ipl_efx_adaptiveFilter(i_img_ptr, &temp_img_ptr));
  }
  else if ((filter_i == IPL_BLUR_GAUSSIAN) || (filter_i == IPL_BLUR_UNIFORM))
  {
    MSG_LOW("ipl_filter_image marker_105\n");
    return(ipl_filter(i_img_ptr, &temp_img_ptr, filter_i));
  }
  else if (filter_i == IPL_BLUR_MEDIAN)
  {
    MSG_LOW("ipl_filter_image marker_103\n");
    return(ipl_median_blur(i_img_ptr, &temp_img_ptr, val));
  }
  else if (filter_i == IPL_SHARP)
  {
    // set a global variable, VERY ugly
    if (val == 0)
      hp_filter = &hp_filter1[0][0];
    else if (val == 1)
      hp_filter = &hp_filter1[0][0];
    else if (val == 2)
      hp_filter = &hp_filter2[0][0];
    else if (val == 3)
      hp_filter = &hp_filter3[0][0];
    else if (val == 4)
      hp_filter = &hp_filter4[0][0];
    else if (val == 5)
      hp_filter = &hp_filter5[0][0];
    else
      hp_filter = &hp_filter6[0][0];

    MSG_LOW("ipl_filter_image marker_104\n");
    return(ipl_filter(i_img_ptr, &temp_img_ptr, filter_i));
  }
  else
  {
    MSG_LOW("ipl_filter_image marker_105\n");
    return(ipl_filter(i_img_ptr, &temp_img_ptr, filter_i));
  }
} /* End ipl_filter_image */






#ifndef FEATURE_IPL_LIGHT



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_efx_meshWarp

DESCRIPTION
  The input must be YCbCr 4:2:2 or YCbCr 4:2:0 line packed.
  The output must be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr   pointer to the input image
  output_img_ptr  pointer to the output image

RETURN VALUE
  IPL_SUCCESS     indicates operation was successful
  IPL_FAILURE     otherwise

SIDE EFFECTS
  None

EXAMLE

Sample input meshes would be

ipl_grid ipl_srcMesh =
{
  0,10,20,30,40,50,60,70,80,90,100,
  0,10,20,30,40,50,60,70,80,90,100
};

ipl_grid ipl_topStretch =
{
  0,10,20,30,40,50,60,70,80,90,100,
  0,5,15,40,60,70,80,85,90,95,100
};

ipl_grid ipl_centerPinch =
{
  0,10,20,30,40,50,60,70,80,90,100,
  0,15,30,40,46,50,66,70,80,90,100
};

===========================================================================*/
API_EXTERN ipl_status_type ipl_efx_meshWarp
(
  ipl_image_type* input_img_ptr,         /* Points to the input image      */
  ipl_image_type* output_img_ptr,        /* Points to the output image     */
  ipl_grid* dstMesh,
  boolean opp
)
{
  uint32 i;
  ipl_rect_type cropin;
  ipl_rect_type cropout;
  uint32 yWidth, xWidth;
  uint32 yCols = 0;
  uint32 xCols = 0;
  uint32 width, newWidth = 0;
  boolean mustWarpX = 0;
  boolean mustWarpY = 0;
  ipl_image_type tempBuf;

  MSG_LOW("ipl_efx_meshWarp marker_0\n");

  if (!input_img_ptr || !input_img_ptr->imgPtr ||
      !output_img_ptr || !output_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_efx_meshWarp marker_200\n");
    return IPL_FAILURE;
  }

  /* Input must be YCbCr 4:2:2 or YCbCr 4:2:0 line packed */
  if (input_img_ptr->cFormat != IPL_YCbCr &&
      input_img_ptr->cFormat != IPL_YCrCb420_LINE_PK &&
      input_img_ptr->cFormat != IPL_YCbCr420_LINE_PK &&
      input_img_ptr->cFormat != IPL_RGB565)
  {
    MSG_LOW("ipl_efx_meshWarp marker_201\n");
    return IPL_FAILURE;
  }

  /* Output must be YCbCr 4:2:2, YCbCr 4:2:0 line packed, or RGB565 */
  if (output_img_ptr->cFormat != IPL_RGB565 &&
      output_img_ptr->cFormat != IPL_YCbCr &&
      output_img_ptr->cFormat != IPL_YCrCb420_LINE_PK &&
      output_img_ptr->cFormat != IPL_YCbCr420_LINE_PK)
  {
    MSG_LOW("ipl_efx_meshWarp marker_202\n");
    return IPL_FAILURE;
  }

  /* Input and output sizes should be equal */
  if (input_img_ptr->dy != output_img_ptr->dy &&
      input_img_ptr->dx != output_img_ptr->dx)
  {
    MSG_LOW("ipl_efx_meshWarp marker_203\n");
    return IPL_FAILURE;
  }

  /* stretch in Y first */
  //yCols = 2;
  yCols = 1;

  MSG_LOW("ipl_efx_meshWarp marker_1\n");

  /* see how many rows we have, and if all of equal width or not */
  width = dstMesh->cvy[1] - dstMesh->cvy[0];
  while (dstMesh->cvy[++yCols] != 100 && yCols < IPL_MAX_GRID-1)
  {
    newWidth = dstMesh->cvy[yCols] - dstMesh->cvy[yCols-1];
    if (width != newWidth)
      mustWarpY = 1;
  }
  // make sure we got 100 (end marker)
  if (yCols == IPL_MAX_GRID && dstMesh->cvy[IPL_MAX_GRID - 1] != 100)
  {
    MSG_LOW("ipl_efx_meshWarp marker_204\n");
    return IPL_FAILURE;
  }
  yWidth = input_img_ptr->dy / yCols;

  /* see how many rows we have, and if all of equal width or not */
  xCols = 1;
  width = dstMesh->cvx[1] - dstMesh->cvx[0];

  while (++xCols < IPL_MAX_GRID && dstMesh->cvx[xCols] != 100)
  {
    if (width != newWidth)
      mustWarpX = 1;
  }

  if (xCols >= IPL_MAX_GRID)
  {
    MSG_LOW("ipl_efx_meshWarp marker_205\n");
    return IPL_FAILURE;
  }

  newWidth = dstMesh->cvx[xCols] - dstMesh->cvx[xCols-1];

  // make sure we got 100 (end marker)
  //if (xCols == IPL_MAX_GRID && dstMesh->cvx[IPL_MAX_GRID - 1] != 100)
  //  return IPL_FAILURE;

  xWidth = input_img_ptr->dx / xCols;

  /* warp in Y first */
  if (mustWarpY)
  {
    tempBuf.dx = output_img_ptr->dx;
    tempBuf.dy = output_img_ptr->dy;
    tempBuf.cFormat = output_img_ptr->cFormat;

    /* if we are warping in X too, then copy to temp buffer, so Xwarp can then
     * warp into final output */
    if (mustWarpX)
    {
      if (ipl_malloc_img(&tempBuf))
      {
        MSG_LOW("ipl_efx_meshWarp marker_206\n");
        return IPL_NO_MEMORY;
      }
    }
    else
    {
      tempBuf.imgPtr = output_img_ptr->imgPtr;
    }

    cropin.x = cropin.y = cropout.x = cropout.y = 0;
    cropin.dx = input_img_ptr->dx;
    cropout.dx = output_img_ptr->dx;
    for (i = 1; i <= yCols; i++)
    {
      if (opp == 0)
      {
        cropin.dy = yWidth;
        cropout.dy = output_img_ptr->dy *
          (dstMesh->cvy[i] - dstMesh->cvy[i-1])/100;
      }
      else
      {
        cropin.dy = output_img_ptr->dy *
          (dstMesh->cvy[i] - dstMesh->cvy[i-1])/100;
        cropout.dy=yWidth;
      }

      ipl_xform_Resize_qHigh(input_img_ptr, &tempBuf, &cropin, &cropout);
      cropin.y += cropin.dy;
      cropout.y += cropout.dy;
    }
  }

  /* now take result and stretch in X accordingly */
  if (mustWarpX)
  {
    /* see where our input is coming from,i.e. did we warp in Y */
    if (!mustWarpY)
      tempBuf.imgPtr = input_img_ptr->imgPtr;

    cropin.x = cropin.y = cropout.x = cropout.y = 0;
    cropin.dy = input_img_ptr->dy;
    cropout.dy = output_img_ptr->dy;
    for (i = 1; i <= xCols; i++)
    {
      if (opp == 0)
      {
        cropin.dx = xWidth;
        cropout.dx = output_img_ptr->dx *
          (dstMesh->cvx[i] - dstMesh->cvx[i-1])/100;
      }
      else
      {
        cropin.dx = output_img_ptr->dx *
          (dstMesh->cvx[i] - dstMesh->cvx[i-1])/100;
        cropout.dx=xWidth;
      }

      ipl_xform_Resize_qHigh(&tempBuf, output_img_ptr, &cropin, &cropout);
      cropin.x += cropin.dx;
      cropout.x += cropout.dx;
    }
  }

  if (mustWarpY && mustWarpX)
    ipl_free_img(&tempBuf);

  MSG_LOW("ipl_efx_meshWarp marker_100\n");

  return IPL_SUCCESS;
}


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_luma_adaptation

DESCRIPTION
  This function stretches the histogram of an image to provide more detail
  in the lights and darks.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  thresholdQ8

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_luma_adaptation
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  ipl_histogram_type* hist,
  uint16 thresholdQ8
)
{
  ipl_image_type temp_img_ptr;

  uint8 *iptrLuma;
  uint8 *iptrChroma;
  uint8 *optrLuma;
  uint8 *optrChroma;

  uint8 mapping[256]; //lint !e771
  int8 chroma;
  int16 tmp16s;
  uint16 tmp16, scale, max_hist, min_hist;
  uint32 i,j,thresholdN, stepThreshold;
  uint32 sum,tmp;
  uint32 wh;
  uint32 dx;
  ipl_histogram_type histogram;

  #define SCALE_MAX_Q8 512
  #define SCALE_MIN_Q8 205
  #define FLOOR_START  20
  #define FLOOR_HEIGHT_Q12 10

  MSG_LOW("ipl_luma_adaptation marker_0\n");

  // setup some vars
  dx = i_img_ptr->dx;

  wh = i_img_ptr->dx * i_img_ptr->dy;
  iptrLuma = i_img_ptr->imgPtr;

  // if no output image provided, then lets do it inplace
  if (o_img_ptr == NULL)
  {
    temp_img_ptr.dx = i_img_ptr->dx;
    temp_img_ptr.dy = i_img_ptr->dy;
    temp_img_ptr.cFormat = i_img_ptr->cFormat;
    temp_img_ptr.imgPtr = i_img_ptr->imgPtr;
    temp_img_ptr.clrPtr = i_img_ptr->clrPtr;
  }
  else
  {
    temp_img_ptr.dx = o_img_ptr->dx;
    temp_img_ptr.dy = o_img_ptr->dy;
    temp_img_ptr.cFormat = o_img_ptr->cFormat;
    temp_img_ptr.imgPtr = o_img_ptr->imgPtr;
    temp_img_ptr.clrPtr = o_img_ptr->clrPtr;
  }

  // if no histogram provided, then we comput it ourselves
  if (hist == NULL)
  {
    histogram.size = 256;
    histogram.channel = IPL_CHANNEL_LUMA;
    ipl_calc_histograms(i_img_ptr, NULL, &histogram, IPL_QUALITY_HIGH);
    hist = &histogram;
  }
  else
  {
    //user may have forgotten to tell use size of histogram
    if (hist->size == 0)
      hist->size = 256;
  }

  MSG_LOW("ipl_luma_adaptation marker_1\n");

  /* Cap the PDF */
  thresholdN = (uint32)(thresholdQ8 * wh >> 8);
  sum = 0;
  for (i = 0 ; i < hist->size; i++)
  {
    hist->v[i] = IPL_MIN(hist->v[i], thresholdN);
    sum += hist->v[i];
  }
  tmp = (sum << 8) / wh;
  thresholdN = (thresholdN * tmp) >> 8;

  /* Raise PDF between FOOR_START and 255-FLOOR_START by FLOOR_HEIGHT */
  stepThreshold = (wh * FLOOR_HEIGHT_Q12 + 2048) >> 12;
  stepThreshold /= 10;
  for (i = 0;i < 10; i++)
  {
    hist->v[i+FLOOR_START] =IPL_MAX(hist->v[i+FLOOR_START],((i+1)*stepThreshold));
    hist->v[255-FLOOR_START-i] =IPL_MAX(hist->v[255-FLOOR_START-i],((i+1)*stepThreshold));
  }

  for (i = FLOOR_START+10; i < (uint32) (hist->size - FLOOR_START-10); i++)
  {
    hist->v[i] = IPL_MAX((hist->v[i]), (10*stepThreshold));
  }

  /* Compute CDF */
  for (i = 1; i < hist->size; i++)
  {
    hist->v[i] += hist->v[i-1];
  }

  /* Scale capped CDF so it ends at height*width */
  tmp16 = (uint16)((wh<<8) / hist->v[255]);
  for (i = 0; i < hist->size; i++)
  {
    hist->v[i] = (hist->v[i]*tmp16)>>8;
  }

  /* Scale CDF so it ends with 255 and average with y=x mapping*/
  for (i = 0; i < hist->size; i++)
  {
    mapping[i] = (uint8)(((hist->v[i]<<8)/wh+i)/2);
  }

  /* Limit max and min correction */
  for (i = 0; i < hist->size; i++)
  {
    max_hist = (uint16)((i * SCALE_MAX_Q8 + 128) >> 8);
    max_hist = IPL_MIN(max_hist, 255);
    min_hist = (uint16)((i * SCALE_MIN_Q8 + 128) >>8);
    mapping[i] = IPL_MIN(mapping[i], max_hist); //lint !e771
    mapping[i] = IPL_MAX(mapping[i], min_hist);
  }


  /* Perform mapping as
   *
   * Luma_new = Mapping[Luma]
   * Chroma_new = Chroma * Luma_new/Luma
   *
   * */

  iptrLuma = i_img_ptr->imgPtr;
  iptrChroma = i_img_ptr->clrPtr;

  optrLuma = temp_img_ptr.imgPtr;
  optrChroma = temp_img_ptr.clrPtr;

  MSG_LOW("ipl_luma_adaptation marker_2\n");

  // do luma first

  if ((i_img_ptr->cFormat == IPL_YCbCr422_LINE_PK) ||
      (i_img_ptr->cFormat == IPL_YCrCb422_LINE_PK))
  {
    for (i = 0; i < i_img_ptr->dy; i++)
    {
      for (j = 0; j < i_img_ptr->dx/2; j++)
      {
        // do 2 ys for every Cr and Cb pair
        tmp16 = (uint16)mapping[*iptrLuma];
        scale = (tmp16<<8) / (*iptrLuma++ + 1); // avoid div by 0
        *optrLuma++ = (uint8)tmp16;

        tmp16 = (uint16)mapping[*iptrLuma];
        scale += (tmp16<<8) / (*iptrLuma++ + 1); // avoid div by 0
        *optrLuma++ = (uint8)tmp16;

        scale >>= 1;

        chroma = *iptrChroma++ - 128;
        tmp16s = ((chroma*scale) + 128) >> 8;
        tmp16s += 128;
        tmp16s = IPL_MIN(tmp16s, 255);
        tmp16s = IPL_MAX(tmp16s, 0);
        *optrChroma++ = (uint8) tmp16s;

        chroma = *iptrChroma++ - 128;
        tmp16s = ((chroma*scale) + 128) >> 8;
        tmp16s += 128;
        tmp16s = IPL_MIN(tmp16s, 255);
        tmp16s = IPL_MAX(tmp16s, 0);

        *optrChroma++ = (uint8) tmp16s;
      }
    }
  }
  else if ((i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK) ||
           (i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK))
  {
    for (i = 0; i < i_img_ptr->dy/2; i++)
    {
      for (j = 0; j < i_img_ptr->dx/2; j++)
      {
        // do 4 ys for every Cr and Cb pair
        // note: we are not doing the 2x2 ys associated with the Cr, Cb
        // pair, but that is okay, we just wnat to unroll this loop
        tmp16 = (uint16)mapping[*iptrLuma];
        scale = (tmp16<<8) / (*iptrLuma + 1); // avoid div by 0
        *optrLuma = (uint8)tmp16;

        tmp16 = (uint16)mapping[*(iptrLuma + dx)];
        scale += (tmp16<<8) / (*(iptrLuma + dx) + 1); // avoid div by 0
        *(optrLuma + dx) = (uint8)tmp16;

        iptrLuma++;
        optrLuma++;

        tmp16 = (uint16)mapping[*iptrLuma];
        scale += (tmp16<<8) / (*iptrLuma + 1); // avoid div by 0
        *optrLuma = (uint8)tmp16;

        tmp16 = (uint16)mapping[*(iptrLuma + dx)];
        scale += (tmp16<<8) / (*(iptrLuma + dx) + 1); // avoid div by 0
        *(optrLuma + dx) = (uint8)tmp16;

        scale >>= 2;
        iptrLuma++;
        optrLuma++;

        chroma = *iptrChroma++ - 128;
        tmp16s = ((chroma*scale) + 128) >> 8;
        tmp16s += 128;
        tmp16s = IPL_MIN(tmp16s, 255);
        tmp16s = IPL_MAX(tmp16s, 0);
        *optrChroma++ = (uint8) tmp16s;

        chroma = *iptrChroma++ - 128;
        tmp16s = ((chroma*scale) + 128) >> 8;
        tmp16s += 128;
        tmp16s = IPL_MIN(tmp16s, 255);
        tmp16s = IPL_MAX(tmp16s, 0);
        *optrChroma++ = (uint8) tmp16s;
      }

      // skip odd rows since we already processed it.
      iptrLuma += dx;
      optrLuma += dx;
    }
  }
  else
  {
    MSG_LOW("ipl_luma_adaptation marker_200\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_luma_adaptation marker_100\n");
  return IPL_SUCCESS;
}



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_hue

DESCRIPTION
  This function performs hue scaling and color conversion if required.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  hue_factor     an additive hue scale factor (range is -360 to 360)

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_hue
(
  ipl_image_type* i_img_ptr,         /* Points to the input image          */
  ipl_image_type* o_img_ptr,         /* Points to the output image         */
  int32 hue_factor                   /* Hue scaling factor                 */
)
{
  uint32 row,col,index;
  int32 temp;
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  ipl_image_type hsv_buffer;

  MSG_LOW("ipl_hue marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_hue marker_200\n");
    return IPL_FAILURE;
  }

  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;


  if (!((input_img_ptr->dx == output_img_ptr->dx) &&
        (input_img_ptr->dy == output_img_ptr->dy)))
  {
    MSG_LOW("ipl_hue marker_201\n");
    /* Input and Output should be of same dimension */
    return IPL_FAILURE;
  }

  //if ((input_img_ptr->cFormat != IPL_YCbCr) ||
  //    (output_img_ptr->cFormat != IPL_YCbCr))
  //{
  //  MSG_LOW("ipl_hue marker_202\n");
  //  /* Only YCbCr Input format currently supported */
  //  return IPL_FAILURE;
  //}


  // make sure we can complete this rather complex task in a reasonable
  // amount of time, i.e. do not process images too big
  if (i_img_ptr->dx * i_img_ptr->dy >= IPL_IMAGE_MAX)
    //return IPL_2CPU_INTENSIVE;
    return IPL_UNSUPPORTED;

  /* Check the range */
  if ((hue_factor>360) || (hue_factor<-360))
  {
    MSG_LOW("ipl_hue marker_203\n");
    return IPL_FAILURE;
  }

  /* Buffer allocation */
  hsv_buffer.dx = i_img_ptr->dx;
  hsv_buffer.dy = i_img_ptr->dy;
  hsv_buffer.cFormat = IPL_HSV;
  if (ipl_malloc_img(&hsv_buffer))
  {
    MSG_LOW("ipl_hue marker_204\n");
    return IPL_NO_MEMORY;
  }

  if (!hsv_buffer.imgPtr)
  {
    MSG_LOW("ipl_hue marker_205\n");
    /* Ran out of memory */
    //sys_free(hsv_buffer->imgPtr);
    return IPL_FAILURE;
  }

  if (ipl_convert_image(input_img_ptr,&hsv_buffer) != IPL_SUCCESS )
  {
    ipl_sys_free(hsv_buffer.imgPtr);
    MSG_LOW("ipl_hue marker_206\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_hue marker_1\n");

  /* Change Hue */
  for(row = 0; row < input_img_ptr->dy; row++)
  {
    for(col = 0; col < input_img_ptr->dx; col=col+1)
    {
      index = ((row*input_img_ptr->dx) + col)*3;
      temp = hsv_buffer.imgPtr[index] + hue_factor;
      temp=CLIPIT(temp);
      hsv_buffer.imgPtr[index] = (unsigned char) temp;
    }
  }

  /* Convert back to YCbCr */
  if (ipl_convert_image(&hsv_buffer,output_img_ptr) != IPL_SUCCESS )
  {
    ipl_sys_free(hsv_buffer.imgPtr);
    MSG_LOW("ipl_hue marker_207\n");
    return IPL_FAILURE;
  }

  ipl_sys_free(hsv_buffer.imgPtr);
  MSG_LOW("ipl_hue marker_100\n");
  return IPL_SUCCESS;
} /* end ipl_hue */




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_sat

DESCRIPTION
  This function performs saturation scaling and color conversion if required.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image
  sat_factor    additive saturation scale factor (range is -255 to 255)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_sat
(
  ipl_image_type* i_img_ptr,         /* Points to the input image          */
  ipl_image_type* o_img_ptr,         /* Points to the output image         */
  int32 sat_factor                   /* Saturation scaling factor          */
)
{
  uint32 row,col,index;
  int32 temp;
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  ipl_image_type hsv_buffer;

  MSG_LOW("ipl_sat marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_sat marker_200\n");
    return IPL_FAILURE;
  }

  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;

  // make sure we can complete this rather complex task in a reasonable
  // amount of time, i.e. do not process images too big
  if (i_img_ptr->dx * i_img_ptr->dy >= IPL_IMAGE_MAX)
    //return IPL_2CPU_INTENSIVE;
    return IPL_UNSUPPORTED;


  if (!((input_img_ptr->dx == output_img_ptr->dx) &&
        (input_img_ptr->dy == output_img_ptr->dy)))
  {
    MSG_LOW("ipl_sat marker_201\n");
    /* Input and Output should be of same dimension */
    return IPL_FAILURE;
  }

  //if ((input_img_ptr->cFormat != IPL_YCbCr) ||
  //    (output_img_ptr->cFormat != IPL_YCbCr))
  //{
  //  MSG_LOW("ipl_sat marker_202\n");
  //  /* Only YCbCr Input format currently supported */
  //  return IPL_FAILURE;
  //}

  /* Check the range */
  if ((sat_factor>255) || (sat_factor<-255))
  {
    MSG_LOW("ipl_sat marker_203\n");
    return IPL_FAILURE;
  }

  /* Buffer allocation */
  hsv_buffer.dx = i_img_ptr->dx;
  hsv_buffer.dy = i_img_ptr->dy;
  hsv_buffer.cFormat = IPL_HSV;
  if (ipl_malloc_img(&hsv_buffer))
  {
    MSG_LOW("ipl_sat marker_204\n");
    return IPL_NO_MEMORY;
  }

  if (!hsv_buffer.imgPtr)
  {
    MSG_LOW("ipl_sat marker_205\n");
    /* Ran out of memory */
    //sys_free(hsv_buffer);
    return IPL_FAILURE;
  }

  if (ycbcr_to_hsv_normalized(input_img_ptr,&hsv_buffer) != IPL_SUCCESS )
  {
    ipl_sys_free(hsv_buffer.imgPtr);
    MSG_LOW("ipl_sat marker_206\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_sat marker_1\n");

  /* Change Sat */
  for(row = 0; row < input_img_ptr->dy; row++)
  {
    for(col = 0; col < input_img_ptr->dx; col=col+1)
    {
      index = ((row*input_img_ptr->dx) + col)*3;
      temp = hsv_buffer.imgPtr[index+1] + sat_factor;
      temp=CLIPIT(temp);
      hsv_buffer.imgPtr[index+1] = (uint8)temp;
    }
  }

  /* Convert back to YCbCr */
  if (hsv_to_ycbcr_normalized(&hsv_buffer, output_img_ptr) != IPL_SUCCESS )
  {
    ipl_sys_free(hsv_buffer.imgPtr);
    MSG_LOW("ipl_sat marker_207\n");
    return IPL_FAILURE;
  }

  ipl_sys_free(hsv_buffer.imgPtr);
  MSG_LOW("ipl_sat marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_sat */




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_int

DESCRIPTION
  This function performs intensity scaling.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image
  int_factor    intensity scale factor (range is -255 to 255)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_int
(
  ipl_image_type* i_img_ptr,         /* Points to the input image          */
  ipl_image_type* o_img_ptr,         /* Points to the output image         */
  int32 int_factor                   /* Intensity scaling factor           */
)
{
  uint32 row,col,index;
  int32 temp;
  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  ipl_image_type hsv_buffer;

  MSG_LOW("ipl_int marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_int marker_200\n");
    return IPL_FAILURE;
  }

  // make sure we can complete this rather complex task in a reasonable
  // amount of time, i.e. do not process images too big
  if (i_img_ptr->dx * i_img_ptr->dy >= IPL_IMAGE_MAX)
    //return IPL_2CPU_INTENSIVE;
    return IPL_UNSUPPORTED;

  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;


  if (!((input_img_ptr->dx == output_img_ptr->dx) &&
        (input_img_ptr->dy == output_img_ptr->dy)))
  {
    MSG_LOW("ipl_int marker_201\n");
    /* Input and Output should be of same dimension */
    return IPL_FAILURE;
  }

  //if ((input_img_ptr->cFormat != IPL_YCbCr) ||
  //    (output_img_ptr->cFormat != IPL_YCbCr))
  //{
  //  MSG_LOW("ipl_int marker_202\n");
  //  /* Only YCbCr Input format currently supported */
  //  return IPL_FAILURE;
  //}

  /* Check the range */
  if ((int_factor>255) || (int_factor<-255))
  {
    MSG_LOW("ipl_int marker_203\n");
    return IPL_FAILURE;
  }

  /* Buffer allocation */
  hsv_buffer.dx = i_img_ptr->dx;
  hsv_buffer.dy = i_img_ptr->dy;
  hsv_buffer.cFormat = IPL_HSV;
  if (ipl_malloc_img(&hsv_buffer))
  {
    MSG_LOW("ipl_int marker_204\n");
    return IPL_NO_MEMORY;
  }

  if (ipl_convert_image(input_img_ptr,&hsv_buffer) != IPL_SUCCESS )
  {
    ipl_sys_free(hsv_buffer.imgPtr);
    MSG_LOW("ipl_int marker_205\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_int marker_1\n");

  /* Change Int */
  for(row = 0; row < input_img_ptr->dy; row++)
  {
    for(col = 0; col < input_img_ptr->dx; col=col+1)
    {
      index = ((row*input_img_ptr->dx) + col)*3;
      temp = hsv_buffer.imgPtr[index+2] + int_factor;
      temp = CLIPIT(temp);
      hsv_buffer.imgPtr[index+2] = (uint8)temp;
    }
  }

  /* Convert back to YCbCr */
  if (ipl_convert_image(&hsv_buffer, output_img_ptr) != IPL_SUCCESS )
  {
    ipl_sys_free(hsv_buffer.imgPtr);
    MSG_LOW("ipl_int marker_206\n");
    return IPL_FAILURE;
  }
  ipl_sys_free(hsv_buffer.imgPtr);
  MSG_LOW("ipl_int marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_int */







/* <EJECT> */
/*===========================================================================

FUNCTION ipl_magnify_rgb565

DESCRIPTION
  This function magnifies an input image in a circular region of
  arbitrary location and radius.  The center of the magnified region
  must be within the input image boundaries. Areas outside the circular
  region are not magnified. If part of the magnified region extends
  beyond image boundaries, only the part within boundaries is
  displayed.

  Input and output image sizes must be equal.

  Input and output images must be in RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr     pointer to the input image
  out_img_ptr    pointer to the output image
  circle         the circular region of magnification

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_magnify_rgb565
(
  ipl_image_type* in_img_ptr,    /* Points to the input image        */
  ipl_image_type* out_img_ptr,   /* Points to the output image       */
  ipl_circle_type* circle        /* Circular region of magnification */
)
{
  uint16 *inImgPtr, *outImgPtr, *blankPixels;
  uint32 outWidth, outHeight, xin, yin, xout, yout, rSq, endx1, endy1,
         endx2, endy2, mapWidth, mapHeight, mapSize, xytemp,
         outIndex, inIndex, mapIndex, nbIndex, inc, xo, yo, r;
  int16 *xMap, *yMap;
  int8 *nbXMap, *nbYMap;
  uint16 rsum, gsum, bsum;
  uint8 rval, gval, bval, rgbCnt;
  uint32 k1, k2, factor;
  int32 xa, ya, xan, yan;
  uint32 xb, yb, xbn, ybn;

  MSG_LOW("ipl_magnify_rgb565 marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr ||
      !circle)
  {
    MSG_LOW("ipl_magnify_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = (uint16*)in_img_ptr->imgPtr;
  outImgPtr = (uint16*)out_img_ptr->imgPtr;
  outWidth = out_img_ptr->dx;
  outHeight = out_img_ptr->dy;
  xo = circle->x;
  yo = circle->y;
  r = circle->r;

  /*Restricting the raduis of the magnifying glass to be 256
  to avoid black borders*/
  if (r > 255)
  {
    r = 255;
  }

  /* Initialize index endpoints and local variables */
  if (xo < r) {
    endx1 = 0;
  } else {
    endx1 = xo - r;
  }
  endx2 = xo + r + 1;
  if (endx2 > outWidth) {
    endx2 = outWidth;
  }
  if (yo < r) {
    endy1 = 0;
  } else {
    endy1 = yo - r;
  }
  endy2 = yo + r + 1;
  if (endy2 > outHeight) {
    endy2 = outHeight;
  }
  mapWidth = endx2 - endx1;
  mapHeight = endy2 - endy1;
  mapSize = mapWidth * mapHeight;
  rSq = r*r;

  /*
  ** Malloc buffers for mapping output pixels to input pixels:
  ** xMap maps output (x,y) coordinates to input x-coordinates
  ** yMap maps output (x,y) coordinates to input y-coordinates
  */
  xMap = ipl_malloc(mapSize*sizeof(int16));
  if (!xMap)
  {
    MSG_LOW("ipl_magnify_rgb565 marker_201\n");
    return IPL_NO_MEMORY;
  }
  yMap = ipl_malloc(mapSize*sizeof(int16));
  if (!yMap)
  {
    ipl_sys_free(xMap);
    MSG_LOW("ipl_magnify_rgb565 marker_202\n");
    return IPL_NO_MEMORY;
  }

  /* Initialize xMap and yMap with "blank" points (-1, -1) */
  for (mapIndex = 0; mapIndex < mapSize; mapIndex++) {
    *((int16*)(xMap + mapIndex)) = -1;
  }
  for (mapIndex = 0; mapIndex < mapSize; mapIndex++) {
    *((int16*)(yMap + mapIndex)) = -1;
  }

  MSG_LOW("ipl_magnify_rgb565 marker_1\n");

  /* Create xMap, yMap: mapping from (xout, yout) to (xin, yin) */
  k1 = 5767168 / r;
  k2 = 2048 / r;
  for (yin = endy1; yin < endy2; yin++) {
    for (xin = endx1; xin < endx2; xin++) {
      xytemp = (uint32)((int32)(xin-xo)*(int32)(xin-xo) +
                        (int32)(yin-yo)*(int32)(yin-yo));
      if (xytemp <= rSq) {
        /* within magnified region */
        /* (1) xin, yin */
        factor = 8388608 + (5767168-xytemp*k1/r) +
                 (2048-xytemp*k2/r)*(1024-(xytemp*k2>>1)/r) +
                 (128-xytemp*128/rSq)*(64-xytemp*64/rSq)*
                 (64-xytemp*64/rSq);
        xout = (uint32)(xo + (((int32)factor*(int32)(xin-xo))>>23));
        yout = (uint32)(yo + (((int32)factor*(int32)(yin-yo))>>23));
        if (xout >= endx1 && xout < endx2 && yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* values used in the calculations below */
        xa = ((int32)(xin - xo) << 3) + 3;
        ya = ((int32)(yin - yo) << 3) + 3;
        xan = ((int32)(xin - xo) << 3) - 3;
        yan = ((int32)(yin - yo) << 3) - 3;
        xb = (uint32)(xo+(((int32)factor*(int32)(xin-xo+1))>>23));
        yb = (uint32)(yo+(((int32)factor*(int32)(yin-yo+1))>>23));
        xbn = (uint32)(xo+(((int32)factor*(int32)(xin-xo-1))>>23));
        ybn = (uint32)(yo+(((int32)factor*(int32)(yin-yo-1))>>23));

        /* (2) xin + 0.4, yin (in fixed point arithmetic) */
        xout = (uint32)(xo + ((((int32)factor>>3)*xa)>>23));
        /* yout already calculated */
        /* Check xin + 1, yin */
        if (xout != xb && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (3) xin + 0.4, yin + 0.4 (in fixed point arithmetic)*/
        /* xout already calculated */
        yout = (uint32)(yo + ((((int32)factor>>3)*ya)>>23));
        /* Check xin + 1, yin + 1 */
        if (xout != xb && yout != yb && xout >= endx1 &&
            xout < endx2 && yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                   (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (4) xin, yin + 0.4 (in fixed point arithmetic) */
        xout = (uint32)(xo + (((int32)factor*(int32)(xin-xo))>>23));
        /* yout already calculated */
        /* Check xin, yin + 1 */
        if (yout != yb && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                   (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (5) xin, yin - 0.4 (in fixed point arithmetic) */
        /* xout already calculated */
        yout = (uint32)(yo + ((((int32)factor>>3)*yan)>>23));
        /* Check xin, yin - 1 */
        if (yout != ybn && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                   (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (6) xin - 0.4, yin - 0.4 (in fixed point arithmetic) */
        xout = (uint32)(xo + ((((int32)factor>>3)*xan)>>23));
        /* yout already calculated */
        /* Check xin - 1, yin - 1 */
        if (xout != xbn && yout != ybn && xout >= endx1 &&
            xout < endx2 && yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                   (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (7) xin - 0.4, yin (in fixed point arithmetic) */
        /* xout already calculated */
        yout = (uint32)(yo + (((int32)factor*(int32)(yin-yo))>>23));
        /* Check xin - 1, yin */
        if (xout != xbn && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                   (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */
      } /* end if (xin, yin) within magnified region */
    } /* end yin loop */
  } /* end xin loop */

  /*
  ** Fill in output pixels in the following order:
  ** |---------------------------|
  ** |            (1)            |
  ** |---------------------------|
  ** | (2a)    |  (2b)  |   (2c) |
  ** |---------------------------|
  ** |            (3)            |
  ** |---------------------------|
  */
  /* (1) non-magnified region ABOVE magnified region */
  outIndex = 0;
  for (yout = 0; yout < endy1; yout++) {
    for (xout = 0; xout < outWidth; xout++) {
      *((uint16*)(outImgPtr+outIndex)) = *((uint16*)(inImgPtr+outIndex));
      outIndex++;
    }
  } /* end (1) */

  /* (2) region around magnified region */
  mapIndex = 0;
  for (yout = endy1; yout < endy2; yout++) {
    /* (2a) non-magnified region to the left of the magnified area */
    for (xout = 0; xout < endx1; xout++) {
      *((uint16*)(outImgPtr+outIndex)) = *((uint16*)(inImgPtr+outIndex));
      outIndex++;
    }
    /* (2b) region affected by magnification */
    for (xout = endx1; xout < endx2; xout++) {
    if (*((int16*)(xMap + mapIndex)) == -1) {
        *((uint16*)(outImgPtr + outIndex++)) = 0;
      } else {
        inIndex = *((int16*)(xMap+mapIndex)) +
                  *((int16*)(yMap+mapIndex)) * outWidth;
        *((uint16*)(outImgPtr+outIndex++)) = *((uint16*)(inImgPtr+inIndex));
      }
      mapIndex++;
    }
    /* (2c) non-magnified region to the right of the magnified area */
    for (xout = endx2; xout < outWidth; xout++) {
      *((uint16*)(outImgPtr+outIndex)) = *((uint16*)(inImgPtr+outIndex));
      outIndex++;
    }
  } /* end (2) */

  /* (3) non-magnified region BELOW magnified area */
  for (yout = endy2; yout < outHeight; yout++) {
    for (xout = 0; xout < outWidth; xout++) {
      *((uint16*)(outImgPtr+outIndex)) = *((uint16*)(inImgPtr+outIndex));
      outIndex++;
    }
  } /* end (3) */

  /*
  ** Malloc 3 buffers:
  ** blankPixels stores interpolated pixel values for
  **     pixels left blank in the previous step
  ** nbXMap, nbYMap stores the order in which
  **     neighboring pixels are used during the
  **     interpolation process
  */
  blankPixels = ipl_malloc(mapSize*sizeof(uint16));
  if (!blankPixels)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(yMap);
    MSG_LOW("ipl_magnify_rgb565 marker_203\n");
    return IPL_NO_MEMORY;
  }
  nbXMap = ipl_malloc(8*sizeof(int8));
  if (!nbXMap)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(yMap);
    ipl_sys_free(blankPixels);
    MSG_LOW("ipl_magnify_rgb565 marker_204\n");
    return IPL_NO_MEMORY;
  }
  nbYMap = ipl_malloc(8*sizeof(int8));
  if (!nbYMap)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(yMap);
    ipl_sys_free(nbXMap);
    ipl_sys_free(blankPixels);
    MSG_LOW("ipl_magnify_rgb565 marker_205\n");
    return IPL_NO_MEMORY;
  }

  /* Initialize nbXMap, nbYMap */
  *nbXMap = -1;
  *((int8*)(nbXMap+1)) = 0;
  *((int8*)(nbXMap+2)) = 1;
  *((int8*)(nbXMap+3)) = -1;
  *((int8*)(nbXMap+4)) = 1;
  *((int8*)(nbXMap+5)) = -1;
  *((int8*)(nbXMap+6)) = 0;
  *((int8*)(nbXMap+7)) = 1;
  *nbYMap = -1;
  *((int8*)(nbYMap+1)) = -1;
  *((int8*)(nbYMap+2)) = -1;
  *((int8*)(nbYMap+3)) = 0;
  *((int8*)(nbYMap+4)) = 0;
  *((int8*)(nbYMap+5)) = 1;
  *((int8*)(nbYMap+6)) = 1;
  *((int8*)(nbYMap+7)) = 1;

  /* Compute missing values for area affected by magnification */
  mapIndex = 0;
  for (yout = endy1; yout < endy2; yout++) {
    for (xout = endx1; xout < endx2; xout++) {
      if (*((int16*)(xMap + mapIndex)) == -1) {
        /* blank pixel */
        xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                          (int32)(yout-yo)*(int32)(yout-yo));
        if (xytemp > rSq) {
          /* outside magnified region */
          inIndex = xout + yout * outWidth;
          *((uint16*)(blankPixels+mapIndex)) = *((uint16*)(inImgPtr+inIndex));
        } else {
          /* inside magnified region */
          nbIndex = 0;
          rsum = 0;
          gsum = 0;
          bsum = 0;
          rgbCnt = 0;
          while (nbIndex < 8) {
            /* neighboring pixel */
            xin = (uint32)((int32)xout + (int32)*((int8*)(nbXMap+nbIndex)));
            yin = (uint32)((int32)yout + (int32)*((int8*)(nbYMap+nbIndex)));
            if (xin < outWidth && yin < outHeight) {
              /* within image boundaries */
              outIndex = xin + yin * outWidth;
              /* unpack to get rgb values */
              rval = (uint8)((*((uint16*)(outImgPtr+outIndex)) & 0xF800)>>8);
              gval = (uint8)((*((uint16*)(outImgPtr+outIndex)) & 0x07E0)>>3);
              bval = (uint8)((*((uint16*)(outImgPtr+outIndex)) & 0x001F)<<3);
              if (rval != 0 || gval != 0 || bval != 0) {
                rsum += rval;
                gsum += gval;
                bsum += bval;
                rgbCnt++;
              }
            }
            nbIndex++;
          } /* end while loop */
          /* get average */
          if (rgbCnt > 0) {
            rsum /= rgbCnt;
            gsum /= rgbCnt;
            bsum /= rgbCnt;
          }
          /* pack into rgb565 format */
          *((uint16*)(blankPixels + mapIndex)) = pack_rgb565(rsum, gsum, bsum);
        } /* end if blank pixel outside magnified region */
      } /* end if blank pixel */
      else {
        /* non-blank pixel */
        outIndex = xout + yout * outWidth;
        *((uint16*)(blankPixels+mapIndex)) = *((uint16*)(outImgPtr+outIndex));
      }
      /* increment the index */
      mapIndex++;
    } /* end xout loop */
  } /* end yout loop */

  /*
  ** Fill in missing values in final output for area
  ** affected by magnification
  */
  mapIndex = 0;
  inc = outWidth - mapWidth;
  outIndex = endx1 + endy1 * outWidth;
  for (yout = endy1; yout < endy2; yout++) {
    for (xout = endx1; xout < endx2; xout++) {
      *((uint16*)(outImgPtr+outIndex++))=*((uint16*)(blankPixels+mapIndex++));
    }
    outIndex += inc;
  }

  /* Free memory */
  ipl_sys_free(xMap);
  ipl_sys_free(yMap);
  ipl_sys_free(blankPixels);
  ipl_sys_free(nbXMap);
  ipl_sys_free(nbYMap);

  MSG_LOW("ipl_magnify_rgb565 marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_magnify_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_magnify_ycbcr

DESCRIPTION
  This function magnifies an input image in a circular region of
  arbitrary location and radius.  The center of the magnified region
  must be within the input image boundaries. Areas outside the circular
  region are not magnified. If part of the magnified region extends
  beyond image boundaries, only the part within boundaries is
  displayed.

  Input and output image sizes must be equal.

  Input and output images must be in YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr     pointer to the input image
  out_img_ptr    pointer to the output image
  circle         the circular region of magnification

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_magnify_ycbcr
(
  ipl_image_type* in_img_ptr,  /* Points to the input image        */
  ipl_image_type* out_img_ptr, /* Points to the output image       */
  ipl_circle_type* circle      /* Circular region of magnification */
)
{
  unsigned char *inImgPtr, *outImgPtr, *blankPixels, *fullImgPtr,
                *outFullImgPtr;
  unsigned char cb, cr, luma1, luma2;
  uint32 outWidth, outHeight, xin, yin, xout, yout, rSq,
         endx1, endy1, endx2, endy2, mapWidth, mapHeight, mapSize,
         xytemp, outIndex, inIndex, mapIndex, nbIndex, inc,
         xo, yo, r;
  int16 *xMap, *yMap;
  int8 *nbXMap, *nbYMap;
  uint16 lumasum, cbsum, crsum;
  uint8 cnt;
  uint32 k1, k2, factor;
  int32 xa, ya, xan, yan;
  uint32 xb, yb, xbn, ybn;

  MSG_LOW("ipl_magnify_ycbcr marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr ||
      !circle)
  {
    MSG_LOW("ipl_magnify_ycbcr marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = in_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;
  outWidth = out_img_ptr->dx;
  outHeight = out_img_ptr->dy;
  xo = circle->x;
  yo = circle->y;
  r = circle->r;

  /*Restricting the raduis of the magnifying glass to be 256
  to avoid black borders*/
  if (r > 255)
  {
    r = 255;
  }

  /* Initialize index endpoints and local variables */
  fullImgPtr = ipl_malloc(outWidth*outHeight*3*sizeof(unsigned char));
  if (!fullImgPtr) {
    MSG_LOW("ipl_magnify_ycbcr marker_201\n");
    return IPL_NO_MEMORY;
  }
  outFullImgPtr = ipl_malloc(outWidth*outHeight*3*sizeof(unsigned char));
  if (!outFullImgPtr)
  {
    ipl_sys_free(fullImgPtr);
    MSG_LOW("ipl_magnify_ycbcr marker_202\n");
    return IPL_NO_MEMORY;
  }

  /* Initialize index endpoints and local variables */
  if (xo < r) {
    endx1 = 0;
  } else {
    endx1 = xo - r;
  }
  endx2 = xo + r + 1;
  if (endx2 > outWidth) {
    endx2 = outWidth;
  }
  if (yo < r) {
    endy1 = 0;
  } else {
    endy1 = yo - r;
  }
  endy2 = yo + r + 1;
  if (endy2 > outHeight) {
    endy2 = outHeight;
  }
  mapWidth = endx2 - endx1;
  mapHeight = endy2 - endy1;
  mapSize = mapWidth * mapHeight;
  rSq = r*r;

  /*
  ** Malloc buffers for mapping output pixels to input pixels:
  ** xMap maps output (x,y) coordinates to input x-coordinates
  ** yMap maps output (x,y) coordinates to input y-coordinates
  */
  xMap = ipl_malloc(mapSize*sizeof(int16));
  if (!xMap)
  {
    ipl_sys_free(fullImgPtr);
    ipl_sys_free(outFullImgPtr);
    MSG_LOW("ipl_magnify_ycbcr marker_203\n");
    return IPL_NO_MEMORY;
  }
  yMap = ipl_malloc(mapSize*sizeof(int16));
  if (!yMap)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(fullImgPtr);
    ipl_sys_free(outFullImgPtr);
    MSG_LOW("ipl_magnify_ycbcr marker_204\n");
    return IPL_NO_MEMORY;
  }

  /* Initialize xMap and yMap with "blank" points (-1, -1) */
  for (mapIndex = 0; mapIndex < mapSize; mapIndex++) {
    *((int16*)(xMap + mapIndex)) = -1;
  }
  for (mapIndex = 0; mapIndex < mapSize; mapIndex++) {
    *((int16*)(yMap + mapIndex)) = -1;
  }

  MSG_LOW("ipl_magnify_ycbcr marker_1\n");

  /* Create xMap, yMap: mapping from (xout, yout) to (xin, yin) */
  k1 = 5767168 / r;
  k2 = 2048 / r;
  for (yin = endy1; yin < endy2; yin++) {
    for (xin = endx1; xin < endx2; xin++) {
      xytemp = (uint32)((int32)(xin-xo)*(int32)(xin-xo) +
                        (int32)(yin-yo)*(int32)(yin-yo));
      if (xytemp <= rSq) {
        /* within magnified region */
        /* (1) xin, yin */
        factor = 8388608 + (5767168-xytemp*k1/r) +
                 (2048-xytemp*k2/r)*(1024-(xytemp*k2>>1)/r) +
                 (128-xytemp*128/rSq)*(64-xytemp*64/rSq)*
                 (64-xytemp*64/rSq);
        xout = (uint32)(xo + (((int32)factor*(int32)(xin-xo))>>23));
        yout = (uint32)(yo + (((int32)factor*(int32)(yin-yo))>>23));
        if (xout >= endx1 && xout < endx2 && yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

    /* values used in the calculations below */
        xa = ((int32)(xin - xo) << 3) + 3;
        ya = ((int32)(yin - yo) << 3) + 3;
        xan = ((int32)(xin - xo) << 3) - 3;
        yan = ((int32)(yin - yo) << 3) - 3;
        xb = (uint32)(xo+(((int32)factor*(int32)(xin-xo+1))>>23));
        yb = (uint32)(yo+(((int32)factor*(int32)(yin-yo+1))>>23));
        xbn = (uint32)(xo+(((int32)factor*(int32)(xin-xo-1))>>23));
        ybn = (uint32)(yo+(((int32)factor*(int32)(yin-yo-1))>>23));

        /* (2) xin + 0.4, yin (in fixed point arithmetic) */
        xout = (uint32)(xo + ((((int32)factor>>3)*xa)>>23));
        /* yout already calculated */
        /* Check xin + 1, yin */
        if (xout != xb && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (3) xin + 0.4, yin + 0.4 (in fixed point arithmetic) */
        /* xout already calculated */
        yout = (uint32)(yo + ((((int32)factor>>3)*ya)>>23));
        /* Check xin + 1, yin + 1 */
        if (xout != xb && yout != yb && xout >= endx1 &&
            xout < endx2 && yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (4) xin, yin + 0.4 (in fixed point arithmetic) */
        xout = (uint32)(xo + (((int32)factor*(int32)(xin-xo))>>23));
        /* yout already calculated */
        /* Check xin, yin + 1 */
        if (yout != yb && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (5) xin, yin - 0.4 (in fixed point arithmetic) */
        /* xout already calculated */
        yout = (uint32)(yo + ((((int32)factor>>3)*yan)>>23));
        /* Check xin, yin - 1 */
        if (yout != ybn && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (6) xin - 0.4, yin - 0.4 (in fixed point arithmetic) */
        xout = (uint32)(xo + ((((int32)factor>>3)*xan)>>23));
        /* yout already calculated */
        /* Check xin - 1, yin - 1 */
        if (xout != xbn && yout != ybn && xout >= endx1 &&
            xout < endx2 && yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

        /* (7) xin - 0.4, yin (in fixed point arithmetic) */
        /* xout already calculated */
        yout = (uint32)(yo + (((int32)factor*(int32)(yin-yo))>>23));
        /* Check xin - 1, yin */
        if (xout != xbn && xout >= endx1 && xout < endx2 &&
            yout >= endy1 && yout < endy2)
        {
          /* within mapped region */
          xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                            (int32)(yout-yo)*(int32)(yout-yo));
          if (xytemp <= rSq) {
            /* within magnified region */
            mapIndex = (xout-endx1) + mapWidth*(yout-endy1);
            *((int16*)(xMap + mapIndex)) = (int16)xin;
            *((int16*)(yMap + mapIndex)) = (int16)yin;
          } /* end if (xout, yout) within magnified region */
        } /* end if (xout, yout) within mapped region */

      } /* end if (xin, yin) within magnified region */
    } /* end yin loop */
  } /* end xin loop */

  /* Create full YCbCr image */
  outIndex = 0;
  for (yout = 0; yout < outHeight; yout++) {
    for (xout = 0; xout < outWidth; xout+=2) {
      cb = *inImgPtr++;
      luma1 = *inImgPtr++;
      cr = *inImgPtr++;
      luma2 = *inImgPtr++;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cb;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cr;
      *((unsigned char*)(fullImgPtr+outIndex++)) = luma1;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cb;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cr;
      *((unsigned char*)(fullImgPtr+outIndex++)) = luma2;
    } /* end xout loop */
  } /* end yout loop */

  /*
  ** Fill in output pixels in the following order:
  ** |---------------------------|
  ** |            (1)            |
  ** |---------------------------|
  ** | (2a)    |  (2b)  |   (2c) |
  ** |---------------------------|
  ** |            (3)            |
  ** |---------------------------|
  */
  /* (1) non-magnified region ABOVE magnified region */
  outIndex = 0;
  for (yout = 0; yout < endy1; yout++) {
    for (xout = 0; xout < outWidth; xout++) {
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
    }
  } /* end (1) */

  /* (2) region around magnified region */
  mapIndex = 0;
  for (yout = endy1; yout < endy2; yout++) {
    /* (2a) non-magnified region to the left of the magnified area */
    for (xout = 0; xout < endx1; xout++) {
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
    }
    /* (2b) region affected by magnification */
    for (xout = endx1; xout < endx2; xout++) {
      if (*((int16*)(xMap + mapIndex)) == -1) {
        *((unsigned char*)(outFullImgPtr + outIndex++)) = 128;
        *((unsigned char*)(outFullImgPtr + outIndex++)) = 128;
        *((unsigned char*)(outFullImgPtr + outIndex++)) = 16;
      } else {
        inIndex = (*((int16*)(xMap+mapIndex)) +
                   *((int16*)(yMap+mapIndex)) * outWidth)*3;
        *((unsigned char*)(outFullImgPtr + outIndex++)) =
          *((unsigned char*)(fullImgPtr + inIndex++));
        *((unsigned char*)(outFullImgPtr + outIndex++)) =
          *((unsigned char*)(fullImgPtr + inIndex++));
        *((unsigned char*)(outFullImgPtr + outIndex++)) =
          *((unsigned char*)(fullImgPtr + inIndex));
      }
      mapIndex++;
    }
    /* (2c) non-magnified region to the right of the magnified area */
    for (xout = endx2; xout < outWidth; xout++) {
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
    }
  } /* end (2) */

  /* (3) non-magnified region BELOW magnified area */
  for (yout = endy2; yout < outHeight; yout++) {
    for (xout = 0; xout < outWidth; xout++) {
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
      *((unsigned char*)(outFullImgPtr + outIndex)) =
        *((unsigned char*)(fullImgPtr + outIndex));
      outIndex++;
    }
  } /* end (3) */

  /*
  ** Malloc 3 buffers:
  ** blankPixels stores interpolated pixel values for
  **     pixels left blank in the previous step
  ** nbXMap, nbYMap stores the order in which
  **     neighboring pixels are used during the
  **     interpolation process
  */
  blankPixels = ipl_malloc(mapSize*3*sizeof(unsigned char));
  if (!blankPixels)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(yMap);
    ipl_sys_free(fullImgPtr);
    ipl_sys_free(outFullImgPtr);
    MSG_LOW("ipl_magnify_ycbcr marker_205\n");
    return IPL_NO_MEMORY;
  }

  nbXMap = ipl_malloc(8*sizeof(int8));
  if (!nbXMap)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(yMap);
    ipl_sys_free(fullImgPtr);
    ipl_sys_free(outFullImgPtr);
    ipl_sys_free(blankPixels);
    MSG_LOW("ipl_magnify_ycbcr marker_206\n");
    return IPL_NO_MEMORY;
  }
  nbYMap = ipl_malloc(8*sizeof(int8));
  if (!nbYMap)
  {
    ipl_sys_free(xMap);
    ipl_sys_free(yMap);
    ipl_sys_free(fullImgPtr);
    ipl_sys_free(outFullImgPtr);
    ipl_sys_free(blankPixels);
    ipl_sys_free(nbXMap);
    MSG_LOW("ipl_magnify_ycbcr marker_207\n");
    return IPL_NO_MEMORY;
  }

  /* Initialize nbXMap, nbYMap */
  *nbXMap = -1;
  *((int8*)(nbXMap+1)) = 0;
  *((int8*)(nbXMap+2)) = 1;
  *((int8*)(nbXMap+3)) = -1;
  *((int8*)(nbXMap+4)) = 1;
  *((int8*)(nbXMap+5)) = -1;
  *((int8*)(nbXMap+6)) = 0;
  *((int8*)(nbXMap+7)) = 1;
  *nbYMap = -1;
  *((int8*)(nbYMap+1)) = -1;
  *((int8*)(nbYMap+2)) = -1;
  *((int8*)(nbYMap+3)) = 0;
  *((int8*)(nbYMap+4)) = 0;
  *((int8*)(nbYMap+5)) = 1;
  *((int8*)(nbYMap+6)) = 1;
  *((int8*)(nbYMap+7)) = 1;

  /* Compute missing values for area affected by magnification */
  mapIndex = 0;
  outIndex = 0;
  for (yout = endy1; yout < endy2; yout++) {
    for (xout = endx1; xout < endx2; xout++) {
      if (*((int16*)(xMap + mapIndex)) == -1) {
        /* blank pixel */
        xytemp = (uint32)((int32)(xout-xo)*(int32)(xout-xo) +
                          (int32)(yout-yo)*(int32)(yout-yo));
        if (xytemp > rSq) {
          /* outside magnified region */
          inIndex = (xout + yout * outWidth) * 3;
          *((unsigned char*)(blankPixels + outIndex++)) =
            *((unsigned char*)(fullImgPtr + inIndex++));
          *((unsigned char*)(blankPixels + outIndex++)) =
            *((unsigned char*)(fullImgPtr + inIndex++));
          *((unsigned char*)(blankPixels + outIndex++)) =
            *((unsigned char*)(fullImgPtr + inIndex));
        } else {
          /* inside magnified region */
          nbIndex = 0;
          lumasum = 0;
          crsum = 0;
          cbsum = 0;
          cnt = 0;
          while (nbIndex < 8) {
            /* neighboring pixel */
            xin = (uint32)((int32)xout + (int32)*((int8*)(nbXMap+nbIndex)));
            yin = (uint32)((int32)yout + (int32)*((int8*)(nbYMap+nbIndex)));
            if (xin < outWidth && yin < outHeight) {
              /* within image boundaries */
              inIndex = (xin + yin * outWidth) * 3;
              cb = *((unsigned char*)(outFullImgPtr+inIndex++));
              cr = *((unsigned char*)(outFullImgPtr+inIndex++));
              luma1 = *((unsigned char*)(outFullImgPtr+inIndex));
              if (cb != 128 || cr != 128 || luma1 != 16) {
                cbsum += cb;
                crsum += cr;
                lumasum += luma1;
                cnt++;
              }
            }
            nbIndex++;
          } /* end while loop */
          /* get average */
          if (cnt > 0) {
            cbsum /= cnt;
            crsum /= cnt;
            lumasum /= cnt;
          } else {
            cbsum = 128;
            crsum = 128;
            lumasum = 16;
          }
          /* set output pixel value */
          *((unsigned char*)(blankPixels+outIndex++)) = (unsigned char)cbsum;
          *((unsigned char*)(blankPixels+outIndex++)) = (unsigned char)crsum;
          *((unsigned char*)(blankPixels+outIndex++)) = (unsigned char)lumasum;
        } /* end if blank pixel outside magnified region */
      } /* end if blank pixel */
      else {
        /* non-blank pixel */
        inIndex = (xout + yout * outWidth) * 3;
        *((unsigned char*)(blankPixels + outIndex++)) =
          *((unsigned char*)(outFullImgPtr + inIndex++));
        *((unsigned char*)(blankPixels + outIndex++)) =
          *((unsigned char*)(outFullImgPtr + inIndex++));
        *((unsigned char*)(blankPixels + outIndex++)) =
          *((unsigned char*)(outFullImgPtr + inIndex));
      }
      /* increment the index */
      mapIndex++;
    } /* end xout loop */
  } /* end yout loop */

  /*
  ** Fill in missing values in full YCbCr output for area
  ** affected by magnification
  */
  inc = (outWidth - mapWidth)*3;
  outIndex = (endx1 + endy1 * outWidth)*3;
  inIndex = 0;
  for (yout = endy1; yout < endy2; yout++)
  {
    for (xout = endx1; xout < endx2; xout++)
    {
      *((unsigned char*)(outFullImgPtr + outIndex++)) =
        *((unsigned char*)(blankPixels + inIndex++));
      *((unsigned char*)(outFullImgPtr + outIndex++)) =
        *((unsigned char*)(blankPixels + inIndex++));
      *((unsigned char*)(outFullImgPtr + outIndex++)) =
        *((unsigned char*)(blankPixels + inIndex++));
    }
    outIndex += inc;
  }

  /* Copy to subsampled YCbCr output */
  inIndex = 0;
  for (yout = 0; yout < outHeight; yout++)
  {
    for (xout = 0; xout < outWidth; xout+=2)
    {
      /* get Cb */
      *outImgPtr++ = *((unsigned char*)(outFullImgPtr + inIndex++));
      inIndex++;
      *outImgPtr++ = *((unsigned char*)(outFullImgPtr + inIndex++));
      /* get Cr */
      inIndex++;
      *outImgPtr++ = *((unsigned char*)(outFullImgPtr + inIndex++));
      *outImgPtr++ = *((unsigned char*)(outFullImgPtr + inIndex++));
    } /* end xout loop */
  } /* end yout loop */

  /* Free memory */
  ipl_sys_free(xMap);
  ipl_sys_free(yMap);
  ipl_sys_free(blankPixels);
  ipl_sys_free(nbXMap);
  ipl_sys_free(nbYMap);
  ipl_sys_free(fullImgPtr);
  ipl_sys_free(outFullImgPtr);

  MSG_LOW("ipl_magnify_ycbcr marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_magnify_ycbcr */



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_magnify

DESCRIPTION
  This function magnifies an input image in a circular region of
  arbitrary location and radius.  The center of the magnified region
  must be within the input image boundaries. Areas outside the circular
  region are not magnified. If part of the magnified region extends
  beyond image boundaries, only the part within boundaries is
  displayed.

  Input and output image sizes must be equal.

  Input and output images must have the same color format, which
  can be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr     pointer to the input image
  out_img_ptr    pointer to the output image
  circle         the circular region of magnification

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_magnify
(
  ipl_image_type* in_img_ptr,    /* Points to the input image        */
  ipl_image_type* out_img_ptr,   /* Points to the output image       */
  ipl_circle_type* circle        /* Circular region of magnification */
)
{
  ipl_status_type retval;
  MSG_LOW("ipl_magnify marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr ||
      !circle)
  {
    MSG_LOW("ipl_magnify marker_200\n");
    return IPL_FAILURE;
  }

  /* Input and output color formats must be the same */
  if (in_img_ptr->cFormat != out_img_ptr->cFormat)
  {
    MSG_LOW("ipl_magnify marker_201\n");
    return IPL_FAILURE;
  }
  /* Input and output image sizes must be the same */
  if (in_img_ptr->dx != out_img_ptr->dx ||
      in_img_ptr->dy != out_img_ptr->dy)
  {
    MSG_LOW("ipl_magnify marker_202\n");
    return IPL_FAILURE;
  }


  // make sure we can complete this rather complex task in a reasonable
  // amount of time, i.e. do not process images too big
  if (in_img_ptr->dx * in_img_ptr->dy >= IPL_IMAGE_MAX)
    //return IPL_2CPU_INTENSIVE;
    return IPL_UNSUPPORTED;

  /*
  ** Radius must be positive; x- and y-coordinates must be
  ** within image boundaries
  */
  if (circle->r == 0 || circle->x >= out_img_ptr->dx ||
      circle->y >= out_img_ptr->dy)
  {
    MSG_LOW("ipl_magnify marker_203\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_magnify marker_1\n");

  /* Call the appropriate function */
  if (in_img_ptr->cFormat == IPL_RGB565)
  {
    retval = ipl_magnify_rgb565(in_img_ptr, out_img_ptr, circle);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_magnify marker_204\n");
      return retval;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCbCr)
  {
    retval = ipl_magnify_ycbcr(in_img_ptr, out_img_ptr, circle);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_magnify marker_205\n");
      return retval;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
           in_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    ipl_image_type innew_img, out422_img;

    /* input 1 */
    innew_img.cFormat = IPL_YCbCr;
    innew_img.dx = in_img_ptr->dx;
    innew_img.dy = in_img_ptr->dy;
    if (ipl_malloc_img(&innew_img))
    {
      MSG_LOW("ipl_magnify marker_206\n");
      return IPL_NO_MEMORY;
    }
    if (ipl_convert_image(in_img_ptr, &innew_img) != IPL_SUCCESS)
    {
      ipl_free_img(&innew_img);
      MSG_LOW("ipl_magnify marker_207\n");
      return IPL_NO_MEMORY;
    }

    /* ycbcr 4:2:2 output */
    out422_img.cFormat = IPL_YCbCr;
    out422_img.dx = out_img_ptr->dx;
    out422_img.dy = out_img_ptr->dy;
    if (ipl_malloc_img(&out422_img))
    {
      ipl_free_img(&innew_img);
      MSG_LOW("ipl_magnify marker_208\n");
      return IPL_NO_MEMORY;
    }

    /* call ycbcr 4:2:2 function */
    retval = ipl_magnify_ycbcr(&innew_img, &out422_img, circle);
    if (retval != IPL_SUCCESS)
    {
      ipl_free_img(&innew_img);
      ipl_free_img(&out422_img);
      MSG_LOW("ipl_magnify marker_209\n");
      return retval;
    }

    /* get YCbCr 4:2:0 output */
    if (ipl_convert_image(&out422_img, out_img_ptr) != IPL_SUCCESS)
    {
      ipl_free_img(&innew_img);
      ipl_free_img(&out422_img);
      MSG_LOW("ipl_magnify marker_210\n");
      return IPL_FAILURE;
    }

    /* sys_free memory */
    ipl_free_img(&innew_img);
    ipl_free_img(&out422_img);
  }
  else
  {
    MSG_LOW("ipl_magnify marker_211\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_magnify marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_magnify */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_motion_blur_rgb565

DESCRIPTION
  This function produces motion blur in any arbitrary direction. The size
  of the blurring window must be an odd, positive integer in the range
  3 <= size <= 1/2 * min(w, h), where w and h are the width and height of
  the input image. The direction of motion is specified by a positive integer
  angle measured in degrees from the horizontal.

  Input and output images must have the same size.
  Input and output images must be RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  size          size of blurring window
  angle         angle of motion blur

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_motion_blur_rgb565
(
  ipl_image_type* in_img_ptr,   /* Points to the input image  */
  ipl_image_type* out_img_ptr,  /* Points to the output image */
  uint32 size,                  /* Size of blurring window   */
  uint16 angle                  /* Angle of motion blur       */
)
{
	uint16 *inImgPtr, *outImgPtr, *rImgPtr, *routImgPtr;
  uint8 *cntPtr;
	uint32 rSum, gSum, bSum, inIndex, outIndex;
	int32 w, h, xmin, xmax, ymin, ymax, wout, hout,
        x, y, xin, yin, n, a, b, endn, beta, xo, yo, xxo, yyo;
  uint32 radian, cnt;
  int8 sinSign, cosSign;
  int32 sintheta, costheta;
  uint16 out;

  MSG_LOW("ipl_motion_blur_rgb565 marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_motion_blur_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

	/* Initialize image pointers and local variables */
	inImgPtr = (uint16*)in_img_ptr->imgPtr;
	outImgPtr = (uint16*)out_img_ptr->imgPtr;
	wout = out_img_ptr->dx;
	hout = out_img_ptr->dy;
	if ((size > (uint32)(wout>>1)) || (size > (uint32)(hout>>1))) {
		/*
		** Window size should not be larger than half the image.
		** Set to default size.
		*/
		size = 5;
	}
	a = size >> 1;
  angle %= 360;

  MSG_LOW("ipl_motion_blur_rgb565 marker_1\n");

  if (angle > 0)
  {
    sinSign = 1;
    cosSign = 1;
    if (angle <= 90) {
      beta = angle;
    } else if (angle <= 180) {
      beta = 180 - angle;
      cosSign = -1;
    } else if (angle <= 270) {
      beta = angle - 180;
      sinSign = -1;
      cosSign = -1;
    } else {
      beta = 360 - angle;
      sinSign = -1;
    }
    /* Angle in radians */
    radian = beta * 9;
    if (radian <= 360) {
      sintheta = ((radian*(262144-(radian*radian)/6))>>8)*sinSign;
      costheta = (524288-radian*radian)*cosSign;
    }
    else
    {
      if (radian == 810)
      {
        sintheta = 524288*sinSign;
        costheta = 0;
      }
      else
      {
        sintheta = (((radian*(262144-(radian*radian)/6))>>8) +
                  (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                  radian)/42)*((11010048-radian*radian)>>10))>>21))*sinSign;
        costheta = ((524288-radian*radian) +
                  (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                  ((7864320-radian*radian)>>10))>>12))*cosSign;
      }
    }

    /*
    ** Rotated image size must be large enough to fit rotated result.
    ** Find the necessary output size by checking 4 corners:
    ** (0,0), (0,h-1), (w-1,0), (w-1,h-1).
    */
    xo = wout >> 1;
    yo = hout >> 1;
    xmin = 0;
    xmax = 0;
    ymin = 0;
    ymax = 0;

    /* (0,0) */
    x = xo+((-xo*costheta+yo*sintheta)>>19);
    y = yo+((-xo*sintheta-yo*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (0,h-1) */
    x = xo+((-xo*costheta-(hout-1-yo)*sintheta)>>19);
    y = yo+((-xo*sintheta+(hout-1-yo)*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (w-1,0) */
    x = xo+(((wout-1-xo)*costheta+yo*sintheta)>>19);
    y = yo+(((wout-1-xo)*sintheta-yo*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (w-1,h-1) */
    x = xo+(((wout-1-xo)*costheta-(hout-1-yo)*sintheta)>>19);
    y = yo+(((wout-1-xo)*sintheta+(hout-1-yo)*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* Large output */
    w = xmax-xmin+1;
    h = ymax-ymin+1;
    x = w*h;
    rImgPtr = ipl_malloc(x*sizeof(uint16));
    if (!rImgPtr)
    {
      MSG_LOW("ipl_motion_blur_rgb565 marker_201\n");
      return IPL_NO_MEMORY;
    }

    routImgPtr = ipl_malloc(x*sizeof(uint16));
    if (!routImgPtr)
    {
      ipl_sys_free(rImgPtr);
      MSG_LOW("ipl_motion_blur_rgb565 marker_202\n");
      return IPL_NO_MEMORY;
    }

    cntPtr = ipl_malloc(x*sizeof(uint8));
    if (!cntPtr)
    {
      ipl_sys_free(rImgPtr);
      ipl_sys_free(routImgPtr);
      MSG_LOW("ipl_motion_blur_rgb565 marker_203\n");
      return IPL_NO_MEMORY;
    }
    /* Initialize buffers */
    memset(rImgPtr, 0, x<<1);
    memset(routImgPtr, 0, x<<1);
    memset(cntPtr, 1, x);

    /* Center of image */
    xxo = w >> 1;
    yyo = h >> 1;

    MSG_LOW("ipl_motion_blur_rgb565 marker_2\n");

    /* Rotate input */
    outIndex = 0;
    for (y = 0; y < h; y++)
    {
      for (x = 0; x < w; x++)
      {
        xin = xo+(((x-xxo)*costheta+(y-yyo)*sintheta)>>19);
        yin = yo+(((xxo-x)*sintheta+(y-yyo)*costheta)>>19);
        if (xin >= 0 && xin < wout && yin >= 0 && yin < hout)
        {
          *((uint16*)(rImgPtr+outIndex)) =
          *((uint16*)(inImgPtr + yin*wout + xin));
        }
        else
        {
          *((uint8*)(cntPtr+outIndex)) = 0;
        }
        outIndex++;
      } /* end x loop */
    } /* end y loop */

	  /* Loop through input */
	  b = w - a;
	  outIndex = 0;
	  for (y = 0; y < h; y++)
    {
		  /* Left boundary */
		  for (x = 0; x < a; x++)
      {
			  rSum = 0;
			  gSum = 0;
			  bSum = 0;
        cnt = 0;
			  inIndex = outIndex + a;
			  for (n = -a; n < -x; n++)
        {
          if (*((uint8*)(cntPtr+inIndex)))
          {
            out = *((uint16*)(rImgPtr+inIndex));
				    rSum += (uint8)((out & 0xF800)>>8);
				    gSum += (uint8)((out & 0x07E0)>>3);
				    bSum += (uint8)((out & 0x001F)<<3);
            cnt++;
          }
          inIndex--;
			  }
			  inIndex = outIndex - x;
			  for (n = -x; n <= a; n++)
        {
          if (*((uint8*)(cntPtr+inIndex)))
          {
            out = *((uint16*)(rImgPtr+inIndex));
				    rSum += (uint8)((out & 0xF800)>>8);
				    gSum += (uint8)((out & 0x07E0)>>3);
				    bSum += (uint8)((out & 0x001F)<<3);
            cnt++;
          }
          inIndex++;
			  }
			  /* pack into rgb565 format */
        if (cnt > 0)
        {
			    *((uint16*)(routImgPtr+outIndex)) =
				    pack_rgb565((rSum/cnt), (gSum/cnt), (bSum/cnt));
        }
        outIndex++;
		  } /* end x loop */

		  /* Center, non-boundary part */
		  for (x = a; x < b; x++)
      {
			  rSum = 0;
			  gSum = 0;
			  bSum = 0;
        cnt = 0;
			  inIndex = outIndex - a;
			  for (n = -a; n <= a; n++)
        {
          if (*((uint8*)(cntPtr+inIndex)))
          {
            out = *((uint16*)(rImgPtr+inIndex));
				    rSum += (uint8)((out & 0xF800)>>8);
				    gSum += (uint8)((out & 0x07E0)>>3);
				    bSum += (uint8)((out & 0x001F)<<3);
            cnt++;
          }
          inIndex++;
			  }
			  /* pack into rgb565 format */
        if (cnt > 0)
        {
			    *((uint16*)(routImgPtr+outIndex)) =
				    pack_rgb565((rSum/cnt), (gSum/cnt), (bSum/cnt));
        }
        outIndex++;
		  } /* end x loop */

		  /* Right boundary */
		  for (x = b; x < w; x++)
      {
			  rSum = 0;
			  gSum = 0;
			  bSum = 0;
        cnt = 0;
			  endn = w - x;
			  inIndex = outIndex - a;
			  for (n = -a; n < endn; n++)
        {
          if (*((uint8*)(cntPtr+inIndex)))
          {
            out = *((uint16*)(rImgPtr+inIndex));
				    rSum += (uint8)((out & 0xF800)>>8);
				    gSum += (uint8)((out & 0x07E0)>>3);
				    bSum += (uint8)((out & 0x001F)<<3);
            cnt++;
          }
          inIndex++;
			  }
			  inIndex = outIndex - endn;
			  for (n = endn; n <= a; n++)
        {
          if (*((uint8*)(cntPtr+inIndex)))
          {
            out = *((uint16*)(rImgPtr+inIndex));
				    rSum += (uint8)((out & 0xF800)>>8);
				    gSum += (uint8)((out & 0x07E0)>>3);
				    bSum += (uint8)((out & 0x001F)<<3);
            cnt++;
          }
          inIndex--;
			  }
			  /* pack into rgb565 format */
        if (cnt > 0)
        {
			    *((uint16*)(routImgPtr+outIndex)) =
				    pack_rgb565((rSum/cnt), (gSum/cnt), (bSum/cnt));
        }
        outIndex++;
		  } /* end x loop */
	  } /* end y loop */

    /* Rotate to get output */
    outIndex = 0;
    for (y = 0; y < hout; y++)
    {
      for (x = 0; x < wout; x++)
      {
        xin = (xxo+(((x-xo)*costheta+(yo-y)*sintheta)>>19));
        yin = (yyo+(((x-xo)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h)
        {
          *((uint16*)(outImgPtr+outIndex)) =
          *((uint16*)(routImgPtr + yin*w + xin));
        }
        outIndex++;
      } /* end x loop */
    } /* end y loop */

	  /* Free memory */
    ipl_sys_free(rImgPtr);
    ipl_sys_free(routImgPtr);
    ipl_sys_free(cntPtr);
  }
  else
  {
    /* Horizontal motion blur */
	  b = wout - a;
	  outIndex = 0;
	  for (y = 0; y < hout; y++)
    {
		  /* Left boundary */
		  for (x = 0; x < a; x++)
      {
			  rSum = 0;
			  gSum = 0;
			  bSum = 0;
			  inIndex = outIndex + a;
			  for (n = -a; n < -x; n++)
        {
          out = *((uint16*)(inImgPtr+inIndex--));
				  rSum += (uint8)((out & 0xF800)>>8);
				  gSum += (uint8)((out & 0x07E0)>>3);
				  bSum += (uint8)((out & 0x001F)<<3);
			  }
			  inIndex = outIndex - x;
			  for (n = -x; n <= a; n++)
        {
          out = *((uint16*)(inImgPtr+inIndex++));
				  rSum += (uint8)((out & 0xF800)>>8);
				  gSum += (uint8)((out & 0x07E0)>>3);
				  bSum += (uint8)((out & 0x001F)<<3);
			  }
			  /* pack into rgb565 format */
			  *((uint16*)(outImgPtr+outIndex++)) =
				  pack_rgb565((rSum/size), (gSum/size), (bSum/size));
		  } /* end x loop */
		  /* Center, non-boundary part */
		  for (x = a; x < b; x++)
      {
			  rSum = 0;
			  gSum = 0;
			  bSum = 0;
        cnt = 0;
			  inIndex = outIndex - a;
			  for (n = -a; n <= a; n++)
        {
          out = *((uint16*)(inImgPtr+inIndex++));
				  rSum += (uint8)((out & 0xF800)>>8);
				  gSum += (uint8)((out & 0x07E0)>>3);
				  bSum += (uint8)((out & 0x001F)<<3);
			  }
			  /* pack into rgb565 format */
			  *((uint16*)(outImgPtr+outIndex++)) =
				  pack_rgb565((rSum/size), (gSum/size), (bSum/size));
		  } /* end x loop */
		  /* Right boundary */
		  for (x = b; x < wout; x++)
      {
			  rSum = 0;
			  gSum = 0;
			  bSum = 0;
        cnt = 0;
			  endn = wout - x;
			  inIndex = outIndex - a;
			  for (n = -a; n < endn; n++)
        {
          out = *((uint16*)(inImgPtr+inIndex++));
				  rSum += (uint8)((out & 0xF800)>>8);
				  gSum += (uint8)((out & 0x07E0)>>3);
				  bSum += (uint8)((out & 0x001F)<<3);
			  }
			  inIndex = outIndex - endn;
			  for (n = endn; n <= a; n++)
        {
          out = *((uint16*)(inImgPtr+inIndex--));
				  rSum += (uint8)((out & 0xF800)>>8);
				  gSum += (uint8)((out & 0x07E0)>>3);
				  bSum += (uint8)((out & 0x001F)<<3);
			  }
			  /* pack into rgb565 format */
			  *((uint16*)(outImgPtr+outIndex++)) =
				  pack_rgb565((rSum/size), (gSum/size), (bSum/size));
		  } /* end x loop */
	  } /* end y loop */
  } /* end if */

  MSG_LOW("ipl_motion_blur_rgb565 marker_100\n");

	return IPL_SUCCESS;
} /* End ipl_motion_blur_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_motion_blur_ycbcr

DESCRIPTION
  This function produces motion blur in any arbitrary direction. The size
  of the blurring window must be an odd, positive integer in the range
  3 <= size <= 1/2 * min(w, h), where w and h are the width and height of
  the input image. The direction of motion is specified by a positive integer
  angle measured in degrees from the horizontal.

  Input and output images must have the same size.
  Input and output images must be YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  size          size of blurring window
  angle         angle of motion blur

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_motion_blur_ycbcr
(
  ipl_image_type* in_img_ptr,   /* Points to the input image  */
  ipl_image_type* out_img_ptr,  /* Points to the output image */
  uint32 size,                  /* Width of blurring window   */
  uint16 angle                  /* Angle of motion blur       */
)
{
  unsigned char *inImgPtr, *outImgPtr, *fullImgPtr, *rImgPtr, *routImgPtr;
  uint8 *cntPtr;
  unsigned char cb, cr, luma1, luma2;
  uint32 cbSum, crSum, ySum, inIndex, outIndex, cntIndex;
	int32 w, h, xmin, xmax, ymin, ymax, wout, hout, x, y, xin, yin,
        n, a, b, endn, beta, xo, yo, xxo, yyo;
  uint32 radian, cnt;
  int8 sinSign, cosSign;
  int32 sintheta, costheta;

  MSG_LOW("ipl_motion_blur_ycbcr marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_motion_blur_ycbcr marker_200\n");
    return IPL_FAILURE;
  }


  /* Initialize image pointers and local variables */
  inImgPtr = in_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;
	wout = out_img_ptr->dx;
	hout = out_img_ptr->dy;
  fullImgPtr = ipl_malloc(wout*hout*3*sizeof(unsigned char));
  if (!fullImgPtr) {
    MSG_LOW("ipl_motion_blur_ycbcr marker_201\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_motion_blur_ycbcr marker_1\n");

  /* Create full YCbCr image */
  outIndex = 0;
  for (y = 0; y < hout; y++) {
    for (x = 0; x < wout; x+=2) {
      cb = *inImgPtr++;
      luma1 = *inImgPtr++;
      cr = *inImgPtr++;
      luma2 = *inImgPtr++;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cb;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cr;
      *((unsigned char*)(fullImgPtr+outIndex++)) = luma1;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cb;
      *((unsigned char*)(fullImgPtr+outIndex++)) = cr;
      *((unsigned char*)(fullImgPtr+outIndex++)) = luma2;
    } /* end xout loop */
  } /* end yout loop */

	if ((size > (uint32)(wout>>1)) || (size > (uint32)(hout>>1))) {
		/*
		** Window size should not be larger than half the image.
		** Set to default size.
		*/
		size = 5;
	}
	a = size >> 1;
  angle %= 360;

  if (angle > 0)
  {
    /*
    ** Non-horizontal motion blur
    */

    /* Get sine and cosine values */
    sinSign = 1;
    cosSign = 1;
    if (angle <= 90) {
      beta = angle;
    } else if (angle <= 180) {
      beta = 180 - angle;
      cosSign = -1;
    } else if (angle <= 270) {
      beta = angle - 180;
      sinSign = -1;
      cosSign = -1;
    } else {
      beta = 360 - angle;
      sinSign = -1;
    }
    /* Angle in radians */
    radian = beta * 9;
    if (radian <= 360) {
      sintheta = ((radian*(262144-(radian*radian)/6))>>8)*sinSign;
      costheta = (524288-radian*radian)*cosSign;
    } else {
      if (radian == 810) {
        sintheta = 524288*sinSign;
        costheta = 0;
      } else {
        sintheta = (((radian*(262144-(radian*radian)/6))>>8) +
                   (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                   radian)/42)*((11010048-radian*radian)>>10))>>21))*sinSign;
        costheta = ((524288-radian*radian) +
                   (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                   ((7864320-radian*radian)>>10))>>12))*cosSign;
      }
    }

    /*
    ** Rotated image size must be large enough to fit rotated result.
    ** Find the necessary output size by checking 4 corners:
    ** (0,0), (0,h-1), (w-1,0), (w-1,h-1).
    */
    xo = wout >> 1;
    yo = hout >> 1;
    xmin = 0;
    xmax = 0;
    ymin = 0;
    ymax = 0;

    /* (0,0) */
    x = xo+((-xo*costheta+yo*sintheta)>>19);
    y = yo+((-xo*sintheta-yo*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (0,h-1) */
    x = xo+((-xo*costheta-(hout-1-yo)*sintheta)>>19);
    y = yo+((-xo*sintheta+(hout-1-yo)*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (w-1,0) */
    x = xo+(((wout-1-xo)*costheta+yo*sintheta)>>19);
    y = yo+(((wout-1-xo)*sintheta-yo*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (w-1,h-1) */
    x = xo+(((wout-1-xo)*costheta-(hout-1-yo)*sintheta)>>19);
    y = yo+(((wout-1-xo)*sintheta+(hout-1-yo)*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* Large output */
    w = xmax-xmin+1;
    if (w%2) w++;
    h = ymax-ymin+1;
    x = w*h;
    rImgPtr = ipl_malloc(x*3*sizeof(unsigned char));
    if (!rImgPtr)
    {
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_ycbcr marker_202\n");
      return IPL_NO_MEMORY;
    }

    routImgPtr = ipl_malloc(x*3*sizeof(unsigned char));
    if (!routImgPtr)
    {
      ipl_sys_free(rImgPtr);
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_ycbcr marker_203\n");
      return IPL_NO_MEMORY;
    }
    cntPtr = ipl_malloc(x*sizeof(uint8));
    if (!cntPtr)
    {
      ipl_sys_free(rImgPtr);
      ipl_sys_free(routImgPtr);
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_ycbcr marker_204\n");
      return IPL_NO_MEMORY;
    }
    memset(cntPtr, 1, x);

    /* Initialize rotated image to black */
    inIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        *((unsigned char*)(rImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(rImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(rImgPtr+inIndex++)) = 0x10;
      } /* end x loop */
    } /* end y loop */

    /* Initialize full YCbCr output buffer */
    inIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        *((unsigned char*)(routImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(routImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(routImgPtr+inIndex++)) = 0x10;
      } /* end x loop */
    } /* end y loop */

    /* Center of image */
    xxo = w >> 1;
    yyo = h >> 1;

    MSG_LOW("ipl_motion_blur_ycbcr marker_2\n");

    /* Rotate */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
          xin = xo+(((x-xxo)*costheta+(y-yyo)*sintheta)>>19);
          yin = yo+(((xxo-x)*sintheta+(y-yyo)*costheta)>>19);
          if (xin >= 0 && xin < wout && yin >= 0 && yin < hout) {
            inIndex = (yin*wout + xin)*3;
            *((unsigned char*)(rImgPtr+outIndex)) =
              *((unsigned char*)(fullImgPtr+inIndex++));
            *((unsigned char*)(rImgPtr+outIndex+1)) =
              *((unsigned char*)(fullImgPtr+inIndex++));
            *((unsigned char*)(rImgPtr+outIndex+2)) =
              *((unsigned char*)(fullImgPtr+inIndex));
          } else {
            *((uint8*)(cntPtr+cntIndex)) = 0;
          }
          outIndex += 3;
          cntIndex++;
      } /* end x loop */
    } /* end y loop */

    /* Loop through input */
    b = w - a;
    outIndex = 0;
    for (y = 0; y < h; y++) {
      /* Left boundary */
      for (x = 0; x < a; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        inIndex = outIndex + a*3;
        cntIndex = inIndex/3;
        for (n = -a; n < -x; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex -= 3;
          cntIndex--;
        }
        inIndex = outIndex - x*3;
        cntIndex = inIndex/3;
        for (n = -x; n <= a; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));;
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex += 3;
          cntIndex++;
        }
        /* Set output values */
        if (cnt > 0) {
          *((unsigned char*)(routImgPtr+outIndex)) =
            (unsigned char)(cbSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+1)) =
            (unsigned char)(crSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+2)) =
            (unsigned char)(ySum/cnt);
        }
        outIndex += 3;
      }

      /* Center, non-boundary part */
      for (x = a; x < b; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        inIndex = outIndex - a*3;
        cntIndex = inIndex/3;
        for (n = -a; n <= a; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));;
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex += 3;
          cntIndex++;
        }
        /* Set output values */
        if (cnt > 0) {
          *((unsigned char*)(routImgPtr+outIndex)) =
            (unsigned char)(cbSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+1)) =
            (unsigned char)(crSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+2)) =
            (unsigned char)(ySum/cnt);
        }
        outIndex += 3;
      }

      /* Right boundary */
      for (x = b; x < w; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        endn = w - x;
        inIndex = outIndex - a*3;
        cntIndex = inIndex/3;
        for (n = -a; n < endn; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));;
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex += 3;
          cntIndex++;
        }

        inIndex = outIndex - endn*3;
        cntIndex = inIndex/3;
        for (n = endn; n <= a; n++)
        {
          if (*((uint8*)(cntPtr+cntIndex)))
          {
            cbSum += *((unsigned char*) (rImgPtr+inIndex));
            crSum += *((unsigned char*) (rImgPtr+inIndex+1));;
            ySum  += *((unsigned char*) (rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex -= 3;
          cntIndex--;
        }
        /* Set output values */
        if (cnt > 0) {
          *((unsigned char*)(routImgPtr+outIndex)) =
            (unsigned char)(cbSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+1)) =
            (unsigned char)(crSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+2)) =
            (unsigned char)(ySum/cnt);
        }
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */

    /* Rotate and get YCbCr 4:2:2 output */
    outIndex = 0;
    for (y = 0; y < hout; y++) {
      for (x = 0; x < wout; x+=2) {
        /* Process 2 pixels at a time */

        /* Pixel 1: Get Cb */
        xin = xxo+(((x-xo)*costheta+(yo-y)*sintheta)>>19);
        yin = yyo+(((x-xo)*sintheta+(y-yo)*costheta)>>19);
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          *((unsigned char*)(outImgPtr+outIndex)) =
            *((unsigned char*)(routImgPtr+inIndex++));
          inIndex++;
          *((unsigned char*)(outImgPtr+outIndex+1)) =
            *((unsigned char*)(routImgPtr+inIndex));
        }
        outIndex += 2;

        /* Pixel 2: Get Cr */
        xin = xxo+(((x+1-xo)*costheta+(yo-y)*sintheta)>>19);
        yin = yyo+(((x+1-xo)*sintheta+(y-yo)*costheta)>>19);
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          inIndex++;
          *((unsigned char*)(outImgPtr+outIndex)) =
            *((unsigned char*)(routImgPtr+inIndex++));
          *((unsigned char*)(outImgPtr+outIndex+1)) =
            *((unsigned char*)(routImgPtr+inIndex));
        }
        outIndex += 2;
      } /* end x loop */
    } /* end y loop */

    /* Free memory */
    ipl_sys_free(rImgPtr);
    ipl_sys_free(cntPtr);
  }
  else
  {
    /*
    ** Horizontal motion blur
    */

    /* Malloc buffer for full YCbCr output */
    routImgPtr = ipl_malloc(wout*hout*3*sizeof(unsigned char));
    if (!routImgPtr)
    {
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_ycbcr marker_205\n");
      return IPL_NO_MEMORY;
    }

    /* Loop through input */
    b = wout - a;
    outIndex = 0;
    for (y = 0; y < hout; y++) {
      /* Left boundary */
      for (x = 0; x < a; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        inIndex = outIndex + a*3;
        for (n = -a; n < -x; n++) {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex));
          crSum += *((unsigned char*)(fullImgPtr+inIndex+1));
          ySum += *((unsigned char*)(fullImgPtr+inIndex+2));
          inIndex -= 3;
        }
        inIndex = outIndex - x*3;
        for (n = -x; n <= a; n++) {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex++));
          crSum += *((unsigned char*)(fullImgPtr+inIndex++));
          ySum += *((unsigned char*)(fullImgPtr+inIndex++));
        }
        /* Set output values */
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(cbSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(crSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(ySum/size);
      }

      /* Center, non-boundary part */
      for (x = a; x < b; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        inIndex = outIndex - a*3;
        for (n = -a; n <= a; n++) {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex++));
          crSum += *((unsigned char*)(fullImgPtr+inIndex++));
          ySum += *((unsigned char*)(fullImgPtr+inIndex++));
        }
        /* Set output values */
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(cbSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(crSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(ySum/size);
      }

      /* Right boundary */
      for (x = b; x < wout; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        endn = wout - x;
        inIndex = outIndex - a*3;
        for (n = -a; n < endn; n++) {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex++));
          crSum += *((unsigned char*)(fullImgPtr+inIndex++));
          ySum += *((unsigned char*)(fullImgPtr+inIndex++));
        }
        inIndex = outIndex - endn*3;
        for (n = endn; n <= a; n++) {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex));
          crSum += *((unsigned char*)(fullImgPtr+inIndex+1));
          ySum += *((unsigned char*)(fullImgPtr+inIndex+2));
          inIndex -= 3;
        }
        /* Set output values */
        *((unsigned char*)(routImgPtr+outIndex)) =
          (unsigned char)(cbSum/size);
        *((unsigned char*)(routImgPtr+outIndex+1)) =
          (unsigned char)(crSum/size);
        *((unsigned char*)(routImgPtr+outIndex+2)) =
          (unsigned char)(ySum/size);
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */

    /* Get YCbCr 4:2:2 output */
    outIndex = 0;
    inIndex = 0;
    for (y = 0; y < hout; y++) {
      for (x = 0; x < wout; x+=2) {
        /* Process 2 pixels at a time */

        /* Pixel 1: Get Cb */
        *((unsigned char*)(outImgPtr+outIndex++)) =
          *((unsigned char*)(routImgPtr+inIndex++));
        inIndex++;
        *((unsigned char*)(outImgPtr+outIndex++)) =
          *((unsigned char*)(routImgPtr+inIndex++));

        /* Pixel 2: Get Cr */
        inIndex++;
        *((unsigned char*)(outImgPtr+outIndex++)) =
          *((unsigned char*)(routImgPtr+inIndex++));
        *((unsigned char*)(outImgPtr+outIndex++)) =
          *((unsigned char*)(routImgPtr+inIndex++));
      } /* end x loop */
    } /* end y loop */
  } /* end if */

  /* Free memory */
  ipl_sys_free(routImgPtr);
  ipl_sys_free(fullImgPtr);

  MSG_LOW("ipl_motion_blur_ycbcr marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_motion_blur_ycbcr */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_motion_blur_420lp

DESCRIPTION
  This function produces motion blur in any arbitrary direction. The size
  of the blurring window must be an odd, positive integer in the range
  3 <= size <= 1/2 * min(w, h), where w and h are the width and height of
  the input image. The direction of motion is specified by a positive integer
  angle measured in degrees from the horizontal.

  Input and output images must have the same size.
  Input and output images must have the same color format, which can be
  YCbCr 4:2:0 line packed or YCrCb 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  size          size of blurring window
  angle         angle of motion blur

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_motion_blur_420lp
(
  ipl_image_type* in_img_ptr,   /* Points to the input image  */
  ipl_image_type* out_img_ptr,  /* Points to the output image */
  uint32 size,                  /* Width of blurring window   */
  uint16 angle                  /* Angle of motion blur       */
)
{
  unsigned char *inImgPtr, *outImgPtr, *fullImgPtr, *rImgPtr, *routImgPtr,
                *inClrPtr, *outClrPtr, *full2ImgPtr;
  uint8* cntPtr;
  unsigned char cb, cr;
  uint32 cbSum, crSum, ySum, inIndex, outIndex, cntIndex, inc;
	int32 w, h, xmin, xmax, ymin, ymax, wout, hout, x, y, xin, yin,
        n, a, b, endn, beta, xo, yo, xxo, yyo;
  uint32 radian, cnt;
  int8 sinSign, cosSign;
  int32 sintheta, costheta;

  MSG_LOW("ipl_motion_blur_420lp marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_motion_blur_420lp marker_200\n");
    return IPL_FAILURE;
  }


  /* Initialize image pointers and local variables */
  inImgPtr = in_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;
  inClrPtr = in_img_ptr->clrPtr;
  outClrPtr = out_img_ptr->clrPtr;
	wout = out_img_ptr->dx;
	hout = out_img_ptr->dy;
  fullImgPtr = ipl_malloc(wout*hout*3*sizeof(unsigned char));
  if (!fullImgPtr) {
    MSG_LOW("ipl_motion_blur_420lp marker_201\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_motion_blur_420lp marker_1\n");

  /* Create full YCbCr image */
  /* Luma values */
  outIndex = 2;
  for (y = 0; y < hout; y++)
  {
    for (x = 0; x < wout; x++)
    {
      *((unsigned char*)(fullImgPtr+outIndex)) = *inImgPtr++;
      outIndex += 3;
    } /* end x loop */
  } /* end y loop */

  /* Chroma values */
  outIndex = 0;
  inc = wout*3;
  full2ImgPtr = fullImgPtr + inc;
  for (y = 0; y < hout; y+=2)
  {
    for (x = 0; x < wout; x+=2)
    {
      /* Process 4 pixels at a time */
      cb = *inClrPtr++;
      cr = *inClrPtr++;
      /* Pixel 1 */
      *((unsigned char*)(fullImgPtr+outIndex)) = cb;
      *((unsigned char*)(fullImgPtr+outIndex+1)) = cr;
      /* Pixel 2 */
      *((unsigned char*)(fullImgPtr+outIndex+3)) = cb;
      *((unsigned char*)(fullImgPtr+outIndex+4)) = cr;
      /* Pixel 3 */
      *((unsigned char*)(full2ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(full2ImgPtr+outIndex++)) = cr;
      outIndex++;
      /* Pixel 4 */
      *((unsigned char*)(full2ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(full2ImgPtr+outIndex++)) = cr;
      outIndex++;
    } /* end x loop */
    outIndex += inc;
  } /* end y loop */

	if ((size > (uint32)(wout>>1)) || (size > (uint32)(hout>>1)))
  {
		/*
		** Window size should not be larger than half the image.
		** Set to default size.
		*/
		size = 5;
	}
	a = size >> 1;
  angle %= 360;

  if (angle > 0)
  {
    /*
    ** Non-horizontal motion blur
    */

    /* Find sine and cosine of angle */
    sinSign = 1;
    cosSign = 1;
    if (angle <= 90) {
      beta = angle;
    } else if (angle <= 180) {
      beta = 180 - angle;
      cosSign = -1;
    } else if (angle <= 270) {
      beta = angle - 180;
      sinSign = -1;
      cosSign = -1;
    } else {
      beta = 360 - angle;
      sinSign = -1;
    }
    /* Angle in radians */
    radian = beta * 9;
    if (radian <= 360) {
      sintheta = ((radian*(262144-(radian*radian)/6))>>8)*sinSign;
      costheta = (524288-radian*radian)*cosSign;
    } else {
      if (radian == 810) {
        sintheta = 524288*sinSign;
        costheta = 0;
      } else {
        sintheta = (((radian*(262144-(radian*radian)/6))>>8) +
                  (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                  radian)/42)*((11010048-radian*radian)>>10))>>21))*sinSign;
        costheta = ((524288-radian*radian) +
                  (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                  ((7864320-radian*radian)>>10))>>12))*cosSign;
      }
    }

    /*
    ** Rotated image size must be large enough to fit rotated result.
    ** Find the necessary output size by checking 4 corners:
    ** (0,0), (0,h-1), (w-1,0), (w-1,h-1).
    */
    xo = wout >> 1;
    yo = hout >> 1;
    xmin = 0;
    xmax = 0;
    ymin = 0;
    ymax = 0;

    /* (0,0) */
    x = xo+((-xo*costheta+yo*sintheta)>>19);
    y = yo+((-xo*sintheta-yo*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (0,h-1) */
    x = xo+((-xo*costheta-(hout-1-yo)*sintheta)>>19);
    y = yo+((-xo*sintheta+(hout-1-yo)*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (w-1,0) */
    x = xo+(((wout-1-xo)*costheta+yo*sintheta)>>19);
    y = yo+(((wout-1-xo)*sintheta-yo*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* (w-1,h-1) */
    x = xo+(((wout-1-xo)*costheta-(hout-1-yo)*sintheta)>>19);
    y = yo+(((wout-1-xo)*sintheta+(hout-1-yo)*costheta)>>19);
    if (x < xmin) xmin = x;
    if (x > xmax) xmax = x;
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;

    /* Large output */
    w = xmax-xmin+1;
    if (w%2) w++;
    h = ymax-ymin+1;
    x = w*h;
    rImgPtr = ipl_malloc(x*3*sizeof(unsigned char));
    if (!rImgPtr)
    {
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_420lp marker_202\n");
      return IPL_NO_MEMORY;
    }

    routImgPtr = ipl_malloc(x*3*sizeof(unsigned char));
    if (!routImgPtr)
    {
      ipl_sys_free(rImgPtr);
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_420lp marker_203\n");
      return IPL_NO_MEMORY;
    }
    cntPtr = ipl_malloc(x*sizeof(uint8));
    if (!cntPtr)
    {
      ipl_sys_free(rImgPtr);
      ipl_sys_free(routImgPtr);
      ipl_sys_free(fullImgPtr);
      MSG_LOW("ipl_motion_blur_420lp marker_204\n");
      return IPL_NO_MEMORY;
    }
    memset(cntPtr, 1, x);

    /* Initialize rotated image to black */
    inIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        *((unsigned char*)(rImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(rImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(rImgPtr+inIndex++)) = 0x10;
      } /* end x loop */
    } /* end y loop */

    /* Initialize full YCbCr output buffer */
    inIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        *((unsigned char*)(routImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(routImgPtr+inIndex++)) = 0x80;
        *((unsigned char*)(routImgPtr+inIndex++)) = 0x10;
      } /* end x loop */
    } /* end y loop */

    /* Center of rotation */
    xxo = w >> 1;
    yyo = h >> 1;

    MSG_LOW("ipl_motion_blur_420lp marker_2\n");

    /* Rotate */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
          xin = xo+(((x-xxo)*costheta+(y-yyo)*sintheta)>>19);
          yin = yo+(((xxo-x)*sintheta+(y-yyo)*costheta)>>19);
          if (xin >= 0 && xin < wout && yin >= 0 && yin < hout) {
            inIndex = (yin*wout + xin)*3;
            *((unsigned char*)(rImgPtr+outIndex)) =
              *((unsigned char*)(fullImgPtr+inIndex++));
            *((unsigned char*)(rImgPtr+outIndex+1)) =
              *((unsigned char*)(fullImgPtr+inIndex++));
            *((unsigned char*)(rImgPtr+outIndex+2)) =
              *((unsigned char*)(fullImgPtr+inIndex));
          } else {
            *((uint8*)(cntPtr+cntIndex)) = 0;
          }
          outIndex += 3;
          cntIndex++;
      } /* end x loop */
    } /* end y loop */

    /* Loop through input */
    b = w - a;
    outIndex = 0;
    for (y = 0; y < h; y++) {
      /* Left boundary */
      for (x = 0; x < a; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        inIndex = outIndex + a*3;
        cntIndex = inIndex/3;
        for (n = -a; n < -x; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex -= 3;
          cntIndex--;
        }
        inIndex = outIndex - x*3;
        cntIndex = inIndex/3;
        for (n = -x; n <= a; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex += 3;
          cntIndex++;
        }
        /* Sset output values */
        if (cnt > 0) {
          *((unsigned char*)(routImgPtr+outIndex)) =
            (unsigned char)(cbSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+1)) =
            (unsigned char)(crSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+2)) =
            (unsigned char)(ySum/cnt);
        }
        outIndex += 3;
      }

      /* Center, non-boundary part */
      for (x = a; x < b; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        inIndex = outIndex - a*3;
        cntIndex = inIndex/3;
        for (n = -a; n <= a; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex += 3;
          cntIndex++;
        }
        /* Set output values */
        if (cnt > 0) {
          *((unsigned char*)(routImgPtr+outIndex)) =
            (unsigned char)(cbSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+1)) =
            (unsigned char)(crSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+2)) =
            (unsigned char)(ySum/cnt);
        }
        outIndex += 3;
      }

      /* Right boundary */
      for (x = b; x < w; x++) {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        cnt = 0;
        endn = w - x;
        inIndex = outIndex - a*3;
        cntIndex = inIndex/3;
        for (n = -a; n < endn; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex += 3;
          cntIndex++;
        }
        inIndex = outIndex - endn*3;
        cntIndex = inIndex/3;
        for (n = endn; n <= a; n++) {
          if (*((uint8*)(cntPtr+cntIndex))) {
            cbSum += *((unsigned char*)(rImgPtr+inIndex));
            crSum += *((unsigned char*)(rImgPtr+inIndex+1));
            ySum += *((unsigned char*)(rImgPtr+inIndex+2));
            cnt++;
          }
          inIndex -= 3;
          cntIndex--;
        }
        /* Set output values */
        if (cnt > 0) {
          *((unsigned char*)(routImgPtr+outIndex)) =
            (unsigned char)(cbSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+1)) =
            (unsigned char)(crSum/cnt);
          *((unsigned char*)(routImgPtr+outIndex+2)) =
            (unsigned char)(ySum/cnt);
        }
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */

    /* Rotate and get 4:2:0 line packed output */
    outIndex = 0;
    for (y = 0; y < hout; y++) {
      for (x = 0; x < wout; x++) {
        xin = xxo+(((x-xo)*costheta+(yo-y)*sintheta)>>19);
        yin = yyo+(((x-xo)*sintheta+(y-yo)*costheta)>>19);
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          *((unsigned char*)(fullImgPtr+outIndex++)) =
            *((unsigned char*)(routImgPtr+inIndex++));
          *((unsigned char*)(fullImgPtr+outIndex++)) =
            *((unsigned char*)(routImgPtr+inIndex++));
          *((unsigned char*)(fullImgPtr+outIndex++)) =
            *((unsigned char*)(routImgPtr+inIndex));
        } else {
          *((unsigned char*)(fullImgPtr+outIndex++)) = 0x80;
          *((unsigned char*)(fullImgPtr+outIndex++)) = 0x80;
          *((unsigned char*)(fullImgPtr+outIndex++)) = 0x10;
        } /* end if */
      } /* end x loop */
    } /* end y loop */

    /* Get output */
    /* Luma values */
    inIndex = 2;
    for (y = 0; y < hout; y++)
    {
      for (x = 0; x < wout; x++)
      {
        *outImgPtr++ = *((unsigned char*)(fullImgPtr+inIndex));
        inIndex += 3;
      } /* end x loop */
    } /* end y loop */

    /* Chroma values */
    inIndex = 0;
    inc = wout*3;
    for (y = 0; y < hout; y+=2)
    {
      for (x = 0; x < wout; x+=2)
      {
        *outClrPtr++ = *((unsigned char*)(fullImgPtr+inIndex++));
        *outClrPtr++ = *((unsigned char*)(fullImgPtr+inIndex++));
        inIndex += 4;
      } /* end x loop */
      inIndex += inc;
    } /* end y loop */

    /* Free memory */
    ipl_sys_free(rImgPtr);
    ipl_sys_free(cntPtr);
  }
  else
  {
    /*
    ** Horizontal motion blur
    */

    /* Malloc full YCbCr output buffer */
    routImgPtr = ipl_malloc(wout*hout*3*sizeof(unsigned char));
    if (!routImgPtr)
    {
      MSG_LOW("ipl_motion_blur_420lp marker_205\n");
      return IPL_NO_MEMORY;
    }

    /* Loop through input */
    b = wout - a;
    outIndex = 0;
    for (y = 0; y < hout; y++)
    {
      /* Left boundary */
      for (x = 0; x < a; x++)
      {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        inIndex = outIndex + a*3;
        for (n = -a; n < -x; n++)
        {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex));
          crSum += *((unsigned char*)(fullImgPtr+inIndex+1));
          ySum += *((unsigned char*)(fullImgPtr+inIndex+2));
          inIndex -= 3;
        }
        inIndex = outIndex - x*3;
        for (n = -x; n <= a; n++)
        {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex++));
          crSum += *((unsigned char*)(fullImgPtr+inIndex++));
          ySum += *((unsigned char*)(fullImgPtr+inIndex++));
        }
        /* Sset output values */
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(cbSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(crSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(ySum/size);
      }

      /* Center, non-boundary part */
      for (x = a; x < b; x++)
      {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        inIndex = outIndex - a*3;
        for (n = -a; n <= a; n++)
        {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex++));
          crSum += *((unsigned char*)(fullImgPtr+inIndex++));
          ySum += *((unsigned char*)(fullImgPtr+inIndex++));
        }
        /* Set output values */
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(cbSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(crSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(ySum/size);
      }

      /* Right boundary */
      for (x = b; x < wout; x++)
      {
        cbSum = 0;
        crSum = 0;
        ySum = 0;
        endn = wout - x;
        inIndex = outIndex - a*3;
        for (n = -a; n < endn; n++)
        {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex++));
          crSum += *((unsigned char*)(fullImgPtr+inIndex++));
          ySum += *((unsigned char*)(fullImgPtr+inIndex++));
        }
        inIndex = outIndex - endn*3;
        for (n = endn; n <= a; n++)
        {
          cbSum += *((unsigned char*)(fullImgPtr+inIndex));
          crSum += *((unsigned char*)(fullImgPtr+inIndex+1));
          ySum += *((unsigned char*)(fullImgPtr+inIndex+2));
          inIndex -= 3;
        }
        /* Set output values */
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(cbSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(crSum/size);
        *((unsigned char*)(routImgPtr+outIndex++)) =
          (unsigned char)(ySum/size);
      } /* end x loop */
    } /* end y loop */

    /* Get 4:2:0 line packed output */
    /* Luma values */
    inIndex = 2;
    for (y = 0; y < hout; y++)
    {
      for (x = 0; x < wout; x++)
      {
        *outImgPtr++ = *((unsigned char*)(routImgPtr+inIndex));
        inIndex += 3;
      } /* end x loop */
    } /* end y loop */

    /* Chroma values */
    inIndex = 0;
    inc = wout*3;
    for (y = 0; y < hout; y+=2)
    {
      for (x = 0; x < wout; x+=2)
      {
        *outClrPtr++ = *((unsigned char*)(routImgPtr+inIndex++));
        *outClrPtr++ = *((unsigned char*)(routImgPtr+inIndex++));
        inIndex += 4;
      } /* end x loop */
      inIndex += inc;
    } /* end y loop */
  } /* end if */

  /* Free memory */
  ipl_sys_free(fullImgPtr);
  ipl_sys_free(routImgPtr);

  MSG_LOW("ipl_motion_blur_420lp marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_motion_blur_420lp */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_motion_blur

DESCRIPTION
  This function produces motion blur in any arbitrary direction. The size
  of the blurring window must be an odd, positive integer in the range
  3 <= size <= 1/2 * min(w, h), where w and h are the width and height of
  the input image. The direction of motion is specified by a positive integer
  angle measured in degrees from the horizontal.

  Input and output images must have the same size.
  Input and output images must be in the same color format, which can be
  RGB565, YCbCr 4:2:2, YCbCr 4:2:0 line packed, or YCrCb 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  size          size of blurring window
  angle         angle of motion blur

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_motion_blur
(
  ipl_image_type* in_img_ptr,   /* Points to the input image  */
  ipl_image_type* out_img_ptr,  /* Points to the output image */
  uint32 size,                  /* Width of blurring window   */
  uint16 angle                  /* Angle of motion blur       */
)
{
  ipl_status_type retval;

  MSG_LOW("ipl_motion_blur marker_0\n");

  if (!in_img_ptr || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_motion_blur marker_200\n");
    return IPL_FAILURE;
  }

  if (in_img_ptr->cFormat != out_img_ptr->cFormat)
  {
    MSG_LOW("ipl_motion_blur marker_201\n");
    return IPL_FAILURE;
  }
  if (in_img_ptr->dx != out_img_ptr->dx ||
      in_img_ptr->dy != out_img_ptr->dy)
  {
    MSG_LOW("ipl_motion_blur marker_202\n");
    return IPL_FAILURE;
  }
  /* Size of blurring window must be positive and odd */
  if (size == 0 || !(size%2))
  {
    MSG_LOW("ipl_motion_blur marker_203\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_motion_blur marker_1\n");

  /* Call the appropriate function */
  if (in_img_ptr->cFormat == IPL_RGB565)
  {
    retval = ipl_motion_blur_rgb565(in_img_ptr, out_img_ptr, size, angle);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_motion_blur marker_204\n");
      return retval;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCbCr)
  {
    retval = ipl_motion_blur_ycbcr(in_img_ptr, out_img_ptr, size, angle);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_motion_blur marker_205\n");
      return retval;
    }
  } else if (in_img_ptr->cFormat == IPL_YCbCr420_LINE_PK ||
             in_img_ptr->cFormat == IPL_YCrCb420_LINE_PK)
  {
    retval = ipl_motion_blur_420lp(in_img_ptr, out_img_ptr, size, angle);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_motion_blur marker_206\n");
      return retval;
    }
  }
  else
  {
    MSG_LOW("ipl_motion_blur marker_207\n");
    /* No other formats supported */
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_motion_blur marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_motion_blur */



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_neon_rgb565

DESCRIPTION
  This function creates a neon version of the input image.  Input and
  output images must be the same size.

  Input and output images must be in RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_neon_rgb565
(
  ipl_image_type* i_img_ptr,   /* Points to the input image  */
  ipl_image_type* o_img_ptr    /* Points to the output image */
)
{
  uint16 *inImgPtr, *outImgPtr;
  uint32 inIndex, outIndex, w, h, x, y, endx, endy, offset;
  uint8 i;
  int32 rSum, gSum, bSum, rSum2, gSum2, bSum2;

  MSG_LOW("ipl_neon_rgb565 marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_neon_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = (uint16*)i_img_ptr->imgPtr;
  outImgPtr = (uint16*)o_img_ptr->imgPtr;
  w = o_img_ptr->dx;
  h = o_img_ptr->dy;

  MSG_LOW("ipl_neon_rgb565 marker_1\n");

  /* Center area of output image */
  outIndex = w+1;
  endx = w-1;
  endy = h-1;
  offset = w+1;
  for (y = 1; y < endy; y++) {
    for (x = 1; x < endx; x++) {
      rSum = 0;
      gSum = 0;
      bSum = 0;
      /* horizontal */
      rSum2 = 0;
      gSum2 = 0;
      bSum2 = 0;
      inIndex = outIndex - offset;
      /* + */
      for (i = 0; i < 3; i++) {
        /* unpack to get rgb values */
        rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(inImgPtr+inIndex++)) & 0x001F)<<3;
      }
      inIndex = outIndex + endx;
      /* - */
      for (i = 0; i < 3; i++) {
        /* unpack to get rgb values */
        rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(inImgPtr+inIndex++)) & 0x001F)<<3;
      }
      /* Take absolute value */
      if (rSum2 < 0) rSum2 = -rSum2;
      if (gSum2 < 0) gSum2 = -gSum2;
      if (bSum2 < 0) bSum2 = -bSum2;
      /* Update max sum */
      if (rSum2 > rSum) rSum = rSum2;
      if (gSum2 > gSum) gSum = gSum2;
      if (bSum2 > bSum) bSum = bSum2;
      /* vertical */
      rSum2 = 0;
      gSum2 = 0;
      bSum2 = 0;
      inIndex = outIndex - offset;
      /* + */
      for (i = 0; i < 3; i++) {
        /* unpack to get rgb values */
        rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
        inIndex += w;
      }
      inIndex = outIndex - endx;
      /* - */
      for (i = 0; i < 3; i++) {
        /* unpack to get rgb values */
        rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
        inIndex += w;
      }
      /* Take absolute value */
      if (rSum2 < 0) rSum2 = -rSum2;
      if (gSum2 < 0) gSum2 = -gSum2;
      if (bSum2 < 0) bSum2 = -bSum2;
      /* Update maximum sum */
      if (rSum2 > rSum) rSum = rSum2;
      if (gSum2 > gSum) gSum = gSum2;
      if (bSum2 > bSum) bSum = bSum2;
      /* diagonal 1: \ */
      rSum2 = 0;
      gSum2 = 0;
      bSum2 = 0;
      inIndex = outIndex - offset;
      /* 1 */
      rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 += (*((uint16*)(inImgPtr+inIndex++)) & 0x001F)<<3;
      /* 2 */
      rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      inIndex += endx;
      /* 3 */
      rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 += (*((uint16*)(inImgPtr+inIndex++)) & 0x001F)<<3;
      inIndex++;
      /* 4 */
      rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      inIndex += w;
      /* 5 */
      rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 -= (*((uint16*)(inImgPtr+inIndex--)) & 0x001F)<<3;
      /* 6 */
      rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      /* Take absolute value */
      if (rSum2 < 0) rSum2 = -rSum2;
      if (gSum2 < 0) gSum2 = -gSum2;
      if (bSum2 < 0) bSum2 = -bSum2;
      /* Update maximum sum */
      if (rSum2 > rSum) rSum = rSum2;
      if (gSum2 > gSum) gSum = gSum2;
      if (bSum2 > bSum) bSum = bSum2;
      /* diagonal 2: / */
      rSum2 = 0;
      gSum2 = 0;
      bSum2 = 0;
      inIndex = outIndex - w;
      /* 1 */
      rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 += (*((uint16*)(inImgPtr+inIndex++)) & 0x001F)<<3;
      /* 2 */
      rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      inIndex += w;
      /* 3 */
      rSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 += (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      inIndex -= 2;
      /* 4 */
      rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      inIndex += w;
      /* 5 */
      rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 -= (*((uint16*)(inImgPtr+inIndex++)) & 0x001F)<<3;
      /* 6 */
      rSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0xF800)>>8;
      gSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x07E0)>>3;
      bSum2 -= (*((uint16*)(inImgPtr+inIndex)) & 0x001F)<<3;
      /* Take absolute value */
      if (rSum2 < 0) rSum2 = -rSum2;
      if (gSum2 < 0) gSum2 = -gSum2;
      if (bSum2 < 0) bSum2 = -bSum2;
      /* Update maximum sum */
      if (rSum2 > rSum) rSum = rSum2;
      if (gSum2 > gSum) gSum = gSum2;
      if (bSum2 > bSum) bSum = bSum2;
      /* Scale and clip to 255 */
      rSum = rSum << 1;
      if (rSum > 255) rSum = 255;
      gSum = gSum << 1;
      if (gSum > 255) gSum = 255;
      bSum = bSum << 1;
      if (bSum > 255) bSum = 255;

      /* Set output pixel value */
      *((uint16*)(outImgPtr+outIndex++)) = pack_rgb565(rSum, gSum, bSum);
    } /* end x loop */
    outIndex += 2;
  } /* end y loop */

  /* Boundaries */
  outIndex = 0;
  /* top */
  for (x = 0; x < w; x++) {
    *((uint16*)(outImgPtr+outIndex++)) = 0;
  }
  /* left and right */
  outIndex = w;
  for (y = 1; y < h; y++) {
    /* left */
    *((uint16*)(outImgPtr+outIndex--)) = 0;
    outIndex += w;
    /* right */
    *((uint16*)(outImgPtr+outIndex++)) = 0;
  }
  /* bottom */
  outIndex = (h-1)*w;
  for (x = 0; x < w; x++) {
    *((uint16*)(outImgPtr+outIndex++)) = 0;
  }

  MSG_LOW("ipl_neon_rgb565 marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_neon_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_neon_ycbcr

DESCRIPTION
  This function creates a neon version of the input image.  Input and
  output images must be the same size.

  Input and output images must be in YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_neon_ycbcr
(
  ipl_image_type* i_img_ptr,   /* Points to the input image  */
  ipl_image_type* o_img_ptr    /* Points to the output image */
)
{
  unsigned char *inImgPtr, *outImgPtr;

  uint16 *rgbImgPtr, *rgbOutImgPtr;

  ipl_image_type rgbImg2;
  ipl_image_type rgbOutImg2;

  uint16 *rgbImgPtr2, *rgbOutImgPtr2;

  uint32 inIndex, outIndex, w, h, x, y, endx, endy, offset;
  uint8 i;
  int32 rSum, gSum, bSum, rSum2, gSum2, bSum2;

  MSG_LOW("ipl_neon_ycbcr marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_neon_ycbcr marker_200\n");
    return IPL_FAILURE;
  }


  if (i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK ||
      i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK)
  {
    /* Initialize image pointers and local variables */
    w = o_img_ptr->dx;
    h = o_img_ptr->dy;

    rgbImg2.dx = w;
    rgbImg2.dy = h;
    rgbImg2.cFormat = IPL_RGB565;

    if (ipl_malloc_img(&rgbImg2) != IPL_SUCCESS)
    {
      MSG_LOW("ipl_neon_ycbcr marker_201\n");
      return IPL_NO_MEMORY;
    }

    rgbOutImg2.dx = w;
    rgbOutImg2.dy = h;
    rgbOutImg2.cFormat = IPL_RGB565;

    if (ipl_malloc_img(&rgbOutImg2) != IPL_SUCCESS)
    {
      MSG_LOW("ipl_neon_ycbcr marker_201\n");
      ipl_free_img(&rgbImg2);
      return IPL_NO_MEMORY;
    }

    MSG_LOW("ipl_neon_ycbcr marker_1\n");

    /* Convert to RGB565 */
    if (ipl_convert_image(i_img_ptr, &rgbImg2) != IPL_SUCCESS)
    {
      ipl_free_img(&rgbImg2);
      ipl_free_img(&rgbOutImg2);
      return IPL_FAILURE;
    }

    /* Center area of output image */
    outIndex = w+1;
    endx = w-1;
    endy = h-1;
    offset = w+1;

    rgbImgPtr2 = (uint16 *) rgbImg2.imgPtr;
    rgbOutImgPtr2 = (uint16 *) rgbOutImg2.imgPtr;

    for (y = 1; y < endy; y++)
    {
      for (x = 1; x < endx; x++)
      {
        rSum = 0;
        gSum = 0;
        bSum = 0;



        /* horizontal */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - offset;
        /* + */
        for (i = 0; i < 1; i++)
        {
          /* unpack to get rgb values */
          rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
          gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
          bSum2 += (*((uint16*)(rgbImgPtr2+inIndex++)) & 0x001F)<<3;
        }
        inIndex = outIndex + endx;
        /* - */
        for (i = 0; i < 1; i++) {
          /* unpack to get rgb values */
          rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
          gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
          bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex++)) & 0x001F)<<3;
        }
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update max sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;




        /* vertical */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - offset;
        /* + */
        for (i = 0; i < 1; i++) {
          /* unpack to get rgb values */
          rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
          gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
          bSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
          inIndex += w;
        }
        inIndex = outIndex - endx;
        /* - */
        for (i = 0; i < 1; i++) {
          /* unpack to get rgb values */
          rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
          gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
          bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
          inIndex += w;
        }
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update maximum sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;


#if 0

        /* diagonal 1: \ */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - offset;
        /* 1 */
        rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr2+inIndex++)) & 0x001F)<<3;
        /* 2 */
        rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        inIndex += endx;
        /* 3 */
        rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr2+inIndex++)) & 0x001F)<<3;
        inIndex++;
        /* 4 */
        rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        inIndex += w;
        /* 5 */
        rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex--)) & 0x001F)<<3;
        /* 6 */
        rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update maximum sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;




        /* diagonal 2: / */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - w;
        /* 1 */
        rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr2+inIndex++)) & 0x001F)<<3;
        /* 2 */
        rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        inIndex += w;
        /* 3 */
        rSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        inIndex -= 2;
        /* 4 */
        rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        inIndex += w;
        /* 5 */
        rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex++)) & 0x001F)<<3;
        /* 6 */
        rSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr2+inIndex)) & 0x001F)<<3;
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update maximum sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;

#endif

        /* Scale and clip to 255 */
        rSum = rSum << 1;
        if (rSum > 255) rSum = 255;
        gSum = gSum << 1;
        if (gSum > 255) gSum = 255;
        bSum = bSum << 1;
        if (bSum > 255) bSum = 255;



        /* Set output pixel value */
        *((uint16*)(rgbOutImgPtr2+outIndex++)) = pack_rgb565(rSum, gSum, bSum);
      } /* end x loop */
      outIndex += 2;
    } /* end y loop */

    /* Boundaries */
    outIndex = 0;

    /* top */
    for (x = 0; x < w; x++)
    {
      *((uint16*)(rgbOutImgPtr2+outIndex++)) = 0;
    }

    /* left and right */
    outIndex = w;
    for (y = 1; y < h; y++)
    {
      /* left */
      *((uint16*)(rgbOutImgPtr2+outIndex--)) = 0;
      outIndex += w;

      /* right */
      *((uint16*)(rgbOutImgPtr2+outIndex++)) = 0;
    }

    /* bottom */
    outIndex = (h-1)*w;
    for (x = 0; x < w; x++)
    {
      *((uint16*)(rgbOutImgPtr2+outIndex++)) = 0;
    }

    /* Convert back to YCbCr 4:2:2 */
    ipl_convert_image(&rgbOutImg2, o_img_ptr);

    /* Free memory */
    ipl_free_img(&rgbImg2);
    ipl_free_img(&rgbOutImg2);
  }
  else if (i_img_ptr->cFormat == IPL_YCbCr)
  {
    /* Initialize image pointers and local variables */
    inImgPtr = i_img_ptr->imgPtr;
    outImgPtr = o_img_ptr->imgPtr;
    w = o_img_ptr->dx;
    h = o_img_ptr->dy;
    rgbImgPtr = ipl_malloc(w*h*sizeof(uint16));
    if (!rgbImgPtr) {
      MSG_LOW("ipl_neon_ycbcr marker_201\n");
      return IPL_NO_MEMORY;
    }
    rgbOutImgPtr = ipl_malloc(w*h*sizeof(uint16));
    if (!rgbOutImgPtr) {
      ipl_sys_free(rgbImgPtr);
      MSG_LOW("ipl_neon_ycbcr marker_202\n");
      return IPL_NO_MEMORY;
    }

    MSG_LOW("ipl_neon_ycbcr marker_1\n");

    /* Convert to RGB565 */
    ipl_YCbCr2RGB(inImgPtr, rgbImgPtr, (short)w, (short)h);

    /* Center area of output image */
    outIndex = w+1;
    endx = w-1;
    endy = h-1;
    offset = w+1;
    for (y = 1; y < endy; y++)
    {
      for (x = 1; x < endx; x++)
      {
        rSum = 0;
        gSum = 0;
        bSum = 0;



        /* horizontal */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - offset;
        /* + */
        for (i = 0; i < 3; i++) {
          /* unpack to get rgb values */
          rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
          gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
          bSum2 += (*((uint16*)(rgbImgPtr+inIndex++)) & 0x001F)<<3;
        }
        inIndex = outIndex + endx;
        /* - */
        for (i = 0; i < 3; i++) {
          /* unpack to get rgb values */
          rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
          gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
          bSum2 -= (*((uint16*)(rgbImgPtr+inIndex++)) & 0x001F)<<3;
        }
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update max sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;




        /* vertical */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - offset;
        /* + */
        for (i = 0; i < 3; i++) {
          /* unpack to get rgb values */
          rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
          gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
          bSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
          inIndex += w;
        }
        inIndex = outIndex - endx;
        /* - */
        for (i = 0; i < 3; i++) {
          /* unpack to get rgb values */
          rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
          gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
          bSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
          inIndex += w;
        }
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update maximum sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;




        /* diagonal 1: \ */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - offset;
        /* 1 */
        rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr+inIndex++)) & 0x001F)<<3;
        /* 2 */
        rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        inIndex += endx;
        /* 3 */
        rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr+inIndex++)) & 0x001F)<<3;
        inIndex++;
        /* 4 */
        rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        inIndex += w;
        /* 5 */
        rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr+inIndex--)) & 0x001F)<<3;
        /* 6 */
        rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update maximum sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;




        /* diagonal 2: / */
        rSum2 = 0;
        gSum2 = 0;
        bSum2 = 0;
        inIndex = outIndex - w;
        /* 1 */
        rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr+inIndex++)) & 0x001F)<<3;
        /* 2 */
        rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        inIndex += w;
        /* 3 */
        rSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 += (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        inIndex -= 2;
        /* 4 */
        rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        inIndex += w;
        /* 5 */
        rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr+inIndex++)) & 0x001F)<<3;
        /* 6 */
        rSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0xF800)>>8;
        gSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x07E0)>>3;
        bSum2 -= (*((uint16*)(rgbImgPtr+inIndex)) & 0x001F)<<3;
        /* Take absolute value */
        if (rSum2 < 0) rSum2 = -rSum2;
        if (gSum2 < 0) gSum2 = -gSum2;
        if (bSum2 < 0) bSum2 = -bSum2;
        /* Update maximum sum */
        if (rSum2 > rSum) rSum = rSum2;
        if (gSum2 > gSum) gSum = gSum2;
        if (bSum2 > bSum) bSum = bSum2;

        /* Scale and clip to 255 */
        rSum = rSum << 1;
        if (rSum > 255) rSum = 255;
        gSum = gSum << 1;
        if (gSum > 255) gSum = 255;
        bSum = bSum << 1;
        if (bSum > 255) bSum = 255;



        /* Set output pixel value */
        *((uint16*)(rgbOutImgPtr+outIndex++)) = pack_rgb565(rSum, gSum, bSum);
      } /* end x loop */
      outIndex += 2;
    } /* end y loop */

    /* Boundaries */
    outIndex = 0;
    /* top */
    for (x = 0; x < w; x++) {
      *((uint16*)(rgbOutImgPtr+outIndex++)) = 0;
    }
    /* left and right */
    outIndex = w;
    for (y = 1; y < h; y++) {
      /* left */
      *((uint16*)(rgbOutImgPtr+outIndex--)) = 0;
      outIndex += w;
      /* right */
      *((uint16*)(rgbOutImgPtr+outIndex++)) = 0;
    }
    /* bottom */
    outIndex = (h-1)*w;
    for (x = 0; x < w; x++) {
      *((uint16*)(rgbOutImgPtr+outIndex++)) = 0;
    }

    /* Convert back to YCbCr 4:2:2 */
    ipl_RGB2YCbCr((unsigned char*)rgbOutImgPtr, outImgPtr, (short)w, (short)h);

    /* Free memory */
    ipl_sys_free(rgbImgPtr);
    ipl_sys_free(rgbOutImgPtr);
  }

  MSG_LOW("ipl_neon_ycbcr marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_neon_ycbcr */



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_neon

DESCRIPTION
  This function creates a neon version of the input image.  Input and
  output images must be the same size.

  Input and output images must have the same color format, which can
  be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr     pointer to the input image
  o_img_ptr     pointer to the output image

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_neon
(
  ipl_image_type* input_img_ptr,    /* Points to the input image  */
  ipl_image_type* output_img_ptr     /* Points to the output image */
)
{
  ipl_image_type * i_img_ptr;
  ipl_image_type * o_img_ptr;
  ipl_status_type retval;

  // see if we are doing this inplace
  if (output_img_ptr == NULL)
  {
    o_img_ptr = input_img_ptr;
  }
  else
  {
    o_img_ptr = output_img_ptr;
  }
  i_img_ptr = input_img_ptr;


  MSG_LOW("ipl_neon marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_neon marker_200\n");
    return IPL_FAILURE;
  }

  /* Input and output color formats must be the same */
  if (i_img_ptr->cFormat != o_img_ptr->cFormat)
  {
    MSG_LOW("ipl_neon marker_201\n");
    return IPL_FAILURE;
  }

  /* Input and output images must be the same size */
  if (i_img_ptr->dx != o_img_ptr->dx ||
      i_img_ptr->dy != o_img_ptr->dy)
  {
    MSG_LOW("ipl_neon marker_202\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_neon marker_1\n");

  /* Call the appropriate function */
  if (i_img_ptr->cFormat == IPL_RGB565)
  {
    retval = ipl_neon_rgb565(i_img_ptr, o_img_ptr);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_neon marker_203\n");
      return retval;
    }
  }
  else if (i_img_ptr->cFormat == IPL_YCbCr ||
           i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
           i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    retval = ipl_neon_ycbcr(i_img_ptr, o_img_ptr);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_neon marker_204\n");
      return retval;
    }
  }
  else
  {
    MSG_LOW("ipl_neon marker_210\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_neon marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_neon */




//
// Featuize: should we use include corner fold, fog
//



#ifdef FEATURE_IPL_FUNC_CORNER_FOLD

/* <EJECT> */
/*===========================================================================

FUNCTION ipl_corner_fold_rgb565

DESCRIPTION
  This function folds over a corner of the image. The folded corner can
  be the upper left (0), upper right (1), lower left (2), or lower
  right (3) corner. The first input image is the image whose corner is
  folded. The second input image is behind the first input image and
  will be partially revealed by the folded corner.

  Input and output image sizes must be equal.
  Input and output must be in RGB565 format.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr   points to the first input image
  in2_img_ptr   points to the second input image
  o_img_ptr     points to the output image
  position      position of the corner fold

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_corner_fold_rgb565
(
  ipl_image_type* in1_img_ptr,    /* Points to the first input image  */
  ipl_image_type* in2_img_ptr,    /* Points to the second input image */
  ipl_image_type* out_img_ptr,    /* Points to the output image       */
  uint8 position                  /* Position of corner fold          */
)
{
  uint16 *in1ImgPtr, *in2ImgPtr, *outImgPtr;
  uint16 *cImgPtr, *cin1ImgPtr, *cin2ImgPtr, *fImgPtr, *tImgPtr;
  uint16 *cOrigImgPtr = corner_rgb_420x216;
  uint32 inIndex, outIndex, cSize;
  int32 w, h, x, y, xin, yin, xo, yo, xoo, yoo, a, b, c, wwc, hhc,
        inc1, inc2, sintheta, costheta, cRatio, paramRatio;
  uint8 rr, gg, bb;
  uint8 fliphorz = 0, flipvert = 0, flag;
  uint16 cval, val;
  /* Corner image parameters */
  int32 numParams = 16;
  int32 params[16] = {0};
  int32 paramsOrig[] = {420, 216, 274, 96, 39, 25, 10, 37, 25,
                        15, 115, 215, 61, 8, 13, 18};
  int32 radian = 382;  /* Q9 */
  int32 slopes[] = {35, 17, 192, 43};  /* Q8 */
  /* Pixel values in corner template image */
  uint16 pv1 = 0;       /* input 1 */
  uint16 pv2 = 0x630c;  /* input 2 */
  uint16 pvc = 0xc638;  /* corner fold */

  MSG_LOW("ipl_corner_fold_rgb565 marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_corner_fold_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  in1ImgPtr = (uint16*)in1_img_ptr->imgPtr;
  in2ImgPtr = (uint16*)in2_img_ptr->imgPtr;
  outImgPtr = (uint16*)out_img_ptr->imgPtr;
  w = out_img_ptr->dx;
  h = out_img_ptr->dy;
  /* Determine if horizontal or vertical flips are needed */
  if (position == 1) {
    fliphorz = 1;
  } else if (position == 2) {
    flipvert = 1;
  } else if (position == 3) {
    fliphorz = 1;
    flipvert = 1;
  }

	/* Adjust corner template size according to input aspect ratio */
	if ((520*h) < (390*w)) {
		/* Case 1: width is too big, use height to adjust size */
		a = (h*288)/520;
		params[0] = (420*a)/216;
		params[1] = a;
		cRatio = (a<<10)/216;
	} else {
		/* Case 2: height is too big, use width to adjust size */
		a = (w*315)/390;
		params[0] = a;
		params[1] = (216*a)/420;
		cRatio = (a<<10)/420;
	}

	/* New corner template size */
	a = params[0];
	b = params[1];
	cSize = a * b;

	/* New corner fold parameters */
	paramRatio = (params[0]<<10) / 420;
	for (c = 2; c < numParams; c++) {
		params[c] = (paramRatio * paramsOrig[c])>>10;
	}

	/* New corner template */
	cImgPtr = ipl_malloc(cSize*sizeof(uint16));
	if (!cImgPtr)
  {
    MSG_LOW("ipl_corner_fold_rgb565 marker_201\n");
    return IPL_NO_MEMORY;
	}
  memset(cImgPtr, 0, cSize*2);

  MSG_LOW("ipl_corner_fold_rgb565 marker_1\n");

	/* Corner fold area */
	inIndex = 0;
	xo = paramsOrig[0];
	yo = paramsOrig[1];
	for (yin = 0; yin < yo; yin++) {
		for (xin = 0; xin < xo; xin++) {
			if (*((uint16*)(cOrigImgPtr+inIndex)) == pvc) {
				x = (cRatio * xin) >> 10;
				y = (cRatio * yin) >> 10;
				*((uint16*)(cImgPtr+x+y*a)) = pvc;
			}
			inIndex++;
		} /* end xin loop */
	} /* end yin loop */
	*((uint16*)(cImgPtr+a-1)) = pvc;

	/* Area where input 1 will be */
	c = (b - 1)*a;
	for (x = 0; x < a; x++) {
		outIndex = x+c;
		for (y = 0; y < b; y++) {
			if (*((uint16*)(cImgPtr+outIndex)) == pvc) {
				break;
			}
			*((uint16*)(cImgPtr+outIndex)) = pv1;
			outIndex -= a;
		} /* end y loop */
	} /* end x loop */
	/* Area where input 2 will be */
	for (x = 0; x < a; x++) {
		outIndex = x;
		for (y = 0; y < b; y++) {
			if (*((uint16*)(cImgPtr+outIndex)) == pvc) {
				break;
			}
			*((uint16*)(cImgPtr+outIndex)) = pv2;
			outIndex += a;
		} /* end y loop */
	} /* end x loop */

	/* Malloc buffers for corner patches from input images */
	cin1ImgPtr = ipl_malloc(cSize*sizeof(uint16));
	if (!cin1ImgPtr)
  {
    MSG_LOW("ipl_corner_fold_rgb565 marker_202\n");
    ipl_sys_free(cImgPtr);
    return IPL_NO_MEMORY;
	}
	cin2ImgPtr = ipl_malloc(cSize*sizeof(uint16));
	if (!cin2ImgPtr)
  {
    MSG_LOW("ipl_corner_fold_rgb565 marker_203\n");
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    return IPL_NO_MEMORY;
	}

	/* Malloc buffer for corner fold region */
	wwc = params[2] + params[7] + params[12] + params[13];
	hhc = params[3] + params[5] + params[9];
	fImgPtr = ipl_malloc(wwc*hhc*sizeof(uint16));
	if (!fImgPtr)
  {
    MSG_LOW("ipl_corner_fold_rgb565 marker_204\n");
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    ipl_sys_free(cin2ImgPtr);
    return IPL_NO_MEMORY;
	}

	/* Sine and cosine for rotation of corner fold region */
	sintheta = -(((radian*(262144-(radian*radian)/6))>>8) +
			    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
				radian)/42)*((11010048-radian*radian)>>10))>>21));
	costheta = (524288-radian*radian) +
				(((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
				((7864320-radian*radian)>>10))>>12);

	/* Initialize increment for getting corner patches */
	inc1 = w - a;

	/* Get corner patch from 1st input image */
	outIndex = 0;
	if (position == 0) {
		/* Upper left corner */
		inIndex = 0;
	} else if (position == 1) {
		/* Upper right corner */
		inIndex = w-a;
	} else if (position == 2) {
		/* Lower left corner */
		inIndex = (h-b)*w;
	} else {
		/* Lower right corner */
		inIndex = (h-b)*w + w-a;
	}
	for (y = 0; y < b; y++) {
		for (x = 0; x < a; x++) {
			*((uint16*)(cin1ImgPtr+outIndex++)) =
				*((uint16*)(in1ImgPtr+inIndex++));
		} /* end x loop */
		inIndex += inc1;
	} /* end y loop */

	/* Get corner patch from 2nd input image */
	outIndex = 0;
	if (position == 0) {
		/* Upper left corner */
		inIndex = 0;
	} else if (position == 1) {
		/* Upper right corner */
		inIndex = w-a;
	} else if (position == 2) {
		/* Lower left corner */
		inIndex = (h-b)*w;
	} else {
		/* Lower right corner */
		inIndex = (h-b)*w + w-a;
	}
	for (y = 0; y < b; y++) {
		for (x = 0; x < a; x++) {
			*((uint16*)(cin2ImgPtr+outIndex++)) =
				*((uint16*)(in2ImgPtr+inIndex++));
		} /* end x loop */
		inIndex += inc1;
	} /* end y loop */

	/* Flip corner patches if needed */
	if (position != 0)
  {
		/* Malloc temporary buffer for storing flipped corner patch */
		tImgPtr = ipl_malloc(cSize*sizeof(uint16));
		if (!tImgPtr)
    {
      MSG_LOW("ipl_corner_fold_rgb565 marker_205\n");
      ipl_sys_free(cImgPtr);
      ipl_sys_free(cin1ImgPtr);
      ipl_sys_free(cin2ImgPtr);
      ipl_sys_free(fImgPtr);
      return IPL_NO_MEMORY;
		}

		/* Flip 1st corner patch */
		flag = 0;  /* corner patch is not in temporary buffer */
		if (fliphorz == 1) {
			/* Horizontal flip */
			inIndex = 0;
			outIndex = a-1;
			inc1 = a<<1;
			for (y = 0; y < b; y++) {
				for (x = 0; x < a; x++) {
					*((uint16*)(tImgPtr+outIndex--)) =
						*((uint16*)(cin1ImgPtr+inIndex++));
				}
				outIndex += inc1;
			}
			/* Reset flag */
			flag = 1;
		} /* end if fliphorz */
		if (flipvert == 1) {
			/* Vertical flip */
			inIndex = 0;
			outIndex = (b-1)*a;
			inc1 = a<<1;
			if (flag == 0) {
				/* Corner patch is not in temporary buffer */
				for (y = 0; y < b; y++) {
					for (x = 0; x < a; x++) {
						*((uint16*)(tImgPtr+outIndex++)) =
							*((uint16*)(cin1ImgPtr+inIndex++));
					}
					outIndex -= inc1;
				}
				/* Reset flag */
				flag = 1;
			} else {
				/* Corner patch is in temporary buffer */
				for (y = 0; y < b; y++) {
					for (x = 0; x < a; x++) {
						*((uint16*)(cin1ImgPtr+outIndex++)) =
							*((uint16*)(tImgPtr+inIndex++));
					}
					outIndex -= inc1;
				}
				/* Reset flag */
				flag = 0;
			} /* end if flag */
		} /* end if flipvert */
		if (flag == 1) {
			/* Corner patch is in temporary buffer */
			outIndex = 0;
			for (y = 0; y < b; y++) {
				for (x = 0; x < a; x++) {
					*((uint16*)(cin1ImgPtr+outIndex)) =
						*((uint16*)(tImgPtr+outIndex));
					outIndex++;
				} /* end x loop */
			} /* end y loop */
		}

		/* Flip 2nd corner patch */
		flag = 0;  /* corner patch is not in temporary buffer */
		if (fliphorz == 1) {
			/* Horizontal flip */
			inIndex = 0;
			outIndex = a-1;
			inc1 = a<<1;
			for (y = 0; y < b; y++) {
				for (x = 0; x < a; x++) {
					*((uint16*)(tImgPtr+outIndex--)) =
						*((uint16*)(cin2ImgPtr+inIndex++));
				}
				outIndex += inc1;
			}
			/* Reset flag */
			flag = 1;
		} /* end if fliphorz */
		if (flipvert == 1) {
			/* Vertical flip */
			inIndex = 0;
			outIndex = (b-1)*a;
			inc1 = a<<1;
			if (flag == 0) {
				/* Corner patch is not in temporary buffer */
				for (y = 0; y < b; y++) {
					for (x = 0; x < a; x++) {
					*((uint16*)(tImgPtr+outIndex++)) =
						*((uint16*)(cin2ImgPtr+inIndex++));
					}
					outIndex -= inc1;
				}
				/* Reset flag */
				flag = 1;
			} else {
				/* Corner patch is in temporary buffer */
				for (y = 0; y < b; y++) {
					for (x = 0; x < a; x++) {
					*((uint16*)(cin2ImgPtr+outIndex++)) =
						*((uint16*)(tImgPtr+inIndex++));
					}
					outIndex -= inc1;
				}
				/* Reset flag */
				flag = 0;
			} /* end if flag */
		} /* end if flipvert */
		if (flag == 1) {
			/* Corner patch is in temporary buffer */
			outIndex = 0;
			for (y = 0; y < b; y++) {
				for (x = 0; x < a; x++) {
					*((uint16*)(cin2ImgPtr+outIndex)) =
						*((uint16*)(tImgPtr+outIndex));
					outIndex++;
				} /* end x loop */
			} /* end y loop */
		}

		/* Free memory */
		ipl_sys_free(tImgPtr);
	} /* end if position */

  MSG_LOW("ipl_corner_fold_ycbcr marker_2\n");

	/* Get pixel value in blank image */
  memset(fImgPtr, 0, wwc*hhc*2);
  val = 0;

	/* Copy corner fold region from 1st corner patch */
	/* (1) bottom part */
	a = params[2] + params[7] + params[8];
	b = params[9];
	inIndex = 0;
	outIndex = (hhc-b-1)*wwc + params[4];
	inc1 = params[0] - a;
	inc2 = -(wwc + a);
	for (y = 0; y < b; y++) {
		for (x = 0; x < a; x++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(cin1ImgPtr+inIndex));
			inIndex++;
			outIndex++;
		} /* end x loop */
		inIndex += inc1;
		outIndex += inc2;
	} /* end y loop */
	/* (2) middle part */
	yo = params[9];
	a = params[2];
	b = params[3];
	inc1 = params[0] - a;
	inc2 = -(wwc + a);
	inIndex = yo * params[0];
	outIndex = (hhc-(yo<<1)-1)*wwc + params[4];
	for (y = yo; y < b; y++) {
		for (x = 0; x < a; x++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(cin1ImgPtr+inIndex));
			inIndex++;
			outIndex++;
		} /* end x loop */
		inIndex += inc1;
		outIndex += inc2;
	} /* end y loop */
	/* (3) top part */
	yo = params[3];
	a = params[12];
	b = hhc - params[9];
	inc1 = params[0] - a;
	inc2 = -(wwc + a);
	inIndex = yo * params[0];
	outIndex = (params[5]-1)*wwc + params[4];
	for (y = yo; y < b; y++) {
		for (x = 0; x < a; x++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(cin1ImgPtr+inIndex));
			inIndex++;
			outIndex++;
		} /* end x loop */
		inIndex += inc1;
		outIndex += inc2;
	} /* end y loop */

	/* Shift corner fold region to fit shape of corner fold */
	/* Segment on the right */
	b = slopes[0];
	c = params[9];
	for (x = wwc-params[7]-2*params[8]; x < wwc; x++) {
		a = ((b*(x-wwc))>>8)+c;
		outIndex = (hhc-c-1+a)*wwc+x;
		inIndex = outIndex-a*wwc;
		for (y = 0; y <= c; y++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(fImgPtr+inIndex));
			outIndex -= wwc;
			inIndex -= wwc;
		} /* end y loop */
	} /* end x loop */
	/* 1st segment on the left */
	xo = params[4];
	yo = hhc - params[9] - 1;
	b = params[13];
	c = slopes[1];
	inc1 = params[5];
	for (y = inc1-1; y < yo; y++) {
		a = b-((c*(y-inc1+1))>>8);
		outIndex = y*wwc+(xo-a);
		inIndex = outIndex+a;
		for (x = 0; x < b; x++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(fImgPtr+inIndex));
			outIndex++;
			inIndex++;
		}
	}
	/* 2nd segment on the left */
	xo = params[13] + params[14];
	yo = params[6];
	b = slopes[2];
	c = params[12];
	inc1 = params[4];
	inc2 = params[5];
	for (y = yo; y < inc2; y++) {
		a = xo-((b*(y-yo+1))>>8);
		outIndex = y*wwc+(inc1-a);
		inIndex = outIndex+a;
		for (x = 0; x < c; x++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(fImgPtr+inIndex));
			outIndex++;
			inIndex++;
		}
	}
	/* 3rd segment on the left */
	xo = params[13] + params[14] + params[15];
	yo = params[6];
	b = slopes[3];
	c = params[12];
	inc1 = params[4];
	for (y = 0; y < yo; y++) {
		a = xo-((b*y)>>8);
		outIndex = y*wwc+(inc1-a);
		inIndex = outIndex+a;
		for (x = 0; x < c; x++) {
			*((uint16*)(fImgPtr+outIndex)) = *((uint16*)(fImgPtr+inIndex));
			outIndex++;
			inIndex++;
		}
	}

	/* Rotate and copy corner fold onto corner template */
	outIndex = 0;
	xo = params[4];
	yo = hhc - params[9] - 1;
	a = params[0];
	b = params[1];
	xoo = params[10];
	yoo = params[11];
	for (y = 0; y < b; y++) {
		for (x = 0; x < a; x++) {
			if (*((uint16*)(cImgPtr+outIndex)) == pvc) {
				xin = xo+(((x-xoo)*costheta+(y-yoo)*sintheta)>>19);
				yin = yo+(((xoo-x)*sintheta+(y-yoo)*costheta)>>19);
				if (xin >= 0 && xin < wwc && yin >= 0 && yin < hhc) {
					inIndex = xin + yin*wwc;
					cval = *((uint16*)(fImgPtr+inIndex));
					if (cval != val) {
						rr = (uint8)((((cval & 0xF800)>>8)+255)>>1);
						gg = (uint8)((((cval & 0x07E0)>>3)+255)>>1);
						bb = (uint8)((((cval & 0x001F)<<3)+255)>>1);
						*((uint16*)(cImgPtr+outIndex)) = pack_rgb565(rr,gg,bb);
					} /* end if cval */
				} /* end if xin, yin */
			} /* end if pvc */
			outIndex++;
		} /* end x loop */
	} /* end y loop */

	/* Copy corner patches to corner template */
	if (position < 2) {
		/* Upper left or right corner */

		/* Copy 1st corner patch to corner template */
		c = (b-1)*a;
		for (x = 0; x < a; x++) {
			outIndex = x+c;
			for (y = 0; y < b; y++) {
				if (*((uint16*)(cImgPtr+outIndex)) != pv1) {
					break;
				}
				*((uint16*)(cImgPtr+outIndex)) =
					*((uint16*)(cin1ImgPtr+outIndex));
				outIndex -= a;
			} /* end x loop */
		} /* end y loop */

		/* Copy 2nd corner patch to corner template */
		for (x = 0; x < a; x++) {
			outIndex = x;
			for (y = 0; y < b; y++) {
				if (*((uint16*)(cImgPtr+outIndex)) != pv2) {
					break;
				}
				*((uint16*)(cImgPtr+outIndex)) =
					*((uint16*)(cin2ImgPtr+outIndex));
				outIndex += a;
			} /* end x loop */
		} /* end y loop */
	} else {
		/* Lower left or right corner */

		/* Copy 1st corner patch to corner template */
		c = (b-1)*a;
		for (x = 0; x < a; x++) {
			outIndex = x+c;
			for (y = 0; y < b; y++) {
				if (*((uint16*)(cImgPtr+outIndex)) != pv1) {
					break;
				}
				*((uint16*)(cImgPtr+outIndex)) =
					*((uint16*)(cin1ImgPtr+outIndex));
				outIndex -= a;
			} /* end x loop */
		} /* end y loop */

		/* Copy 2nd corner patch to corner template */
		for (x = 0; x < a; x++) {
			outIndex = x;
			for (y = 0; y < b; y++) {
				if (*((uint16*)(cImgPtr+outIndex)) != pv2) {
					break;
				}
				*((uint16*)(cImgPtr+outIndex)) =
					*((uint16*)(cin2ImgPtr+outIndex));
				outIndex += a;
			} /* end x loop */
		} /* end y loop */
	}

	/* Copy 1st input image to output */
  memset(outImgPtr, 0, h*w*2);
	outIndex = 0;
	for (y = 0; y < h; y++) {
		for (x = 0; x < w; x++) {
			*((uint16*)(outImgPtr+outIndex)) = *((uint16*)(in1ImgPtr+outIndex));
			outIndex++;
		} /* end x loop */
	} /* end y loop */

	if (position == 0) {
		/* Upper left corner */
		outIndex = 0;
		inc1 = w - params[0];
		inc2 = 1;
	} else if (position == 1) {
		/* Upper right corner */
		outIndex = w - 1;
		inc1 = w + params[0];
		inc2 = -1;
	} else if (position == 2) {
		/* Lower left corner */
		outIndex = (h - 1)*w;
		inc1 = -(w + params[0]);
		inc2 = 1;
	} else {
		/* Lower right corner */
		outIndex = h*w - 1;
		inc1 = -(w - params[0]);
		inc2 = -1;
	}

	/* Copy corner template to output image */
	inIndex = 0;
	a = params[0];
	b = params[1];
	for (y = 0; y < b; y++) {
		for (x = 0; x < a; x++) {
			*((uint16*)(outImgPtr+outIndex)) = *((uint16*)(cImgPtr+inIndex));
			inIndex++;
			outIndex += inc2;
		} /* end x loop */
		outIndex += inc1;
	} /* end y loop */

	/* Free memory */
	ipl_sys_free(cImgPtr);
	ipl_sys_free(fImgPtr);
	ipl_sys_free(cin1ImgPtr);
	ipl_sys_free(cin2ImgPtr);

  MSG_LOW("ipl_corner_fold_rgb565 marker_100\n");

	return IPL_SUCCESS;
} /* End ipl_corner_fold_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_corner_fold_ycbcr

DESCRIPTION
  This function folds over a corner of the image. The folded corner can
  be the upper left (0), upper right (1), lower left (2), or lower
  right (3) corner. The first input image is the image whose corner is
  folded. The second input image is behind the first input image and
  will be partially revealed by the folded corner.

  Input and output image sizes must be equal.
  Input and output must be in YCbCr 4:2:2 format.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr   points to the first input image
  in2_img_ptr   points to the second input image
  o_img_ptr     points to the output image
  position      position of the corner fold

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_corner_fold_ycbcr
(
  ipl_image_type* in1_img_ptr,        /* Points to the first input image  */
  ipl_image_type* in2_img_ptr,        /* Points to the second input image  */
  ipl_image_type* out_img_ptr,      /* Points to the output image */
  uint8 position            /* Position of corner fold */
)
{
  unsigned char *in1ImgPtr, *in2ImgPtr, *outImgPtr;
  unsigned char *cImgPtr, *cin1ImgPtr, *cin2ImgPtr, *fImgPtr,
                *tImgPtr, *ffImgPtr;
  uint8 *cOrigImgPtr = (uint8*)corner_ycbcr_420x216;
  uint32 inIndex, outIndex, cSize;
  int32 w, h, x, y, xin, yin, xo, yo, xoo, yoo, a, b, c, wwc, hhc,
      inc1, inc2, sintheta, costheta, cRatio, paramRatio;
  uint8 fliphorz = 0, flipvert = 0, flag;
  unsigned char cval, cval2, cval3, val, val2, cb, cr, luma1, luma2;
  /* Corner image parameters */
  int32 numParams = 16;
  int32 params[16] = {0};
  int32 paramsOrig[] = {420, 216, 274, 96, 39, 25, 10, 37, 25,
                        15, 115, 215, 61, 8, 13, 18};
  int32 radian = 382;  /* Q9 */
  int32 slopes[] = {35, 17, 192, 43}; /* Q8 */
  /* Pixel values in corner template image */
  unsigned char pv1 = 0x80, pv12 = 0x10;  /* input 1 */
  unsigned char pv2 = 0x80, pv22 = 0x65;  /* input 2 */
  unsigned char pvc = 0x80, pvc2 = 0xBB;  /* corner fold */


  MSG_LOW("ipl_corner_fold_ycbcr marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_corner_fold_ycbcr marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  in1ImgPtr = in1_img_ptr->imgPtr;
  in2ImgPtr = in2_img_ptr->imgPtr;
  outImgPtr = out_img_ptr->imgPtr;
  w = out_img_ptr->dx;
  h = out_img_ptr->dy;
  /* Determine if horizontal or vertical flips are needed */
  if (position == 1) {
    fliphorz = 1;
  } else if (position == 2) {
    flipvert = 1;
  } else if (position == 3) {
    fliphorz = 1;
    flipvert = 1;
  }

  /* Adjust corner template size according to input aspect ratio */
  if ((520*h) < (390*w)) {
    /* Case 1: width is too big, use height to adjust size */
    a = (h*288)/520;
    params[0] = (420*a)/216;
    params[1] = a;
    cRatio = (a<<10)/216;
  } else {
    /* Case 2: height is too big, use width to adjust size */
    a = (w*315)/390;
    params[0] = a;
    params[1] = (216*a)/420;
    cRatio = (a<<10)/420;
  }

  /* New corner template size */
  if (params[0]%2) params[0]--;
  a = params[0];
  b = params[1];
  cSize = (a * b) << 1;

  /* New corner fold parameters */
  paramRatio = (params[0]<<10) / 420;
  for (c = 2; c < numParams; c++) {
    params[c] = (paramRatio * paramsOrig[c]) >> 10;
  }

  /* New corner template */
  cImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
  if (!cImgPtr) {
    MSG_LOW("ipl_corner_fold_ycbcr marker_201\n");
    return IPL_NO_MEMORY;
  }
  memset(cImgPtr, 0, cSize);
  /* Corner fold area */
  inIndex = 0;
  xo = paramsOrig[0];
  yo = paramsOrig[1];
  MSG_LOW("ipl_corner_fold_ycbcr marker_1\n");

  for (yin = 0; yin < yo; yin++) {
    for (xin = 0; xin < xo; xin++) {
      if (*((unsigned char*)(cOrigImgPtr+inIndex)) == pvc &&
        *((unsigned char*)(cOrigImgPtr+inIndex+1)) == pvc2)
      {
        x = (cRatio * xin) >> 10;
        y = (cRatio * yin) >> 10;
        outIndex = (x+y*a)<<1;
        *((unsigned char*)(cImgPtr+outIndex++)) = pvc;
        *((unsigned char*)(cImgPtr+outIndex)) = pvc2;
      }
      inIndex += 2;
    } /* end xin loop */
  } /* end yin loop */

  /* Area where input 1 will be */
  c = (b-1)*a;
  inc1 = a<<1;
  for (x = 0; x < a; x++) {
    outIndex = (x+c)<<1;
    for (y = 0; y < b; y++) {
      if (*((unsigned char*)(cImgPtr+outIndex)) == pvc &&
        *((unsigned char*)(cImgPtr+outIndex+1)) == pvc2) {
        break;
      }
      *((unsigned char*)(cImgPtr+outIndex)) = pv1;
      *((unsigned char*)(cImgPtr+outIndex+1)) = pv12;
      outIndex -= inc1;
    } /* end x loop */
  } /* end y loop */

  /* Area where input 2 will be */
  for (x = 0; x < a; x++) {
    outIndex = x<<1;
    for (y = 0; y < b; y++) {
      if (*((unsigned char*)(cImgPtr+outIndex)) == pvc &&
        *((unsigned char*)(cImgPtr+outIndex+1)) == pvc2) {
        break;
      }
      *((unsigned char*)(cImgPtr+outIndex)) = pv2;
      *((unsigned char*)(cImgPtr+outIndex+1)) = pv22;
      outIndex += inc1;
    } /* end x loop */
  } /* end y loop */

  /* Malloc buffers for corner patches from input images */
  cin1ImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
  if (!cin1ImgPtr)
  {
    MSG_LOW("ipl_corner_fold_ycbcr marker_202\n");
    ipl_sys_free(cin1ImgPtr);
    return IPL_NO_MEMORY;
  }
  cin2ImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
  if (!cin2ImgPtr)
  {
    MSG_LOW("ipl_corner_fold_ycbcr marker_203\n");
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    return IPL_NO_MEMORY;
  }

  /* Malloc buffer for corner fold region */
  wwc = params[2] + params[7] + params[12] + params[13];
  hhc = params[3] + params[5] + params[9];
  c = wwc*hhc;
  fImgPtr = ipl_malloc((c<<1)*sizeof(unsigned char));
  if (!fImgPtr)
  {
    MSG_LOW("ipl_corner_fold_ycbcr marker_204\n");
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    ipl_sys_free(cin2ImgPtr);
    return IPL_NO_MEMORY;
  }
  /* Malloc buffer for full YCbCr corner fold region */
  ffImgPtr = ipl_malloc(c*3*sizeof(unsigned char));
  if (!ffImgPtr)
  {
    MSG_LOW("ipl_corner_fold_ycbcr marker_205\n");
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    ipl_sys_free(cin2ImgPtr);
    ipl_sys_free(fImgPtr);
    return IPL_NO_MEMORY;
  }

  /* Sine and cosine for rotation of corner fold region */
  sintheta = -(((radian*(262144-(radian*radian)/6))>>8) +
             (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
             radian)/42)*((11010048-radian*radian)>>10))>>21));
  costheta = (524288-radian*radian) +
             (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
             ((7864320-radian*radian)>>10))>>12);

  /* Initialize increment for getting corner patches */
  inc1 = (w - a)<<1;

  /* Get corner patch from 1st input image */
  outIndex = 0;
  if (position == 0) {
    /* Upper left corner */
    inIndex = 0;
  } else if (position == 1) {
    /* Upper right corner */
    inIndex = (w-a)<<1;
  } else if (position == 2) {
    /* Lower left corner */
    inIndex = ((h-b)*w)<<1;
  } else {
    /* Lower right corner */
    inIndex = ((h-b)*w + w-a)<<1;
  }
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x++) {
      *((unsigned char*)(cin1ImgPtr+outIndex++)) =
        *((unsigned char*)(in1ImgPtr+inIndex++));
      *((unsigned char*)(cin1ImgPtr+outIndex++)) =
        *((unsigned char*)(in1ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
  } /* end y loop */

  /* Get corner patch from 2nd input image */
  outIndex = 0;
  if (position == 0) {
    /* Upper left corner */
    inIndex = 0;
  } else if (position == 1) {
    /* Upper right corner */
    inIndex = (w-a)<<1;
  } else if (position == 2) {
    /* Lower left corner */
    inIndex = ((h-b)*w)<<1;
  } else {
    /* Lower right corner */
    inIndex = ((h-b)*w + w-a)<<1;
  }
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x++) {
      *((unsigned char*)(cin2ImgPtr+outIndex++)) =
        *((unsigned char*)(in2ImgPtr+inIndex++));
      *((unsigned char*)(cin2ImgPtr+outIndex++)) =
        *((unsigned char*)(in2ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
  } /* end y loop */

  /* Flip corner patches if needed */
  if (position != 0) {
    /* Malloc temporary buffer for storing flipped corner patch */
    tImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
    if (!tImgPtr)
    {
      MSG_LOW("ipl_corner_fold_ycbcr marker_206\n");
      ipl_sys_free(cImgPtr);
      ipl_sys_free(cin1ImgPtr);
      ipl_sys_free(cin2ImgPtr);
      ipl_sys_free(fImgPtr);
      ipl_sys_free(ffImgPtr);
      return IPL_NO_MEMORY;
    }

    /* Flip 1st corner patch */
    flag = 0;  /* corner patch is not in temporary buffer */
    if (fliphorz == 1) {
      /* Horizontal flip */
      inIndex = 0;
      outIndex = (a-2)<<1;
      inc1 = a<<2;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x+=2) {
          *((unsigned char*)(tImgPtr+outIndex)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+3)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+2)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+1)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          outIndex -= 4;
        }
        outIndex += inc1;
      }
      /* Reset flag */
      flag = 1;
    } /* end if fliphorz */
    if (flipvert == 1) {
      /* Vertical flip */
      inIndex = 0;
      outIndex = ((b-1)*a)<<1;
      inc1 = a<<2;
      if (flag == 0) {
        /* Corner patch is not in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin1ImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin1ImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 1;
      } else {
        /* Corner patch is in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(cin1ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cin1ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 0;
      } /* end if flag */
    } /* end if flipvert */
    if (flag == 1) {
      /* Corner patch is in temporary buffer */
      outIndex = 0;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(cin1ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cin1ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
        } /* end x loop */
      } /* end y loop */
    }

    /* Flip 2nd corner patch */
    flag = 0;  /* corner patch is not in temporary buffer */
    if (fliphorz == 1) {
      /* Horizontal flip */
      inIndex = 0;
      outIndex = (a-2)<<1;
      inc1 = a<<2;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x+=2) {
          *((unsigned char*)(tImgPtr+outIndex)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+3)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+2)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+1)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          outIndex -= 4;
        }
        outIndex += inc1;
      }
      /* Reset flag */
      flag = 1;
    } /* end if fliphorz */
    if (flipvert == 1) {
      /* Vertical flip */
      inIndex = 0;
      outIndex = ((b-1)*a)<<1;
      inc1 = a<<2;
      if (flag == 0) {
        /* Corner patch is not in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin2ImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin2ImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 1;
      } else {
        /* Corner patch is in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(cin2ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cin2ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 0;
      } /* end if flag */
    } /* end if flipvert */
    if (flag == 1) {
      /* Corner patch is in temporary buffer */
      outIndex = 0;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(cin2ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cin2ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
        } /* end x loop */
      } /* end y loop */
    }

    /* Free memory */
    ipl_sys_free(tImgPtr);
  } /* end if position */

  MSG_LOW("ipl_corner_fold_ycbcr marker_2\n");

  /* Get pixel value in blank image */
  memset(fImgPtr, 0, wwc*hhc*2);
  val = 0;
  val2 = 0;
  /* Copy corner fold region from 1st corner patch */
  /* (1) bottom part */
  a = wwc - params[4];
  if (a%2) a++;
  b = params[9];
  inIndex = 0;
  outIndex = ((hhc-b-1)*wwc + params[4]-1)<<1;
  inc1 = (params[0] - a)<<1;
  inc2 = -((wwc + a)<<1);
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x+=2) {
      *((unsigned char*)(fImgPtr+outIndex)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+1)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+2)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+3)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      outIndex += 4;
    } /* end x loop */
    inIndex += inc1;
    outIndex += inc2;
  } /* end y loop */
  /* (2) middle part */
  yo = params[9];
  a = params[2];
  if (a%2) a++;
  b = params[3];
  inc1 = (params[0] - a)<<1;
  inc2 = -((wwc + a)<<1);
  inIndex = (yo * params[0])<<1;
  outIndex = ((hhc-(yo<<1)-1)*wwc + params[4]-1)<<1;
  for (y = yo; y < b; y++) {
    for (x = 0; x < a; x+=2) {
      *((unsigned char*)(fImgPtr+outIndex)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+1)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+2)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+3)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      outIndex += 4;
    } /* end x loop */
    inIndex += inc1;
    outIndex += inc2;
  } /* end y loop */
  /* (3) top part */
  yo = params[3];
  a = params[12];
  if (a%2) a++;
  b = hhc - params[9];
  inc1 = (params[0] - a)<<1;
  inc2 = -((wwc + a)<<1);
  inIndex = (yo * params[0])<<1;
  outIndex = ((params[5]-1)*wwc + params[4]-1)<<1;
  for (y = yo; y < b; y++) {
    for (x = 0; x < a; x+=2) {
      *((unsigned char*)(fImgPtr+outIndex)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+1)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+2)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex+3)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      outIndex += 4;
    } /* end x loop */
    inIndex += inc1;
    outIndex += inc2;
  } /* end y loop */

  /* Create full YCbCr corner fold region for shifting and rotation */
  outIndex = 0;
  inIndex = 0;
  for (y = 0; y < hhc; y++) {
    for (x = 0; x < wwc; x+=2) {
      cb = *((unsigned char*)(fImgPtr+inIndex++));
      luma1 = *((unsigned char*)(fImgPtr+inIndex++));
      cr = *((unsigned char*)(fImgPtr+inIndex++));
      luma2 = *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) = cb;
      *((unsigned char*)(ffImgPtr+outIndex++)) = cr;
      *((unsigned char*)(ffImgPtr+outIndex++)) = luma1;
      *((unsigned char*)(ffImgPtr+outIndex++)) = cb;
      *((unsigned char*)(ffImgPtr+outIndex++)) = cr;
      *((unsigned char*)(ffImgPtr+outIndex++)) = luma2;
    } /* end x loop */
  } /* end y loop */

  /* Shift corner fold region to fit shape of corner fold */
  /* Segment on the right */
  b = slopes[0];
  c = params[9];
  inc1 = wwc*3;
  for (x = wwc-params[7]-2*params[8]; x < wwc; x++) {
    a = ((b*(x-wwc))>>8)+c;
    outIndex = ((hhc-c-1+a)*wwc+x)*3;
    inIndex = outIndex-(a*wwc)*3;
    for (y = 0; y <= c; y++) {
      *((unsigned char*)(ffImgPtr+outIndex)) =
        *((unsigned char*)(ffImgPtr+inIndex));
      *((unsigned char*)(ffImgPtr+outIndex+1)) =
        *((unsigned char*)(ffImgPtr+inIndex+1));
      *((unsigned char*)(ffImgPtr+outIndex+2)) =
        *((unsigned char*)(ffImgPtr+inIndex+2));
      outIndex -= inc1;
      inIndex -= inc1;
    } /* end y loop */
  } /* end x loop */
  /* 1st segment on the left */
  xo = params[4];
  yo = hhc - params[9] - 1;
  b = params[13];
  c = slopes[1];
  inc1 = params[5];
  for (y = inc1-1; y < yo; y++) {
    a = b-((c*(y-inc1+1))>>8);
    outIndex = (y*wwc+(xo-a))*3;
    inIndex = outIndex+a*3;
    for (x = 0; x < b; x++) {
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
    }
  }
  /* 2nd segment on the left */
  xo = params[13] + params[14];
  yo = params[6];
  b = slopes[2];
  c = params[12];
  inc1 = params[4];
  inc2 = params[5];
  for (y = yo; y < inc2; y++) {
    a = xo-((b*(y-yo+1))>>8);
    outIndex = (y*wwc+(inc1-a))*3;
    inIndex = outIndex+a*3;
    for (x = 0; x < c; x++) {
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
    }
  }
  /* 3rd segment on the left */
  xo = params[13] + params[14] + params[15];
  yo = params[6];
  b = slopes[3];
  c = params[12];
  inc1 = params[4];
  for (y = 0; y < yo; y++) {
    a = xo-((b*y)>>8);
    outIndex = (y*wwc+(inc1-a))*3;
    inIndex = outIndex+(a*3);
    for (x = 0; x < c; x++) {
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
      *((unsigned char*)(ffImgPtr+outIndex++)) =
        *((unsigned char*)(ffImgPtr+inIndex++));
    }
  }

  /* Rotate and copy corner fold onto corner template */
  outIndex = 0;
  xo = params[4];
  yo = hhc - params[9] - 1;
  a = params[0];
  b = params[1];
  xoo = params[10];
  yoo = params[11];
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x++) {
      if (*((unsigned char*)(cImgPtr+outIndex)) == pvc &&
        *((unsigned char*)(cImgPtr+outIndex+1)) == pvc2) {
        xin = xo+(((x-xoo)*costheta+(y-yoo)*sintheta)>>19);
        yin = yo+(((xoo-x)*sintheta+(y-yoo)*costheta)>>19);
        if (xin >= 0 && xin < wwc && yin >= 0 && yin < hhc) {
          inIndex = (xin + yin*wwc)*3;
          cval = *((unsigned char*)(ffImgPtr+inIndex));
          cval2 = *((unsigned char*)(ffImgPtr+inIndex+1));
          cval3 = *((unsigned char*)(ffImgPtr+inIndex+2));
          if (cval != val && cval2 != val && cval3 != val2) {
            if (x%2) {
              /* get Cr */
              *((unsigned char*)(cImgPtr+outIndex)) =
                (unsigned char)((cval2+0x80)>>1);
              *((unsigned char*)(cImgPtr+outIndex+1)) =
                (unsigned char)((cval3+0xEB)>>1);
            } else {
              /* get Cb */
              *((unsigned char*)(cImgPtr+outIndex)) =
                (unsigned char)((cval+0x80)>>1);
              *((unsigned char*)(cImgPtr+outIndex+1)) =
                (unsigned char)((cval3+0xEB)>>1);
            }
          } /* end if cval */
        } /* end if xin, yin */
      } /* end if pvc */
      outIndex += 2;
    } /* end x loop */
  } /* end y loop */

  /* Copy corner patches to corner template */
  if (position < 2) {
    /* Upper left or right corner */
    c = (b-1)*a;
    inc1 = a<<1;

    /* Copy 1st corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = (x+c)<<1;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv1 ||
          *((unsigned char*)(cImgPtr+outIndex+1)) != pv12) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin1ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin1ImgPtr+outIndex+1));
        outIndex -= inc1;
      } /* end x loop */
    } /* end y loop */

    /* Copy 2nd corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = x<<1;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv2 ||
          *((unsigned char*)(cImgPtr+outIndex+1)) != pv22) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin2ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin2ImgPtr+outIndex+1));
        outIndex += inc1;
      } /* end x loop */
    } /* end y loop */
  } else {
    /* Lower left or right corner */
    c = (b-1)*a;
    inc1 = a<<1;

    /* Copy 1st corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = (x+c)<<1;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv1 ||
          *((unsigned char*)(cImgPtr+outIndex+1)) != pv12) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin1ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin1ImgPtr+outIndex+1));
        outIndex -= inc1;
      } /* end x loop */
    } /* end y loop */

    /* Copy 2nd corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = x<<1;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv2 ||
          *((unsigned char*)(cImgPtr+outIndex+1)) != pv22) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin2ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin2ImgPtr+outIndex+1));
        outIndex += inc1;
      } /* end x loop */
    } /* end y loop */
  }

  /* Copy 1st input image to output */
  memset(outImgPtr, 0, w*h*2);
  outIndex = 0;
  for (y = 0; y < h; y++) {
    for (x = 0; x < w; x++) {
      *((unsigned char*)(outImgPtr+outIndex)) =
        *((unsigned char*)(in1ImgPtr+outIndex));
      outIndex++;
      *((unsigned char*)(outImgPtr+outIndex)) =
        *((unsigned char*)(in1ImgPtr+outIndex));
      outIndex++;
    } /* end x loop */
  } /* end y loop */

  /* Flip corner template if needed */
  if (position != 0) {
    /* Malloc temporary buffer for storing flipped corner template */
    tImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
    if (!tImgPtr) {
      MSG_LOW("ipl_corner_fold_ycbcr marker_207\n");
      return IPL_NO_MEMORY;
    }

    /* Flip corner template */
    flag = 0;  /* corner template is not in temporary buffer */
    if (fliphorz == 1) {
      /* Horizontal flip */
      inIndex = 0;
      outIndex = (a-2)<<1;
      inc1 = a<<2;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x+=2) {
          *((unsigned char*)(tImgPtr+outIndex)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+3)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+2)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+1)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          outIndex -= 4;
        }
        outIndex += inc1;
      }
      /* Reset flag */
      flag = 1;
    } /* end if fliphorz */
    if (flipvert == 1) {
      /* Vertical flip */
      inIndex = 0;
      outIndex = ((b-1)*a)<<1;
      inc1 = a<<2;
      if (flag == 0) {
        /* Corner template is not in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 1;
      } else {
        /* Corner template is in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(cImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 0;
      } /* end if flag */
    } /* end if flipvert */
    if (flag == 1) {
      /* Corner template is in temporary buffer */
      outIndex = 0;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(cImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
        } /* end x loop */
      } /* end y loop */
    }

    /* Free memory */
    ipl_sys_free(tImgPtr);
  } /* end if position */

  if (position == 0) {
    /* Upper left corner */
    outIndex = 0;
  } else if (position == 1) {
    /* Upper right corner */
    outIndex = (w-a)<<1;
  } else if (position == 2) {
    /* Lower left corner */
    outIndex = ((h-b)*w)<<1;
  } else {
    /* Lower right corner */
    outIndex = ((h-b)*w + w-a)<<1;
  }

  /* Copy corner template to output image */
  inIndex = 0;
  a = params[0];
  b = params[1];
  inc1 = (w - params[0])<<1;
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x++) {
      *((unsigned char*)(outImgPtr+outIndex)) =
        *((unsigned char*)(cImgPtr+inIndex++));
      *((unsigned char*)(outImgPtr+outIndex+1)) =
        *((unsigned char*)(cImgPtr+inIndex++));
      outIndex += 2;
    } /* end x loop */
    outIndex += inc1;
  } /* end y loop */

  /* Free memory */
  ipl_sys_free(cImgPtr);
  ipl_sys_free(cin1ImgPtr);
  ipl_sys_free(cin2ImgPtr);
  ipl_sys_free(fImgPtr);
  ipl_sys_free(ffImgPtr);

  MSG_LOW("ipl_corner_fold_ycbcr marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_corner_fold_ycbcr */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_corner_fold_420lp

DESCRIPTION
  This function folds over a corner of the image. The folded corner can
  be the upper left (0), upper right (1), lower left (2), or lower
  right (3) corner. The first input image is the image whose corner is
  folded. The second input image is behind the first input image and
  will be partially revealed by the folded corner.

  Input and output image sizes must be equal.
  Input and output must be in YCbCr 4:2:0 line packed or YCrCb 4:2:0 line
  packed format.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr   points to the first input image
  in2_img_ptr   points to the second input image
  o_img_ptr     points to the output image
  position      position of the corner fold

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_corner_fold_420lp
(
  ipl_image_type* in1_img_ptr,    /* Points to the first input image  */
  ipl_image_type* in2_img_ptr,    /* Points to the second input image */
  ipl_image_type* out_img_ptr,    /* Points to the output image       */
  uint8 position                  /* Position of corner fold          */
)
{
  unsigned char *in1ImgPtr, *in2ImgPtr, *outImgPtr,
                *in1ClrPtr, *in2ClrPtr, *outClrPtr,
                *in12ImgPtr, *in22ImgPtr, *out2ImgPtr;
  unsigned char *cImgPtr, *c2ImgPtr, *cOrig2ImgPtr,
                *cin1ImgPtr, *cin2ImgPtr, *cin12ImgPtr, *cin22ImgPtr,
                *fImgPtr, *tImgPtr, *cfullOrigImgPtr, *cfullOrig2ImgPtr,
                *cOrigClrPtr;
  uint8 *cOrigImgPtr = (uint8*)corner_ycbcr420lp_420x216;
  uint32 inIndex, inIndex2, outIndex, outIndex2, clrIndex, cSize;
  int32 w, h, x, y, xin, yin, xo, yo, xoo, yoo, a, b, c, wwc, hhc,
        inc1, inc2, sintheta, costheta, cRatio, paramRatio;
  uint8 fliphorz = 0, flipvert = 0, flag;
  unsigned char cval, cval2, cval3, val, val2, val3, cb, cr;
  /* Corner image parameters */
  int32 numParams = 16;
  int32 params[16] = {0};
  int32 paramsOrig[] = {420, 216, 274, 96, 39, 25, 10, 37, 25,
                        15, 115, 215, 61, 8, 13, 18};
  int32 radian = 382; /* Q9 */
  int32 slopes[] = {35, 17, 192, 43};  /* Q8 */
  /* Pixel values in corner template image */
  unsigned char pv1 = 0x80, pv12 = 0x10;  /* input 1 */
  unsigned char pv2 = 0x80, pv22 = 0x65;  /* input 2 */
  unsigned char pvc = 0x80, pvc2 = 0xBB;  /* corner fold */


  MSG_LOW("ipl_corner_fold_420lp marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_corner_fold_420lp marker_200\n");
    return IPL_FAILURE;
  }
  /* Initialize image pointers and local variables */
  in1ImgPtr = in1_img_ptr->imgPtr;
  in1ClrPtr = in1_img_ptr->clrPtr;
  in2ImgPtr = in2_img_ptr->imgPtr;
  in2ClrPtr = in2_img_ptr->clrPtr;
  outImgPtr = out_img_ptr->imgPtr;
  outClrPtr = out_img_ptr->clrPtr;
	a = paramsOrig[0];
	b = paramsOrig[1];
	clrIndex = a * b;
	cSize = (clrIndex * 3) >> 1;
  cOrigClrPtr = (unsigned char*)(cOrigImgPtr+clrIndex);
  w = out_img_ptr->dx;
  h = out_img_ptr->dy;
  /* Determine if horizontal or vertical flips are needed */
  if (position == 1) {
    fliphorz = 1;
  } else if (position == 2) {
    flipvert = 1;
  } else if (position == 3) {
    fliphorz = 1;
    flipvert = 1;
  }

  /* Malloc full YCbCr original corner template */
  cfullOrigImgPtr = ipl_malloc((cSize<<1)*sizeof(unsigned char));
  if (!cfullOrigImgPtr)
  {
    MSG_LOW("ipl_corner_fold_420lp marker_201\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_corner_fold_420lp marker_1\n");

  /* Create full YCbCr original corner template */
  inIndex = 0;
  inIndex2 = 0;
  outIndex = 0;
  inc1 = a * 3;
  cOrig2ImgPtr = cOrigImgPtr + a;
  cfullOrig2ImgPtr = cfullOrigImgPtr + a*3;
  for (y = 0; y < b; y+=2) {
    for (x = 0; x < a; x+=2) {
      /* Process 4 pixels at a time */
      cb = *((unsigned char*)(cOrigClrPtr+inIndex2++));
      cr = *((unsigned char*)(cOrigClrPtr+inIndex2++));
      /* 1st pixel */
      *((unsigned char*)(cfullOrigImgPtr+outIndex)) = cb;
      *((unsigned char*)(cfullOrigImgPtr+outIndex+1)) = cr;
      *((unsigned char*)(cfullOrigImgPtr+outIndex+2)) =
        *((unsigned char*)(cOrigImgPtr+inIndex));
      /* 2nd pixel */
      *((unsigned char*)(cfullOrigImgPtr+outIndex+3)) = cb;
      *((unsigned char*)(cfullOrigImgPtr+outIndex+4)) = cr;
      *((unsigned char*)(cfullOrigImgPtr+outIndex+5)) =
        *((unsigned char*)(cOrigImgPtr+inIndex+1));
      /* 3rd pixel */
      *((unsigned char*)(cfullOrig2ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(cfullOrig2ImgPtr+outIndex++)) = cr;
      *((unsigned char*)(cfullOrig2ImgPtr+outIndex++)) =
        *((unsigned char*)(cOrig2ImgPtr+inIndex++));
      /* 4th pixel */
      *((unsigned char*)(cfullOrig2ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(cfullOrig2ImgPtr+outIndex++)) = cr;
      *((unsigned char*)(cfullOrig2ImgPtr+outIndex++)) =
        *((unsigned char*)(cOrig2ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += a;
    outIndex += inc1;
  } /* end y loop */

  /* Adjust corner template size according to input aspect ratio */
  if ((520*h) < (390*w)) {
    /* Case 1: width is too big, use height to adjust size */
    a = (h*288)/520;
    params[0] = (420*a)/216;
    params[1] = a;
    cRatio = (a<<10)/216;
  } else {
    /* Case 2: height is too big, use width to adjust size */
    a = (w*315)/390;
    params[0] = a;
    params[1] = (216*a)/420;
    cRatio = (a<<10)/420;
  }

  /* New corner template size */
  if (params[0]%2) params[0]--;
  if (params[1]%2) params[1]--;
  a = params[0];
  b = params[1];
  clrIndex = a * b;
  cSize = clrIndex * 3;

  /* New corner fold parameters */
  paramRatio = (params[0]<<10) / paramsOrig[0];
  for (c = 2; c < numParams; c++) {
    params[c] = (paramRatio * paramsOrig[c]) >> 10;
  }

  /* Malloc resized full YCbCr corner template */
  cImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
  if (!cImgPtr)
  {
    MSG_LOW("ipl_corner_fold_420lp marker_202\n");
    ipl_sys_free(cfullOrigImgPtr);
    return IPL_NO_MEMORY;
  }
  memset(cImgPtr, 0, cSize);

  /* Fill in resized corner template using original full YCbCr template */
  /* Corner fold area */
  xo = paramsOrig[0];
  yo = paramsOrig[1];
  inIndex = 0;
  for (yin = 0; yin < yo; yin++) {
    for (xin = 0; xin < xo; xin++) {
      if (*((unsigned char*)(cfullOrigImgPtr+inIndex)) == pvc &&
        *((unsigned char*)(cfullOrigImgPtr+inIndex+1)) == pvc &&
        *((unsigned char*)(cfullOrigImgPtr+inIndex+2)) == pvc2)
      {
        x = (cRatio * xin) >> 10;
        y = (cRatio * yin) >> 10;
        outIndex = (x+y*a)*3;
        *((unsigned char*)(cImgPtr+outIndex++)) = pvc;
        *((unsigned char*)(cImgPtr+outIndex++)) = pvc;
        *((unsigned char*)(cImgPtr+outIndex)) = pvc2;
      }
      inIndex += 3;
    } /* end xin loop */
  } /* end yin loop */
  /* Area where input 1 will be */
  c = (b-1)*a;
  inc1 = a*3;
  for (x = 0; x < a; x++) {
    outIndex = (x+c)*3;
    for (y = 0; y < b; y++) {
      if (*((unsigned char*)(cImgPtr+outIndex)) == pvc &&
        *((unsigned char*)(cImgPtr+outIndex+2)) == pvc2) {
        break;
      }
      *((unsigned char*)(cImgPtr+outIndex)) = pv1;
      *((unsigned char*)(cImgPtr+outIndex+1)) = pv1;
      *((unsigned char*)(cImgPtr+outIndex+2)) = pv12;
      outIndex -= inc1;
    } /* end x loop */
  } /* end y loop */
  /* Area where input 2 will be */
  for (x = 0; x < a; x++) {
    outIndex = x*3;
    for (y = 0; y < b; y++) {
      if (*((unsigned char*)(cImgPtr+outIndex)) == pvc &&
        *((unsigned char*)(cImgPtr+outIndex+2)) == pvc2) {
        break;
      }
      *((unsigned char*)(cImgPtr+outIndex)) = pv2;
      *((unsigned char*)(cImgPtr+outIndex+1)) = pv2;
      *((unsigned char*)(cImgPtr+outIndex+2)) = pv22;
      outIndex += inc1;
    } /* end x loop */
  } /* end y loop */

  /* Malloc buffers for corner patches from input images */
  cin1ImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
  if (!cin1ImgPtr)
  {
    MSG_LOW("ipl_corner_fold_420lp marker_202\n");
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cfullOrigImgPtr);
    return IPL_NO_MEMORY;
  }
  cin2ImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
  if (!cin2ImgPtr)
  {
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    ipl_sys_free(cfullOrigImgPtr);
    MSG_LOW("ipl_corner_fold_420lp marker_203\n");
    return IPL_NO_MEMORY;
  }

  /* Malloc buffer for full YCbCr corner fold region */
  wwc = params[2] + params[7] + params[12] + params[13];
  hhc = params[3] + params[5] + params[9];
  fImgPtr = ipl_malloc(wwc*hhc*3*sizeof(unsigned char));
  if (!fImgPtr)
  {
    ipl_sys_free(cImgPtr);
    ipl_sys_free(cin1ImgPtr);
    ipl_sys_free(cin2ImgPtr);
    ipl_sys_free(cfullOrigImgPtr);
    MSG_LOW("ipl_corner_fold_420lp marker_204\n");
    return IPL_NO_MEMORY;
  }

  /* Sine and cosine for rotation of corner fold region */
  sintheta = -(((radian*(262144-(radian*radian)/6))>>8) +
             (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
             radian)/42)*((11010048-radian*radian)>>10))>>21));
  costheta = (524288-radian*radian) +
             (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
             ((7864320-radian*radian)>>10))>>12);

  /* Initialize increment for getting corner patches */
  inc1 = (w<<1)-a;
  inc2 = a*3;
  c = w-a;

  /* Get full YCbCr corner patch from 1st input image */
  if (position == 0) {
    /* Upper left corner */
    inIndex = 0;
    inIndex2 = 0;
  } else if (position == 1) {
    /* Upper right corner */
    inIndex = w-a;
    inIndex2 = inIndex;
  } else if (position == 2) {
    /* Lower left corner */
    inIndex = (h-b)*w;
    inIndex2 = inIndex >> 1;
  } else {
    /* Lower right corner */
    inIndex = (h-b)*w + w-a;
    inIndex2 = (((h-b)*w)>>1) + w-a;
  }
  outIndex = 0;
  in12ImgPtr = in1ImgPtr + w;
  cin12ImgPtr = cin1ImgPtr + a*3;

  for (y = 0; y < b; y+=2) {
    for (x = 0; x < a; x+=2) {
      /* Process 4 pixels at a time */
      cb = *((unsigned char*)(in1ClrPtr+inIndex2++));
      cr = *((unsigned char*)(in1ClrPtr+inIndex2++));
      /* 1st pixel */
      *((unsigned char*)(cin1ImgPtr+outIndex)) = cb;
      *((unsigned char*)(cin1ImgPtr+outIndex+1)) = cr;
      *((unsigned char*)(cin1ImgPtr+outIndex+2)) =
        *((unsigned char*)(in1ImgPtr+inIndex));
      /* 2nd pixel */
      *((unsigned char*)(cin1ImgPtr+outIndex+3)) = cb;
      *((unsigned char*)(cin1ImgPtr+outIndex+4)) = cr;
      *((unsigned char*)(cin1ImgPtr+outIndex+5)) =
        *((unsigned char*)(in1ImgPtr+inIndex+1));
      /* 3rd pixel */
      *((unsigned char*)(cin12ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(cin12ImgPtr+outIndex++)) = cr;
      *((unsigned char*)(cin12ImgPtr+outIndex++)) =
        *((unsigned char*)(in12ImgPtr+inIndex++));
      /* 4th pixel */
      *((unsigned char*)(cin12ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(cin12ImgPtr+outIndex++)) = cr;
      *((unsigned char*)(cin12ImgPtr+outIndex++)) =
        *((unsigned char*)(in12ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
    inIndex2 += c;
    outIndex += inc2;
  } /* end y loop */

  /* Get corner patch from 2nd input image */
  outIndex = 0;
  if (position == 0) {
    /* Upper left corner */
    inIndex = 0;
    inIndex2 = 0;
  } else if (position == 1) {
    /* Upper right corner */
    inIndex = w-a;
    inIndex2 = inIndex;
  } else if (position == 2) {
    /* Lower left corner */
    inIndex = (h-b)*w;
    inIndex2 = inIndex >> 1;
  } else {
    /* Lower right corner */
    inIndex = (h-b)*w + w-a;
    inIndex2 = (((h-b)*w)>>1) + w-a;
  }
  in22ImgPtr = in2ImgPtr + w;
  cin22ImgPtr = cin2ImgPtr + a*3;
  for (y = 0; y < b; y+=2) {
    for (x = 0; x < a; x+=2) {
      /* Process 4 pixels at a time */
      cb = *((unsigned char*)(in2ClrPtr+inIndex2++));
      cr = *((unsigned char*)(in2ClrPtr+inIndex2++));
      /* 1st pixel */
      *((unsigned char*)(cin2ImgPtr+outIndex)) = cb;
      *((unsigned char*)(cin2ImgPtr+outIndex+1)) = cr;
      *((unsigned char*)(cin2ImgPtr+outIndex+2)) =
        *((unsigned char*)(in2ImgPtr+inIndex));
      /* 2nd pixel */
      *((unsigned char*)(cin2ImgPtr+outIndex+3)) = cb;
      *((unsigned char*)(cin2ImgPtr+outIndex+4)) = cr;
      *((unsigned char*)(cin2ImgPtr+outIndex+5)) =
        *((unsigned char*)(in2ImgPtr+inIndex+1));
      /* 3rd pixel */
      *((unsigned char*)(cin22ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(cin22ImgPtr+outIndex++)) = cr;
      *((unsigned char*)(cin22ImgPtr+outIndex++)) =
        *((unsigned char*)(in22ImgPtr+inIndex++));
      /* 4th pixel */
      *((unsigned char*)(cin22ImgPtr+outIndex++)) = cb;
      *((unsigned char*)(cin22ImgPtr+outIndex++)) = cr;
      *((unsigned char*)(cin22ImgPtr+outIndex++)) =
        *((unsigned char*)(in22ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
    inIndex2 += c;
    outIndex += inc2;
  } /* end y loop */

  /* Flip corner patches if needed */
  if (position != 0) {
    /* Malloc temporary buffer for storing flipped corner patch */
    tImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
    if (!tImgPtr)
    {
      ipl_sys_free(cImgPtr);
      ipl_sys_free(cin1ImgPtr);
      ipl_sys_free(cin2ImgPtr);
      ipl_sys_free(cfullOrigImgPtr);
      ipl_sys_free(fImgPtr);
      MSG_LOW("ipl_corner_fold_420lp marker_205\n");
      return IPL_NO_MEMORY;
    }

    /* Flip 1st corner patch */
    flag = 0;  /* corner patch is not in temporary buffer */
    if (fliphorz == 1) {
      /* Horizontal flip */
      inIndex = 0;
      outIndex = (a-1)*3;
      inc1 = a*6;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(tImgPtr+outIndex)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+1)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+2)) =
            *((unsigned char*)(cin1ImgPtr+inIndex++));
          outIndex -= 3;
        }
        outIndex += inc1;
      }
      /* Reset flag */
      flag = 1;
    } /* end if fliphorz */
    if (flipvert == 1) {
      /* Vertical flip */
      inIndex = 0;
      outIndex = (b-1)*a*3;
      inc1 = a*6;
      if (flag == 0) {
        /* Corner patch is not in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin1ImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin1ImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin1ImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 1;
      } else {
        /* Corner patch is in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(cin1ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cin1ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cin1ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 0;
      } /* end if flag */
    } /* end if flipvert */
    if (flag == 1) {
      /* Corner patch is in temporary buffer */
      outIndex = 0;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(cin1ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cin1ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cin1ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
        } /* end x loop */
      } /* end y loop */
    }

    /* Flip 2nd corner patch */
    flag = 0;  /* corner patch is not in temporary buffer */
    if (fliphorz == 1) {
      /* Horizontal flip */
      inIndex = 0;
      outIndex = (a-1)*3;
      inc1 = a*6;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(tImgPtr+outIndex)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+1)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+2)) =
            *((unsigned char*)(cin2ImgPtr+inIndex++));
          outIndex -= 3;
        }
        outIndex += inc1;
      }
      /* Reset flag */
      flag = 1;
    } /* end if fliphorz */
    if (flipvert == 1) {
      /* Vertical flip */
      inIndex = 0;
      outIndex = (b-1)*a*3;
      inc1 = a*6;
      if (flag == 0) {
        /* Corner patch is not in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin2ImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin2ImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cin2ImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 1;
      } else {
        /* Corner patch is in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(cin2ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cin2ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cin2ImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 0;
      } /* end if flag */
    } /* end if flipvert */
    if (flag == 1) {
      /* Corner patch is in temporary buffer */
      outIndex = 0;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(cin2ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cin2ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cin2ImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
        } /* end x loop */
      } /* end y loop */
    }

    /* Free memory */
    ipl_sys_free(tImgPtr);
  } /* end if position */

  MSG_LOW("ipl_corner_fold_420lp marker_2\n");

  /* Get pixel value in blank image */
  memset(fImgPtr, 0, wwc*hhc*3);
  val = 0;
  val2 = 0;
  val3 = 0;

  /* Copy corner fold region from 1st corner patch */
  /* (1) bottom part */
  c = params[4];
  a = wwc - c;
  b = params[9];
  inIndex = 0;
  outIndex = ((hhc-b-1)*wwc + c-1)*3;
  inc1 = (params[0] - a)*3;
  inc2 = (wwc + a)*3;
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x++) {
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
    outIndex -= inc2;
  } /* end y loop */
  /* (2) middle part */
  yo = params[9];
  a = params[2];
  b = params[3];
  inc1 = (params[0] - a)*3;
  inc2 = -((wwc + a)*3);
  inIndex = (yo * params[0])*3;
  outIndex = ((hhc-(yo<<1)-1)*wwc + params[4]-1)*3;
  for (y = yo; y < b; y++) {
    for (x = 0; x < a; x++) {
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
    outIndex += inc2;
  } /* end y loop */
  /* (3) top part */
  yo = params[3];
  a = params[12];
  b = hhc - params[9];
  inc1 = (params[0] - a)*3;
  inc2 = -((wwc + a)*3);
  inIndex = (yo * params[0])*3;
  outIndex = ((params[5]-1)*wwc + params[4]-1)*3;
  for (y = yo; y < b; y++) {
    for (x = 0; x < a; x++) {
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(cin1ImgPtr+inIndex++));
    } /* end x loop */
    inIndex += inc1;
    outIndex += inc2;
  } /* end y loop */

  /* Shift corner fold region to fit shape of corner fold */
  /* Segment on the right */
  b = slopes[0];
  c = params[9];
  inc1 = wwc*3;
  for (x = wwc-params[7]-2*params[8]; x < wwc; x++) {
    a = ((b*(x-wwc))>>8)+c;
    outIndex = ((hhc-c-1+a)*wwc+x)*3;
    inIndex = outIndex-(a*wwc)*3;
    for (y = 0; y <= c; y++) {
      *((unsigned char*)(fImgPtr+outIndex)) =
        *((unsigned char*)(fImgPtr+inIndex));
      *((unsigned char*)(fImgPtr+outIndex+1)) =
        *((unsigned char*)(fImgPtr+inIndex+1));
      *((unsigned char*)(fImgPtr+outIndex+2)) =
        *((unsigned char*)(fImgPtr+inIndex+2));
      outIndex -= inc1;
      inIndex -= inc1;
    } /* end y loop */
  } /* end x loop */
  /* 1st segment on the left */
  xo = params[4];
  yo = hhc - params[9] - 1;
  b = params[13];
  c = slopes[1];
  inc1 = params[5];
  for (y = inc1-1; y < yo; y++) {
    a = b-((c*(y-inc1+1))>>8);
    outIndex = (y*wwc+(xo-a))*3;
    inIndex = outIndex+a*3;
    for (x = 0; x < b; x++) {
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
    }
  }
  /* 2nd segment on the left */
  xo = params[13] + params[14];
  yo = params[6];
  b = slopes[2];
  c = params[12];
  inc1 = params[4];
  inc2 = params[5];
  for (y = yo; y < inc2; y++) {
    a = xo-((b*(y-yo+1))>>8);
    outIndex = (y*wwc+(inc1-a))*3;
    inIndex = outIndex+a*3;
    for (x = 0; x < c; x++) {
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
    }
  }
  /* 3rd segment on the left */
  xo = params[13] + params[14] + params[15];
  yo = params[6];
  b = slopes[3];
  c = params[12];
  inc1 = params[4];
  for (y = 0; y < yo; y++) {
    a = xo-((b*y)>>8);
    outIndex = (y*wwc+(inc1-a))*3;
    inIndex = outIndex+(a*3);
    for (x = 0; x < c; x++) {
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
      *((unsigned char*)(fImgPtr+outIndex++)) =
        *((unsigned char*)(fImgPtr+inIndex++));
    }
  }

  /* Rotate and copy corner fold onto corner template */
  outIndex = 0;
  xo = params[4];
  yo = hhc - params[9] - 1;
  a = params[0];
  b = params[1];
  xoo = params[10];
  yoo = params[11];
  for (y = 0; y < b; y++) {
    for (x = 0; x < a; x++) {
      if (*((unsigned char*)(cImgPtr+outIndex)) == pvc &&
        *((unsigned char*)(cImgPtr+outIndex+2)) == pvc2) {
        xin = xo+(((x-xoo)*costheta+(y-yoo)*sintheta)>>19);
        yin = yo+(((xoo-x)*sintheta+(y-yoo)*costheta)>>19);
        if (xin >= 0 && xin < wwc && yin >= 0 && yin < hhc) {
          inIndex = (xin + yin*wwc)*3;
          cval = *((unsigned char*)(fImgPtr+inIndex));
          cval2 = *((unsigned char*)(fImgPtr+inIndex+1));
          cval3 = *((unsigned char*)(fImgPtr+inIndex+2));
          if (cval != val && cval2 != val2 && cval3 != val3) {
            *((unsigned char*)(cImgPtr+outIndex)) =
              (unsigned char)((cval+0x80)>>1);
            *((unsigned char*)(cImgPtr+outIndex+1)) =
              (unsigned char)((cval2+0x80)>>1);
            *((unsigned char*)(cImgPtr+outIndex+2)) =
              (unsigned char)((cval3+0xEB)>>1);
          } /* end if cval */
        } /* end if xin, yin */
      } /* end if pvc */
      outIndex += 3;
    } /* end x loop */
  } /* end y loop */

  /* Copy corner patches to corner template */
  if (position < 2) {
    /* Upper left or right corner */
    c = (b-1)*a;
    inc1 = a*3;

    /* Copy 1st corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = (x+c)*3;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv1 ||
          *((unsigned char*)(cImgPtr+outIndex+2)) != pv12) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin1ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin1ImgPtr+outIndex+1));
        *((unsigned char*)(cImgPtr+outIndex+2)) =
          *((unsigned char*)(cin1ImgPtr+outIndex+2));
        outIndex -= inc1;
      } /* end x loop */
    } /* end y loop */

    /* Copy 2nd corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = x*3;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv2 ||
          *((unsigned char*)(cImgPtr+outIndex+2)) != pv22) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin2ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin2ImgPtr+outIndex+1));
        *((unsigned char*)(cImgPtr+outIndex+2)) =
          *((unsigned char*)(cin2ImgPtr+outIndex+2));
        outIndex += inc1;
      } /* end x loop */
    } /* end y loop */
  } else {
    /* Lower left or right corner */
    c = (b-1)*a;
    inc1 = a*3;

    /* Copy 1st corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = (x+c)*3;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv1 ||
          *((unsigned char*)(cImgPtr+outIndex+2)) != pv12) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin1ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin1ImgPtr+outIndex+1));
        *((unsigned char*)(cImgPtr+outIndex+2)) =
          *((unsigned char*)(cin1ImgPtr+outIndex+2));
        outIndex -= inc1;
      } /* end x loop */
    } /* end y loop */

    /* Copy 2nd corner patch to corner template */
    for (x = 0; x < a; x++) {
      outIndex = x*3;
      for (y = 0; y < b; y++) {
        if (*((unsigned char*)(cImgPtr+outIndex)) != pv2 ||
          *((unsigned char*)(cImgPtr+outIndex+2)) != pv22) {
          break;
        }
        *((unsigned char*)(cImgPtr+outIndex)) =
          *((unsigned char*)(cin2ImgPtr+outIndex));
        *((unsigned char*)(cImgPtr+outIndex+1)) =
          *((unsigned char*)(cin2ImgPtr+outIndex+1));
        *((unsigned char*)(cImgPtr+outIndex+2)) =
          *((unsigned char*)(cin2ImgPtr+outIndex+2));
        outIndex += inc1;
      } /* end x loop */
    } /* end y loop */
  }

  /* Copy 1st input image to output */
  memset(outImgPtr, 0, (w*h*3)>>1);
  outIndex = 0;
  for (y = 0; y < h; y++) {
    for (x = 0; x < w; x++) {
      *((unsigned char*)(outImgPtr+outIndex)) =
        *((unsigned char*)(in1ImgPtr+outIndex));
      outIndex++;
    } /* end x loop */
  } /* end y loop */
  outIndex = 0;
  for (y = 0; y < h; y+=2) {
    for (x = 0; x < w; x+=2) {
      *((unsigned char*)(outClrPtr+outIndex)) =
        *((unsigned char*)(in1ClrPtr+outIndex));
      outIndex++;
      *((unsigned char*)(outClrPtr+outIndex)) =
        *((unsigned char*)(in1ClrPtr+outIndex));
      outIndex++;
    } /* end x loop */
  } /* end y loop */

  /* Flip corner template if needed */
  if (position != 0) {
    /* Malloc temporary buffer for storing flipped corner template */
    tImgPtr = ipl_malloc(cSize*sizeof(unsigned char));
    if (!tImgPtr)
    {
      ipl_sys_free(cImgPtr);
      ipl_sys_free(cin1ImgPtr);
      ipl_sys_free(cin2ImgPtr);
      ipl_sys_free(cfullOrigImgPtr);
      ipl_sys_free(fImgPtr);
      MSG_LOW("ipl_corner_fold_420lp marker_206\n");
      return IPL_NO_MEMORY;
    }

    /* Flip corner template */
    flag = 0;  /* corner template is not in temporary buffer */
    if (fliphorz == 1) {
      /* Horizontal flip */
      inIndex = 0;
      outIndex = (a-1)*3;
      inc1 = a*6;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(tImgPtr+outIndex)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+1)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          *((unsigned char*)(tImgPtr+outIndex+2)) =
            *((unsigned char*)(cImgPtr+inIndex++));
          outIndex -= 3;
        }
        outIndex += inc1;
      }
      /* Reset flag */
      flag = 1;
    } /* end if fliphorz */
    if (flipvert == 1) {
      /* Vertical flip */
      inIndex = 0;
      outIndex = (b-1)*a*3;
      inc1 = a*6;
      if (flag == 0) {
        /* Corner template is not in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cImgPtr+inIndex++));
            *((unsigned char*)(tImgPtr+outIndex++)) =
              *((unsigned char*)(cImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 1;
      } else {
        /* Corner template is in temporary buffer */
        for (y = 0; y < b; y++) {
          for (x = 0; x < a; x++) {
            *((unsigned char*)(cImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
            *((unsigned char*)(cImgPtr+outIndex++)) =
              *((unsigned char*)(tImgPtr+inIndex++));
          }
          outIndex -= inc1;
        }
        /* Reset flag */
        flag = 0;
      } /* end if flag */
    } /* end if flipvert */
    if (flag == 1) {
      /* Corner template is in temporary buffer */
      outIndex = 0;
      for (y = 0; y < b; y++) {
        for (x = 0; x < a; x++) {
          *((unsigned char*)(cImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
          *((unsigned char*)(cImgPtr+outIndex)) =
            *((unsigned char*)(tImgPtr+outIndex));
          outIndex++;
        } /* end x loop */
      } /* end y loop */
    }

    /* Free memory */
    ipl_sys_free(tImgPtr);
  } /* end if position */

  if (position == 0) {
    /* Upper left corner */
    outIndex = 0;
    outIndex2 = 0;
  } else if (position == 1) {
    /* Upper right corner */
    outIndex = w-a;
    outIndex2 = outIndex;
  } else if (position == 2) {
    /* Lower left corner */
    outIndex = (h-b)*w;
    outIndex2 = outIndex >> 1;
  } else {
    /* Lower right corner */
    outIndex = (h-b)*w + w-a;
    outIndex2 = (((h-b)*w)>>1) + w-a;
  }

  /* Copy corner template to output image */
  inIndex = 0;
  inc1 = (w<<1)-a;
  inc2 = w-a;
  c = a*3;
  out2ImgPtr = outImgPtr + w;
  c2ImgPtr = cImgPtr + a*3;
  for (y = 0; y < b; y+=2) {
    for (x = 0; x < a; x+=2) {
      /* Process 4 pixels at a time */
      /* 1st pixel */
      *((unsigned char*)(outImgPtr+outIndex)) =
        *((unsigned char*)(cImgPtr+inIndex+2));
      /* 2nd pixel */
      *((unsigned char*)(outImgPtr+outIndex+1)) =
        *((unsigned char*)(cImgPtr+inIndex+5));
      /* 3rd pixel */
      inIndex+=2;
      *((unsigned char*)(out2ImgPtr+outIndex++)) =
        *((unsigned char*)(c2ImgPtr+inIndex++));
      /* CbCr */
      *((unsigned char*)(outClrPtr+outIndex2++)) =
        *((unsigned char*)(c2ImgPtr+inIndex++));
      *((unsigned char*)(outClrPtr+outIndex2++)) =
        *((unsigned char*)(c2ImgPtr+inIndex++));
      /* 4th pixel */
      *((unsigned char*)(out2ImgPtr+outIndex++)) =
        *((unsigned char*)(c2ImgPtr+inIndex++));
    } /* end x loop */
    outIndex += inc1;
    outIndex2 += inc2;
    inIndex += c;
  } /* end y loop */

  /* Free memory */
  ipl_sys_free(cImgPtr);
  ipl_sys_free(fImgPtr);
  ipl_sys_free(cin1ImgPtr);
  ipl_sys_free(cin2ImgPtr);
  ipl_sys_free(cOrigImgPtr);
  ipl_sys_free(cfullOrigImgPtr);

  MSG_LOW("ipl_corner_fold_420lp marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_corner_fold_ycbcr420lp */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_corner_fold

DESCRIPTION
  This function folds over a corner of the image. The folded corner can
  be the upper left (0), upper right (1), lower left (2), or lower
  right (3) corner. The first input image is the image whose corner is
  folded. The second input image is behind the first input image and
  will be partially revealed by the folded corner.

  Input and output image sizes must be equal.

  Input and output must have the same color format, which can be
  RGB565, YCbCr 4:2:2, YCbCr 4:2:0 line packed, or YCrCb 4:2:0 line
  packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in1_img_ptr   points to the first input image
  in2_img_ptr   points to the second input image
  o_img_ptr     points to the output image
  position      position of the corner fold

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_corner_fold
(
  ipl_image_type* in1_img_ptr,  /* Points to the first input image  */
  ipl_image_type* in2_img_ptr,  /* Points to the second input image */
  ipl_image_type* out_img_ptr,  /* Points to the output image       */
  uint8 position                /* Position of corner fold          */
)
{
  MSG_LOW("ipl_corner_fold marker_0\n");

  if (!in1_img_ptr || !in1_img_ptr->imgPtr ||
      !in2_img_ptr || !in2_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_corner_fold marker_200\n");
    return IPL_FAILURE;
  }
  /* Input and output color formats must be the same */
  if (in1_img_ptr->cFormat != in2_img_ptr->cFormat ||
      in1_img_ptr->cFormat != out_img_ptr->cFormat) {
    MSG_LOW("ipl_corner_fold marker_201\n");
    return IPL_FAILURE;
  }
  /* Input and output image sizes must be equal */
  if (in1_img_ptr->dx != in2_img_ptr->dx ||
      in1_img_ptr->dy != in2_img_ptr->dy ||
      in1_img_ptr->dx != out_img_ptr->dx ||
      in1_img_ptr->dy != out_img_ptr->dy) {
    MSG_LOW("ipl_corner_fold marker_202\n");
    return IPL_FAILURE;
  }
  /*
  ** Position can only be 0 (upper left), 1 (upper right),
  ** 2 (lower left), or 3 (lower right)
  */
  if (position > 3) {
    MSG_LOW("ipl_corner_fold marker_203\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_corner_fold marker_1\n");

  /* Call the appropriate function */
  if (in1_img_ptr->cFormat == IPL_RGB565) {
    if (ipl_corner_fold_rgb565( \
        in1_img_ptr, in2_img_ptr,
        out_img_ptr, position) != IPL_SUCCESS) {
      MSG_LOW("ipl_corner_fold marker_204\n");
      return IPL_FAILURE;
    }
  } else if (in1_img_ptr->cFormat == IPL_YCbCr) {
    if (ipl_corner_fold_ycbcr( \
        in1_img_ptr, in2_img_ptr,
        out_img_ptr, position) != IPL_SUCCESS) {
      MSG_LOW("ipl_corner_fold marker_205\n");
      return IPL_FAILURE;
    }
  } else if (in1_img_ptr->cFormat == IPL_YCbCr420_LINE_PK ||
             in1_img_ptr->cFormat == IPL_YCrCb420_LINE_PK) {
    if (ipl_corner_fold_420lp( \
        in1_img_ptr, in2_img_ptr,
        out_img_ptr, position) != IPL_SUCCESS) {
      MSG_LOW("ipl_corner_fold marker_206\n");
      return IPL_FAILURE;
    }
  } else {
    MSG_LOW("ipl_corner_fold marker_207\n");
    /* No other color formats supported */
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_corner_fold marker_100\n");

  return IPL_SUCCESS;
} /* End ipl_corner_fold */


#endif // #if FEATURE_IPL_FUNC_CORNER_FOLD




#if 0

/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fog_rgb565

DESCRIPTION
  This function creates a foggy image.  The user specifies the level of
  fogginess, either light (0) or heavy (1).

  Input and output images must be in RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  level         fog level, either light (0) or heavy (1)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_fog_rgb565
(
  ipl_image_type* in_img_ptr,    /* Points to the input image   */
  ipl_image_type* out_img_ptr,   /* Points to the output image  */
  uint8 level                    /* Level of fogginess          */
)
{
  uint16 *inImgPtr, *outImgPtr, *fogImgPtr;
  uint32 index, xfactor, yfactor, a, b, w, h, x, y, yin, out;
  uint8 r1, g1, b1, r2, g2, b2, rout, gout, bout;
  uint32 *xmap;

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
    return IPL_FAILURE;

  /* Initialize the image pointers and local variables */
  inImgPtr = (uint16*)in_img_ptr->imgPtr;
  outImgPtr = (uint16*)out_img_ptr->imgPtr;
  w = out_img_ptr->dx;
  h = out_img_ptr->dy;
  if (level == 0) {
    /* light fog */
    a = 64;
    b = 64;
  } else {
    /* heavy fog */
    a = 19;
    b = 109;
  }

  /* Get foggy output */
  if (w != 176 || h != 144)
  {
    /* Resize fog if image is not qcif */
    fogImgPtr = ipl_malloc(w*h*sizeof(uint16));
    if (!fogImgPtr)
    {
      return IPL_NO_MEMORY;
    }

    xmap = ipl_malloc(w*sizeof(uint32));
    if (!xmap)
    {
      ipl_sys_free(fogImgPtr);
      return IPL_NO_MEMORY;
    }

    /* Resize factors */
    xfactor = 180224/w;
    yfactor = 147456/h;
    /* Map x-coordinate in resized image to x-coordinate in input */
    xmap[0] = 0;
    for (x = 1; x < w; x++) {
      xmap[x] = (x*xfactor)>>10;
    }
    index = 0;
    for (y = 0; y < h; y++) {
      yin = ((yfactor*y)>>10)*176;
      for (x = 0; x < w; x++) {
        *((uint16*)(fogImgPtr+index++)) = fog_rgb_176x144[yin+xmap[x]];
      } /* end x loop */
    } /* end y loop */

    /* Loop through input */
    index = 0;
    for(y = 0; y < h; y++) {
      for(x = 0; x < w; x++) {
        /* unpack input rgb values */
        out = *inImgPtr++;
        r1 = (uint8)((out & 0xF800)>>8);
        g1 = (uint8)((out & 0x07E0)>>3);
        b1 = (uint8)((out & 0x001F)<<3);
        out = *((uint16*)(fogImgPtr+index++));
        r2 = (uint8)((out & 0xF800)>>8);
        g2 = (uint8)((out & 0x07E0)>>3);
        b2 = (uint8)((out & 0x001F)<<3);
        /* find output rgb values */
        rout = (uint8)((r1*a+r2*b)>>7);
        gout = (uint8)((g1*a+g2*b)>>7);
        bout = (uint8)((b1*a+b2*b)>>7);
        *outImgPtr++ = pack_rgb565(rout, gout, bout);
      } /* end x loop */
    } /* end y loop */

    ipl_sys_free(fogImgPtr);
    ipl_sys_free(xmap);
  }
  else
  {
    /* Loop through input */
    index = 0;
    for(y = 0; y < h; y++) {
      for(x = 0; x < w; x++) {
        /* unpack input rgb values */
        out = *inImgPtr++;
        r1 = (uint8)((out & 0xF800)>>8);
        g1 = (uint8)((out & 0x07E0)>>3);
        b1 = (uint8)((out & 0x001F)<<3);
        out = fog_rgb_176x144[index++];
        r2 = (uint8)((out & 0xF800)>>8);
        g2 = (uint8)((out & 0x07E0)>>3);
        b2 = (uint8)((out & 0x001F)<<3);
        /* find output rgb values */
        rout = (uint8)((r1*a+r2*b)>>7);
        gout = (uint8)((g1*a+g2*b)>>7);
        bout = (uint8)((b1*a+b2*b)>>7);
        *outImgPtr++ = pack_rgb565(rout, gout, bout);
      } /* end x loop */
    } /* end y loop */
  } /* end if */


  return IPL_SUCCESS;
} /* End ipl_fog_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fog_ycbcr

DESCRIPTION
  This function creates a foggy image.  The user specifies the level of
  fogginess, either light (0) or heavy (1).

  Input and output images must be in YCbCr 4:2:2.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  level         fog level, either light (0) or heavy (1)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_fog_ycbcr
(
  ipl_image_type* in_img_ptr,    /* Points to the  input image  */
  ipl_image_type* out_img_ptr,   /* Points to the output image  */
  uint8 level                    /* Level of fogginess          */
)
{
  unsigned char *in1ImgPtr, *outImgPtr, *fogImgPtr = NULL;
  uint32 w, h, x, y, a, b, xin, yin, index, xfactor, yfactor;
  uint32 *xmap = NULL;
  uint16 out;

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
    return IPL_FAILURE;

  /* Initialize image pointers and local variables */
  in1ImgPtr = (unsigned char*)in_img_ptr->imgPtr;
  outImgPtr = (unsigned char*)out_img_ptr->imgPtr;
  w = out_img_ptr->dx;
  h = out_img_ptr->dy;
  if (level == 0) {
    /* light fog */
    a = 64;
    b = 64;
  } else {
    /* heavy fog */
    a = 19;
    b = 109;
  }

  /* Get foggy output */
  if (w != 176 || h != 144)
  {
    /* Resize fog if image is not qcif */
    fogImgPtr = ipl_malloc(w*h*2*sizeof(unsigned char));
    if (!fogImgPtr)
    {
      return IPL_NO_MEMORY;
    }

    xmap = ipl_malloc(w*sizeof(uint32));
    if (!xmap)
    {
      ipl_sys_free(fogImgPtr);
      return IPL_NO_MEMORY;
    }
    /* Resize factors */
    xfactor = 180224/w;
    yfactor = 147456/h;
    /* Map x-coordinate in resized image to x-coordinate in input */
    xmap[0] = 0;
    for (x = 1; x < w; x++)
    {
      xin = (x*xfactor)>>10;
      if ((xin + xmap[x-1])%2)
      {
        xmap[x] = xin;
      }
      else
      {
        xmap[x] = xin-1;
      }
    }
    index = 0;
    for (y = 0; y < h; y++)
    {
      yin = ((yfactor*y)>>10)*176;
      for (x = 0; x < w; x++)
      {
        out = fog_ycbcr_176x144[yin + xmap[x]];
        *((unsigned char*)(fogImgPtr+index++)) = (uint8)(out & 0x00ff);
        *((unsigned char*)(fogImgPtr+index++)) = (uint8)((out & 0xff00)>>8);
      } /* end x loop */
    } /* end y loop */

    /* Loop through input image */
    index = 0;
    for (y = 0; y < h; y++)
    {
      for (x = 0; x < w; x++)
      {
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>7) +
                       ((*((unsigned char*)(fogImgPtr+index++))*b)>>7));
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>7) +
                       ((*((unsigned char*)(fogImgPtr+index++))*b)>>7));
      } /* end x loop */
    } /* end y loop */
  }
  else
  {
    /* Loop through input image */
    index = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        out = fog_ycbcr_176x144[index++];
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>7) +
                       (((uint8)(out & 0x00ff)*b)>>7));
        *outImgPtr++ = (unsigned char)(((*in1ImgPtr++*a)>>7) +
                       (((uint8)((out & 0xff00)>>8)*b)>>7));
      } /* end x loop */
    } /* end y loop */
  } /* end if */

  ipl_sys_free(xmap);
  ipl_sys_free(fogImgPtr);
  return IPL_SUCCESS;
} /* End ipl_fog_ycbcr */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fog

DESCRIPTION
  This function creates a foggy image.  The user specifies the level of
  fogginess, either light (0) or heavy (1).

  Input and output images must have the same color format, which can
  be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  level         fog level, either light (0) or heavy (1)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_fog
(
  ipl_image_type* in_img_ptr,    /* Points to the input image   */
  ipl_image_type* out_img_ptr,   /* Points to the output image  */
  uint8 level                    /* Level of fogginess          */
)
{
  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
    return IPL_FAILURE;

  /* Input and output color formats must be the same */
  if (in_img_ptr->cFormat != out_img_ptr->cFormat)
  {
    return IPL_FAILURE;
  }
  /* Input and output image sizes must be the same */
  if (in_img_ptr->dx != out_img_ptr->dx ||
      in_img_ptr->dy != out_img_ptr->dy)
  {
    return IPL_FAILURE;
  }
  /* Fog level must be either light (0) or heavy (1) */
  if ((level != 0) && (level != 1))
  {
    return IPL_FAILURE;
  }

  /* Call the appropriate function */
  if (in_img_ptr->cFormat == IPL_RGB565)
  {
    if (ipl_fog_rgb565(in_img_ptr, out_img_ptr, level) != IPL_SUCCESS)
    {
      return IPL_FAILURE;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCbCr)
  {
    if (ipl_fog_ycbcr(in_img_ptr, out_img_ptr, level) != IPL_SUCCESS)
    {
      return IPL_FAILURE;
    }
  }
  else if (in_img_ptr->cFormat == IPL_YCrCb420_LINE_PK ||
           in_img_ptr->cFormat == IPL_YCbCr420_LINE_PK)
  {
    ipl_image_type innew_img, out422_img;
    unsigned char *innew_data, *out422_data;
    /* allocate memory for YCbCr4:2:2 images */
    innew_data = ipl_malloc(in_img_ptr->dx*in_img_ptr->dy*2*
                        sizeof(unsigned char));
    if (!innew_data) {
      return IPL_NO_MEMORY;
    }
    out422_data = ipl_malloc(out_img_ptr->dx*out_img_ptr->dy*2*
                         sizeof(unsigned char));
    if (!out422_data) {
      ipl_sys_free(innew_data);
      return IPL_NO_MEMORY;
    }
    /* input 1 */
    innew_img.cFormat = IPL_YCbCr;
    innew_img.dx = in_img_ptr->dx;
    innew_img.dy = in_img_ptr->dy;
    innew_img.imgPtr = innew_data;
    if (ipl_convert_ycbcr420lp_to_ycbcr422(in_img_ptr, &innew_img)
        != IPL_SUCCESS)
    {
      ipl_sys_free(innew_data);
      ipl_sys_free(out422_data);
      return IPL_FAILURE;
    }
    /* ycbcr 4:2:2 output */
    out422_img.cFormat = IPL_YCbCr;
    out422_img.dx = out_img_ptr->dx;
    out422_img.dy = out_img_ptr->dy;
    out422_img.imgPtr = out422_data;
    /* call ycbcr 4:2:2 function */
    if (ipl_fog_ycbcr(&innew_img, &out422_img, level) != IPL_SUCCESS)
    {
      ipl_sys_free(innew_data);
      ipl_sys_free(out422_data);
      return IPL_FAILURE;
    }
    /* get YCbCr 4:2:0 output */
    if (ipl_convert_ycbcr422_to_ycbcr420lp(&out422_img, out_img_ptr)
        != IPL_SUCCESS)
    {
      ipl_sys_free(innew_data);
      ipl_sys_free(out422_data);
      return IPL_FAILURE;
    }

    /* ipl_sys_free memory */
    ipl_sys_free(innew_data);
    ipl_sys_free(out422_data);
  }
  else
  {
    /* other formats not supported */
    return IPL_FAILURE;
  }

  return IPL_SUCCESS;
} /* End ipl_fog */



#endif



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_fog

DESCRIPTION
  The fog function requires too much memory. Lets just increate
  brightness for low memory phones and call it a day. This is more to
  get the code to compile with current UI than for use bye OEMs.

  Input and output images must have the same color format, which can
  be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  in_img_ptr    pointer to the input image
  out_img_ptr   pointer to the output image
  level         fog level, either light (0) or heavy (1)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_fog
(
  ipl_image_type* in_img_ptr,    /* Points to the input image   */
  ipl_image_type* out_img_ptr,   /* Points to the output image  */
  uint8 level                    /* Level of fogginess          */
)
{
  MSG_LOW("ipl_fog marker_0\n");

  return (ipl_image_brightness(in_img_ptr, out_img_ptr, 12,30));
}




/* <EJECT> */
/*===========================================================================

FUNCTION ipl_red_eye

DESCRIPTION
  This function finds and fixes red eye

DEPENDENCIES
  None

ARGUMENTS IN
  in      pointer to the input image
  out     pointer to the output image
  icrip   where to search
  ocrip   where to put output
  arg1    future use
  arg2    future use

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_red_eye(ipl_image_type * in,
                                      ipl_image_type * out,
                                      ipl_rect_type * icrop,
                                      ipl_rect_type * ocrop,
                                      void * arg1,
                                      void * arg2)
{
  MSG_LOW("ipl_red_eye marker_0\n");

  //ipl_copy_and_paste(in, out, icrop, ocrop);
  //return (ipl_fixRedEye(in, out, icrop,0));

  return IPL_SUCCESS;
}



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_median_blur

DESCRIPTION
  This function performs median blurring.  If input is YCbCr 4:2:2,
  the function outputs YCbCr 4:2:2.  If input is RGB565, the function
  outputs RGB565.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  mag            magnitude of blur

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_median_blur
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  uint32 mag
)
{
#define SORT_2PIX(a,b) { if ((a)>(b)) SWAP_2PIX((a),(b));}
#define SWAP_2PIX(a,b) { unsigned char t=(a);(a)=(b);(b)=t;}

  uint32 row,col,i;
  ipl_status_type retval;

  ipl_image_type* input_img_ptr;
  ipl_image_type* output_img_ptr;
  register uint16* dataout_ptr;
  register uint16* datain_ptr;
  register uint16 rout16,gout16,bout16;
  uint32 dx, dx3, dy;
  unsigned char * ping8_ptr, *pong8_ptr;
  unsigned char * in8_ptr, *out8_ptr;
  unsigned char * chromap, *lumap;
  boolean ping;
  unsigned char rout8,gout8,bout8;
  unsigned char p0,p1,p2,p3,p4,p5,p6,p7,p8;

  MSG_LOW("ipl_median_blur marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_median_blur marker_200\n");
    return IPL_FAILURE;
  }
  input_img_ptr = i_img_ptr;
  output_img_ptr = o_img_ptr;
  dataout_ptr = (uint16*)output_img_ptr->imgPtr;
  datain_ptr = (uint16*)input_img_ptr->imgPtr;
  dx = output_img_ptr->dx;
  dx3 = 3*dx;
  dy = output_img_ptr->dy;


  if (!((input_img_ptr->dx == output_img_ptr->dx) &&
        (input_img_ptr->dy == output_img_ptr->dy)))
  {
    MSG_LOW("ipl_median_blur marker_201\n");
    /* Input and Output should be of same dimension */
    return IPL_FAILURE;
  }

  if ( (input_img_ptr->cFormat != IPL_YCbCr) &&
       (input_img_ptr->cFormat != IPL_RGB565))
  {
    MSG_LOW("ipl_median_blur marker_202\n");
    /* Only YCbCr 4:2:2 and RGB565 Input format currently supported */
    return IPL_FAILURE;
  }

  if ( !((output_img_ptr->cFormat == IPL_YCbCr)
    || (output_img_ptr->cFormat == IPL_RGB565)))
  {
    MSG_LOW("ipl_median_blur marker_203\n");
    /* Only YCbCr 4:2:2 or RGB565 output format currently supported */
    return IPL_FAILURE;
  }

  if (input_img_ptr->cFormat == IPL_YCbCr)
  {
    /* create two temp buffers of just Ys so we can do multiple 3x3 kernels. */
    ping8_ptr = (uint8*)ipl_malloc(dx*dy);
    if (!ping8_ptr)
    {
      MSG_LOW("ipl_median_blur marker_204\n");
      return IPL_FAILURE;
    }
    pong8_ptr = (uint8*)ipl_malloc(dx*dy);
    if (!pong8_ptr)
    {
      ipl_sys_free(ping8_ptr);
      MSG_LOW("ipl_median_blur marker_205\n");
      return IPL_NO_MEMORY;
    }

    MSG_LOW("ipl_median_blur marker_1\n");

    /* copy lumas to input buffer */
    /* we copy to output too since output will soon become input buffer, and
     * for boundary conditions, we need to have date in top/bottom row and
     * left/right most column */
    lumap = input_img_ptr->imgPtr;
    lumap++; /* skip cb to get to luma */
    in8_ptr = ping8_ptr;
    out8_ptr = pong8_ptr;
    for(i = dx*dy; i; i--)
    {
      *in8_ptr++ = *lumap;
      *out8_ptr++ = *lumap;
      lumap += 2;
    }

    /* now let go through and for each pixel, look at 3x3 kernel,
     * sort, and take middle value */
    ping = TRUE;
    for (i=0; i<mag; i++)
    {
      if (ping)
      {
        in8_ptr = ping8_ptr;
        out8_ptr = pong8_ptr;
      }
      else
      {
        in8_ptr = pong8_ptr;
        out8_ptr = ping8_ptr;
      }

      in8_ptr += (1 + dx);    /* skip a row and column */
      out8_ptr += (1 + dx);   /* skip a row and column */
      for(row = 0; row < dy-1; row++)
      {
        for(col = 0; col < dx-1; col++)
        {
          // for(c=0; c < 3; c++)
          // use the red channel for now only
          p0 = *(in8_ptr-dx-1);
          p1 = *(in8_ptr-dx);
          p2 = *(in8_ptr-dx+1);

          p3 = *(in8_ptr-1);
          p4 = *(in8_ptr);
          p5 = *(in8_ptr+1);

          p6 = *(in8_ptr+dx-1);
          p7 = *(in8_ptr+dx);
          p8 = *(in8_ptr+dx+1);

          // see each of the 9 pixels, sort and see who is in 4th place
          SORT_2PIX(p1,p2); SORT_2PIX(p4,p5); SORT_2PIX(p7,p8);
          SORT_2PIX(p0,p1); SORT_2PIX(p3,p4); SORT_2PIX(p6,p7);
          SORT_2PIX(p1,p2); SORT_2PIX(p4,p5); SORT_2PIX(p7,p8);
          SORT_2PIX(p0,p3); SORT_2PIX(p5,p8); SORT_2PIX(p4,p7);
          SORT_2PIX(p3,p6); SORT_2PIX(p1,p4); SORT_2PIX(p2,p5);
          SORT_2PIX(p4,p7); SORT_2PIX(p4,p2); SORT_2PIX(p6,p4);
          SORT_2PIX(p4,p2);

          *out8_ptr++ = p4;
          in8_ptr++;
        }
      }
      ping ^= 1;
    }

    /* now write lumas and original chromas to output */
    /* make sure we know where our last output was written too */
    if (ping)
      lumap = ping8_ptr;
    else
      lumap = pong8_ptr;

    out8_ptr = output_img_ptr->imgPtr;
    chromap = input_img_ptr->imgPtr;
    for(row = dy; row; row--)
    {
      for(col = dx; col; col--)
      {
        *out8_ptr++ = *chromap;
        chromap += 2;
        *out8_ptr++ = *lumap++;
      }
    }
    retval = IPL_SUCCESS;

    ipl_sys_free(ping8_ptr);
    ipl_sys_free(pong8_ptr);
  }
  else if (input_img_ptr->cFormat == IPL_RGB565)
  {
    /* lets unpack our data into temp memroy
    * so we dont unpack each pixel 9 times! */
    dx3 = dx*3;

    /* create two temp buffers so we can do multiple 3x3 kernels. */
    ping8_ptr = (uint8*)ipl_malloc(dx3*dy);
    if (!ping8_ptr)
    {
      MSG_LOW("ipl_median_blur marker_206\n");
      return IPL_NO_MEMORY;
    }
    pong8_ptr = (uint8*)ipl_malloc(dx3*dy);
    if (!pong8_ptr)
    {
      ipl_sys_free(ping8_ptr);
      MSG_LOW("ipl_median_blur marker_207\n");
      return IPL_NO_MEMORY;
    }

    datain_ptr = (uint16*)input_img_ptr->imgPtr;
    in8_ptr = ping8_ptr;
    out8_ptr = pong8_ptr;
    for(i = dy*dx; i; i--)
    {
      unpack_rgb565(*datain_ptr++,&rout8,&gout8,&bout8);
      *in8_ptr++ = rout8;
      *in8_ptr++ = gout8;
      *in8_ptr++ = bout8;

      *out8_ptr++ = rout8;
      *out8_ptr++ = gout8;
      *out8_ptr++ = bout8;
    }

    /* now let go through and for each pixel, look at 3x3 kernel,
     * sort, and take middle value */
    ping = TRUE;
    for (i=0; i<mag; i++)
    {
      if (ping)
      {
        in8_ptr = ping8_ptr;
        out8_ptr = pong8_ptr;
      }
      else
      {
        in8_ptr = pong8_ptr;
        out8_ptr = ping8_ptr;
      }

      in8_ptr += (3 + dx3);    /* skip a row and column */
      out8_ptr += (3 + dx3);   /* skip a row and column */
      for(row = 0; row < dy-1; row++)
      {
        for(col = 0; col < dx-1; col++)
        {
          // for(c=0; c < 3; c++)
          // use the red channel for now only
          p0 = *(in8_ptr-dx3-3);
          p1 = *(in8_ptr-dx3);
          p2 = *(in8_ptr-dx3+3);

          p3 = *(in8_ptr-3);
          p4 = *(in8_ptr);
          p5 = *(in8_ptr+3);

          p6 = *(in8_ptr+dx3-3);
          p7 = *(in8_ptr+dx3);
          p8 = *(in8_ptr+dx3+3);

          // see of the 9 pixels, sort and see who is in 4th place
          SORT_2PIX(p1,p2); SORT_2PIX(p4,p5); SORT_2PIX(p7,p8);
          SORT_2PIX(p0,p1); SORT_2PIX(p3,p4); SORT_2PIX(p6,p7);
          SORT_2PIX(p1,p2); SORT_2PIX(p4,p5); SORT_2PIX(p7,p8);
          SORT_2PIX(p0,p3); SORT_2PIX(p5,p8); SORT_2PIX(p4,p7);
          SORT_2PIX(p3,p6); SORT_2PIX(p1,p4); SORT_2PIX(p2,p5);
          SORT_2PIX(p4,p7); SORT_2PIX(p4,p2); SORT_2PIX(p6,p4);
          SORT_2PIX(p4,p2);

          // now we gotta see where this red value came from
          if (*(in8_ptr-dx3-3) == p4)
          {
            rout16 = *(in8_ptr-dx3-3);
            gout16 = *(in8_ptr-dx3-2);
            bout16 = *(in8_ptr-dx3-1);
          }
          else if (*(in8_ptr-dx3) == p4)
          {
            rout16 = *(in8_ptr-dx3);
            gout16 = *(in8_ptr-dx3+1);
            bout16 = *(in8_ptr-dx3+2);
          }
          else if (*(in8_ptr-dx3+3) == p4)
          {
            rout16 = *(in8_ptr-dx3+3);
            gout16 = *(in8_ptr-dx3+4);
            bout16 = *(in8_ptr-dx3+5);
          }
          else if (*(in8_ptr-3) == p4)
          {
            rout16 = *(in8_ptr-3);
            gout16 = *(in8_ptr-2);
            bout16 = *(in8_ptr-1);
          }
          else if (*(in8_ptr) == p4)
          {
            rout16 = *(in8_ptr);
            gout16 = *(in8_ptr+1);
            bout16 = *(in8_ptr+2);
          }
          else if (*(in8_ptr+3) == p4)
          {
            rout16 = *(in8_ptr+3);
            gout16 = *(in8_ptr+4);
            bout16 = *(in8_ptr+5);
          }
          else if (*(in8_ptr+dx3-3) == p4)
          {
            rout16 = *(in8_ptr+dx3-3);
            gout16 = *(in8_ptr+dx3-2);
            bout16 = *(in8_ptr+dx3-1);
          }
          else if (*(in8_ptr+dx3) == p4)
          {
            rout16 = *(in8_ptr+dx3);
            gout16 = *(in8_ptr+dx3+1);
            bout16 = *(in8_ptr+dx3+2);
          }
          else
          {
            rout16 = *(in8_ptr+dx3+3);
            gout16 = *(in8_ptr+dx3+4);
            bout16 = *(in8_ptr+dx3+5);
          }

          *out8_ptr++ = (unsigned char) rout16;
          *out8_ptr++ = (unsigned char) gout16;
          *out8_ptr++ = (unsigned char) bout16;
          in8_ptr += 3;
        }
      }

      ping ^= 1;
    }

    /* now convert 888 rgb data to 565 */
    if (ping)
      out8_ptr = ping8_ptr;
    else
      out8_ptr = pong8_ptr;
    dataout_ptr = (uint16*)output_img_ptr->imgPtr;
    for(row = dy; row; row--)
    {
      for(col = dx; col; col--)
      {
        *dataout_ptr++ = pack_rgb565(*out8_ptr, *(out8_ptr+1), *(out8_ptr+2));
        out8_ptr += 3;
      }
    }
    retval = IPL_SUCCESS;

    ipl_sys_free(ping8_ptr);
    ipl_sys_free(pong8_ptr);
  }
  else
  {
    retval = IPL_FAILURE;
  }

  if (retval == IPL_SUCCESS)
    MSG_LOW("ipl_median_blur marker_100\n");
  else
    MSG_LOW("ipl_median_blur marker_208\n");

  return retval;
}


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_watercolor

DESCRIPTION
  This function performs watercolor effect. If input is YCbCr 4:2:2,
  the function outputs YCbCr 4:2:2.  If input is RGB565, the function
  outputs RGB565.

  The kernel size is 3x3. This size kernel is not adequate for images
  having resolution greatern than 500x500 and larger kenrnel should be used.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  mag            magnitude of blur

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_watercolor
(
  ipl_image_type* i_img_ptr,         /* Points to the input image      */
  ipl_image_type* o_img_ptr,         /* Points to the output image     */
  uint32 mag
)
{
  ipl_image_type t_img_ptr;

  MSG_LOW("ipl_watercolor marker_0\n");

  if (mag < 1)
  {
    MSG_LOW("ipl_watercolor marker_200\n");
    return IPL_FAILURE;
  }
  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_watercolor marker_201\n");
    return IPL_FAILURE;
  }

  t_img_ptr.dx = i_img_ptr->dx;
  t_img_ptr.dy = i_img_ptr->dy;
  t_img_ptr.cFormat = i_img_ptr->cFormat;
  if (ipl_malloc_img(&t_img_ptr))
  {
    MSG_LOW("ipl_watercolor marker_202\n");
    return IPL_NO_MEMORY;
  }
  if (ipl_median_blur(i_img_ptr, &t_img_ptr, mag) != IPL_SUCCESS)
  {
    MSG_LOW("ipl_watercolor marker_203\n");
    return IPL_NO_MEMORY;
  }
  // make iamge a bit brighter
  if (ipl_image_brightness(&t_img_ptr, o_img_ptr, 12,30) != IPL_SUCCESS)
  {
    MSG_LOW("ipl_watercolor marker_204\n");
    return IPL_FAILURE;
  }
  ipl_free_img(&t_img_ptr);

  MSG_LOW("ipl_watercolor marker_100\n");

  return IPL_SUCCESS;
}



#if 0

/* <EJECT> */
/*===========================================================================

FUNCTION ipl_deblur

DESCRIPTION
  This function deblurs and image

DEPENDENCIES
  None

ARGUMENTS IN
  input_ptr        pointer to the input image
  mult             value to multiply pixel by
  add              value to add to pixel (before multiply)

ARGUMENTS OUT
  output_ptr       pointer to the output image

RETURN VALUE
  IPL_SUCCESS      indicates operation was successful
  IPL_FAILURE      otherwise

SIDE EFFECTS
  None

===========================================================================*/
extern ipl_status_type ipl_deblur
(
  ipl_image_type *s_img_ptr,  /* Points to the input image  */
  ipl_image_type *b_img_ptr   /* Points to the output image */
)
{
  ipl_status_type retval = IPL_FAILURE;

  register uint8* s_ptr;
  register uint8* b_ptr;

  register uint32 b_accumY;
  register uint32 b_accumCb;
  register uint32 b_accumCr;
  register uint32 s_accumY;
  register uint32 s_accumCb;
  register uint32 s_accumCr;

  uint32 dx;
  uint32 dy;



  // how much to halve in x and y dimension
  int nper = 5;
  int mper = 5;

  int i, j;
  int n,m,nmax,mmax,ncol,mrow;
  int pitch;

  float g_y,g_cb,g_cr;

  if (!s_img_ptr || !s_img_ptr->imgPtr ||
      !b_img_ptr || !b_img_ptr->imgPtr)
    return IPL_FAILURE;

  dx = s_img_ptr->dx;
  dy = s_img_ptr->dy;

  if (!((b_img_ptr->dx == dx) && (b_img_ptr->dy == dy)))
    return IPL_FAILURE;

  if (s_img_ptr->cFormat != b_img_ptr->cFormat)
    return IPL_FAILURE;

  // size of each block
  ncol = (dx >> nper);
  mrow = (dy >> mper);


  // number of blocks in x and y dimention of size ncol and mrow
  nmax = pow(2.0, (double) nper);
  mmax = pow(2.0, (double) mper);


  if (s_img_ptr->cFormat == IPL_YCbCr)
  {
    pitch = 2*(nmax - 1)*(dx >> nper);

    if (IPL_EFX_DEBUG) //lint !e774 !e506
    {
      printf ("ncol, mrow: %d %d\n", ncol, mrow);
      printf ("nmax, mmax: %d %d\n", nmax, mmax);
      printf ("pitch: %d\n", pitch);
    }

    for (m = 0; m < mmax; m++)
    {
      for (n = 0; n < nmax; n++)
      {
        s_ptr = s_img_ptr->imgPtr + m*mrow*dx*2 + n*ncol*2;
        b_ptr = b_img_ptr->imgPtr + m*mrow*dx*2 + n*ncol*2;

        // compute average Y, Cb, and Cr
        b_accumY = b_accumCb = b_accumCr = 0;
        s_accumY = s_accumCb = s_accumCr = 0;

        for(j=0; j < mrow; j++)
        {
          for(i=0; i < ncol/2; i++)
          {
            b_accumCb += *b_ptr++;
            b_accumY  += *b_ptr++;
            b_accumCr += *b_ptr++;
            b_accumY  += *b_ptr++;

            s_accumCb += *s_ptr++;
            s_accumY  += *s_ptr++;
            s_accumCr += *s_ptr++;
            s_accumY  += *s_ptr++;
          }

          b_ptr += pitch;
          s_ptr += pitch;
        }

        if (IPL_EFX_DEBUG) //lint !e774 !e506
        {
          printf("Block nm: %d %d\n", n,m);
          printf("by bb br: %ld %ld %ld\n", b_accumY, b_accumCb, b_accumCr);
          printf("sy sb sr: %ld %ld %ld\n", s_accumY, s_accumCb, s_accumCr);
        }

        g_y  = (float) b_accumY  / (float) (s_accumY+1);
        g_cb = (float) b_accumCb / (float) (s_accumCb+1);
        g_cr = (float) b_accumCr / (float) (s_accumCr+1);

        if (IPL_EFX_DEBUG)  //lint !e774 !e506
          printf("g_y g_cb g_cr: %f %f %f\n\n", g_y, g_cb, g_cr);


        s_ptr = s_img_ptr->imgPtr + m*mrow*dx*2 + n*ncol*2;
        b_ptr = b_img_ptr->imgPtr + m*mrow*dx*2 + n*ncol*2;

        for(j=0; j < mrow; j++)
        {
          for(i=0; i < ncol/2; i++)
          {
            *s_ptr++ *= g_cb;
            *s_ptr++ *= g_y;
            *s_ptr++ *= g_cr;
            *s_ptr++ *= g_y;
          }

          b_ptr += pitch;
          s_ptr += pitch;
        }
      }
    }

    retval = IPL_SUCCESS;
  }
  else
  {
    retval = IPL_FAILURE;
  }

  return retval;
}


#endif

/* <EJECT> */
/*===========================================================================

FUNCTION ipl_radial_blur_rgb565

DESCRIPTION
  This function performs radial blur. The blurring level can be set
  to an integer between 0 and 100, inclusive. No blurring occurs
  when the blurring level is 0.

  Input and output image sizes must be equal.

  Input and output images must be in RGB565 format.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr points to the input image
  o_img_ptr points to the output image
  xo is the x-coordinate of the center of rotation
  yo is the y-coordinate of the center of rotation
  level is the level of blurring (range: 0 to 100)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_radial_blur_rgb565
(
  ipl_image_type* i_img_ptr,   /* Points to the input image           */
  ipl_image_type* o_img_ptr,   /* Points to the output image          */
  int32 xo,                    /* x-coordinate of center of rotation  */
  int32 yo,                    /* y-coordinate of center of rotation  */
  uint8 level                  /* Blurring level                      */
)
{
  uint16 *inImgPtr, *outImgPtr, *imgCnt;
  uint32 *sImgPtr;
  int32 w, h, x, y, xin, yin, angle, radian, sintheta, costheta;
  uint32 outIndex, inIndex, cntIndex, r, g, b;
  uint16 out, i;
  int16 n;

  MSG_LOW("ipl_radial_blur_rgb565 marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_radial_blur_rgb565 marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = (uint16*)i_img_ptr->imgPtr;
  outImgPtr = (uint16*)o_img_ptr->imgPtr;
  w = o_img_ptr->dx;
  h = o_img_ptr->dy;
  xo = w >> 1;
  yo = h >> 1;

  /* No blurring if level is 0, just copy from input */
  if (level == 0) {
    for (y = w*h; y; y--) {
      *outImgPtr++ = *inImgPtr++;
    }
    MSG_LOW("ipl_radial_blur_rgb565 marker_100\n");
    return IPL_SUCCESS;
  }

  /* Level > 0, must perform blurring */
  x = w * h;
  /* Malloc buffer to count number of pixels summed */
  imgCnt = ipl_malloc(x*sizeof(uint16));
  if (!imgCnt) {
    MSG_LOW("ipl_radial_blur_rgb565 marker_201\n");
    return IPL_NO_MEMORY;
  }
  /* Malloc buffer for summed pixel values */
  sImgPtr = ipl_malloc(x*3*sizeof(uint32));
  if (!sImgPtr)
  {
    ipl_sys_free(imgCnt);
    MSG_LOW("ipl_radial_blur_rgb565 marker_202\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_radial_blur_rgb565 marker_1\n");

  /* Initialize counters */
  inIndex = 0;
  for (y = 0; y < h; y++) {
    for (x = 0; x < w; x++) {
      *((uint16*)(imgCnt+inIndex++)) = 1;
    }
  }

  /* Initialize pixel sums */
  inIndex = 0;
  outIndex = 0;
  for (y = w*h; y; y--) {
    *((uint32*)(sImgPtr+outIndex++)) = 0;
    *((uint32*)(sImgPtr+outIndex++)) = 0;
    *((uint32*)(sImgPtr+outIndex++)) = 0;
  } /* end y loop */

  /*
  ** Now rotate and sum pixels
  */

  /*
  ** For level = 1: Rotate by 1 degree, in 1/8 degree increments clockwise
  ** and counterclockwise.
  */

  /* Counterclockwise */
  for (angle = -4; angle < 0; angle++) {
    radian = (-angle * 9) >> 3;
    sintheta = -((radian*(262144-(radian*radian)/6))>>8);
    costheta = 524288-radian*radian;
    /* Loop through input */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
        yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          out = *((uint16*)(inImgPtr + yin*w + xin));
          *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>8;
          *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>3;
          *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<3;
          (*((uint16*)(imgCnt+cntIndex)))++;
        }
        cntIndex++;
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */
  } /* end angle loop */

  /* Clockwise */
  for (angle = 1; angle <= 4; angle++) {
    radian = (angle * 9)>>3;
    sintheta = ((radian*(262144-(radian*radian)/6))>>8);
    costheta = 524288-radian*radian;
    /* Loop through input */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
        yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          out = *((uint16*)(inImgPtr + yin*w + xin));
          *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>8;
          *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>3;
          *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<3;
          (*((uint16*)(imgCnt+cntIndex)))++;
        }
        cntIndex++;
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */
  } /* end angle loop */

  if (level > 1 && level <= 5) {
    /*
    ** For level = 2, 3, 4, 5: Add onto result from level 1. Rotate
    ** 2,3,...,'level' degrees in 1/4 degree increments clockwise
    ** and counterclockwise.
    */
    n = level << 1;

    /* Counterclockwise */
    for (angle = -n; angle < -2; angle++) {
      radian = (-angle * 9)>>2;
      sintheta = -((radian*(262144-(radian*radian)/6))>>8);
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            out = *((uint16*)(inImgPtr + yin*w + xin));
            *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>7;
            *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>2;
            *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<4;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 3; angle <= n; angle++) {
      radian = (angle * 9)>>2;
      sintheta = (radian*(262144-(radian*radian)/6))>>8;
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            out = *((uint16*)(inImgPtr + yin*w + xin));
            *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>7;
            *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>2;
            *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<4;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */
  }
  else if (level > 5) {
    /*
    ** For level > 5: Add onto result from 1 through 5.
    ** Rotate 6,7,...,'level' degrees in 1/2 degree increments.
    */

    /*
    ** (1) Degree: 2, 3, 4, 5  -->  1/4 degree increments cw and ccw
    */

    /* Counterclockwise */
    for (angle = -10; angle < -2; angle++) {
      radian = (-angle * 9)>>2;
      sintheta = -((radian*(262144-(radian*radian)/6))>>8);
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            out = *((uint16*)(inImgPtr + yin*w + xin));
            *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>7;
            *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>2;
            *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<4;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 3; angle <= 10; angle++) {
      radian = (angle * 9)>>2;
      sintheta = (radian*(262144-(radian*radian)/6))>>8;
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            out = *((uint16*)(inImgPtr + yin*w + xin));
            *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>7;
            *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>2;
            *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<4;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /*
    ** (2) Degree: 6, 7, ... , level  -->  1/2 degree increments cw and ccw
    */
    n = level;

    /* Counterclockwise */
    for (angle = -n; angle < -5; angle++) {
      radian = (-angle * 9)>>1;
      if (radian <= 360) {
        sintheta = -((radian*(262144-(radian*radian)/6))>>8);
        costheta = 524288-radian*radian;
      } else {
        sintheta = -(((radian*(262144-(radian*radian)/6))>>8) +
                    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                    radian)/42)*((11010048-radian*radian)>>10))>>21));
        costheta = (524288-radian*radian) +
                    (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                    ((7864320-radian*radian)>>10))>>12);
      }
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            out = *((uint16*)(inImgPtr + yin*w + xin));
            *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>6;
            *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>1;
            *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<5;
            (*((uint16*)(imgCnt+cntIndex)))+=4;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 6; angle <= n; angle++) {
      radian = (angle * 9)>>1;
      if (radian <= 360) {
        sintheta = (radian*(262144-(radian*radian)/6))>>8;
        costheta = 524288-radian*radian;
      } else {
        sintheta = ((radian*(262144-(radian*radian)/6))>>8) +
                    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                    radian)/42)*((11010048-radian*radian)>>10))>>21);
        costheta = (524288-radian*radian) +
                    (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                    ((7864320-radian*radian)>>10))>>12);
      }
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            out = *((uint16*)(inImgPtr + yin*w + xin));
            *((uint32*)(sImgPtr+outIndex)) += (out & 0xf800)>>6;
            *((uint32*)(sImgPtr+outIndex+1)) += (out & 0x07e0)>>1;
            *((uint32*)(sImgPtr+outIndex+2)) += (out & 0x001f)<<5;
            (*((uint16*)(imgCnt+cntIndex)))+=4;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */
  } /* end if level */

  /* Add on original image */
  inIndex = 0;
  outIndex = 0;
  for (y = w*h; y; y--) {
    out = *((uint16*)(inImgPtr+inIndex++));
    *((uint32*)(sImgPtr+outIndex++)) += ((out & 0xf800)>>8);
    *((uint32*)(sImgPtr+outIndex++)) += ((out & 0x07e0)>>3);
    *((uint32*)(sImgPtr+outIndex++)) += ((out & 0x001f)<<3);
  } /* end y loop */

  /* Divide to get output */
  inIndex = 0;
  cntIndex = 0;
  for (y = w*h; y; y--) {
    i = *((uint16*)(imgCnt+cntIndex++));
    r = ((*((uint32*)(sImgPtr+inIndex++))) / i);
    g = ((*((uint32*)(sImgPtr+inIndex++))) / i);
    b = ((*((uint32*)(sImgPtr+inIndex++))) / i);
    *outImgPtr++ = pack_rgb565(r,g,b);
  } /* end y loop */

  /* Free memory */
  ipl_sys_free(sImgPtr);
  ipl_sys_free(imgCnt);

  MSG_LOW("ipl_radial_blur_rgb565 marker_101\n");

  return IPL_SUCCESS;
} /* End ipl_radial_blur_rgb565 */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_radial_blur_ycbcr

DESCRIPTION
  This function performs radial blur. The blurring level can be set
  to an integer between 0 and 100, inclusive. No blurring occurs
  when the blurring level is 0.

  Input and output image sizes must be equal.

  Input and output images must be in YCbCr 4:2:2 format.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr points to the input image
  o_img_ptr points to the output image
  xo is the x-coordinate of the center of rotation
  yo is the y-coordinate of the center of rotation
  level is the level of blurring (range: 0 to 100)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_radial_blur_ycbcr
(
  ipl_image_type* i_img_ptr,   /* Points to the input image           */
  ipl_image_type* o_img_ptr,   /* Points to the output image          */
  int32 xo,                    /* x-coordinate of center of rotation  */
  int32 yo,                    /* y-coordinate of center of rotation  */
  uint8 level                  /* Blurring level                      */
)
{
  uint8 *inImgPtr, *outImgPtr, *fullImgPtr;
  uint16 *imgCnt;
  uint32 *sImgPtr;
  int32 w, h, x, y, xin, yin, angle, radian, sintheta, costheta;
  uint32 outIndex, inIndex, cntIndex;
  int16 n;
  uint16 i;
  uint8 cb, cr;

  MSG_LOW("ipl_radial_blur_ycbcr marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_radial_blur_ycbcr marker_200\n");
    return IPL_FAILURE;
  }



  /* Initialize image pointers and local variables */
  inImgPtr = i_img_ptr->imgPtr;
  outImgPtr = o_img_ptr->imgPtr;
  w = o_img_ptr->dx;
  h = o_img_ptr->dy;

  /* No blurring if level is 0, just copy from input */
  if (level == 0) {
    for (y = (h*w)<<1; y; y--) {
      *outImgPtr++ = *inImgPtr++;
    } /* end y loop */
    MSG_LOW("ipl_radial_blur_ycbcr marker_100\n");
    return IPL_SUCCESS;
  }

  /* Level > 0, must perform blurring */
  x = w * h;

  /* Malloc full YCbCr input image */
  fullImgPtr = ipl_malloc(x*3*sizeof(uint8));
  if (!fullImgPtr) {
    MSG_LOW("ipl_radial_blur_ycbcr marker_201\n");
    return IPL_NO_MEMORY;
  }

  /* Malloc buffer to count number of pixels summed */
  imgCnt = ipl_malloc(x*sizeof(uint16));
  if (!imgCnt)
  {
    ipl_sys_free(fullImgPtr);
    MSG_LOW("ipl_radial_blur_ycbcr marker_202\n");
    return IPL_NO_MEMORY;
  }

  /* Malloc buffer for summed pixel values */
  sImgPtr = ipl_malloc(x*3*sizeof(uint32));
  if (!sImgPtr)
  {
    ipl_sys_free(imgCnt);
    ipl_sys_free(fullImgPtr);
    MSG_LOW("ipl_radial_blur_ycbcr marker_203\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_radial_blur_ycbcr marker_1\n");
  /* Initialize full YCbCr input image */
  outIndex = 0;
  for (y = (h*w)>>1; y; y--) {
    cb = *inImgPtr++;
    cr = *((uint8*)(inImgPtr+1));
    *((uint8*)(fullImgPtr+outIndex++)) = cb;
    *((uint8*)(fullImgPtr+outIndex++)) = cr;
    *((uint8*)(fullImgPtr+outIndex++)) = *inImgPtr++;
    *((uint8*)(fullImgPtr+outIndex++)) = cb;
    *((uint8*)(fullImgPtr+outIndex++)) = cr;
    inImgPtr++;
    *((uint8*)(fullImgPtr+outIndex++)) = *inImgPtr++;
  } /* end y loop */

  /* Initialize counters */
  inIndex = 0;
  for (y = h*w; y; y--) {
    *((uint16*)(imgCnt+inIndex++)) = 1;
  } /* end y loop */

  /* Initialize pixel sums */
  outIndex = 0;
  for (y = h*w*3; y; y--) {
    *((uint32*)(sImgPtr+outIndex++)) = 0;
  } /* end y loop */

  /*
  ** Now rotate and sum pixels
  */

  /*
  ** For level = 1: Rotate by 1 degree, in 1/8 degree increments clockwise
  ** and counterclockwise.
  */

  /* Counterclockwise */
  for (angle = -4; angle < 0; angle++) {
    radian = (-angle * 9) >> 3;
    sintheta = -((radian*(262144-(radian*radian)/6))>>8);
    costheta = 524288-radian*radian;
    /* Loop through input */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
        yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          *((uint32*)(sImgPtr+outIndex)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+1)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+2)) +=
            *((uint8*)(fullImgPtr+inIndex));
          (*((uint16*)(imgCnt+cntIndex)))++;
        }
        cntIndex++;
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */
  } /* end angle loop */

  /* Clockwise */
  for (angle = 1; angle <= 4; angle++) {
    radian = (angle * 9)>>3;
    sintheta = ((radian*(262144-(radian*radian)/6))>>8);
    costheta = 524288-radian*radian;
    /* Loop through input */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
        yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          *((uint32*)(sImgPtr+outIndex)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+1)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+2)) +=
            *((uint8*)(fullImgPtr+inIndex));
          (*((uint16*)(imgCnt+cntIndex)))++;
        }
        cntIndex++;
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */
  } /* end angle loop */

  if (level > 1 && level <= 5) {
    /*
    ** For level = 2, 3, 4, 5: Add onto result from level 1. Rotate
    ** 2,3,...,'level' degrees in 1/4 degree increments clockwise
    ** and counterclockwise.
    */
    n = level << 1;

    /* Counterclockwise */
    for (angle = -n; angle < -2; angle++) {
      radian = (-angle * 9)>>2;
      sintheta = -((radian*(262144-(radian*radian)/6))>>8);
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 3; angle <= n; angle++) {
      radian = (angle * 9)>>2;
      sintheta = (radian*(262144-(radian*radian)/6))>>8;
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */
  }
  else if (level > 5) {
    /*
    ** For level > 5: Add onto result from 1 through 5 degrees.
    ** Rotate 6,7,...,'level' degrees in 1/2 degree increments.
    */

    /*
    ** (1) Degree: 2, 3, 4, 5  -->  1/4 degree increments cw and ccw
    */

    /* Counterclockwise */
    for (angle = -10; angle < -2; angle++) {
      radian = (-angle * 9)>>2;
      sintheta = -((radian*(262144-(radian*radian)/6))>>8);
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 3; angle <= 10; angle++) {
      radian = (angle * 9)>>2;
      sintheta = (radian*(262144-(radian*radian)/6))>>8;
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /*
    ** (2) Degree: 6, 7, ... , level  -->  1/2 degree increments cw and ccw
    */
    n = level;

    /* Counterclockwise */
    for (angle = -n; angle < -5; angle++) {
      radian = (-angle * 9)>>1;
      if (radian <= 360) {
        sintheta = -((radian*(262144-(radian*radian)/6))>>8);
        costheta = 524288-radian*radian;
      } else {
        sintheta = -(((radian*(262144-(radian*radian)/6))>>8) +
                    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                    radian)/42)*((11010048-radian*radian)>>10))>>21));
        costheta = (524288-radian*radian) +
                    (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                    ((7864320-radian*radian)>>10))>>12);
      }
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<2;
            (*((uint16*)(imgCnt+cntIndex)))+=4;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 6; angle <= n; angle++) {
      radian = (angle * 9)>>1;
      if (radian <= 360) {
        sintheta = (radian*(262144-(radian*radian)/6))>>8;
        costheta = 524288-radian*radian;
      } else {
        sintheta = ((radian*(262144-(radian*radian)/6))>>8) +
                    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                    radian)/42)*((11010048-radian*radian)>>10))>>21);
        costheta = (524288-radian*radian) +
                    (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                    ((7864320-radian*radian)>>10))>>12);
      }
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<2;
            (*((uint16*)(imgCnt+cntIndex)))+=4;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */
  } /* end if level */

  /* Add on original image */
  outIndex = 0;
  for (y = h*w*3; y; y--) {
    *((uint32*)(sImgPtr+outIndex)) += *((uint8*)(fullImgPtr+outIndex));
    outIndex++;
  } /* end y loop */

  /* Get output */
  inIndex = 0;
  cntIndex = 0;
  for (y = (h*w)>>1; y; y--) {
    i = *((uint16*)(imgCnt+cntIndex++));
    *outImgPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex++))) / i);
    inIndex++;
    *outImgPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex++))) / i);
    i = *((uint16*)(imgCnt+cntIndex++));
    inIndex++;
    *outImgPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex++))) / i);
    *outImgPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex++))) / i);
  } /* end y loop */

  /* Free memory */
  ipl_sys_free(fullImgPtr);
  ipl_sys_free(sImgPtr);
  ipl_sys_free(imgCnt);

  MSG_LOW("ipl_radial_blur_ycbcr marker_101\n");

  return IPL_SUCCESS;
} /* End ipl_radial_blur_ycbcr */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_radial_blur_420lp

DESCRIPTION
  This function performs radial blur. The blurring level can be set
  to an integer between 0 and 100, inclusive. No blurring occurs
  when the blurring level is 0.

  Input and output image sizes must be equal.

  Input and output images must be in YCbCr 4:2:0 line packed format.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr points to the input image
  o_img_ptr points to the output image
  xo is the x-coordinate of the center of rotation
  yo is the y-coordinate of the center of rotation
  level is the level of blurring (range: 0 to 100)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_radial_blur_420lp
(
  ipl_image_type* i_img_ptr,   /* Points to the input image           */
  ipl_image_type* o_img_ptr,   /* Points to the output image          */
  int32 xo,                    /* x-coordinate of center of rotation  */
  int32 yo,                    /* y-coordinate of center of rotation  */
  uint8 level                  /* Blurring level                      */
)
{
  uint8 *inImgPtr, *outImgPtr, *inClrPtr, *outClrPtr, *out2ImgPtr,
        *fullImgPtr, *full2ImgPtr;
  uint16 *imgCnt;
  uint32 *sImgPtr, *r2ImgPtr;
  int32 w, h, x, y, xin, yin, angle, radian, sintheta, costheta;
  uint32 outIndex, inIndex, cntIndex, cnt2Index, inc;
  int16 n;
  uint16 i;
  uint8 cb, cr;

  MSG_LOW("ipl_radial_blur_420lp marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_radial_blur_420lp marker_200\n");
    return IPL_FAILURE;
  }

  /* Initialize image pointers and local variables */
  inImgPtr = i_img_ptr->imgPtr;
  outImgPtr = o_img_ptr->imgPtr;
  inClrPtr = i_img_ptr->clrPtr;
  outClrPtr = o_img_ptr->clrPtr;
  w = o_img_ptr->dx;
  h = o_img_ptr->dy;

  /* No blurring if level is 0, just copy from input */
  if (level == 0) {
    /* Luma values */
    for (y = h*w; y; y--) {
      *outImgPtr++ = *inImgPtr++;
    }
    /* Chroma values */
    for (y = h*w; y; y--) {
      *outClrPtr++ = *inClrPtr++;
    }
    MSG_LOW("ipl_radial_blur_420lp marker_100\n");
    return IPL_SUCCESS;
  }

  /* Level > 0, must perform blurring */
  x = w * h;

  /* Malloc full YCbCr input image */
  fullImgPtr = ipl_malloc(x*3*sizeof(uint8));
  if (!fullImgPtr) {
    MSG_LOW("ipl_radial_blur_420lp marker_201\n");
    return IPL_NO_MEMORY;
  }

  /* Malloc buffer to count number of pixels summed */
  imgCnt = ipl_malloc(x*sizeof(uint16));
  if (!imgCnt)
  {
    ipl_sys_free(fullImgPtr);
    MSG_LOW("ipl_radial_blur_420lp marker_202\n");
    return IPL_NO_MEMORY;
  }

  /* Malloc buffer for summed pixel values */
  sImgPtr = ipl_malloc(x*3*sizeof(uint32));
  if (!sImgPtr)
  {
    ipl_sys_free(fullImgPtr);
    ipl_sys_free(imgCnt);
    MSG_LOW("ipl_radial_blur_420lp marker_203\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_radial_blur_420lp marker_1\n");

  /* Full YCbCr input image */
  outIndex = 2;
  /* Luma values */
  for (y = h*w; y; y--) {
    *((uint8*)(fullImgPtr+outIndex)) = *inImgPtr++;
    outIndex += 3;
  }
  /* Chroma values */
  outIndex = 0;
  inc = w*3;
  full2ImgPtr = fullImgPtr + inc;
  for (y = 0; y < h; y+=2) {
    for (x = 0; x < w; x+=2) {
      /* Process 4 pixels at a time */
      cb = *inClrPtr++;
      cr = *inClrPtr++;
      /* Pixel 1 */
      *((uint8*)(fullImgPtr+outIndex)) = cb;
      *((uint8*)(fullImgPtr+outIndex+1)) = cr;
      /* Pixel 2 */
      *((uint8*)(fullImgPtr+outIndex+3)) = cb;
      *((uint8*)(fullImgPtr+outIndex+4)) = cr;
      /* Pixel 3 */
      *((uint8*)(full2ImgPtr+outIndex++)) = cb;
      *((uint8*)(full2ImgPtr+outIndex++)) = cr;
      outIndex++;
      /* Pixel 4 */
      *((uint8*)(full2ImgPtr+outIndex++)) = cb;
      *((uint8*)(full2ImgPtr+outIndex++)) = cr;
      outIndex++;
    } /* end x loop */
    outIndex += inc;
  } /* end y loop */

  /* Initialize counters */
  inIndex = 0;
  for (y = h*w; y; y--) {
    *((uint16*)(imgCnt+inIndex++)) = 1;
  } /* end y loop */

  /* Initialize pixel sums */
  outIndex = 0;
  for (y = h*w*3; y; y--) {
    *((uint32*)(sImgPtr+outIndex++)) = 0;
  } /* end y loop */

  /*
  ** Now rotate and sum pixels
  */

  /*
  ** For level = 1: Rotate by 1 degree, in 1/8 degree increments clockwise
  ** and counterclockwise.
  */

  /* Counterclockwise */
  for (angle = -4; angle < 0; angle++) {
    radian = (-angle * 9) >> 3;
    sintheta = -((radian*(262144-(radian*radian)/6))>>8);
    costheta = 524288-radian*radian;
    /* Loop through input */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
        yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          *((uint32*)(sImgPtr+outIndex)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+1)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+2)) +=
            *((uint8*)(fullImgPtr+inIndex));
          (*((uint16*)(imgCnt+cntIndex)))++;
        }
        cntIndex++;
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */
  } /* end angle loop */

  /* Clockwise */
  for (angle = 1; angle <= 4; angle++) {
    radian = (angle * 9)>>3;
    sintheta = ((radian*(262144-(radian*radian)/6))>>8);
    costheta = 524288-radian*radian;
    /* Loop through input */
    outIndex = 0;
    cntIndex = 0;
    for (y = 0; y < h; y++) {
      for (x = 0; x < w; x++) {
        xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
        yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
        if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
          inIndex = (yin*w + xin)*3;
          *((uint32*)(sImgPtr+outIndex)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+1)) +=
            *((uint8*)(fullImgPtr+inIndex++));
          *((uint32*)(sImgPtr+outIndex+2)) +=
            *((uint8*)(fullImgPtr+inIndex));
          (*((uint16*)(imgCnt+cntIndex)))++;
        }
        cntIndex++;
        outIndex += 3;
      } /* end x loop */
    } /* end y loop */
  } /* end angle loop */

  if (level > 1 && level <= 5) {
    /*
    ** For level = 2, 3, 4, 5: Add onto result from level 1. Rotate
    ** 2,3,...,'level' degrees in 1/4 degree increments clockwise
    ** and counterclockwise.
    */
    n = level << 1;

    /* Counterclockwise */
    for (angle = -n; angle < -2; angle++) {
      radian = (-angle * 9)>>2;
      sintheta = -((radian*(262144-(radian*radian)/6))>>8);
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 3; angle <= n; angle++) {
      radian = (angle * 9)>>2;
      sintheta = (radian*(262144-(radian*radian)/6))>>8;
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */
  }
  else if (level > 5) {
    /*
    ** For level > 5: Add onto result from 1 through 5 degrees.
    ** Rotate 6,7,...,'level' degrees in 1/2 degree increments.
    */

    /*
    ** (1) Degree: 2, 3, 4, 5  -->  1/4 degree increments cw and ccw
    */

    /* Counterclockwise */
    for (angle = -10; angle < -2; angle++) {
      radian = (-angle * 9)>>2;
      sintheta = -((radian*(262144-(radian*radian)/6))>>8);
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 3; angle <= 10; angle++) {
      radian = (angle * 9)>>2;
      sintheta = (radian*(262144-(radian*radian)/6))>>8;
      costheta = 524288-radian*radian;
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<1;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<1;
            (*((uint16*)(imgCnt+cntIndex)))+=2;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /*
    ** (2) Degree: 6, 7, ... , level  -->  1/2 degree increments cw and ccw
    */
    n = level;

    /* Counterclockwise */
    for (angle = -n; angle < -5; angle++) {
      radian = (-angle * 9)>>1;
      if (radian <= 360) {
        sintheta = -((radian*(262144-(radian*radian)/6))>>8);
        costheta = 524288-radian*radian;
      } else {
        sintheta = -(((radian*(262144-(radian*radian)/6))>>8) +
                    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                    radian)/42)*((11010048-radian*radian)>>10))>>21));
        costheta = (524288-radian*radian) +
                    (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                    ((7864320-radian*radian)>>10))>>12);
      }
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<2;
            (*((uint16*)(imgCnt+cntIndex)))+=4;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */

    /* Clockwise */
    for (angle = 6; angle <= n; angle++) {
      radian = (angle * 9)>>1;
      if (radian <= 360) {
        sintheta = (radian*(262144-(radian*radian)/6))>>8;
        costheta = 524288-radian*radian;
      } else {
        sintheta = ((radian*(262144-(radian*radian)/6))>>8) +
                    (((((((((radian*radian*radian)/120)>>3)*radian)>>10)*
                    radian)/42)*((11010048-radian*radian)>>10))>>21);
        costheta = (524288-radian*radian) +
                    (((((((radian*radian*radian)/24)>>3)*radian/30)>>10)*
                    ((7864320-radian*radian)>>10))>>12);
      }
      /* Loop through input */
      outIndex = 0;
      cntIndex = 0;
      for (y = 0; y < h; y++) {
        for (x = 0; x < w; x++) {
          xin = (xo+(((x-xo)*costheta+(y-yo)*sintheta)>>19));
          yin = (yo+(((xo-x)*sintheta+(y-yo)*costheta)>>19));
          if (xin >= 0 && xin < w && yin >= 0 && yin < h) {
            inIndex = (yin*w + xin)*3;
            *((uint32*)(sImgPtr+outIndex)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+1)) +=
              *((uint8*)(fullImgPtr+inIndex++))<<2;
            *((uint32*)(sImgPtr+outIndex+2)) +=
              *((uint8*)(fullImgPtr+inIndex))<<2;
            (*((uint16*)(imgCnt+cntIndex)))+=4;
          }
          cntIndex++;
          outIndex += 3;
        } /* end x loop */
      } /* end y loop */
    } /* end angle loop */
  } /* end if level */

  /* Add on original image */
  outIndex = 0;
  for (y = h*w*3; y; y--) {
    *((uint32*)(sImgPtr+outIndex)) += *((uint8*)(fullImgPtr+outIndex));
    outIndex++;
  } /* end y loop */

  /* Get output */
  /* Luma values */
  inIndex = 0;
  cntIndex = 0;
  cnt2Index = w;
  inc = w*3;
  out2ImgPtr = outImgPtr + w;
  r2ImgPtr = sImgPtr + inc;
  for (y = 0; y < h; y+=2) {
    for (x = 0; x < w; x+=2) {
      i = *((uint16*)(imgCnt+cntIndex++));
      *outClrPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex))) / i);
      *outClrPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex+1))) / i);
      /* Pixel 1 */
      inIndex += 2;
      *outImgPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex))) / i);
      /* Pixel 2 */
      i = *((uint16*)(imgCnt+cntIndex++));
      *outImgPtr++ = (uint8)((*((uint32*)(sImgPtr+inIndex+3))) / i);
      /* Pixel 3 */
      i = *((uint16*)(imgCnt+cnt2Index++));
      *out2ImgPtr++ = (uint8)((*((uint32*)(r2ImgPtr+inIndex++))) / i);
      /* Pixel 4 */
      i = *((uint16*)(imgCnt+cnt2Index++));
      inIndex += 2;
      *out2ImgPtr++ = (uint8)((*((uint32*)(r2ImgPtr+inIndex++))) / i);
    } /* end x loop */
    outImgPtr += w;
    out2ImgPtr += w;
    inIndex += inc;
    cntIndex += w;
    cnt2Index += w;
  } /* end y loop */

  /* Free memory */
  ipl_sys_free(fullImgPtr);
  ipl_sys_free(sImgPtr);
  ipl_sys_free(imgCnt);

  MSG_LOW("ipl_radial_blur_420lp marker_101\n");

  return IPL_SUCCESS;
} /* End ipl_radial_blur_420lp */


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_radial_blur

DESCRIPTION
  This function performs radial blur. The blurring level can be set
  to an integer between 0 and 100, inclusive. No blurring occurs
  when the blurring level is 0.

  Input and output image sizes must be equal.

  Input and output images must have the same color format, which
  can be RGB565, YCbCr 4:2:2, or YCbCr 4:2:0 line packed.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr points to the input image
  o_img_ptr points to the output image
  xo is the x-coordinate of the center of rotation
  yo is the y-coordinate of the center of rotation
  level is the level of blurring (range: 0 to 100)

RETURN VALUE
  IPL_SUCCESS   indicates operation was successful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_radial_blur
(
  ipl_image_type* i_img_ptr,   /* Points to the input image           */
  ipl_image_type* o_img_ptr,   /* Points to the output image          */
  int32 xo,                   /* x-coordinate of center of rotation  */
  int32 yo,                   /* y-coordinate of center of rotation  */
  uint8 level                  /* Blurring level                      */
)
{
  ipl_status_type retval;

  MSG_LOW("ipl_radial_blur marker_0\n");

  if (!i_img_ptr || !i_img_ptr->imgPtr ||
      !o_img_ptr || !o_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_radial_blur marker_200\n");
    return IPL_FAILURE;
  }

  /* Input and output color formats must be the same */
  if (i_img_ptr->cFormat != o_img_ptr->cFormat)
  {
    MSG_LOW("ipl_radial_blur marker_201\n");
    return IPL_FAILURE;
  }
  /* Input and output image sizes must be equal */
  if (i_img_ptr->dx != o_img_ptr->dx || i_img_ptr->dy != o_img_ptr->dy) {
    MSG_LOW("ipl_radial_blur marker_202\n");
    return IPL_FAILURE;
  }
  /* Blurring level must be between 0 and 100 inclusive */
  if (level > 100) {
    MSG_LOW("ipl_radial_blur marker_203\n");
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_radial_blur marker_1\n");

  /* Call the appropriate function */
  if (i_img_ptr->cFormat == IPL_RGB565)
  {
    retval = ipl_radial_blur_rgb565(i_img_ptr, o_img_ptr,xo, yo, level);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_radial_blur marker_204\n");
      return retval;
    }
  }
  else if (i_img_ptr->cFormat == IPL_YCbCr)
  {
    retval = ipl_radial_blur_ycbcr(i_img_ptr, o_img_ptr, xo, yo, level);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_radial_blur marker_205\n");
      return retval;
    }
  }
  else if (i_img_ptr->cFormat == IPL_YCbCr420_LINE_PK ||
           i_img_ptr->cFormat == IPL_YCrCb420_LINE_PK)
  {
    retval = ipl_radial_blur_420lp(i_img_ptr, o_img_ptr, xo, yo, level);
    if (retval != IPL_SUCCESS)
    {
      MSG_LOW("ipl_radial_blur marker_206\n");
      return retval;
    }
  }
  else
  {
    MSG_LOW("ipl_radial_blur marker_207\n");

    /* other formats not supported */
    return IPL_FAILURE;
  }

  MSG_LOW("ipl_radial_blur marker_100\n");
  return IPL_SUCCESS;
} /* End ipl_radial_blur */



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_whiteboard_ycbcr

DESCRIPTION
  This function takes an image taken of a white board, or chalk board, and
  cleans it up for easy viewing and printing.


DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  blackmode      0 = auto, 1 = do whiteboard, 2 = do blackboard
  th_noise       noise threshold, 10 is a good default
  rm_border      size of tiles to use when trying to remove non-whiteboard
                 parts of image. Default is 1 which maps to 8x8 tiles.

                 0: tile size 4;
                 1: tile size 8;
                 2: tile size 12;
                 3: tile size 0;

  gray           0 = auto, 1 = always make gray, 2 = never make gray

ALGORITHM

  Downsize IN image 16x in each dimension
  Record what median Y,Cb,Cr is for center portion, call medY, medCb, medCr
  If in auto mode, decide if image is whiteboard or blackboard based on luma
  Upsize image back to original, call this BG
  Compute difference in luma of BG  IN, call DIFFYs
  For tiles of size x*x, (default is 8x8, but user can change via UI),
    if no pixel in tile matches medY && medCb && medCr within some tolerance,
    the tile most likely is not part of whiteboard, set DIFFYs[p] forall
    pixels p in tile to 0.
  For every pixel p in  DIFFYs, if DIFFYs[p] less than threshold, set OUT[p]
    luma to 255, else 255  DIFFYs[p] * ratio. Do same for Chroma.


RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_whiteboard_ycbcr(ipl_image_type *in_img_ptr,
    ipl_image_type *out_img_ptr, int blackMode, int th_noise, int rm_border,
    int gray)
{
  unsigned int x;
  unsigned char * in;
  unsigned char * inChroma;
  unsigned char * out;

  int Y1_out, Y2_out;
  int C1_out, C2_out;

  ipl_image_type img_downsize;
  ipl_image_type bg_upsize;

  ipl_rect_type center;
  unsigned char ay, acb, acr;
  uint32 med;
  int ratio;

  // tunable parameters
  int wbThresh = 115;     // decided if image is blackboard or whiteboard
  int downscaleRatio = 16;// how much to downsize when getting bg
  uint32 grayThresh = 30; // how far do Cb and Cr need to be to considered
                          // part of pixel that has color
  int med_tol = 50;       // how close does our y,cb,cr, need to be to
                          // the median y,cb,cr to be considered close
  int fill_color = 16744576;  // What to set a tile to if no pixel matches
                              // median y, cb, cr.
                              // 32896

  MSG_LOW("ipl_whiteboard_ycbcr marker_0\n");


  // process the rm_border field which tells us how fine is the search
  // kernel that removes non-whiteboard elements
  switch (rm_border)
  {
    // if user select this, then use smaller tiles
    case 0:
      rm_border = 4;
    break;

    // if user select this, then use 8x8 tile which we think is good default
    case 1:
      rm_border = 8;
    break;

    // if user select this, then use big tiles
    case 2:
      rm_border = 12;
    break;

    // if user select this, then turn off process of trying to remove tiles
    case 3:
      rm_border = 0;
    break;

    // by default, use tile size 8x8 to decide if bg or not
    default:
      rm_border = 8;
    break;
  }


  // downsize by some factor in each dimension
  img_downsize.dx = in_img_ptr->dx >> downscaleRatio;
  img_downsize.dy = in_img_ptr->dy >> downscaleRatio;

  if (img_downsize.dx < 64)
    img_downsize.dx = IPL_MIN(in_img_ptr->dx,64);
  if (img_downsize.dy < 48)
    img_downsize.dy = IPL_MIN(in_img_ptr->dy,48);

  img_downsize.cFormat = IPL_YCbCr;
  if (ipl_malloc_img(&img_downsize))
  {
    MSG_LOW("ipl_whiteboard_ycbcr marker_200\n");
    return IPL_NO_MEMORY;
  }

  MSG_LOW("ipl_whiteboard_ycbcr marker_1\n");

  if (ipl_downsize(in_img_ptr, &img_downsize, NULL))
  {
    ipl_free_img(&img_downsize);
    MSG_LOW("ipl_whiteboard_ycbcr marker_201\n");
    return IPL_FAILURE;
  }

  // You would think that since we downsized n times we wouldn't have to
  // blur, but it does help.
  if (ipl_filter_image(&img_downsize, NULL, IPL_BLUR, 3))
  {
    ipl_free_img(&img_downsize);
    MSG_LOW("ipl_whiteboard_ycbcr marker_202\n");
    return IPL_FAILURE;
  }

  // lets see if this is whiteboard or blackboard, do on downsized imaged
  // find average of center box
  center.x = img_downsize.dx/5;
  center.y = img_downsize.dy/4;
  center.dx = 3*img_downsize.dx/5;
  center.dy = 2*img_downsize.dy/4;

  // great for debugging
  //ipl_draw_box(&img_downsize, NULL, &center, 0, 65535);
  //ipl_copy_and_paste(&img_downsize, out_img_ptr, NULL, NULL);

  // compute median for border removal we do later
  med = ipl_calc_median(&img_downsize, &center);
  if (med == 0)
  {
    MSG_LOW("ipl_whiteboard_ycbcr marker_203\n");
    return IPL_FAILURE;
  }

  // make all boxes not the bg color the bg color so
  unpack_ycbcr(med, &ay, &acb, &acr);
  if (IPL_EFX_DEBUG) //lint !e774 !e506
  {
    printf("Avg y,cb,cr for this image is %d,%d,%d\n", ay, acb, acr);
    printf("if ay = %d >? %d white\n",
        ay, wbThresh);
  }

  // if we are auto detecting white vs blackboard, use the avegage luma
  // of the center of image to determine how we proceed
  if (blackMode == 0)
  {
    acb = IPL_ABS((acb-128));
    acr = IPL_ABS((acr-128));
    if (ay < wbThresh)
    {
      if (IPL_EFX_DEBUG) //lint !e774 !e506
        printf("should do blackboard if auto\n");
      blackMode = 2;
    }
    else
    {
      if (IPL_EFX_DEBUG) //lint !e774 !e506
        printf("should do whiteboard if auto\n");
      blackMode = 1;
    }
  }

  // upsize
  bg_upsize.dx = in_img_ptr->dx;
  bg_upsize.dy = in_img_ptr->dy;
  bg_upsize.cFormat = IPL_LUMA_ONLY;
  if (ipl_malloc_img(&bg_upsize))
  {
    ipl_free_img(&img_downsize);
    MSG_LOW("ipl_whiteboard_ycbcr marker_204\n");
    return IPL_NO_MEMORY;
  }

  if (ipl_crop_resize_rot(&img_downsize, &bg_upsize, NULL, NULL, IPL_NOROT, IPL_QUALITY_LOW))
  {
    ipl_free_img(&bg_upsize);
    ipl_free_img(&img_downsize);
    MSG_LOW("ipl_whiteboard_ycbcr marker_205\n");
    return IPL_FAILURE;
  }
  else
  {
    // lets sys_free some memory we dont need anymore
    ipl_free_img(&img_downsize);
  }

  //ipl_copy_and_paste(&bg_upsize, out_img_ptr, NULL, NULL);

  MSG_LOW("ipl_whiteboard_ycbcr marker_2\n");
#if 1

  // do blackboard
  if (blackMode == 2)
  {
    if (IPL_EFX_DEBUG) //lint !e774  !e506
      printf("Doing blackborad \n");

    ratio = 3;          // how much to boost Chroma if text on whiteboard
    // th_noise = th_noise >> 1; // we need a smaller threshold when doing
                              // blackboard

    // subtract the lumas to create mask which will be used to show which CBs
    // we want to keep
    if (ipl_compose(in_img_ptr, &bg_upsize, &bg_upsize, IPL_SUBTRACT_LUMA, 0))
    {
      ipl_free_img(&bg_upsize);
      MSG_LOW("ipl_whiteboard_ycbcr marker_206\n");
      return IPL_FAILURE;
    }
    else

    if (rm_border > 0)
    {
      // remove parts of blurred bg image that did not match the main board
      // med = color to test
      // 50 = tolerance
      // 167.. good color
      // 32896 bad color
      if (ipl_test_and_set_block(in_img_ptr,NULL,&bg_upsize,NULL,1, rm_border, rm_border, med, 50, 16744576, 32896) == IPL_FAILURE)
      {
        ipl_free_img(&bg_upsize);
        MSG_LOW("ipl_whiteboard_ycbcr marker_207\n");
        return IPL_FAILURE;
      }
    }

    in = bg_upsize.imgPtr;
    inChroma = in_img_ptr->imgPtr;
    out = out_img_ptr->imgPtr;

    // check for each Y value, two neighbour Ys share one group of Cb,
    // Cr. the order is CbYCrY....
    out++;

    for (x = 1; x < (in_img_ptr->dx * in_img_ptr->dy * 2); x+=4)
    {
      if ((*in) <= th_noise)
		    Y1_out = (*in) ;				// or = 235
	    else
		    Y1_out = (*in) * ratio;

	    if ((*(in+1)) <= th_noise)
		    Y2_out = *(in+1);			// or = 235
	    else
		    Y2_out = *(in+1) * ratio;

	    // if both Y < noise, the Cb = Cr = 0; otherwise CbCr are enhanced
	    if (((*in) <= th_noise) && ((*(in+1)) <= th_noise))
	    {
		    C1_out = 128;
		    C2_out = 128;
	    }
	    else
	    {
		    C1_out = (((*(inChroma))   - 128) * ratio) + 128;
		    C2_out = (((*(inChroma+2)) - 128) * ratio) + 128;
	    }

      // posterize??
		  Y1_out >>= 4;
		  Y1_out <<= 4;

		  Y2_out >>= 4;
		  Y2_out <<= 4;

		  *(out-1) = CLIPIT(C1_out);
      *out = CLIPIT(Y1_out);
		  *(out+1) = CLIPIT(C2_out);
		  *(out+2) = CLIPIT(Y2_out);

      in += 2;
      inChroma += 4;
      out += 4;
    }
  }
  else
  {
    if (IPL_EFX_DEBUG) //lint !e774 !e506
      printf("Doing whiteboard \n");
    ratio = 4;          // how much to boost Chroma if text on whiteboard

    if (ipl_compose(&bg_upsize, in_img_ptr, &bg_upsize, IPL_SUBTRACT_LUMA, 0))
    {
      ipl_free_img(&bg_upsize);
      MSG_LOW("ipl_whiteboard_ycbcr marker_208\n");
      return IPL_FAILURE;
    }

    if (rm_border)
    {
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("Removing border via rm_border\n");

      // remove parts of blurred bg image that did not match the main board
      if (ipl_test_and_set_block(in_img_ptr,NULL,&bg_upsize,NULL,1, rm_border, rm_border, med, med_tol, fill_color, 0) == IPL_FAILURE)
      {
        ipl_free_img(&bg_upsize);
        MSG_LOW("ipl_whiteboard_ycbcr marker_209\n");
        return IPL_FAILURE;
      }
    }

    in = bg_upsize.imgPtr;
    inChroma = in_img_ptr->imgPtr;
    out = out_img_ptr->imgPtr;

    // check for each Y value, two neighbour Ys share one group of Cb,
    // Cr. the order is CbYCrY....
    out++;

    for (x = 1; x < (in_img_ptr->dx * in_img_ptr->dy * 2); x+=4)
    {
      if ((*in) <= th_noise)
		    Y1_out = 255 - (*in);				// or = 235
	    else
		    Y1_out =  255 - (*in) * ratio;

	    if ((*(in+1)) <= th_noise)
		    Y2_out = 255 - (*(in+1));			// or = 235
	    else
		    Y2_out = 255 - (*(in+1)) * ratio;

	    // if both Y < noise, the Cb = Cr = 0; otherwise CbCr are enhanced
	    if (((*in) <= th_noise) && ((*(in+1)) <= th_noise))
	    {
		    C1_out = 128;
		    C2_out = 128;
	    }
	    else
	    {
		    C1_out = (((*(inChroma))   - 128) * ratio) + 128;
		    C2_out = (((*(inChroma+2)) - 128) * ratio) + 128;
	    }


      // posterize??
		  Y1_out >>= 4;
		  Y1_out <<= 4;

		  Y2_out >>= 4;
		  Y2_out <<= 4;

		  *(out-1) = CLIPIT(C1_out);
      *out = CLIPIT(Y1_out);
		  *(out+1) = CLIPIT(C2_out);
		  *(out+2) = CLIPIT(Y2_out);

      in += 2;
      inChroma += 4;
      out += 4;
    }
  }

  // lets see if center of resulting image has much color
  // if not,then make image grayscale!
#if 1

  if (gray == 0 || gray == 1)
  {
    if (gray == 0)
    {
      if (IPL_EFX_DEBUG)  //lint !e774 !e506
        printf("Making grayscale in autom mode\n");

      center.x = out_img_ptr->dx/7;
      center.y = out_img_ptr->dy/7;
      center.dx = 3*out_img_ptr->dx/7;
      center.dy = 3*out_img_ptr->dy/7;

      // great for debugging
      //ipl_draw_box(out_img_ptr, NULL, &center, 0, 65535);

      // compute avg for border removal we do later
      if (ipl_count_members(out_img_ptr, &center, 0, &grayThresh, &med, NULL))
      {
        ipl_free_img(&bg_upsize);
        MSG_LOW("ipl_whiteboard_ycbcr marker_210\n");
        return IPL_FAILURE;
      }

      if (IPL_EFX_DEBUG) //lint !e774 !e506
        printf("Found %lu color pixels in %lux%lu. Of %lu pixels, cut off is %lu\n",
        med, center.dx,center.dy, center.dx*center.dy,
        (center.dx*center.dy)>>6);

      // see if we have a lot of color pixels
      // If we are whiteboard, then okay, if we are blackboard and we do make
      // the image grayscale, then also invert it cause it is easier to read
      // and print
    }

    if (blackMode == 1)
    {
      if (gray == 1 || med > (center.dx*center.dy)>>6)
      {
        // however, study has shown, that if we have TOO many, then the image
        // is busy and not really a few lines or some diagrams on whiteboard,
        // rather, picture from yellowpages or something where we color is
        // not importnat
        if (IPL_EFX_DEBUG)  //lint !e774 !e506
          printf("Let see if image has too much color, cut off is %lu\n",
          (center.dx*center.dy)/12);

        if (gray == 1 || med > (center.dx*center.dy)/12)
        {
          if (IPL_EFX_DEBUG) //lint !e774 !e506
            printf("Image has too much color, lets make result grayscale\n");

          out = out_img_ptr->imgPtr;
          for (x = out_img_ptr->dx * out_img_ptr->dy; x; x--)
          {
            *out = 128;
            out += 2;
          }
        }
        else
        {
          if (IPL_EFX_DEBUG) //lint !e774 !e506
            printf("Lets NOT make result grayscale since color pixels seem valid\n");
        }
      }
      else
      {
        if (IPL_EFX_DEBUG) //lint !e774 !e506
          printf("Lets make result grayscale\n");

        // check to see if image has color. If so, preserve it, if not, then
        // make the image grayscale
        out = out_img_ptr->imgPtr;
        for (x = out_img_ptr->dx * out_img_ptr->dy; x; x--)
        {
          *out = 128;
          out += 2;
        }
      }
    }
    else
    {
      if (gray == 1 || med > (center.dx*center.dy)>>6)
      {
        // however, study has shown, that if we have TOO many, then the image
        // is busy and not really a few lines or some diagrams on whiteboard,
        // rather, picture from yellowpages or something where we color is
        // not importnat
        if (IPL_EFX_DEBUG) //lint !e774 !e506
          printf("Let see if image has too much color, cut off is %lu\n",
            (center.dx*center.dy)/12);

        if (gray == 1 || med > (center.dx*center.dy)/12)
        {
          if (IPL_EFX_DEBUG) //lint !e774 !e506
            printf("Image has too much color, lets make result grayscale\n");

          out = out_img_ptr->imgPtr;
          for (x = out_img_ptr->dx * out_img_ptr->dy; x; x--)
          {
            *out++ = 128;
            *out = (255 - *out);
            out++;
          }
        }
        else
        {
          if (IPL_EFX_DEBUG) //lint !e774 !e506
            printf("Lets NOT make result grayscale since color pixels seem valid\n");
        }
      }
      else
      {
        if (IPL_EFX_DEBUG) //lint !e774 !e506
          printf("Lets make result grayscale\n");

        // check to see if image has color. If so, preserve it, if not, then
        // make the image grayscale
        out = out_img_ptr->imgPtr;
        for (x = out_img_ptr->dx * out_img_ptr->dy; x; x--)
        {
          *out++ = 128;
          *out = (255 - *out);
          out++;
        }
      }
    }
  }
  else
  {
    if (IPL_EFX_DEBUG) //lint !e774 !e506
      printf("Told not to even consider making image grayscale\n");
  }

#endif
#endif

  ipl_free_img(&bg_upsize);
  MSG_LOW("ipl_whiteboard_ycbcr marker_100\n");
  return IPL_SUCCESS;
}






/* <EJECT> */
/*===========================================================================

FUNCTION ipl_whiteboard

DESCRIPTION
  This function takes an image taken of a white board, or chalk board, and
  cleans it up for easy viewing and printing.


DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  blackmode      0 = auto, 1 = do whiteboard, 2 = do blackboard
  th_noise       noise threshold, 10 is a good default
  rm_border      size of tiles to use when trying to remove non-whiteboard
                 parts of image. Default is 1 which maps to 8x8 tiles.

                 0: tile size 4;
                 1: tile size 8;
                 2: tile size 12;
                 3: tile size 0;

  gray           0 = auto, 1 = always make gray, 2 = never make gray


RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_whiteBoard(ipl_image_type *in_img_ptr,
    ipl_image_type *out_img_ptr, int blackMode, int th_noise, int rm_border, int gray)
{

  MSG_LOW("ipl_whiteboard marker_0\n");

  if (!in_img_ptr  || !in_img_ptr->imgPtr ||
      !out_img_ptr || !out_img_ptr->imgPtr)
  {
    MSG_LOW("ipl_whiteboard marker_200\n");
    return IPL_FAILURE;
  }

  if (th_noise < 0 || th_noise > 255)
    th_noise = 19;

  if (rm_border < 0)
    rm_border = 0;

  if (in_img_ptr->cFormat != out_img_ptr->cFormat)
  {
    MSG_LOW("ipl_whiteboard marker_201\n");
    return IPL_FAILURE;
  }

  if (in_img_ptr->dx != out_img_ptr->dx ||
      (in_img_ptr->dy != out_img_ptr->dy))
  {
    MSG_LOW("ipl_whiteboard marker_202\n");
    return IPL_FAILURE;
  }

  if (in_img_ptr->cFormat == IPL_YCbCr)
  {
    MSG_LOW("ipl_whiteboard marker_100\n");
    return(ipl_whiteboard_ycbcr(in_img_ptr,out_img_ptr, blackMode,
          th_noise, rm_border, gray));
  }
  else
  {
    MSG_LOW("ipl_whiteboard marker_203\n");
    return IPL_FAILURE;
  }
}


#endif



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_match_histogram

DESCRIPTION
  This function analyazes the distribution of a histogram

DEPENDENCIES
  None

ARGUMENTS IN
  hist          histogram to look at
  hweights      weight for pixel count at that level

RETURN VALUE
  sum            sum of histogram times weights
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl_match_histogram
(
  ipl_histogram_type * hist,
  ipl_curve_type * hweights,
  int32 * sum,
  int32 * lookedat
)
{
  uint32 i;
  MSG_LOW("ipl_match_histogram maker_0\n");

  if (hist == NULL || hweights == NULL)
  {
    MSG_LOW("ipl_match_histogram maker_200\n");
    return IPL_FAILURE;
  }

  //user may have forgotten to tell use size of histogram
  if (hist->size == 0)
    hist->size = 256;

  if (hweights->size == 0)
    hweights->size = 256;

  *sum = 0;
  *lookedat = 0;
  for (i = 0 ; i < hist->size; i++)
  {
    if (hweights->v[i] == 0)
    {
      // dont count these pixels
    }
    else
    {
      *sum      += (hist->v[i] * hweights->v[i]);
      *lookedat += hist->v[i];
    }
  }

  MSG_LOW("ipl_match_histogram maker_100\n");
  return IPL_SUCCESS;
}



/* <EJECT> */
/*===========================================================================

FUNCTION ipl_analyze_histogram

DESCRIPTION
  This function stretches the histogram of an image to provide more detail
  in the lights and darks.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr      pointer to the input image
  o_img_ptr      pointer to the output image
  thresholdQ8

RETURN VALUE
  IPL_SUCCESS    indicates operation was successful
  IPL_FAILURE    otherwise

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_analyze_histogram
(
  ipl_image_type      * i_img_ptr,
  ipl_histogram_type  * hist,
  ipl_rect_type       * crop,
  uint32         mode
)
{
  uint32 wh;
  int32 sum = 0;
  int32 lookedat = 0;
  uint32 per, dist;
  ipl_histogram_type histogram;
  ipl_histogram_type * thist;
  ipl_status_type retval = IPL_SUCCESS;

  MSG_LOW("ipl_analyze_histogram marker_0\n");

  // setup some vars
  wh = i_img_ptr->dx * i_img_ptr->dy;

  // if no histogram provided, then we comput it ourselves
  if (hist == NULL)
  {
    histogram.size = 256;
    histogram.channel = IPL_CHANNEL_LUMA;
    ipl_calc_histograms(i_img_ptr, NULL, &histogram, IPL_QUALITY_HIGH);
    thist = &histogram;
  }
  else
  {
    //user may have forgotten to tell use size of histogram
    if (hist->size == 0)
      hist->size = 256;
    thist = hist;
  }

  // now see if histogram matches what we are looking for
  switch(mode)
  {
    case 0:
      ipl_match_histogram(thist, &hweights, &sum, &lookedat);
      per =  ((lookedat * 100) / wh);
      dist = ((sum * 100) / lookedat);
      //printf("%3.2fp at ends (%d), wsum of %fp (%d), given %d pix\n", per, lookedat, dist, sum, wh);
      printf("%lu at ends, wsum of %lu\n", per, dist);
    break;

    default:
      MSG_LOW("ipl_analyze_histogram marker_200\n");
      retval = IPL_FAILURE;
    break;
  }

  MSG_LOW("ipl_analyze_histogram marker_100\n");
  return retval;
}



#if 0


/* <EJECT> */
/*===========================================================================

FUNCTION ipl_auto_contrast

DESCRIPTION
  This function will calculate the image histogram.
  It currently computes luma only, but the infrastructre is here to do all
  3 channels.



DEPENDENCIES
  None

ARGUMENTS IN/OUT
  in is the input image whose histogram needs to be calculated
  crop is the area to look at
  img_hist is where we write values

  Currently only support RGB565 and YCbCr images
  The historgram returned is only the luma channel right now


RETURN VALUE
  None

SIDE EFFECTS
  None

===========================================================================*/
API_EXTERN ipl_status_type ipl_auto_contrast
(
  ipl_image_type      *in,
  ipl_image_type      *out
)
{
  uint32 x,y;
  unsigned int index;
  unsigned char * p;
  unsigned char * c;
  ipl_rect_type crop;
  int i1;
  uint16 * p16;
  uint8 r,g,b;
  uint8 luma1, cb, cr;
  int rc;
  ipl_histogram_type img_hist;
  int mini, maxi;
  int i;
  uint32 avg;
  float scale;
  ipl_curve_type gamma;

  MSG_LOW("ipl_auto_conrast marker_0\n");

  if (in == NULL)
  {
    MSG_LOW("ipl_auto_contrast marker_200\n");
    return IPL_FAILURE;
  }
  if (in->imgPtr == NULL)
  {
    MSG_LOW("ipl_auto_contrast marker_201\n");
    return IPL_FAILURE;
  }

  img_hist.size = 256;
  img_hist.channel = IPL_CHANNEL_LUMA;

  // compute histogram
  if (ipl_calc_histogram (in, NULL, &img_hist))
  {
    MSG_LOW("ipl_auto_contrast marker_202\n");
    return IPL_FAILURE;
  }

  // print it
  if (IPL_EFX_DEBUG)  //lint !e774 !e506
  {
    for (i = 0; i < img_hist.size; i++)
      printf("hist %d: %d\n", i, img_hist.v[i]);
    printf("\n");
  }

  // compute min
  for (i = 0; i < img_hist.size; i++)
  {
    if (img_hist.v[i] != 0)
      break;
  }
  if (i == img_hist.size)
    mini = 0;
  else
    mini = i;
  printf("min y is %d\n", i);

  // compute max
  for (i = img_hist.size-1; i; i--)
  {
    //printf("max: %d at %d", img_hist.v[i], i);
    if (img_hist.v[i] != 0)
      break;
  }
  if (i == 0)
    maxi = img_hist.size;
  else
    maxi = i;
  printf("max y is %d\n", i);

  // compute avg
  avg = 0;
  for (i = 0; i < img_hist.size; i++)
  {
    avg += (i * img_hist.v[i]);
  }
  avg = avg / (in->dx*in->dy);
  printf("avg y is %d\n", avg);

  // create gamma curve
#if 1
  // map mean to max    to  mean to 255
  // avg scale 128
  // max scale 138
  // 124 steps to 10 steps
  gamma.size = 256;

  scale = 255.0/maxi;
  printf("getting %d to 255 requires scale of %f\n", maxi, scale);
  scale = (scale) / (maxi - avg);
  printf("getting %d to 255 requires each step of %f\n", maxi, scale);

  for (i = avg; i <= maxi; i++)
  {
    gamma.v[i] = (i + ((i - avg) * scale));
    printf("%d + ((%d - %d) * %f)\n", i, i, avg, scale);
  }

  for (i = maxi; i < gamma.size; i++)
    gamma.v[i] = img_hist.size-1;

  // map mean to min to  mean to 0
  scale = (avg)/(avg - mini);
  printf("getting %d to 0 requires scale of %f\n", mini, scale);
  for (i = avg; i > mini; i--)
    gamma.v[i] =  i * (1 + (avg - i) * scale);
  for (i = mini; i; i--)
    gamma.v[i] = 0;

  if (IPL_EFX_DEBUG)  //lint !e774 !e506
  {
    for (i = 0; i < gamma.size; i++)
      printf("gamma %d: %d\n", i, gamma.v[i]);
    printf("\n");
  }
#endif


  MSG_LOW("ipl_auto_contrast marker_100\n");
  return IPL_SUCCESS;

}


#endif




/*lint -restore */
