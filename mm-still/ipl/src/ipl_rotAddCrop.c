/*===========================================================================

                          IPL2_RGB565.c

DESCRIPTION
  This file contains the implementation of the IPL APIs. Below is an
  approximate call flow. Compressed into this function header.


             ipl2_handle_RGB565Img
                              |
                              |-----------------------------|
                             /                              |
      ipl2_rgb565Img(norot, but framing)  |
                             |                              |
                             |     ipl2_cropFrame_RGB565(rotation)
                             |                              |
                             |                              |(iconlist == TRUE)
                             |                              |
                             |---------------ipl2_process_RGBIconList
                            (iconlist == TRUE)

EXTERNALIZED FUNCTIONS

  ipl2_handle_RGB565Img()

    Single function which calls other function to do various processing on
    RGB565 based images.


INITIALIZATION AND SEQUENCING REQUIREMENTS

  None

Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
===========================================================================*/

/*===========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.


$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
03/22/05   babakf  added YCrCb420_LINE_PK support to rotAddCrop (no frames).
01/27/05   babakf  Use sadeep's faster rgb565 to ycbcr conversion for all
                   rot_add_crop functions. 
05/04/04   srk     Review comments from David, Roy, Ramesh, Nikhil, Jun
                   and Nish
04/20/04   srk     Moved the processing of RGB565 based images into this file.
=========================================================================== */

/*=========================================================================

                     INCLUDE FILES FOR MODULE

===========================================================================*/
#include <stdio.h>
#include <string.h>
#include "ipl_types.h"
#include "ipl_qvp.h"
#include "ipl_helper.h"
#include "ipl_rotAddCrop.h"



/*lint -save -e506, constant value boolean is totally okay */
/*lint -save -e508, constant value boolean is totally okay */
/*lint -save -e509, constant value boolean is totally okay */
/*lint -save -e613  don worry about checking if input is null */
/*lint -save -e703, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e734, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e736, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e737, loss of precision,signed to unsigned,usigned to signed OK*/
/*lint -save -e747, errors in create gamma curve are okay */
/*lint -save -e774, constant value boolean is totally okay */
/*lint -save -e818, lets not worry about const optimization right now */
/*lint -save -e834, this warning is just dumb */
/*lint -save -e826, we should look into this someday */



/*--------------------------------------------------------------------------
  * lookup table which simplifies the conversion from YCBR to RGB565
  * these tables store computationally intensive intermediate
  * functions. Look at ipl_init_lookup_tables for more .
  * Selection of these smaller tables and co-locating them
  * is to aid better cache performance.
--------------------------------------------------------------------------*/
int16 ipl2_CrToRTable[0xff + 1];
int16 ipl2_CrToGTable[0xff + 1];
int16 ipl2_CbToGTable[0xff + 1];
int16 ipl2_CbToBTable[0xff + 1];



int16 ipl2_rgb565ToYR[ 0xff + 1 ];  /* R to Y conversion normalized RGB565 */
int16 ipl2_rgb565ToYG[ 0xff + 1 ];  /* G to Y conversion normalized RGB565 */
int16 ipl2_rgb565ToYB[ 0xff + 1 ];  /* B to Y conversion normalized RGB565 */
int16 ipl2_rgb565ToCbR[ 0xff + 1 ]; /* R to Cb conversion normalized RGB565 */
int16 ipl2_rgb565ToCbG[ 0xff + 1 ]; /* G to Cb conversion normalized RGB565 */
int16 ipl2_rgb565ToCbB[ 0xff + 1 ]; /* B to Cb conversion normalized RGB565 */
int16 ipl2_rgb565ToCrR[ 0xff + 1 ]; /* R to Cr conversion normalized RGB565 */
int16 ipl2_rgb565ToCrG[ 0xff + 1 ]; /* G to Cr conversion normalized RGB565 */
int16 ipl2_rgb565ToCrB[ 0xff + 1 ]; /* B to Cr conversion normalized RGB565 */

//uint8 ipl2_rgb565B2ToG[ 0xff + 1 ];
//uint8 ipl2_rgb565B1ToG[ 0xff + 1 ];

/*--------------------------------------------------------------------------
 *     Multiplcation for 3.
 *--------------------------------------------------------------------------*/
static int16 multby3_lookup_table[0xff  * 2 + 1];

/*--------------------------------------------------------------------------
 *       Since the input can be -ve we will offset the table by 255 and use -ve
 *             index.
 *--------------------------------------------------------------------------*/
static int16 * ipl2_multab3by4 = multby3_lookup_table   + 0xff;


/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit r value to 5 bits and shifted
  for RGB565 format
--------------------------------------------------------------------------*/
uint16 const ipl2_r5xx[512] = {
  0, 0, 0, 0, 2048, 2048, 2048, 2048,
  2048, 2048, 2048, 2048, 4096, 4096, 4096, 4096,
  4096, 4096, 4096, 4096, 6144, 6144, 6144, 6144,
  6144, 6144, 6144, 6144, 8192, 8192, 8192, 8192,
  8192, 8192, 8192, 8192, 10240, 10240, 10240, 10240,
  10240, 10240, 10240, 10240, 12288, 12288, 12288, 12288,
  12288, 12288, 12288, 12288, 14336, 14336, 14336, 14336,
  14336, 14336, 14336, 14336, 16384, 16384, 16384, 16384,
  16384, 16384, 16384, 16384, 18432, 18432, 18432, 18432,
  18432, 18432, 18432, 18432, 20480, 20480, 20480, 20480,
  20480, 20480, 20480, 20480, 22528, 22528, 22528, 22528,
  22528, 22528, 22528, 22528, 24576, 24576, 24576, 24576,
  24576, 24576, 24576, 24576, 26624, 26624, 26624, 26624,
  26624, 26624, 26624, 26624, 28672, 28672, 28672, 28672,
  28672, 28672, 28672, 28672, 30720, 30720, 30720, 30720,
  30720, 30720, 30720, 30720, 32768, 32768, 32768, 32768,
  32768, 32768, 32768, 32768, 34816, 34816, 34816, 34816,
  34816, 34816, 34816, 34816, 36864, 36864, 36864, 36864,
  36864, 36864, 36864, 36864, 38912, 38912, 38912, 38912,
  38912, 38912, 38912, 38912, 40960, 40960, 40960, 40960,
  40960, 40960, 40960, 40960, 43008, 43008, 43008, 43008,
  43008, 43008, 43008, 43008, 45056, 45056, 45056, 45056,
  45056, 45056, 45056, 45056, 47104, 47104, 47104, 47104,
  47104, 47104, 47104, 47104, 49152, 49152, 49152, 49152,
  49152, 49152, 49152, 49152, 51200, 51200, 51200, 51200,
  51200, 51200, 51200, 51200, 53248, 53248, 53248, 53248,
  53248, 53248, 53248, 53248, 55296, 55296, 55296, 55296,
  55296, 55296, 55296, 55296, 57344, 57344, 57344, 57344,
  57344, 57344, 57344, 57344, 59392, 59392, 59392, 59392,
  59392, 59392, 59392, 59392, 61440, 61440, 61440, 61440,
  61440, 61440, 61440, 61440, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/

  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488,
  63488, 63488, 63488, 63488, 63488, 63488, 63488, 63488

};
/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit g value to 6 bits and shifted
  for RGB565 format
--------------------------------------------------------------------------*/
uint16 const ipl2_gx6x[340] = {
  0, 0, 32, 32, 32, 32, 64, 64,
  64, 64, 96, 96, 96, 96, 128, 128,
  128, 128, 160, 160, 160, 160, 192, 192,
  192, 192, 224, 224, 224, 224, 256, 256,
  256, 256, 288, 288, 288, 288, 320, 320,
  320, 320, 352, 352, 352, 352, 384, 384,
  384, 384, 416, 416, 416, 416, 448, 448,
  448, 448, 480, 480, 480, 480, 512, 512,
  512, 512, 544, 544, 544, 544, 576, 576,
  576, 576, 608, 608, 608, 608, 640, 640,
  640, 640, 672, 672, 672, 672, 704, 704,
  704, 704, 736, 736, 736, 736, 768, 768,
  768, 768, 800, 800, 800, 800, 832, 832,
  832, 832, 864, 864, 864, 864, 896, 896,
  896, 896, 928, 928, 928, 928, 960, 960,
  960, 960, 992, 992, 992, 992, 1024, 1024,
  1024, 1024, 1056, 1056, 1056, 1056, 1088, 1088,
  1088, 1088, 1120, 1120, 1120, 1120, 1152, 1152,
  1152, 1152, 1184, 1184, 1184, 1184, 1216, 1216,
  1216, 1216, 1248, 1248, 1248, 1248, 1280, 1280,
  1280, 1280, 1312, 1312, 1312, 1312, 1344, 1344,
  1344, 1344, 1376, 1376, 1376, 1376, 1408, 1408,
  1408, 1408, 1440, 1440, 1440, 1440, 1472, 1472,
  1472, 1472, 1504, 1504, 1504, 1504, 1536, 1536,
  1536, 1536, 1568, 1568, 1568, 1568, 1600, 1600,
  1600, 1600, 1632, 1632, 1632, 1632, 1664, 1664,
  1664, 1664, 1696, 1696, 1696, 1696, 1728, 1728,
  1728, 1728, 1760, 1760, 1760, 1760, 1792, 1792,
  1792, 1792, 1824, 1824, 1824, 1824, 1856, 1856,
  1856, 1856, 1888, 1888, 1888, 1888, 1920, 1920,
  1920, 1920, 1952, 1952, 1952, 1952, 1984, 1984,
  1984, 1984, 2016, 2016, 2016, 2016, 2016, 2016,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/

  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016, 2016, 2016, 2016, 2016,
  2016, 2016, 2016, 2016
};

/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit b value to 5 bits and shifted
  for RGB565 format
--------------------------------------------------------------------------*/
uint16 const ipl2_bxx5[] = {
  0, 0, 0, 0, 1, 1, 1, 1,
  1, 1, 1, 1, 2, 2, 2, 2,
  2, 2, 2, 2, 3, 3, 3, 3,
  3, 3, 3, 3, 4, 4, 4, 4,
  4, 4, 4, 4, 5, 5, 5, 5,
  5, 5, 5, 5, 6, 6, 6, 6,
  6, 6, 6, 6, 7, 7, 7, 7,
  7, 7, 7, 7, 8, 8, 8, 8,
  8, 8, 8, 8, 9, 9, 9, 9,
  9, 9, 9, 9, 10, 10, 10, 10,
  10, 10, 10, 10, 11, 11, 11, 11,
  11, 11, 11, 11, 12, 12, 12, 12,
  12, 12, 12, 12, 13, 13, 13, 13,
  13, 13, 13, 13, 14, 14, 14, 14,
  14, 14, 14, 14, 15, 15, 15, 15,
  15, 15, 15, 15, 16, 16, 16, 16,
  16, 16, 16, 16, 17, 17, 17, 17,
  17, 17, 17, 17, 18, 18, 18, 18,
  18, 18, 18, 18, 19, 19, 19, 19,
  19, 19, 19, 19, 20, 20, 20, 20,
  20, 20, 20, 20, 21, 21, 21, 21,
  21, 21, 21, 21, 22, 22, 22, 22,
  22, 22, 22, 22, 23, 23, 23, 23,
  23, 23, 23, 23, 24, 24, 24, 24,
  24, 24, 24, 24, 25, 25, 25, 25,
  25, 25, 25, 25, 26, 26, 26, 26,
  26, 26, 26, 26, 27, 27, 27, 27,
  27, 27, 27, 27, 28, 28, 28, 28,
  28, 28, 28, 28, 29, 29, 29, 29,
  29, 29, 29, 29, 30, 30, 30, 30,
  30, 30, 30, 30, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/

  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31,
  31, 31, 31, 31, 31, 31, 31, 31
};

/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit r value to 6 bits and shifted
  for RGB666 format
--------------------------------------------------------------------------*/
uint32 const ipl2_r666[512] = {
  0x0, 0x0, 0x1000, 0x1000, 0x1000, 0x1000, 0x2000, 0x2000,
  0x2000, 0x2000, 0x3000, 0x3000, 0x3000, 0x3000, 0x4000, 0x4000,
  0x4000, 0x4000, 0x5000, 0x5000, 0x5000, 0x5000, 0x6000, 0x6000,
  0x6000, 0x6000, 0x7000, 0x7000, 0x7000, 0x7000, 0x8000, 0x8000,
  0x8000, 0x8000, 0x9000, 0x9000, 0x9000, 0x9000, 0xa000, 0xa000,
  0xa000, 0xa000, 0xb000, 0xb000, 0xb000, 0xb000, 0xc000, 0xc000,
  0xc000, 0xc000, 0xd000, 0xd000, 0xd000, 0xd000, 0xe000, 0xe000,
  0xe000, 0xe000, 0xf000, 0xf000, 0xf000, 0xf000, 0x10000, 0x10000,
  0x10000, 0x10000, 0x11000, 0x11000, 0x11000, 0x11000, 0x12000, 0x12000,
  0x12000, 0x12000, 0x13000, 0x13000, 0x13000, 0x13000, 0x14000, 0x14000,
  0x14000, 0x14000, 0x15000, 0x15000, 0x15000, 0x15000, 0x16000, 0x16000,
  0x16000, 0x16000, 0x17000, 0x17000, 0x17000, 0x17000, 0x18000, 0x18000,
  0x18000, 0x18000, 0x19000, 0x19000, 0x19000, 0x19000, 0x1a000, 0x1a000,
  0x1a000, 0x1a000, 0x1b000, 0x1b000, 0x1b000, 0x1b000, 0x1c000, 0x1c000,
  0x1c000, 0x1c000, 0x1d000, 0x1d000, 0x1d000, 0x1d000, 0x1e000, 0x1e000,
  0x1e000, 0x1e000, 0x1f000, 0x1f000, 0x1f000, 0x1f000, 0x20000, 0x20000,
  0x20000, 0x20000, 0x21000, 0x21000, 0x21000, 0x21000, 0x22000, 0x22000,
  0x22000, 0x22000, 0x23000, 0x23000, 0x23000, 0x23000, 0x24000, 0x24000,
  0x24000, 0x24000, 0x25000, 0x25000, 0x25000, 0x25000, 0x26000, 0x26000,
  0x26000, 0x26000, 0x27000, 0x27000, 0x27000, 0x27000, 0x28000, 0x28000,
  0x28000, 0x28000, 0x29000, 0x29000, 0x29000, 0x29000, 0x2a000, 0x2a000,
  0x2a000, 0x2a000, 0x2b000, 0x2b000, 0x2b000, 0x2b000, 0x2c000, 0x2c000,
  0x2c000, 0x2c000, 0x2d000, 0x2d000, 0x2d000, 0x2d000, 0x2e000, 0x2e000,
  0x2e000, 0x2e000, 0x2f000, 0x2f000, 0x2f000, 0x2f000, 0x30000, 0x30000,
  0x30000, 0x30000, 0x31000, 0x31000, 0x31000, 0x31000, 0x32000, 0x32000,
  0x32000, 0x32000, 0x33000, 0x33000, 0x33000, 0x33000, 0x34000, 0x34000,
  0x34000, 0x34000, 0x35000, 0x35000, 0x35000, 0x35000, 0x36000, 0x36000,
  0x36000, 0x36000, 0x37000, 0x37000, 0x37000, 0x37000, 0x38000, 0x38000,
  0x38000, 0x38000, 0x39000, 0x39000, 0x39000, 0x39000, 0x3a000, 0x3a000,
  0x3a000, 0x3a000, 0x3b000, 0x3b000, 0x3b000, 0x3b000, 0x3c000, 0x3c000,
  0x3c000, 0x3c000, 0x3d000, 0x3d000, 0x3d000, 0x3d000, 0x3e000, 0x3e000,
  0x3e000, 0x3e000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/

  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000,
  0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000, 0x3f000

};

/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit g value to 6 bits and shifted
  for RGB666 format
--------------------------------------------------------------------------*/

uint32 const ipl2_g666[340] = {
  0x0, 0x0, 0x40, 0x40, 0x40, 0x40, 0x80, 0x80,
  0x80, 0x80, 0xc0, 0xc0, 0xc0, 0xc0, 0x100, 0x100,
  0x100, 0x100, 0x140, 0x140, 0x140, 0x140, 0x180, 0x180,
  0x180, 0x180, 0x1c0, 0x1c0, 0x1c0, 0x1c0, 0x200, 0x200,
  0x200, 0x200, 0x240, 0x240, 0x240, 0x240, 0x280, 0x280,
  0x280, 0x280, 0x2c0, 0x2c0, 0x2c0, 0x2c0, 0x300, 0x300,
  0x300, 0x300, 0x340, 0x340, 0x340, 0x340, 0x380, 0x380,
  0x380, 0x380, 0x3c0, 0x3c0, 0x3c0, 0x3c0, 0x400, 0x400,
  0x400, 0x400, 0x440, 0x440, 0x440, 0x440, 0x480, 0x480,
  0x480, 0x480, 0x4c0, 0x4c0, 0x4c0, 0x4c0, 0x500, 0x500,
  0x500, 0x500, 0x540, 0x540, 0x540, 0x540, 0x580, 0x580,
  0x580, 0x580, 0x5c0, 0x5c0, 0x5c0, 0x5c0, 0x600, 0x600,
  0x600, 0x600, 0x640, 0x640, 0x640, 0x640, 0x680, 0x680,
  0x680, 0x680, 0x6c0, 0x6c0, 0x6c0, 0x6c0, 0x700, 0x700,
  0x700, 0x700, 0x740, 0x740, 0x740, 0x740, 0x780, 0x780,
  0x780, 0x780, 0x7c0, 0x7c0, 0x7c0, 0x7c0, 0x800, 0x800,
  0x800, 0x800, 0x840, 0x840, 0x840, 0x840, 0x880, 0x880,
  0x880, 0x880, 0x8c0, 0x8c0, 0x8c0, 0x8c0, 0x900, 0x900,
  0x900, 0x900, 0x940, 0x940, 0x940, 0x940, 0x980, 0x980,
  0x980, 0x980, 0x9c0, 0x9c0, 0x9c0, 0x9c0, 0xa00, 0xa00,
  0xa00, 0xa00, 0xa40, 0xa40, 0xa40, 0xa40, 0xa80, 0xa80,
  0xa80, 0xa80, 0xac0, 0xac0, 0xac0, 0xac0, 0xb00, 0xb00,
  0xb00, 0xb00, 0xb40, 0xb40, 0xb40, 0xb40, 0xb80, 0xb80,
  0xb80, 0xb80, 0xbc0, 0xbc0, 0xbc0, 0xbc0, 0xc00, 0xc00,
  0xc00, 0xc00, 0xc40, 0xc40, 0xc40, 0xc40, 0xc80, 0xc80,
  0xc80, 0xc80, 0xcc0, 0xcc0, 0xcc0, 0xcc0, 0xd00, 0xd00,
  0xd00, 0xd00, 0xd40, 0xd40, 0xd40, 0xd40, 0xd80, 0xd80,
  0xd80, 0xd80, 0xdc0, 0xdc0, 0xdc0, 0xdc0, 0xe00, 0xe00,
  0xe00, 0xe00, 0xe40, 0xe40, 0xe40, 0xe40, 0xe80, 0xe80,
  0xe80, 0xe80, 0xec0, 0xec0, 0xec0, 0xec0, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf40, 0xf40, 0xf40, 0xf40, 0xf80, 0xf80,
  0xf80, 0xf80, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/

  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0, 0xfc0,
  0xfc0, 0xfc0, 0xfc0, 0xfc0

};
/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit b value to 6 bits and shifted
  for RGB666 format
--------------------------------------------------------------------------*/

uint32 const ipl2_b666[512] = {
  0x0, 0x0, 0x1, 0x1, 0x1, 0x1, 0x2, 0x2,
  0x2, 0x2, 0x3, 0x3, 0x3, 0x3, 0x4, 0x4,
  0x4, 0x4, 0x5, 0x5, 0x5, 0x5, 0x6, 0x6,
  0x6, 0x6, 0x7, 0x7, 0x7, 0x7, 0x8, 0x8,
  0x8, 0x8, 0x9, 0x9, 0x9, 0x9, 0xa, 0xa,
  0xa, 0xa, 0xb, 0xb, 0xb, 0xb, 0xc, 0xc,
  0xc, 0xc, 0xd, 0xd, 0xd, 0xd, 0xe, 0xe,
  0xe, 0xe, 0xf, 0xf, 0xf, 0xf, 0x10, 0x10,
  0x10, 0x10, 0x11, 0x11, 0x11, 0x11, 0x12, 0x12,
  0x12, 0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14,
  0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16,
  0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18,
  0x18, 0x18, 0x19, 0x19, 0x19, 0x19, 0x1a, 0x1a,
  0x1a, 0x1a, 0x1b, 0x1b, 0x1b, 0x1b, 0x1c, 0x1c,
  0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1d, 0x1e, 0x1e,
  0x1e, 0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x20, 0x20,
  0x20, 0x20, 0x21, 0x21, 0x21, 0x21, 0x22, 0x22,
  0x22, 0x22, 0x23, 0x23, 0x23, 0x23, 0x24, 0x24,
  0x24, 0x24, 0x25, 0x25, 0x25, 0x25, 0x26, 0x26,
  0x26, 0x26, 0x27, 0x27, 0x27, 0x27, 0x28, 0x28,
  0x28, 0x28, 0x29, 0x29, 0x29, 0x29, 0x2a, 0x2a,
  0x2a, 0x2a, 0x2b, 0x2b, 0x2b, 0x2b, 0x2c, 0x2c,
  0x2c, 0x2c, 0x2d, 0x2d, 0x2d, 0x2d, 0x2e, 0x2e,
  0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x30, 0x30,
  0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x32, 0x32,
  0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34,
  0x34, 0x34, 0x35, 0x35, 0x35, 0x35, 0x36, 0x36,
  0x36, 0x36, 0x37, 0x37, 0x37, 0x37, 0x38, 0x38,
  0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x3a, 0x3a,
  0x3a, 0x3a, 0x3b, 0x3b, 0x3b, 0x3b, 0x3c, 0x3c,
  0x3c, 0x3c, 0x3d, 0x3d, 0x3d, 0x3d, 0x3e, 0x3e,
  0x3e, 0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/

  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
  0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f

};

/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit r value to 4 bits and shifted
  for RGB444 format
--------------------------------------------------------------------------*/

uint16 const ipl2_r444[] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100,
  0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100, 0x100,
  0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200,
  0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200, 0x200,
  0x300, 0x300, 0x300, 0x300, 0x300, 0x300, 0x300, 0x300,
  0x300, 0x300, 0x300, 0x300, 0x300, 0x300, 0x300, 0x300,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400, 0x400,
  0x500, 0x500, 0x500, 0x500, 0x500, 0x500, 0x500, 0x500,
  0x500, 0x500, 0x500, 0x500, 0x500, 0x500, 0x500, 0x500,
  0x600, 0x600, 0x600, 0x600, 0x600, 0x600, 0x600, 0x600,
  0x600, 0x600, 0x600, 0x600, 0x600, 0x600, 0x600, 0x600,
  0x700, 0x700, 0x700, 0x700, 0x700, 0x700, 0x700, 0x700,
  0x700, 0x700, 0x700, 0x700, 0x700, 0x700, 0x700, 0x700,
  0x800, 0x800, 0x800, 0x800, 0x800, 0x800, 0x800, 0x800,
  0x800, 0x800, 0x800, 0x800, 0x800, 0x800, 0x800, 0x800,
  0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0x900,
  0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0x900, 0x900,
  0xa00, 0xa00, 0xa00, 0xa00, 0xa00, 0xa00, 0xa00, 0xa00,
  0xa00, 0xa00, 0xa00, 0xa00, 0xa00, 0xa00, 0xa00, 0xa00,
  0xb00, 0xb00, 0xb00, 0xb00, 0xb00, 0xb00, 0xb00, 0xb00,
  0xb00, 0xb00, 0xb00, 0xb00, 0xb00, 0xb00, 0xb00, 0xb00,
  0xc00, 0xc00, 0xc00, 0xc00, 0xc00, 0xc00, 0xc00, 0xc00,
  0xc00, 0xc00, 0xc00, 0xc00, 0xc00, 0xc00, 0xc00, 0xc00,
  0xd00, 0xd00, 0xd00, 0xd00, 0xd00, 0xd00, 0xd00, 0xd00,
  0xd00, 0xd00, 0xd00, 0xd00, 0xd00, 0xd00, 0xd00, 0xd00,
  0xe00, 0xe00, 0xe00, 0xe00, 0xe00, 0xe00, 0xe00, 0xe00,
  0xe00, 0xe00, 0xe00, 0xe00, 0xe00, 0xe00, 0xe00, 0xe00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,

/*--------------------------------------------------------------------------
    Extended values to avoid clipping bfore lookup
--------------------------------------------------------------------------*/

  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,
  0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00, 0xf00,

};
/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit g value to 4 bits and shifted
  for RGB444 format
--------------------------------------------------------------------------*/
uint16 const ipl2_g444[] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
  0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
  0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50,
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
  0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60,
  0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70,
  0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70, 0x70,
  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
  0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
  0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
  0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
  0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0, 0xb0,
  0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
  0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
  0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
  0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0,
  0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
  0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0, 0xe0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
  0xf0, 0xf0, 0xf0, 0xf0

};

/*--------------------------------------------------------------------------
 lookup which quantizes an 8 bit b value to 4 bits and shifted
  for RGB444 format
--------------------------------------------------------------------------*/
uint16 const ipl2_b444[] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
  0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1,
  0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
  0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2, 0x2,
  0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
  0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3, 0x3,
  0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
  0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4, 0x4,
  0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
  0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5, 0x5,
  0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
  0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6, 0x6,
  0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
  0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7, 0x7,
  0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
  0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8, 0x8,
  0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
  0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9, 0x9,
  0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
  0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa, 0xa,
  0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
  0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb, 0xb,
  0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
  0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc, 0xc,
  0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
  0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd, 0xd,
  0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
  0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe, 0xe,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,

/*--------------------------------------------------------------------------
   extended quantization values
--------------------------------------------------------------------------*/
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
  0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf

};



/*===========================================================================

                      LOCAL DATA DECLARATIONS

===========================================================================*/
static boolean ipl2_initialized = FALSE;


/*===========================================================================
===========================================================================*/
extern int32 ipl2_roundFloatVal ( float valToRound)
{
  int32 trunc;

  trunc = (int32) valToRound;

  /*------------------------------------------------------------------------
    This assumes that the rouding  setup on call to the function is
    truncation.
  ------------------------------------------------------------------------*/
  if ( valToRound > 0 )
  {
    valToRound +=  0.5;
    trunc = (int32)valToRound;
  }
  else if ( valToRound < 0 )
  {
    valToRound -=  0.5;
    trunc = (int32)valToRound;
  }

  return( trunc );

} /* end of ipl2_roundFloatVal */






/*===========================================================================

FUNCTION IPL2_INIT()

DESCRIPTION
This function will create intermediate values which are used in YCB to RGB
565 conversion. The functions are self explanatory and the initiliazation is
is to populate the values before its used.

DEPENDENCIES
None

ARGUMENTS IN
None

RETURN VALUE
Status - this not used right now. But it is kept to account for possible
errors when we move this to heap.

SIDE EFFECTS
None

===========================================================================*/
extern ipl_status_type   ipl2_init (void)
{
  int32 i = 0;
  float Cr2R = 1.57489;
  float Cb2G = 0.18744;
  float Cr2G = 0.46826;
  float Cb2B = 1.8554;
  float origVal;
  float temp;
  uint32 j;


  /*------------------------------------------------------------------------
      If already intialized bail out returning success

  ------------------------------------------------------------------------*/
  if(ipl2_initialized)
  {
    return( IPL_SUCCESS );
  }

  /*------------------------------------------------------------------------

     Explanation for the magic numbers used in the YCbCr to RGB conversion.

      Here is the matrix represenation for the transformation of YCbCr to
      RGB values.

     | R  |       | 1     Cb2R    Cr2R  |     | Y  |          | Cb2R+Cr2R |
     | G  |   =   | 1     Cb2G    Cr2G  |  x  | Cb | - 128 X  | Cb2G+Cr2G |
     | B  |       | 1     Cb2B    Cr2b  |     | Cr |          | Cb2B+Cr2b |


      where X denotes matrix multiplication. These values are
      derived from the coeffeicents used in the earlier IPL.

    The value of Cb2R = 4.88828 * 10 exp -4 so this is totally igonord
                        given the range and quantization on these values.
    The value of Cr2B = 7.3242 * 10 exp -4  so this is totally igonord
                        given the range and quantization on these values.

   The last values are condensed into appropriate constants.
  ------------------------------------------------------------------------*/

  /*------------------------------------------------------------------------
   this creates thse function for values 0 - 255 for cr and cb.
   The output values are kept in 32 bit values
   -----------------------------------------------------------------------*/
  for ( i = 0; i <= 0xff; i++ )
  {

    /*----------------------------------------------------------------------
    take the conversion routine for the RGB values
    ----------------------------------------------------------------------*/

    /*----------------------------------------------------------------------
         conversion for R value

         The value -201.586 is = 128 * (Cr2R + Cb2G)
     ---------------------------------------------------------------------*/
    
    origVal =   (float) (( (float) (i) * Cr2R )  - 201.586);


    ipl2_CrToRTable[i] = (int16) ipl2_roundFloatVal( origVal);

    /*----------------------------------------------------------------------
       conversion for Cr to G

       The value -83.9296 = 128 * (Cr2g + Cb2G)
   -----------------------------------------------------------------------*/
    origVal = (float) (((float) (i) * Cr2G )  - 83.9296);
    ipl2_CrToGTable[i] = (int16) ipl2_roundFloatVal( origVal);

    /*----------------------------------------------------------------------
        conversion for Cb2G
    ----------------------------------------------------------------------*/
    origVal = (float) (i) * Cb2G;
    ipl2_CbToGTable[i] = (int16) ipl2_roundFloatVal( origVal);

    /*----------------------------------------------------------------------
         conversion for Cb to B

         The value -237.491 = 128 ( Cr2B + Cb2B)
    ----------------------------------------------------------------------*/
    origVal = (float) (((float) (i) * Cb2B )  - 237.491);
    ipl2_CbToBTable[i]=  (int16) ipl2_roundFloatVal( origVal); ;

  } /* end of loop i */


  /*------------------------------------------------------------------------
      Create multiplication for 3 / 4.
  ------------------------------------------------------------------------*/
  for( i = - 255; i <= 255; i++ )
  {
    ipl2_multab3by4[i] = (int16) ((i * 3 + 2) / 4);
  } /* end of for loop */

  /*------------------------------------------------------------------------
      This creates lookup tables for extracting and converting RGB565
      to YCbCr conversion.
   -----------------------------------------------------------------------*/
  for ( i = 0; i <= 0xff; i++ )
  {

    /*----------------------------------------------------------------------
         conversions  for R to Y  value

        | Y  |    | R2Y   G2Y   B2Y   |   | R |   | YC  |
        | Cb |  = | R2Cb  G2Cb  B2Cb  | X | G | + | CbC |
        | Cr |    | R2Cr  R2Cr  R2Cr  |   | B | | CrC |

          Yc = 16
          CbC = CrC = 128

          R2Y = 0.257
          G2Y = 0.504
          B2Y = 0.098

          R2Cr = -0.148
          G2Cr = -0.291
          B2Cr = 0.439

          R2Cr = 0.439
          G2Cr = -0.368
          B2Cr = -0.071
     ---------------------------------------------------------------------*/

    /*----------------------------------------------------------------------
        R2Y table normalized for RGB565
    ----------------------------------------------------------------------*/
    j =  i & 0xf8 ;
    temp = ( float ) j ;

    ipl2_rgb565ToYR[ i ]   = (int16) ipl2_roundFloatVal(
                                (float) 0.257 * temp );

    /*----------------------------------------------------------------------
        R2Cb table normalized for RGB565
    ----------------------------------------------------------------------*/
    j =  i & 0xf8 ;
    temp = ( float)  j ;
    ipl2_rgb565ToCbR[ i ] = (int16) ipl2_roundFloatVal((float)((-0.148)*temp)); 

    /*----------------------------------------------------------------------
        R2Cr table normalized for RGB565
    ----------------------------------------------------------------------*/
    ipl2_rgb565ToCrR[ i ] = (int16) ipl2_roundFloatVal((float)((0.439)*temp)); 

    /*----------------------------------------------------------------------
        G2Y table normalized for RGB565
    ----------------------------------------------------------------------*/
    j =  i & 0xfC ;
    temp = ( float ) i;

    ipl2_rgb565ToYG[ i ] = (int16) ipl2_roundFloatVal((float)((0.504)*temp)); 



    /*----------------------------------------------------------------------
        G2Cb table normalized for RGB565
    ----------------------------------------------------------------------*/
    ipl2_rgb565ToCbG[ i ] = (int16) ipl2_roundFloatVal((float)((-0.291)*temp)); 

    /*----------------------------------------------------------------------
        G2Cr table normalized for RGB565
    ----------------------------------------------------------------------*/
    ipl2_rgb565ToCrG[ i ] = (int16) ipl2_roundFloatVal((float)((-0.368)*temp)); 

    /*----------------------------------------------------------------------
        B2Y table normalized for RGB565
    ----------------------------------------------------------------------*/
    j =  ( i & 0x1f  ) << 3;
    temp = ( float)  j ;
    ipl2_rgb565ToYB[i] = (int16)ipl2_roundFloatVal((float)((0.098)*temp+16.0)); 

    /*----------------------------------------------------------------------
        B2Cb table normalized for RGB565
    ----------------------------------------------------------------------*/
    ipl2_rgb565ToCbB[i]=(int16)ipl2_roundFloatVal((float)((0.439)*temp+128.0)); 




    /*----------------------------------------------------------------------
        B2Cr table normalized for RGB565
    ----------------------------------------------------------------------*/
    ipl2_rgb565ToCrB[i]=(int16)ipl2_roundFloatVal((float)((-0.071)*temp+128.0)); 

    //ipl2_rgb565B1ToG[i] = (uint8) ((i & 0x7)  << 5);
    //ipl2_rgb565B2ToG[i] = (uint8) ((i & 0xE0) >> 3);

  } /* end of loop i */

  /*------------------------------------------------------------------------
      Initialize the filter tables
  ------------------------------------------------------------------------*/
  /*
  if( ipl2_initFilterTables() != IPL_SUCCESS )
  {
    return( IPL_FAILURE );
  }
  */

  /*------------------------------------------------------------------------
     flag the module initialization
  ------------------------------------------------------------------------*/
  ipl2_initialized = TRUE;

  return( IPL_SUCCESS );

} /* end of function ipl2_init */




// *********************************************************************
// Functional Prototypes
// *********************************************************************
//

static ipl_status_type ipl2_handle_RGB565Img
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
);

static ipl_status_type ipl2_rgb565Img
(
  ipl_image_type* i_img_ptr,        /* Points to the input image      */
  ipl_image_type* o_img_ptr,        /* Points to the output image     */
  ipl_rect_type* crop               /* Crop config                    */
);

static ipl_status_type ipl2_Rot000Frame_RGB565
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                     */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                     */
  uint16 transparentValue, /* transparent value of pixel                   */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                     */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);

static ipl_status_type ipl2_Rot000Frame_RGB565ToRGB565
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_Rot000Frame_RGB565ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_Rot000Frame_RGB565ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_Rot000Frame_RGB565ToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_process_RGBIconList(
  ipl_image_type *input_frame_ptr,
  ipl_image_type *o_img_ptr,
  ipl_icon_type** icon_list_ptr,
  uint16 transparentValue     /* Transparent pixel value */
);


static ipl_status_type ipl2_get_rotParam
(
  ipl_image_type* input_img_ptr,        /* Points to the input image        */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl2_rot_param_type *rotParam /* pass by reference -- output parameter*/
);

static ipl_status_type ipl2_handle_YCbCrImg
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
);

static ipl_status_type ipl2_YCbCrToRGB
(
  ipl_image_type* input_img_ptr,        /* Points to the input image     */
  ipl_image_type* output_img_ptr,        /* Points to the output image    */
  ipl_rect_type* crop              /* Crop config                    */
);

static ipl_status_type ipl2_RotFrame_YCrCbToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop,          /* cropping params */
  ipl_rotate90_type rotate      /* Rotatation                       */
);


static ipl_status_type ipl2_Rot000Frame_YCbCrToRGB444
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,        /* Points to the input image        */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
);


static ipl_status_type ipl2_Rot000Frame_YCbCrToRGB565
(
  ipl_image_type* input_img_ptr,        /* input image pointer */
  ipl_image_type* input_frame_ptr,      /* Points to the frame       */
  ipl_image_type* output_img_ptr,       /* Points to the output image     */
  ipl_rect_type* crop,                  /* Crop config                    */
  uint16 transparentValue               /* Transparent pixel value       */
);


static ipl_status_type ipl2_Rot180Frame_YCbCToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                    */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                    */
  uint16 transparentValue, /* transparent value of pixel                  */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                    */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);

static ipl_status_type ipl2_Rot090Frame_YCbCToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                   */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                   */
  uint16 transparentValue, /* transparent value of pixel                 */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                   */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);

static ipl_status_type ipl2_Rot270Frame_YCbCToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                   */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                   */
  uint16 transparentValue, /* transparent value of pixel                 */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                    */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_handle_YCbCr420Img
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
);

static ipl_status_type ipl2_RotFrame_YCrCb420lpToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop,          /* cropping params */
  ipl_rotate90_type rotate      /* Rotatation                       */
);

static ipl_status_type ipl2_handle_YCrCb420lpImg
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
);


static ipl_status_type ipl2_YCbCr420ToRGB
(
  ipl_image_type* input_img_ptr,        /* Points to the input image    */
  ipl_image_type* output_img_ptr,       /* Points to the output image   */
  ipl_rect_type* crop                   /* Crop config                  */
);


static ipl_status_type ipl2_Rot000Frame_YCbCr420ToRGB565
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
);

static ipl_status_type ipl2_RotFrame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop,          /* cropping params */
  ipl_rotate90_type rotate      /* Rotatation                       */
);


static ipl_status_type ipl2_Rot090_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);

static ipl_status_type ipl2_Rot090Frame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop           /* cropping params */
);

static ipl_status_type ipl2_Rot180_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot180Frame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot270_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot270Frame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot270Frame_YCbCToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_YCbCrToRGB666
(
  ipl_image_type* input_img_ptr,        /* Points to the input image      */
  ipl_image_type* output_img_ptr,       /* Points to the output image     */
  ipl_rect_type* crop                   /* Crop config                    */
);


static ipl_status_type ipl2_Rot180Frame_YCbCToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);

static ipl_status_type ipl2_Rot000Frame_YCbCrToRGB666
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
);


static ipl_status_type ipl2_Rot090Frame_YCbCToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);

static ipl_status_type ipl2_RotFrame_YCbCrToYCbCr
(
  ipl_image_type* input_img_ptr,    /* Input Image Pointer           */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer               */
  uint16 transparentValue, /* transparent value of pixel             */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer               */
  ipl_rect_type* crop,
  ipl_rotate90_type rotate         /* Rotatation                     */
);


static ipl_status_type ipl2_Rot270Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_Rot180Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                    */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                    */
  uint16 transparentValue, /* transparent value of pixel                  */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                    */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_Rot000Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
);


static ipl_status_type ipl2_YCbCrToYCbCr
(
  ipl_image_type* input_img_ptr,        /* Points to the input image      */
  ipl_image_type* output_img_ptr,       /* Points to the output image     */
  ipl_rect_type* crop                   /* Crop config                    */
);

static ipl_status_type ipl2_Rot090Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                     */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                     */
  uint16 transparentValue, /* transparent value of pixel                   */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                     */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
);


static ipl_status_type ipl2_Rot000Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the input frame        */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
);

static ipl_status_type ipl2_Rot090Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot180Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot270Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_YCbCr420ToRGB666
(
  ipl_image_type* input_img_ptr,        /* Points to the input image    */
  ipl_image_type* output_img_ptr,       /* Points to the output image   */
  ipl_rect_type* crop                   /* Crop config                  */
);


static ipl_status_type ipl2_Rot000Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the input frame        */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
);


static ipl_status_type ipl2_Rot090_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop           /* cropping params */
);


static ipl_status_type ipl2_Rot090Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot180_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop           /* cropping params */
);


static ipl_status_type ipl2_Rot180Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot270_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);


static ipl_status_type ipl2_Rot270Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
);





/*==========================================================================

FUNCTION        IPL2_ROT_ADD_CROP

DESCRIPTION

  INITIALIZATION

  This module requires some of the conversion tables initialized before
  triggering this function. It is suggested that the user should call the
  API ipl2_init() before calling this API.

 FUNCTIONALITY

  This function is the entry point to a whole variety of display image
  manipulations like color conversion, cropping, framing, rotation and a
  limited overlay of icons. (Read more to know why limited).

  The frame should be in RGB 565 and should be same dimensions  i/p.
  The input can be in YCbCr or RGB565.
  The output can be either YCbCr or RGBxxx where xxx is 565 or 444 or 666.
  |<----- i/p dx ---------------->     |<---------- frame.dx ------------->
  _______________________________      ___________________________________
  |                              |     |                                  |
  |                              |     |                                  |
  |ip.dy                         |     | frame.dy                         |
  |                              |<1:1>|                                  |
  |                              |     |                                  |
  |______________________________|     |__________________________________|

        i/p image                          Frame i/p

   The frame should have a one to one pixel to pixel mapping against
   the input image.

  input image should contain the number of byte's required to present  the
  image. For eg: if your imput is 565 then this routine assumes the image
  pointer inside having dx*dy * 2 bytes. All containing valid pixels.

  The i_frame_ptr is not mandatory. If you are not using an overlay image
  frame, then this image frame should be NULL. The expected behavior is if
  the input image pixel value does not match with the transparency value
  provided then that pixel is copied into the corresponding output pixel
  after doing suitable color conversion/rotation.

  o_img_ptr should be adequately allocated and this is where the output is
  written into.

  LIMITATIONS TO INPUT BUFFER POINTERS
  All the image buffers are assumed to be word aligned. This assumption is
  very critical for faster memory access.

  Crop parameter should be supplied all the time. The crop.x and y specifies
  the position (co ordinate where the image is rendered in the output image
  frame.
        o_img_ptr.dx
  -------------------------------------
  |       |                           |
  |       | (crop.y)                  |
  |       |     (crop.dx)             |
  |--------|----------------------|   |
  |(crop.x)|                      |   |
  |        |                      |   |
  |        |                      |   | (o_img_ptr.dy)
  |        |(crop.dy)             |   |
  |        |                      |   |
  |        |                      |   |
  |        ------------------------   |
  |------------------------------------

  LIMITATIONS TO CROP PARAMETERS.
    Current implementation for YCbCr442 based images only support even number
    of columns are supported. So if the col.dx is 7 as passed value the
    actual crop operation will truncate it to nearest lower even no. In this
    case it is 6. This is a tradeoff for a faster conversion.

    Current implementation for YCCbCr420 based images only even number of
    columns and rows are supported. So if the col.dx is 7 as passed value
    the actual crop operation will truncate it to nearest lower even no. In
    this case it is 6. This is a tradeoff for a faster conversion. Same
    applies with rows as well. This can be enhanced for odd no of rows
    in some cases.

    Whatever the image format is the crop.x which is the X relocation factor
    cannot be a odd number. This is because the IPL writes to the display
    buffer 2 bytes at a time and if the offset is odd boundary we will get
    unexpected results.


  Figure which shows the lay out of cropped image in out put frame.
  Remember the rest of the portion of the output image is left alone.
      From this figure obviously we cant have crop.dx > o_im_ptr.dx and
      same thing applies for dy.


  parameter rotate will specify the rotation you need with respect to the
  input image. This is a clock wise rotation.

  icon_list_ptr - is an optional parameter. If you are not using this
  feature pass a NULL in. If you are using the feature pass a list
  of icons in the pointer. The last icon should be always NULL which tells
  the rendering routine to stop rendering.

  Transparent value - This variable has effect only when the i_frame_ptr is
  valid. For more see the description of i_frame_ptr parameter.


  SPEED OF EXECUTION

  The functionality of the library is divided in such a way that the least
  complex takes least time. For instance if the arguments does not
  specify a crop parameter then the pixel manipulation routines which
  handles the input goes through a different faster code path. In general
  it is advised that the user use the least amount of variance to get the
  display done.


DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  icon_list_ptr is a ptr to a NULL terminated list of icons
  Icons are only processed if input is IPL_RGB565 and output is IPL_RGB565
  transparentValue is the 16 bit transparent pixel value

ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
API_EXTERN ipl_status_type ipl2_rot_add_crop
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  ipl_status_type status;
 
  MSG_LOW("API_EXTERN inside ipl2_rot_add_crop\n");



  /*------------------------------------------------------------------------
      Call the init routine. Mulitiple initializations does not hurt.
  ------------------------------------------------------------------------*/
  if ( ipl2_init() != IPL_SUCCESS )
  {
    IPL2_MSG_FATAL( "ipl2_rot_add_crop :: /\
                    Could not initialize IPL2_IPL lookup tables");
    return( IPL_FAILURE );
  }

  /*------------------------------------------------------------------------
      NULL check the bare minimum parameters required
   -----------------------------------------------------------------------*/
  if ( !crop || !i_img_ptr || !o_img_ptr )
  {
    IPL2_MSG_FATAL( "ipl2_rot_add_crop failed crop = %lx, /\
                   i_img_ptr = %lx, o_img_ptr = %lx", (uint32) crop,
                   (uint32) i_img_ptr, (uint32) o_img_ptr);
    return( IPL_FAILURE );
  }
  else
  {
    /*----------------------------------------------------------------------
        See if images have actual buffers
     ---------------------------------------------------------------------*/

    if ( !i_img_ptr->imgPtr || !o_img_ptr->imgPtr )
    {
      IPL2_MSG_FATAL( "ipl2_rot_add_crop failed  i_img_ptr->imgPtr = %lx, /\
                   o_img_ptr->imgPtr = %lx", (uint32) i_img_ptr->imgPtr,
                   (uint32) o_img_ptr->imgPtr);

      return( IPL_FAILURE );
    }
  }

  /*------------------------------------------------------------------------
      Framing is supported only for RGB565 images i/p as well as o/p
   -----------------------------------------------------------------------*/
  if ( input_frame_ptr != NULL )
  {
    if ( (input_frame_ptr->cFormat != IPL_RGB565) &&
      (!input_frame_ptr->imgPtr ) )
    {
      IPL2_MSG_FATAL( "ipl2_rot_add_crop failed Frame /\
                    input_frame_ptr = %p, color format = %d, imgptr = %p",
                    input_frame_ptr, input_frame_ptr->cFormat,
                    input_frame_ptr->imgPtr
                    );
      /*--------------------------------------------------------------------
            Only RGB Frame format currently supported
      --------------------------------------------------------------------*/
      return(IPL_FAILURE);
    }
  }

  /*------------------------------------------------------------------------
       Icons are only supported in RGB565 input and RGB565 output
  ------------------------------------------------------------------------*/
  if ( icon_list_ptr && !((i_img_ptr->cFormat == IPL_RGB565) &&
    (o_img_ptr->cFormat == IPL_RGB565)) )
  {
    IPL2_MSG_FATAL( "ipl2_rot_add_crop failed on icon processing /\
                     iii_list_ptr = %p, /\
                     i_img_ptr->cFormat = %u, o_img_ptr->cFormat = %d",
                     icon_list_ptr, i_img_ptr->cFormat,
                     o_img_ptr->cFormat );
    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
          Make sure cropping parameters are ok
   -----------------------------------------------------------------------*/
  if ( ( (crop->x + crop->dx) > o_img_ptr->dx ) ||
    ( (crop->y + crop->dy) > o_img_ptr->dy ) )
  {
    /*----------------------------------------------------------------------
             Invalid dimensions set
     ---------------------------------------------------------------------*/
    IPL2_MSG_FATAL( "ipl2_rot_add_crop failed for invalid crop setting /\
                   crop->x = %lu, /\
                   crop->dx= %lu, o_img_ptr->dx = %lu", crop->x,
                   crop->dx, o_img_ptr->dx);

    IPL2_MSG_FATAL( "ipl2_rot_add_crop failed for invalid crop setting /\
                   crop->y = %lu, /\
                   crop->dy= %lu, o_img_ptr->dy = %lu", crop->y,
                   crop->dy, o_img_ptr->dy);

    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
      Warn the user and bail out if the cropped O/P have more pixels than
      the actual no of input pixels.
  ------------------------------------------------------------------------*/
  if(rotate == IPL_NOROT || rotate == IPL_ROT180)
  {
    if( (i_img_ptr->dx < crop->dx) || (i_img_ptr->dy < crop->dy ) )
    {
      IPL2_MSG_FATAL( "ipl2_rot_add_crop not proceeding with less than /\
                    perfect  crop setting  crop->dx = %lu, /\
                     i_img_ptr->dx = %lu, IPL_ROT = %u", crop->dx,
                     i_img_ptr->dx, rotate);

      IPL2_MSG_FATAL( "ipl2_rot_add_crop not proceeding with less than /\
                    perfect crop setting crop->dy = %lu, /\
                   i_img_ptr->dy = %lu", crop->dy,
                   i_img_ptr->dy);
      return( IPL_FAILURE );
    }
  }
  else if(  (rotate == IPL_ROT90) || (rotate == IPL_ROT270) )
  {
      if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy ) )
      {
        IPL2_MSG_FATAL( "ipl2_rot_add_crop not proceeding with less than /\
                        perfect crop setting  crop->dx = %lu, /\
                       i_img_ptr->dx = %lu, IPL_ROT = %u", crop->dx,
                       i_img_ptr->dx, rotate);

        IPL2_MSG_FATAL( "ipl2_rot_add_crop not proceeding with less than /\
                        perfect crop setting crop->dy = %lu, /\
                       i_img_ptr->dy = %lu", crop->dy,
                       i_img_ptr->dy);

        return( IPL_FAILURE );
      }
  }

  /*------------------------------------------------------------------------
     if the frame matches with the input image then only proceed with the
      remainder of the processing
  ------------------------------------------------------------------------*/
  if ( (input_frame_ptr != NULL) &&
    ((rotate == IPL_ROT90) || (rotate == IPL_ROT270)) &&
    ((input_frame_ptr->dx != i_img_ptr->dy) ||
    (input_frame_ptr->dy != i_img_ptr->dx)) )
  {
    /*----------------------------------------------------------------------
          Frame should be the same size as input b/4 cropping
     ---------------------------------------------------------------------*/
    IPL2_MSG_FATAL( "ipl2_rot_add_crop failed for invalid Frame setting /\
               input_frame_ptr= %p, /\
               rotate = %d, input_frame_ptr->dx = %lu", input_frame_ptr,
               rotate, input_frame_ptr->dx );

    IPL2_MSG_FATAL( "ipl2_rot_add_crop failed for invalid Frame setting /\
               i_img_ptr->dy= %lu, /\
               input_frame_ptr->dy = %lu, i_img_ptr->dx) = %lu",i_img_ptr->dy,
               input_frame_ptr->dy, i_img_ptr->dx );

    return(IPL_FAILURE);
  }



  /*------------------------------------------------------------------------
      Dispatch the image to appropriater handlers
  ------------------------------------------------------------------------*/
  switch ( i_img_ptr->cFormat )
  {
    case IPL_YCbCr :
      {
        status = ipl2_handle_YCbCrImg(i_img_ptr, input_frame_ptr, \
                   o_img_ptr, crop, rotate, icon_list_ptr, \
                   transparentValue );
        break;
      }

    /*----------------------------------------------------------------------
       This is the YCbCr encoding stream which is supplied by our DSP
       Y Y----|
              |  Cb, CR
       Y Y----|
    ----------------------------------------------------------------------*/
    case IPL_YCbCr420_FRAME_PK :
      {
        status = ipl2_handle_YCbCr420Img(i_img_ptr,
                   input_frame_ptr, \
                   o_img_ptr,
                   crop,
                   rotate,
                   icon_list_ptr, \
                   transparentValue );
        break;
      }
    case IPL_YCrCb420_LINE_PK :
      {
        status = ipl2_handle_YCrCb420lpImg(i_img_ptr,
                   input_frame_ptr, \
                   o_img_ptr,
                   crop,
                   rotate,
                   icon_list_ptr, \
                   transparentValue );
        break;
      }
    case IPL_RGB565 :
      {
        status =  ipl2_handle_RGB565Img( i_img_ptr, input_frame_ptr,
                    o_img_ptr,
                    crop, rotate,
                    icon_list_ptr,
                    transparentValue );
        break;
      }

    default:
      status =  IPL_FAILURE;
      break;

  } /* end of swith */


  return(status);

} /* end of ipl2_rot_add_crop */



/*===========================================================================

FUNCTION ipl2_handle_RGB565Img()

DESCRIPTION
  This function will handle cropping, color converting and rotation of all
  RGB565 based images.

DEPENDENCIES
  None

ARGUMENTS IN
   i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  icon_list_ptr is a ptr to a NULL terminated list of icons
    Icons are only processed if input is IPL_RGB565 and output is IPL_RGB565
  transparentValue is the 16 bit transparent pixel value

ARGUMENTS IN
  o_img_ptr points to the output image

RETURN VALUE
  Status - returns success or failure mappes ipl_staus_type

SIDE EFFECTS
  In case of proper parameters the image is written
  to output image

===========================================================================*/
static ipl_status_type ipl2_handle_RGB565Img
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  ipl2_rot_param_type rot_param;

  MSG_LOW("inside ipl2_handle_RGB565Img\n");




  /*------------------------------------------------------------------------
     if we do not do rotation and framing call more optimized
    ipl2_rgb565Img
  ------------------------------------------------------------------------*/
  if ( rotate == IPL_NOROT )
  {
    if ( i_img_ptr->dx < crop->dx )
    {
      /*--------------------------------------------------------------------
         Invalid settings
      --------------------------------------------------------------------*/
      return(IPL_FAILURE);
    }

    /*----------------------------------------------------------------------
             Dont rotate
            ** Call a more optimized version
    ----------------------------------------------------------------------*/
    if ( input_frame_ptr == NULL )
    {
      if ( ipl2_rgb565Img( \
        i_img_ptr,
        o_img_ptr, crop ) != IPL_SUCCESS )
      {
        return(IPL_FAILURE);
      }
    }
    else
    {

      /*--------------------------------------------------------------------

        we are not setting rotation here.. we are
        * just using the offset
        * for framing rotation is slightly misleading
      --------------------------------------------------------------------*/
      rot_param.startPos = 0;
      rot_param.colInc = 1;
      rot_param.rowInc = (int32) 1 + (int32) (i_img_ptr->dx - crop->dx);

      /*--------------------------------------------------------------------
           * call the function to rotate add and crop with a ros and ColInc
           * which will just to framing
      --------------------------------------------------------------------*/
      if ( ipl2_Rot000Frame_RGB565( \
        i_img_ptr,
        input_frame_ptr,
        transparentValue,
        o_img_ptr,
        rot_param.startPos,
        rot_param.colInc, 
        rot_param.rowInc,
        crop) != IPL_SUCCESS )
      {
        return(IPL_FAILURE);
      }
    }
  }
  else
  {
    /*----------------------------------------------------------------------
       see if the rotation is actually possible with the given
       set of params

    ----------------------------------------------------------------------*/
    if ( ipl2_get_rotParam( i_img_ptr, crop, rotate, &rot_param)!=IPL_SUCCESS)
    {
      /*--------------------------------------------------------------------
         Rotation Option Not supported
      --------------------------------------------------------------------*/
      return(IPL_FAILURE);
    }
    else
    {
      /*--------------------------------------------------------------------
         * call the the function which will do rotate Crop and frame with t
         * the rotation parameters we just obtained
      --------------------------------------------------------------------*/
      if ( ipl2_Rot000Frame_RGB565( \
        i_img_ptr,
        input_frame_ptr,
        transparentValue,
        o_img_ptr,
        rot_param.startPos,
        rot_param.colInc, 
        rot_param.rowInc,
        crop) != IPL_SUCCESS )
      {
        return(IPL_FAILURE);
      }
    }
  }




  /*------------------------------------------------------------------------
      If we need to process the icons call the function to overlay icons
      over the exising image only supported for RGB565 format for now. The
      icons are processed by the separate function below
   -----------------------------------------------------------------------*/
  if ( icon_list_ptr )
  {
    return( ipl2_process_RGBIconList(
      input_frame_ptr,
      o_img_ptr,
      icon_list_ptr,
      transparentValue
      ) );
  }
  else
  {
    return( IPL_SUCCESS );
  }

} /* end of function ipl2_handle_RGB565Img */


/*===========================================================================

FUNCTION ipl2_rgb565Img()

DESCRIPTION
  This function will handle cropping RGB input image to the same RGB or
  different RGB flavor.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr,        Points to the input image
  crop              Crop config

ARGUMENTS OUT
    o_img_ptr  - output image
RETURN VALUE
  Status

SIDE EFFECTS
  None

===========================================================================*/

static ipl_status_type ipl2_rgb565Img
(
  ipl_image_type* i_img_ptr,        /* Points to the input image      */
  ipl_image_type* o_img_ptr,        /* Points to the output image     */
  ipl_rect_type* crop               /* Crop config                    */
)
{
  uint32 src_index,rowInc,dest_index,destInc;
  uint32 row,col;
  ipl_image_type* input_img_ptr = i_img_ptr;
  ipl_image_type* output_img_ptr = o_img_ptr;
  register uint16* inputImgPtr=(uint16*)i_img_ptr->imgPtr;
  register uint16* outputImgPtr = (uint16*)output_img_ptr->imgPtr;
  register uint16 out2;
  register uint32 out32;
  register uint32* data_out = (uint32*)output_img_ptr->imgPtr;
  register uint8 r;

  unsigned char r1,g1,b1;
  register uint16 out;

  MSG_LOW("inside ipl2_rgb565Img\n");


/*------------------------------------------------------------------------*/

  if ( output_img_ptr->cFormat == IPL_RGB565 )
  {

    rowInc =  ( (input_img_ptr->dx - crop->dx) * 2 );

    /*----------------------------------------------------------------------
        THIS CAN BE A QUICK HACK FOR JPEG/PNG WORKING. I HAVE SENT MAILS TO
        pdo@qc to clarify on this..? I AM NOT SPREADING THIS CODE ANYWHERE
        YET. BUT IF THIS INDEED IS A CONVENTION THEN WE NEED TO SPRINKLE
        THIS CODE IN ALL OUR ROUTINES.
        If the image has odd number of cols then we need to account for 2
        byte padding at the end of every row..
    ----------------------------------------------------------------------*/
    if( input_img_ptr->dx & 0x1 )
    {
      rowInc += 2;
    }

    destInc =  ( (output_img_ptr->dx - crop->dx) * 2 );
    src_index = 0;  /* byte addressed */
    dest_index = (crop->x + output_img_ptr->dx*crop->y) * 2;
    outputImgPtr = (uint16*)( (uint32)outputImgPtr + dest_index);

    if ( !destInc && !rowInc )
    {
      memcpy(outputImgPtr, inputImgPtr, (crop->dy * crop->dx/2 ) * 4 );
    }
    else
    {
      /*--------------------------------------------------------------------
        We need a row col loop here
      --------------------------------------------------------------------*/
      for ( row = crop->dy; row; row-- )
      {
        for ( col = crop->dx/2; col; col-- )
        {
          *outputImgPtr = *inputImgPtr;
          outputImgPtr++;
          inputImgPtr++;
          *outputImgPtr = *inputImgPtr;
          outputImgPtr++;
          inputImgPtr++;
        }
        outputImgPtr = (uint16*)((uint32)outputImgPtr + destInc);
        inputImgPtr = (uint16*)((uint32)inputImgPtr + rowInc);
      }
    }

  }
  else if ( output_img_ptr->cFormat == IPL_RGB666 )
  {
    dest_index = (crop->x + output_img_ptr->dx*crop->y) <<2; //lint !e703
    data_out = (uint32*)((uint32)data_out +  dest_index);
    rowInc = (input_img_ptr->dx - crop->dx )<<1; //lint !e703
    destInc = ( output_img_ptr->dx - crop->dx)<<2; //lint !e703
    /*----------------------------------------------------------------------
        We need a row/col loop
    ----------------------------------------------------------------------*/
    for ( row = crop->dy; row; row-- )
    {
      for ( col = crop->dx/2; col; col-- )
      {
        /*------------------------------------------------------------------
           Convert input from rgb565 to rgb666
        ------------------------------------------------------------------*/
        out = *(uint16*)(inputImgPtr);
        inputImgPtr++;
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *data_out = out32;
        data_out++;
        out = *(uint16*)(inputImgPtr);
        inputImgPtr++;
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *data_out = out32;
        data_out++;

      } /* End of col loop */
      inputImgPtr = (uint16*)((uint32)inputImgPtr + rowInc);
      data_out = (uint32*)((uint32)data_out + destInc);

    } /* End of row loop */
    return(IPL_SUCCESS);
  }
  else if ( output_img_ptr->cFormat == IPL_RGB444 )
  {
    dest_index = (crop->x + output_img_ptr->dx*crop->y) * 2;
    outputImgPtr = (uint16*)((uint32)outputImgPtr +  (dest_index));
    rowInc = (input_img_ptr->dx - crop->dx ) * 2;
    destInc = ( output_img_ptr->dx - crop->dx) * 2;

    /*----------------------------------------------------------------------
      Do a row/col loop
    ----------------------------------------------------------------------*/
    for ( row = crop->dy; row; row-- )
    {
      for ( col = crop->dx/2; col; col-- )
      {
        /*------------------------------------------------------------------
            RGB565 to RGB444 conversion
        ------------------------------------------------------------------*/
        out = *(uint16*)(inputImgPtr);
        inputImgPtr++;
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *outputImgPtr = out2;
        outputImgPtr++;
        out = *(uint16*)(inputImgPtr);
        inputImgPtr++;
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *outputImgPtr = out2;
        outputImgPtr++;

      } /* End of col loop */
      inputImgPtr = (uint16*)((uint32)inputImgPtr + rowInc);
      data_out = (uint32*)((uint32)data_out + destInc);

    } /* End of row loop */
    return(IPL_SUCCESS);
  }
  else if ( output_img_ptr->cFormat == IPL_YCbCr )
  {
    rowInc = (input_img_ptr->dx - crop->dx) * 2;
    destInc = (output_img_ptr->dx - crop->dx) * 2;
    src_index = 0;  /* byte addressed */
    dest_index = (crop->x + output_img_ptr->dx*crop->y) * 2;

    /*----------------------------------------------------------------------
      We need a Row/Col loop
    ----------------------------------------------------------------------*/
    for ( row = 0; row < crop->dy; row++ )
    {
      for ( col = 0; col < (crop->dx); col=col+2 )
      {
        /* 1st pixel */
        out = *((uint16*)((uint32)inputImgPtr + src_index));
        r1 = out >> 8 ;
        g1 = (out >> 3) & 0xff ;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index)) = 
          ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        /* 2nd pixel */
        out = *((unsigned short*)((uint32)inputImgPtr + src_index+2));
        r1 = out >> 8;
        g1 = (out >> 3) & 0xff;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
          ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        src_index += 4; /* byte addressed */
        dest_index += 4;

      } /* End of col loop */
      src_index = src_index + rowInc;  /* byte addressed */
      dest_index = dest_index +
                   ( (output_img_ptr->dx - crop->dx) << 1); //lint !e703

    } /* End of row loop */
    return(IPL_SUCCESS);
  }
  else
  {
    /*------------------------------------------------------------------
      Only YCbCr or RGB666/444 output supported

    ------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  return( IPL_SUCCESS );

} /* end of function ipl2_rgb565Img */


/*===========================================================================

FUNCTION ipl2_Rot000Frame_RGB565

DESCRIPTION
  This function is an optimized version to do rotation, adding frame,cropping
  and color conversion from YCbCr to RGB565.

  It is assumed that the caller will set the input, frame and output
  image structures to have the correct dimensions after
  and rotation.

  The frame is assumed to be established in 2 pixel units. ie. the minimum length
  of any frame edge is 2 pixels.

  Input is assumed to be in rgb565 format

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  input_frame_ptr points to the frame image
  transparentValue is the transparent pixel value
  startPos is the start increment
  colInc is the col incr
  rowInc is the row incr

ARGUMENTS OUT
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/

static ipl_status_type ipl2_Rot000Frame_RGB565
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                     */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                     */
  uint16 transparentValue, /* transparent value of pixel                   */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                     */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{

  MSG_LOW("inside ipl2_Rot000Frame_RGB565\n");

  /*------------------------------------------------------------------------
      Handle the case of RGB565 to RGB565 conversion
  ------------------------------------------------------------------------*/
  if ( o_img_ptr->cFormat == IPL_RGB565 )
  {
      return( ipl2_Rot000Frame_RGB565ToRGB565(i_img_ptr,
                                                i_frame_ptr,
                                                transparentValue,
                                                o_img_ptr,
                                                startPos,
                                                colInc,
                                                rowInc,
                                                crop
                                                ) );

  }
  /*------------------------------------------------------------------------
      Handle the case of RGB565 to 666
  ------------------------------------------------------------------------*/
  else if ( o_img_ptr->cFormat == IPL_RGB666 )
  {
    return( ipl2_Rot000Frame_RGB565ToRGB666(i_img_ptr,
                                              i_frame_ptr,
                                              transparentValue,
                                              o_img_ptr,
                                              startPos,
                                              colInc,
                                              rowInc,
                                              crop
                                              ) );
  }
  else if ( o_img_ptr->cFormat == IPL_RGB444 )
  {
    return( ipl2_Rot000Frame_RGB565ToRGB444(i_img_ptr,
                                              i_frame_ptr,
                                              transparentValue,
                                              o_img_ptr,
                                              startPos,
                                              colInc,
                                              rowInc,
                                              crop
                                              ) );
  }
  else if ( o_img_ptr->cFormat == IPL_YCbCr )
  {
    return( ipl2_Rot000Frame_RGB565ToYCbCr(i_img_ptr,
                                                    i_frame_ptr,
                                                    transparentValue,
                                                    o_img_ptr,
                                                    startPos,
                                                    colInc,
                                                    rowInc,
                                                    crop
                                                    ) );

  } /* end of if output = ycbcr */
  else
  {
    /*----------------------------------------------------------------------
        RGB565 output supported
    ----------------------------------------------------------------------*/
    return (IPL_FAILURE);
  }

  /*NOTREACHED*/
  return( IPL_SUCCESS );
} /* ipl2_image_rot_add_crop_rgbi */

/*===========================================================================

FUNCTION ipl2_Rot000Frame_RGB565ToRGB565

DESCRIPTION
  This function is an optimized version to do rotation, adding frame,cropping
  on a RGB565 based imahe

  It is assumed that the caller will set the input, frame and output
  image structures to have the correct dimensions after
  and rotation.

  The frame is assumed to be established in 2 pixel units. ie. the minimum length
  of any frame edge is 2 pixels.

  Input is assumed to be in rgb565 format

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  input_frame_ptr points to the frame image
  transparentValue is the transparent pixel value
  startPos is the start increment
  colInc is the col incr
  rowInc is the row incr

ARGUMENTS OUT
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl2_Rot000Frame_RGB565ToRGB565
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index,destInc;
  uint32 row,col;
  register uint16* inputImgPtr = (uint16*)i_img_ptr->imgPtr;
  register uint16* outputImgPtr = (uint16*)o_img_ptr->imgPtr;
  register uint16* frameImgPtr =
    (uint16*)((i_frame_ptr == NULL)?
    NULL : i_frame_ptr->imgPtr);
  register int32 rowIncr = (rowInc<<1) - (colInc<<1); //lint !e703
  register int32 colIncr = colInc<<1; //lint !e703
  register uint32 frameIncr = 0;
  register int32 framePresent = 0;

  MSG_LOW("inside ipl2_Rot000Frame_RGB565ToRGB565\n");

  /*------------------------------------------------------------------------
    If we have framing and cropping we need to adjust the increments
    accordingly
  ------------------------------------------------------------------------*/
  if ( i_frame_ptr )
  {
    frameIncr = (i_frame_ptr->dx - crop->dx)<<1;
    framePresent = 1;
  }

  /*------------------------------------------------------------------------
      Handle the case of RGB565 to RGB565 conversion
  ------------------------------------------------------------------------*/
  /* initialize the index to starting position */
  src_index = (uint32) (startPos * 2);
  dest_index = (crop->x + o_img_ptr->dx*crop->y) * 2;
  outputImgPtr = (uint16*)((uint32)outputImgPtr +  dest_index);
  inputImgPtr = (uint16*)((uint32)inputImgPtr + src_index);
  destInc = ( o_img_ptr->dx - crop->dx) * 2;

  /* Now loop through the image once */
  for ( row = crop->dy; row; row-- )
  {
    for ( col = crop->dx; col; col-- )
    {
      if ( framePresent &&
           ((*(uint16*)(frameImgPtr) != transparentValue)) ) //lint !e613
      {

        /*------------------------------------------------------------------
            Copy the frame
        ------------------------------------------------------------------*/

        *outputImgPtr = *frameImgPtr; //lint !e613
        outputImgPtr++;
        frameImgPtr++; //lint !e613
        inputImgPtr = (uint16*)((uint32)inputImgPtr + colIncr); //lint !e737
      }
      else
      {
        /*------------------------------------------------------------------
            Cpy the image
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Suppressing lint warning 539. This is because if frameImgPtr
            is NULL its not used anywhere, so this is harmless addition.
            Although not very optimal
        ------------------------------------------------------------------*/
        frameImgPtr ++; //lint !e539 !e613
        *outputImgPtr = *inputImgPtr;
        outputImgPtr++;
        inputImgPtr = (uint16*)((uint32)inputImgPtr + colIncr); //lint !e737
      }
    }
    inputImgPtr = (uint16*)((uint32)inputImgPtr + rowIncr); //lint !e737
    outputImgPtr = (uint16*)((uint32)outputImgPtr + destInc); //lint !e737
    frameImgPtr = (uint16*)((uint32)frameImgPtr + frameIncr); //lint !e737
  }
  return(IPL_SUCCESS);
}

/*===========================================================================

FUNCTION ipl2_Rot000Frame_RGB565ToRGB565

DESCRIPTION
  This function is an optimized version to do rotation, adding frame,cropping
  on a RGB565 based image and color convert to RGB666

  It is assumed that the caller will set the input, frame and output
  image structures to have the correct dimensions after
  and rotation.

  The frame is assumed to be established in 2 pixel units. ie. the minimum length
  of any frame edge is 2 pixels.

  Input is assumed to be in rgb565 format

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  input_frame_ptr points to the frame image
  transparentValue is the transparent pixel value
  startPos is the start increment
  colInc is the col incr
  rowInc is the row incr

ARGUMENTS OUT
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl2_Rot000Frame_RGB565ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index,destInc;
  uint32 row,col;
  register uint16* inputImgPtr = (uint16*)i_img_ptr->imgPtr;
  register uint16* frameImgPtr =
                (uint16*)((i_frame_ptr == NULL)?
                          NULL : i_frame_ptr->imgPtr);
  register uint16 out;
  register uint32 out32;
  register uint8 r;
  register uint32* data_out = (uint32*)o_img_ptr->imgPtr;
  register int32 rowIncr = (rowInc * 2) - (colInc * 2);
  register int32 colIncr = colInc * 2;
  register uint32 frameIncr = 0;
  register int32 framePresent = 0;

  MSG_LOW("inside ipl2_Rot000Frame_RGB565ToRGB666\n");

  /*------------------------------------------------------------------------
    If we have framing and cropping we need to adjust the increments
    accordingly
  ------------------------------------------------------------------------*/
  if ( i_frame_ptr )
  {
    frameIncr = (i_frame_ptr->dx - crop->dx) * 2;
    framePresent = 1;
  }




  /*
  ** begin of Input = rgb565, output = rgb666
  */
  /* initialize the index to starting position */
  src_index = (uint32) (startPos * 2);  /* byte addressed */
  dest_index = (crop->x + o_img_ptr->dx*crop->y) * 4;
  data_out = (uint32*)((uint32)data_out +  dest_index); //lint !e713
  inputImgPtr = (uint16*)((uint32)inputImgPtr + src_index);
  destInc = ( o_img_ptr->dx - crop->dx) * 4;
  /* Now loop through the image once */
  for ( row = crop->dy; row; row-- )
  {
    for ( col = crop->dx; col; col-- )
    {
      if ( framePresent &&
             (*(uint16*)(frameImgPtr) != transparentValue) ) //lint !e613
      {
        /*
        ** Copy Over the Frame and convert from rgb565 to rgb666
        */
        out = *(uint16*)(frameImgPtr); //lint !e613
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *data_out = out32;
        data_out++;
        frameImgPtr++; //lint !e613
        inputImgPtr = (uint16*)((uint32)inputImgPtr + colIncr);//lint !e737
      }
      else
      {

        /*------------------------------------------------------------------
            Suppressing a lint warning. This is because if this pointier is
            NULL then its not used see the counter part of  this else.

        ------------------------------------------------------------------*/
        frameImgPtr ++; //lint !e613
        out = *(uint16*)(inputImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *data_out = out32;
        data_out++;
        inputImgPtr = (uint16*)((uint32)inputImgPtr + colIncr); //lint !e737
      }
    }
    inputImgPtr = (uint16*)((uint32)inputImgPtr + rowIncr); //lint !e737
    data_out = (uint32*)((uint32)data_out + destInc); //lint !e737
    frameImgPtr = (uint16*)((uint32)frameImgPtr + frameIncr); //lint !e737
  }

  return (IPL_SUCCESS);
}

/*===========================================================================

FUNCTION ipl2_Rot000Frame_RGB565ToRGB444

DESCRIPTION
  This function is an optimized version to do rotation, adding frame,cropping
  on a RGB565 based image and color convert to RGB444

  It is assumed that the caller will set the input, frame and output
  image structures to have the correct dimensions after
  and rotation.

  The frame is assumed to be established in 2 pixel units. ie. the minimum length
  of any frame edge is 2 pixels.

  Input is assumed to be in rgb565 format

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  input_frame_ptr points to the frame image
  transparentValue is the transparent pixel value
  startPos is the start increment
  colInc is the col incr
  rowInc is the row incr

ARGUMENTS OUT
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl2_Rot000Frame_RGB565ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index,destInc;
  uint32 row,col;
  register uint16* inputImgPtr = (uint16*)i_img_ptr->imgPtr;
  register uint16* outputImgPtr = (uint16*)o_img_ptr->imgPtr;
  register uint16* frameImgPtr =
                (uint16*)((i_frame_ptr == NULL)?
                          NULL : i_frame_ptr->imgPtr);
  register uint16 out, out2;
  register uint8 r;
  register int32 rowIncr = (rowInc * 2) - (colInc * 2);
  register int32 colIncr = colInc * 2;
  register uint32 frameIncr = 0;
  register int32 framePresent = 0;

  MSG_LOW("inside ipl2_Rot000Frame_RGB565ToRGB444\n");

  /*------------------------------------------------------------------------
    If we have framing and cropping we need to adjust the increments
    accordingly
  ------------------------------------------------------------------------*/
  if ( i_frame_ptr )
  {
    frameIncr = (i_frame_ptr->dx - crop->dx) * 2;
    framePresent = 1;
  }

  /* initialize the index to starting position */
  src_index = (uint32) (startPos * 2);  /* byte addressed */
  dest_index = (crop->x + o_img_ptr->dx*crop->y)  * 2;
  outputImgPtr = (uint16*)((uint32)outputImgPtr +  dest_index);
  inputImgPtr = (uint16*)((uint32)inputImgPtr + src_index);
  destInc = ( o_img_ptr->dx - crop->dx) * 2;
  /* Now loop through the image once */
  for ( row = crop->dy; row; row-- )
  {
    for ( col = crop->dx; col; col-- )
    {
    if ( framePresent &&
         (*(uint16*)(frameImgPtr) != transparentValue) ) //lint !e613
      {
        /*
        ** Copy Over the Frame and convert from rgb565 to rgb444
        */
        out = *(uint16*)(frameImgPtr); //lint !e613
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *outputImgPtr = out2;
        outputImgPtr++;
        frameImgPtr++; //lint !e613
        inputImgPtr = (uint16*)((uint32)inputImgPtr + colIncr); //lint !e737
      }
      else
      {
        /*--------------------------------------------------------------------
            Suppressing the lint warning 613. This is because we are not using
            this if the pointer is NULL
        --------------------------------------------------------------------*/
        frameImgPtr ++; //lint !e613
        out = *(uint16*)(inputImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *outputImgPtr = out2;
        outputImgPtr++;
        inputImgPtr = (uint16*)((uint32)inputImgPtr + colIncr); //lint !e737
      }
    }

    inputImgPtr = (uint16*)((uint32)inputImgPtr + rowIncr); //lint !e737
    outputImgPtr = (uint16*)((uint32)outputImgPtr + destInc); //lint !e737
    frameImgPtr = (uint16*)((uint32)frameImgPtr + frameIncr); //lint !e737
  }

  return (IPL_SUCCESS);
}
/*===========================================================================

FUNCTION ipl2_Rot000Frame_RGB565ToYCbCr

DESCRIPTION
  This function is an optimized version to do rotation, adding frame,cropping
  on a RGB565 based image and color convert to YCbCr

  It is assumed that the caller will set the input, frame and output
  image structures to have the correct dimensions after
  and rotation.

  The frame is assumed to be established in 2 pixel units. ie. the minimum length
  of any frame edge is 2 pixels.

  Input is assumed to be in rgb565 format

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr points to the input image
  input_frame_ptr points to the frame image
  transparentValue is the transparent pixel value
  startPos is the start increment
  colInc is the col incr
  rowInc is the row incr

ARGUMENTS OUT
  output_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl2_Rot000Frame_RGB565ToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer            */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer            */
  uint16 transparentValue,      /* transparent value of pixel     */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer            */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index;
  uint32 row,col;
  register uint16* inputImgPtr = (uint16*)i_img_ptr->imgPtr;
  register uint8* outputImgPtr = o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16*)((i_frame_ptr == NULL)?
                          NULL : i_frame_ptr->imgPtr);
  unsigned char r1,g1,b1;
  register uint16 out;
  uint32  frame_index = 0;

  MSG_LOW("inside ipl2_Rot000Frame_RGB565ToYCbCr\n");

  if (ipl2_init() != IPL_SUCCESS)
    return( IPL_FAILURE );

  /* initialize the index to starting position */
  src_index = (uint32) (startPos * 2);
  dest_index = (crop->x + o_img_ptr->dx*crop->y) * 2;
  frame_index = 0;

  /* if no frame pointer, then jsut crop/rotate/convert */
  if (i_frame_ptr == NULL)
  {
    for ( row = 0; row < crop->dy; row++ )
    {
      for ( col = 0; col < (crop->dx); col=col+2 )
      {
        /* 1st pixel */
        out = *((unsigned short*)((uint32)inputImgPtr + src_index));
        r1 = out >> 8 ;
        g1 = (out >> 3) & 0xff ;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index)) = 
          ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        /* 2nd pixel */
        out = *((unsigned short*)((uint32)inputImgPtr+src_index+(colInc<<1))); 
        r1 = out >> 8;
        g1 = (out >> 3) & 0xff;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
          ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        src_index += (colInc<<2); 
        dest_index += 4;
      } 
      src_index = src_index + (rowInc<<1) - (colInc<<1);  
      dest_index = dest_index + ( (o_img_ptr->dx - crop->dx) << 1); 
    }
  }
  else if (frameImgPtr != NULL)
  {
    for ( row = 0; row < crop->dy; row++ )
    {
      for ( col = 0; col < (crop->dx); col=col+2 )
      {
        if(((*(uint16*)((uint32)frameImgPtr+frame_index)) != transparentValue) )
        {
          /* 1st pixel */
          out = *((uint16*)((uint32)frameImgPtr + frame_index));
          r1 = out >> 8 ;
          g1 = (out >> 3) & 0xff ;
          b1 = out & 0xff;
          *((uint8*)((uint32)outputImgPtr + dest_index)) = 
            ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
          *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
            ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
  
          /* 2nd pixel */
          out = *((uint16*)((uint32)frameImgPtr + frame_index + 2));
          r1 = out >> 8;
          g1 = (out >> 3) & 0xff;
          b1 = out & 0xff;
          *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
            ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
          *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
            ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
        }
        else
        {
          /* 1st pixel */
          out = *((unsigned short*)((uint32)inputImgPtr + src_index));
          r1 = out >> 8 ;
          g1 = (out >> 3) & 0xff ;
          b1 = out & 0xff;
          *((uint8*)((uint32)outputImgPtr + dest_index)) = 
            ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
          *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
            ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

          /* 2nd pixel */
          out = *((unsigned short*)((uint32)inputImgPtr+src_index+(colInc<<1))); 
          r1 = out >> 8;
          g1 = (out >> 3) & 0xff;
          b1 = out & 0xff;
          *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
            ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
          *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
            ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
        }

        src_index += (colInc<<2); 
        dest_index += 4;
        frame_index += 4;
      } /* End of col loop */

      src_index = src_index + (rowInc<<1) - (colInc<<1);  
	  	frame_index += ((i_frame_ptr->dx - crop->dx) <<1 ); 
      dest_index = dest_index + ( (o_img_ptr->dx - crop->dx) << 1); 
    } /* End of row loop */
  }

  return (IPL_SUCCESS);
}


/*===========================================================================

FUNCTION ipl2_process_RGBIconList()

DESCRIPTION
  This function overlays a set of icons pointed in the icoList variable.


DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr  - input image frame
  icon_list_ptr  - list of icons
  transparentValue - transparent pixel value

ARGUMENTS OUT
  output_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  None

===========================================================================*/
/*ARGSUSED*/
static ipl_status_type ipl2_process_RGBIconList(
  ipl_image_type *input_frame_ptr,
  ipl_image_type *o_img_ptr,
  ipl_icon_type** icon_list_ptr,
  uint16 transparentValue     /* Transparent pixel value */
  )
{
  register uint16* outputImgPtr;
  register uint32 out_offset, pitch_factor, crop_delta;
  register uint16* frameImgPtr;
  register uint32 row,col;
  int32 frame_index;
/*------------------------------------------------------------------------*/
  /*------------------------------------------------------------------------
      ** Lets process icons.  Only valid for input = IPL_RGB565 and
      ** output = IPL_RGB565
  ------------------------------------------------------------------------*/
  frame_index = 0;

  while ( (frame_index < IPL2_MAX_RGB_ICONS) && icon_list_ptr[frame_index] != NULL )
  {
    if ( icon_list_ptr[frame_index]->cFormat != IPL_RGB565 )
    {
      return (IPL_FAILURE);
    }
    outputImgPtr = (uint16*)o_img_ptr->imgPtr;

    out_offset = icon_list_ptr[frame_index]->x +
            icon_list_ptr[frame_index]->y * o_img_ptr->dx;
    outputImgPtr = outputImgPtr + out_offset;

    frameImgPtr = (uint16*)icon_list_ptr[frame_index]->imgPtr;

    crop_delta = o_img_ptr->dx - icon_list_ptr[frame_index]->dx;
    pitch_factor = (uint32) ((uint32) icon_list_ptr[frame_index]->pitch -
                             (icon_list_ptr[frame_index]->dx*2) );
    for ( row=0;row < icon_list_ptr[frame_index]->dy;row++ )
    {
      for ( col=0;col<icon_list_ptr[frame_index]->dx;col++ )
      {
        if ( *frameImgPtr != transparentValue )
        {
          *outputImgPtr = *frameImgPtr;
        }
        outputImgPtr++;
        frameImgPtr++;
      }
      frameImgPtr = (uint16*)((uint32)frameImgPtr + pitch_factor);
      outputImgPtr += crop_delta;
    }
    frame_index++;
  }
  return (IPL_SUCCESS);
}



/*===========================================================================

FUNCTION ipl2_get_rotParam()

DESCRIPTION
  This function is a utility function. This takes the rotation type
  and input and output image types and then calculates the image manipulation
  parameters.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr  - input image frame
  crop           -  Crop config
  rotate          - Rotatation
  rotParam       - rotation parameters, combines row and coloumn increment
RETURN VALUE
  Status - success for failure

SIDE EFFECTS
  None

===========================================================================*/
static ipl_status_type ipl2_get_rotParam
(
  ipl_image_type* input_img_ptr,        /* Points to the input image        */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl2_rot_param_type *rotParam /* pass by reference -- output parameter*/
)
{
/*------------------------------------------------------------------------*/

  switch ( rotate )
  {
    case IPL_ROT90 :
      {
        /*------------------------------------------------------------------
           Rotate 90 clockwise
        ------------------------------------------------------------------*/
        rotParam->startPos = (int32)(input_img_ptr->dx*(input_img_ptr->dy-1) );
        rotParam->colInc = -(int32)input_img_ptr->dx;
        rotParam->rowInc = (int32) ( (input_img_ptr->dx)*(input_img_ptr->dy-1)
                            + 1 - (input_img_ptr->dy -
                                   crop->dx)*input_img_ptr->dx );

        if ( input_img_ptr->dy < crop->dx )
        {
          /*----------------------------------------------------------------
             Invalid settings

          -----------------------------------------------------------------*/
          return(IPL_FAILURE);
        }

      }
      break;

    case IPL_ROT180 :
      {
        /*------------------------------------------------------------------
         Rotate 180 clockwise.  Dont reflect
        ------------------------------------------------------------------*/
        rotParam->startPos = (int32) ( (input_img_ptr->dx
                                        *input_img_ptr->dy)-1 );
        rotParam->colInc = -1;
        rotParam->rowInc = (int32) ( -1 -
                                     (int32) (input_img_ptr->dx - crop->dx) );
        if ( input_img_ptr->dx < crop->dx )
        {
          /*----------------------------------------------------------------
            Invalid settings
          ----------------------------------------------------------------*/
          return(IPL_FAILURE);
        }

      }
      break;

    case IPL_ROT270 :
      {
        /*------------------------------------------------------------------
           Rotate 270 clockwise.  Dont reflect
        ------------------------------------------------------------------*/
        rotParam->startPos = (int32) ( input_img_ptr->dx - 1);
        rotParam->colInc = (int32) input_img_ptr->dx;
        rotParam->rowInc = (int32) ( -(int32)(input_img_ptr->dx)*
                            (int32) (input_img_ptr->dy-1) -1 +
                           (int32) (input_img_ptr->dy -
                             crop->dx) * input_img_ptr->dx  ); //lint !e737
        if ( input_img_ptr->dy < crop->dx )
        {
          /*----------------------------------------------------------------
             Invalid settings
          ----------------------------------------------------------------*/
          return(IPL_FAILURE);
        }
      }
      break;

    default :
      {
        return(IPL_FAILURE);
      }
  }
  /*NOTREACHED*/
  return(IPL_SUCCESS );

} /* end of function ipl2_get_rotParam */



/*==========================================================================

                        IPL2_YCBCR.C

DESCRIPTION
  This file contains the implementation of the IPL APIs. Below is an
  approximate call flow. Compressed into this function header.

            ipl2_handle_YCbCrImg
                |
                |
-----------|-----|--------------
|          |                   |
|          |                   |--ipl2_Rot000Frame_YCbCrToYCbCr
|          |                   |    (handle, rotation framing and cropping
|          |                   |      of YCbCr based image )
|          |                   |
|          |           ipl2_Rot000Frame_YCrCbToRGB(handle rotation)
|          |                       |
|          |                       | (rotation, cropping and framing)
|          |                      ipl2_Rot090Frame_YCbCToRGB
|          |                      ipl2_Rot180Frame_YCbCToRGB
|          |                      ipl2_Rot270Frame_YCbCToRGB
|          |                      ipl2_Rot090Frame_YCbCToRGB666
|          |                      ipl2_Rot180Frame_YCbCToRGB666
|          |                      ipl2_Rot270Frame_YCbCToRGB666
|          |
|          |(no rotation but there is framing and cropping)
|       ipl2_Rot000Frame_YCbCrToRGB444
|       ipl2_Rot000Frame_YCbCrToRGB565
|       ipl2_Rot000Frame_YCbCrToRGB666
|           |
|           |
|          ipl2_Rot000Frame_YCbCrToYCbCr ( frame and crop a YCbCr Img )
|
ipl2_YCbCrToRGB (565/444 no rot no framimg,
|                                   cropping only, most speedy )
ipl2_YCbCrToRGB666
|
ipl2_YCbCripl2_CbToYCrCb crop a YCbCr image


EXTERNALIZED FUNCTIONS

  ipl2_handle_YCbCrImg()
     Handles the YCbCr based images and delgates the processing various
     sub routines - some of which reference across files and hence
     eksxterned.

INITIALIZATION AND SEQUENCING REQUIREMENTS
 The functions will fail if the lookup tables are not initialized properly.


Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
===========================================================================

===========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     ---------------------------------------------------------
05/20/04   srk     Linted added more error checks
05/15/04   srk     Fixed some bugs uncovered in regression
04/30/04   srk     Code review comments from Jun, Nikhil, David, Ramesh
                   and Roy
04/16/04   srk     Initial creation. Modelled the put all the  YCBCR input
                   conversions/cropping/ftraming  in this file. Better
                   readability and call flow that way.
==========================================================================*/


/*==========================================================================

                          FUNCTION DEFINITIONS

==========================================================================*/

/*==========================================================================

FUNCTION ipl2_handle_YCbCrImg()

DESCRIPTION
  This function will handle cropping, color converting and rotation of all
  YCbCr based images.

DEPENDENCIES
  None

ARGUMENTS IN
   i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  icon_list_ptr is a ptr to a NULL terminated list of icons
    Icons are only processed if input is IPL_RGB565 and output is IPL_RGB565
  transparentValue is the 16 bit transparent pixel value

ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  Status - returns success or failure mappes ipl_staus_type

SIDE EFFECTS
  Output image is updated with the processed image

==========================================================================*/
  /*ARGSUSED*/
static ipl_status_type ipl2_handle_YCbCrImg
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  ipl_status_type status;

  MSG_LOW("inside ipl2_handle_YCbCrImg\n");


   /*-----------------------------------------------------------------------
      For the kind of packing used in YUV442 array we need even no of cols
      for sure. For cases involoving rotation rows and cols will change and
      it is best to check cols before proceeding.
      Supporting these will involve more complex routines.
  ------------------------------------------------------------------------*/
  if( i_img_ptr->dx & 0x1 )
  {
    return( IPL_FAILURE );
  }

  /*------------------------------------------------------------------------
      Current scheme will truncate cols to lower even. Otherwise the
      alogorithms will become unnecessarily complex.
  -----------------------------------------------------------------------*/
  if( crop->dx & 0x1 )
  {
    /*----------------------------------------------------------------------
          Warn the user strongly
    ----------------------------------------------------------------------*/
  }



  if ( rotate == IPL_NOROT )
  {
    if ( i_img_ptr->dx < crop->dx )
    {
      /*--------------------------------------------------------------------
           Invalid settings
      --------------------------------------------------------------------*/
      return(IPL_FAILURE);
    }
    /*----------------------------------------------------------------------
        Dont rotate
        Call a more optimized version
    ----------------------------------------------------------------------*/
    if ( input_frame_ptr == NULL )
    {
      if ( o_img_ptr->cFormat == IPL_YCbCr )
      {
        return( ipl2_YCbCrToYCbCr(
          i_img_ptr,
          o_img_ptr,
          crop ) );
      }
      else
      {
        return( ipl2_YCbCrToRGB( \
          i_img_ptr,
          o_img_ptr,crop ) );
      }
    }
    else
    {
      /*--------------------------------------------------------------------
          If the pointer inside is NULL return failure
      --------------------------------------------------------------------*/
      if( !input_frame_ptr->imgPtr )
      {
        return( IPL_FAILURE );
      }
      /*--------------------------------------------------------------------
           This case is where there is no rotation but framing required
        ------------------------------------------------------------------*/
      switch ( o_img_ptr->cFormat )
      {
        case IPL_RGB565 :
          status =  ipl2_Rot000Frame_YCbCrToRGB565(
                      i_img_ptr, input_frame_ptr, o_img_ptr,
                      crop, transparentValue );
          break;

        case IPL_RGB666:
          status = ipl2_Rot000Frame_YCbCrToRGB666(
                     i_img_ptr, input_frame_ptr,
                     o_img_ptr,
                     crop, transparentValue );
          break;

        case IPL_RGB444 :
          status =  ipl2_Rot000Frame_YCbCrToRGB444( \
                      i_img_ptr, input_frame_ptr, o_img_ptr,        \
                      crop,   transparentValue  );
          break;

        case IPL_YCbCr:
          status =  ipl2_Rot000Frame_YCbCrToYCbCr( \
                      i_img_ptr, input_frame_ptr, o_img_ptr,        \
                      crop,   transparentValue  );
          break;

        default:
          IPL2_MSG_FATAL( "ipl2_handle_YCbCrImg :: /\
                  unknown o/p color format = %d", o_img_ptr->cFormat);

          status =  IPL_FAILURE;
          break;
      }

      return( status );

    }
  }
  else
  {
    /*----------------------------------------------------------------------
       This case is where there is rotation and framing required
    ----------------------------------------------------------------------*/
    switch ( o_img_ptr->cFormat )
    {
      case IPL_YCbCr:
        /* all the RGB flavors handled here */
        status =  ipl2_RotFrame_YCbCrToYCbCr(
                    i_img_ptr,    /* Input Image Pointer                 */
                    input_frame_ptr,  /* Input Frame Pointer              */
                    transparentValue, /* transparent value of pix         */
                    o_img_ptr,   /* Output Image Pointer               */
                    crop,
                    rotate
                    );
        break;

      case IPL_RGB444 :
      case IPL_RGB565 :
      case IPL_RGB666 :
        /* all the RGB flavors handled here */
        status = ipl2_RotFrame_YCrCbToRGB(
                   i_img_ptr,    /* Input Image Pointer            */
                   input_frame_ptr,  /* Input Frame Pointer               */
                   transparentValue, /* transparent value of pixel        */
                   o_img_ptr,   /* Output Image Pointer                   */
                   crop,
                   rotate
                   );
        break;

      default:
        IPL2_MSG_FATAL( "ipl2_hanle_YCbCrImg :: /\
                unknown o/p = %d ", o_img_ptr->cFormat);

        status = IPL_FAILURE;
        break;
    }

    return( status );

  }

  /*NOTREACHED*/
  return( IPL_SUCCESS );

} /* end of function ipl2_handle_YCbCrImg */


/*==========================================================================

FUNCTION ipl2_YCbCrToRGB()

DESCRIPTION
  This function will handle cropping, color converting of
  YCbCr based images to different RGB flavors. This function is more optimal
  if you are not cropping . This function is specifically designed for the
  favorable input condition where - there is no framing going on. So
  transparent value check is not needed. This function calls for help when
  the output is RGB666 .This because translation very different and output
  is32 bit value.

DEPENDENCIES
  None

ARGUMENTS IN
  ipl_image_type* input_img_ptr        Points to the input image
  ipl_rect_type* crop                  Cropping parameter

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/
static ipl_status_type ipl2_YCbCrToRGB
(
  ipl_image_type* input_img_ptr,        /* Points to the input image     */
  ipl_image_type* output_img_ptr,        /* Points to the output image    */
  ipl_rect_type* crop              /* Crop config                    */
)
{
  register unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16*) output_img_ptr->imgPtr;
  register uint32 out, out2;
  register uint8 cb,cr;
  register unsigned char lumaa1;
  register int32 lumaa2;
  register int32 r;
  register uint8 *endPtr;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;

  register int16 *Cr2RTbl = &(ipl2_CrToRTable[0]);

  register int16 *Cb2BTbl = &(ipl2_CbToBTable[0]);
  int32 row,col;
  int32 rowInc=0,dest_index,destInc;

  MSG_LOW("inside ipl2_YCbCrToRGB\n");

  /*------------------------------------------------------------------------
      initialize the index to starting position
  ------------------------------------------------------------------------*/

  dest_index = (int32) ( (crop->x + output_img_ptr->dx*crop->y) << 1 ) ;
  rowInc = (int32) ( (input_img_ptr->dx - crop->dx )* 2 );

  switch ( output_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :
      return( ipl2_YCbCrToRGB666(
        input_img_ptr,
        output_img_ptr,
        crop
        ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }
  outputImgPtr =
                 (uint16 *) ( (uint32) outputImgPtr +
                 (uint32) dest_index); //lint !e713
  destInc =
    (int32) ( output_img_ptr->dx - crop->dx) * 2; //lint !e737 !e713

  /*-----------------------------------------------------------------------
      If the crop setting is such that we do not need to adjust the output
      pointer inside the loop . We will use a more optimized loop
  ------------------------------------------------------------------------*/
  if ( !rowInc && !destInc )
  {

    endPtr = (uint8 *) inputImgPtr + (crop->dy * crop->dx) * 2;
    while ( endPtr > inputImgPtr )
    {
      /*-------------------------------------------------------------------
            Convert input to rgb
      --------------------------------------------------------------------*/

      /*-------------------------------------------------------------------
            This is Cb
      --------------------------------------------------------------------*/
      cb = (*((uint8*)(inputImgPtr++)));

      /*--------------------------------------------------------------------
          Next Byte is luma of first pixel
      --------------------------------------------------------------------*/
      lumaa1 = *((uint8*)(inputImgPtr++));

      /*-------------------------------------------------------------------
            Next byte is cr
      --------------------------------------------------------------------*/
      cr = (*((uint8*) (inputImgPtr++)));

      /*------------------------------------------------------------------
            get the next luma value
      --------------------------------------------------------------------*/
      lumaa2 = *((uint8*)(inputImgPtr++));

      /*--------------------------------------------------------------------
          find the difference in lumaa
      --------------------------------------------------------------------*/
      lumaa2 -= lumaa1;

      /*--------------------------------------------------------------------
       Each of these comparisons add and compares are designed to force
       the compiler to do brach on carry instructions like bmi, bpl tc
       -------------------------------------------------------------------*/
      r = lumaa1 + Cr2RTbl[cr];
      if (r > 255) r = 255;
      
      if ( r > 0 )
      {
        out = rTable[ r ];
      }
      else
      {
        out = 0;
      }

      r += lumaa2;
      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out2 = rTable[ r ];
      }
      else
      {
        out2 = 0;
      }

      r = lumaa1 - ipl2_CbToGTable[cb] - ipl2_CrToGTable[cr];
      if (r > 255) r = 255;

      if ( r > 0 )
      {
        out += gTable[r];
      }

      r += lumaa2;
      if (r > 255) r = 255;

      if ( r > 0 )
      {
        out2 += gTable[r];
      }

      r = lumaa1 + Cb2BTbl[cb];
      if (r > 255) r = 255;
      /*--------------------------------------------------------------------
         If we have -ve or zero value we dont need to do anthing as the
         translation or effect of that component on the whole pixel value is
         bound to be zero no matter what encoding RGB flavor we are using.
      --------------------------------------------------------------------*/

      if ( r > 0 )
      {
        out += bTable[r];
      }

      r += lumaa2;
      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out2 += bTable[r];
      }

      *outputImgPtr++ = ( uint16 ) out;
      *outputImgPtr++  =( uint16 ) out2;
    } /* End of col * row  loop */

  }
  else
  {

    /*----------------------------------------------------------------------
        Loop through the image on Row/Coloumn basis
    ----------------------------------------------------------------------*/
    for ( row = crop->dy; row; row-- ) //lint !e713
    {
      for ( col = crop->dx/2; col; col-- ) //lint !e713
      {
        /*------------------------------------------------------------------
              This is Cb
        ------------------------------------------------------------------*/
        cb = (*((uint8*)(inputImgPtr++)));

        /*------------------------------------------------------------------
          Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
            Next byte is cr
        ------------------------------------------------------------------*/
        cr = (*((uint8*) (inputImgPtr++)));

        /*------------------------------------------------------------------
            get the next luma value
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
          all the templates used in this file
          ----------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,
          rTable, gTable, bTable);

        *outputImgPtr++ = ( uint16 )out;
        *outputImgPtr++  = ( uint16 ) out2;

      } /* End of col loop */

      inputImgPtr = (uint8*)( (uint32) inputImgPtr + rowInc); //lint !e737
      outputImgPtr =
                  (uint16 *) ((uint32 )outputImgPtr + destInc); //lint !e737

    } /* End of row loop */

    return(IPL_SUCCESS);
  }

  /*NOTREACHED*/
  return( IPL_SUCCESS );

} /* end of function ipl2_YCbCrToRGB */

/*==========================================================================

FUNCTION ipl2_RotFrame_YCrCbToRGB()

DESCRIPTION
  This function handles the broadest processing condition - which is rotate
  crop and Frame. This condition can sub partitioned as
  we need more optimized code in this area. Calls different handlers
  depending on the rotation settings.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr    - input image frame
  i_frame_ptr      - the frame which needs to be overlayed on the image
  crop             -  Crop config
  rotate           - Rotatation
  transparentValue - transparent value used in the case of framing.
  rotParam         - rotation parameters, combines row and coloumn increment

ARGUMENTS OUT
  output_img_ptr   - Points to the output image

RETURN VALUE
  Status - success for failure

SIDE EFFECTS
 Alters the output image buffer with the cropped/converted frame.
==========================================================================*/
static ipl_status_type ipl2_RotFrame_YCrCbToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop,          /* cropping params */
  ipl_rotate90_type rotate      /* Rotatation                       */
)

{
  int32 startPos, colInc, rowInc;
  ipl_status_type status;

  MSG_LOW("inside ipl2_RotFrame_YCrCbToRGB\n");

  /*------------------------------------------------------------------------
     find the right roation parameter and call the apprpriate sub hanler
   -----------------------------------------------------------------------*/
  switch ( rotate )
  {
    case IPL_ROT90 :
      {
        /*------------------------------------------------------------------
             Rotate 90 clockwise.
        ------------------------------------------------------------------*/
        startPos = ( i_img_ptr->dx * (i_img_ptr->dy - 1) ); //lint !e713
        colInc = -(int32)i_img_ptr->dx;
        rowInc = ( int32 ) ( (i_img_ptr->dx) * (i_img_ptr->dy-1) + 1 -
                  (i_img_ptr->dy - crop->dx) * i_img_ptr->dx ); //lint !e713

        if ( i_img_ptr->dy < crop->dx )
        {
          /*----------------------------------------------------------------
                     Invalid settings
          ----------------------------------------------------------------*/
          return(IPL_FAILURE);
        }

        /*------------------------------------------------------------------
          function which WILL HANDLE 90 rotaion
         -----------------------------------------------------------------*/
        status = ipl2_Rot090Frame_YCbCToRGB( i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr, startPos,
                   colInc,
                   rowInc,
                   crop );

      }
      break;

    case IPL_ROT180 :
      {
        /*------------------------------------------------------------------
             Rotate 180 clockwise.  Dont reflect
        ------------------------------------------------------------------*/
        startPos =  (int32) ( (i_img_ptr->dx*i_img_ptr->dy) - 1 ) ;
        colInc = -1;
        rowInc =
          (int32) ( -1 - (int32) ( i_img_ptr->dx - crop->dx) ); //lint !e713
        if ( i_img_ptr->dx < crop->dx )
        {
          /*----------------------------------------------------------------
                           Invalid settings
           ---------------------------------------------------------------*/
          return(IPL_FAILURE);
        }
        status = ipl2_Rot180Frame_YCbCToRGB( i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr, startPos,
                   colInc,
                   rowInc,
                   crop);


      }
      break;

    case IPL_ROT270 :
      {
        /*------------------------------------------------------------------
               Rotate 270 clockwise.  Dont reflect
         -----------------------------------------------------------------*/
        startPos =  (int32) ( i_img_ptr->dx - (int32) 1 ); //lint !e713
        colInc =  (int32) i_img_ptr->dx;
        rowInc = -(int32) (i_img_ptr->dx)*(i_img_ptr->dy-1) -1 +//lint !e713 !e737
                 (i_img_ptr->dy - crop->dx)* i_img_ptr->dx; //lint !e713
        if ( i_img_ptr->dy < crop->dx )
        {
          /*----------------------------------------------------------------
               Invalid settings
          ----------------------------------------------------------------*/
          return(IPL_FAILURE);
        }

        status = ipl2_Rot270Frame_YCbCToRGB( i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr, startPos,
                   colInc,
                   rowInc,
                   crop );
      }
      break;

    default :
      {
        IPL2_MSG_FATAL( "ipl2_Rot000Frame :: /\
                unknown rotation option = %d", rotate);

        /*------------------------------------------------------------------
                   Option Not supported
         -----------------------------------------------------------------*/
        status = IPL_FAILURE;
      }
  }

  return(status);

} /* end of function ipl2_Rot000Frame_YCrCbToRGB */

/*==========================================================================

FUNCTION ipl2_Rot000Frame_YCbCrToRGB444()

DESCRIPTION
  As the name indicates this function caters for the case of converting a
  YCrCb based image to a RGB444 coded image. The function does framing as
  well using the transpaent value given.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr  - input image frame
  i_frame_ptr    - Points to the input frame which needs to be ovrlayed
  crop           -  Crop config
  transparentValue - transparent pixel value

ARGUMENTS IN
    output_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
Alters the output image buffer.

==========================================================================*/
static ipl_status_type ipl2_Rot000Frame_YCbCrToRGB444
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,        /* Points to the input image        */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  int32 rowInc=0,dest_index,destInc;
  uint32 row,col;
  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16*) o_img_ptr->imgPtr;
  register uint16* frameImgPtr =  (uint16 * ) i_frame_ptr->imgPtr;
  register uint16 out,out2;
  register int32 lumaa1,lumaa2,cb,cr;
  register long r;
  uint8 r1;
  register const uint16 *rTable = &(ipl2_r444[0]);
  register const uint16 *gTable = &(ipl2_g444[0]);
  register const uint16 *bTable = &(ipl2_b444[0]);

  MSG_LOW("inside ipl2_Rot000Frame_YCbCrToRGB444\n");


  /*-------------------------------------------------------------------------
    initialize the index to starting position
  ------------------------------------------------------------------------*/
  dest_index = (int32) ( (crop->x + o_img_ptr->dx * crop->y) << 1 );
  rowInc = (int32) ( (int32) (i_img_ptr->dx - crop->dx ) * (int32) 2 );
  destInc = (int32) ( o_img_ptr->dx - crop->dx) * (int32) 2;

  /*------------------------------------------------------------------------
      reposition the output image to match with the cropping parameter.
     * So that it is correctly positioned in the output frame
  ------------------------------------------------------------------------*/
  outputImgPtr =
    (uint16*) ( (uint32) outputImgPtr +  dest_index); //lint !e737

  /*------------------------------------------------------------------------
     Loop through the whole image once
  ------------------------------------------------------------------------*/
  for ( row = crop->dy; row; row-- )
  {
    for ( col = crop->dx/2; col; col-- )
    {
      if ( *(uint16*) (frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r1 = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r1];
        r1 = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r1];
        r1 = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r1];
        *outputImgPtr = out2;
        outputImgPtr++;
        frameImgPtr++;
        out = *(uint16*)(frameImgPtr);
        r1 = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r1];
        r1 = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r1];
        r1 = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r1];
        *outputImgPtr = out2;
        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr+=4;
      }
      else
      {

        /*------------------------------------------------------------------
              Advance the Frame Pointer
        ------------------------------------------------------------------*/
        frameImgPtr += 2;

        /*------------------------------------------------------------------
              This is Cb
        ------------------------------------------------------------------*/
        cb = (*((uint8*)(inputImgPtr++)));

        /*------------------------------------------------------------------
            Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
               Next byte is cr
        ------------------------------------------------------------------*/
        cr = (*((uint8*) (inputImgPtr++)));

        /*------------------------------------------------------------------
            get the next luma value
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr++));

        /*-----------------------------------------------------------------
        Following piece of code is a template for the YCrCb to RGB
        conversion when you find some bug on this make sure you fix all the
        templates used in this file
        -----------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
          rTable, gTable, bTable);


        *(uint16 *)outputImgPtr++ = out;
        *(uint16 *)outputImgPtr++ = out2;
      }
    } /* End of col loop */

    inputImgPtr = (uint8*)( (uint32) inputImgPtr + rowInc); //lint !e737
    frameImgPtr = (uint16*)((uint32)frameImgPtr + rowInc);  //lint !e737
    outputImgPtr = (uint16*)((uint32)outputImgPtr + destInc); //lint !e737
  } /* End of row loop */

  return(IPL_SUCCESS);

} /* end of function ipl2_Rot000Frame_YCbCrToRGB444 */

/*==========================================================================

FUNCTION ipl2_Rot000Frame_YCbCrToRGB565()

DESCRIPTION
  As the name indicates this function caters for the case of converting a
  YCrCb based image to a RGB565 coded image. The function  cropping
  and framing as well.

DEPENDENCIES
  None

ARGUMENTS IN
 input_img_ptr   - input image frame
 input_frame_ptr -  Points to the frame  for tranparent overlays
 output_img_ptr  - Points to the output image
 transparentValue - transparent value used for framing
 crop            -  Crop config

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Changes the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot000Frame_YCbCrToRGB565
(
  ipl_image_type* input_img_ptr,        /* input image pointer */
  ipl_image_type* input_frame_ptr,      /* Points to the frame       */
  ipl_image_type* output_img_ptr,       /* Points to the output image     */
  ipl_rect_type* crop,                  /* Crop config                    */
  uint16 transparentValue               /* Transparent pixel value       */
)
{
  register uint8 cb, cr;
  register int32 lumaa1, lumaa2, r;
  register unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16*) output_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) input_frame_ptr->imgPtr;
  register uint16 out, out2;
  register uint32 row,col;
  register const uint16 *rTable = &(ipl2_r5xx[0]);
  register const uint16 *gTable = &(ipl2_gx6x[0]);
  register const uint16 *bTable = &(ipl2_bxx5[0]);
  int32 rowInc=0,dest_index,destInc;

  MSG_LOW("inside ipl2_Rot000Frame_YCbCrToRGB565\n");

  /*------------------------------------------------------------------------
       initialize the index to starting position
  ------------------------------------------------------------------------*/
  dest_index =  (int32)( (crop->x + output_img_ptr->dx*crop->y) * 2  );
  rowInc = (int32) ( (int32) (input_img_ptr->dx - crop->dx ) * 2 );
  destInc = (int32) ( output_img_ptr->dx - crop->dx) * (int32) 2;

  /*------------------------------------------------------------------------
    reposition the output image to match with the cropping parameter.
    So that it is correctly positioned in the output frame
  ------------------------------------------------------------------------*/
  outputImgPtr = (uint16*)( (uint32)outputImgPtr +  dest_index); //lint !e737

  /*------------------------------------------------------------------------
    Now loop through the image once
  ------------------------------------------------------------------------*/
  for ( row = crop->dy; row; row-- )
  {
    for ( col = crop->dx/2; col; col-- )
    {
      if ( *(uint16*) (frameImgPtr) != transparentValue )
      {

        /*------------------------------------------------------------------
          Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = *frameImgPtr;
        outputImgPtr++;
        frameImgPtr++;
        *outputImgPtr = *frameImgPtr;
        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr+=4;
      }
      else
      {
        /*------------------------------------------------------------------
            Advance the image frame pointer by one pixel
        ------------------------------------------------------------------*/
        frameImgPtr += 2;

        /*------------------------------------------------------------------
                This is Cb
        ------------------------------------------------------------------*/
        cb = (*((uint8*)(inputImgPtr++)));

        /*------------------------------------------------------------------
                Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
              Next byte is cr
        ------------------------------------------------------------------*/
        cr = (*((uint8*) (inputImgPtr++)));

        /*------------------------------------------------------------------
              get the next luma value
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
        Following piece of code is a template for the YCrCb to RGB
        conversion when you find some bug on this make sure you fix all the
        templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,  \
          rTable, gTable, bTable);

        *(uint16 *)outputImgPtr++ = out;
        *(uint16 *)outputImgPtr++ = out2;
      }

    } /* End of col loop */

    inputImgPtr = (uint8*)((uint32)inputImgPtr + rowInc); //lint !e737
    frameImgPtr = (uint16*)((uint32)frameImgPtr + rowInc); //lint !e737
    outputImgPtr = (uint16*)((uint32)outputImgPtr + destInc); //lint !e737

  } /* End of row loop */
  return(IPL_SUCCESS);

} /* end of function ipl2_Rot000Frame_YCbCrToRGB565 */

/*==========================================================================
FUNCTION ipl2_Rot180Frame_YCbCToRGB()

DESCRIPTION
  This function alters the converts a YCBCR image to an RGB flavor.
  Which includes RGB444/565/666. The function does framing 180 degree
  rotation and cropping as well.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr  - input image frame
  o_img_ptr - Points to the output image
  transparentValue - transparent val for framing
  rowInc         - row increment after each col copy - depends on rotation
  colInc         - the col inrement for iteration - depends on rotation
  crop           - the cropping needed if any

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Alters the output buffer

==========================================================================*/
static ipl_status_type ipl2_Rot180Frame_YCbCToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                    */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                    */
  uint16 transparentValue, /* transparent value of pixel                  */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                    */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  int32 src_index,dest_index;
  int32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* outputImgPtr = o_img_ptr->imgPtr;
  unsigned char* frameImgPtr;
  register uint16 out, out2;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint8 cb,cr, lumaa1=0;
  register int32 r, lumaa2=0;
  register int32 frameIncr = 0;

  MSG_LOW("inside ipl2_Rot180Frame_YCbCrToRGB\n");

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
         initialize the conversion with RGB 565 packing table
       -------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
         initialize the conversion with RGB444 table
       -------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :

      return( ipl2_Rot180Frame_YCbCToRGB666(
        i_img_ptr,    /* Input Image Pointer                     */
        i_frame_ptr,  /* Input Frame Pointer                     */
        transparentValue, /* transparent value of pixel                   */
        o_img_ptr,   /* Output Image Pointer                     */
        startPos, colInc, rowInc,  crop) );
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*NOTREACHED*/
      break;
  }


  /*------------------------------------------------------------------------
     initialize the index to starting position
   -----------------------------------------------------------------------*/
  src_index = startPos * 2;  /* byte addressed */
  dest_index = (int32) ( (crop->x + o_img_ptr->dx*crop->y) <<1 );
  frame_index = 0;

  /*------------------------------------------------------------------------
    2 different loop for framing and no framing case ..
    more optimized for no framing
  ------------------------------------------------------------------------*/
  if ( i_frame_ptr )
  {
    frameImgPtr = i_frame_ptr->imgPtr;

    if( !frameImgPtr )
    {
      return( IPL_FAILURE );
    }

    frameIncr = (int32) ( (i_frame_ptr->dx - crop->dx) <<1 );

    /*----------------------------------------------------------------------
           Now loop through the image once
     ---------------------------------------------------------------------*/
    for ( row = 0; row < crop->dy; row++ )
    {
      for ( col = 0; col < (crop->dx); col=col+2 )
      {
        if ( (*(uint16*)(frameImgPtr + frame_index)) != transparentValue)
        {
          /*----------------------------------------------------------------
             if we have 565 no shift add
          ----------------------------------------------------------------*/
          if ( o_img_ptr->cFormat ==  IPL_RGB565 )
          {
            /*--------------------------------------------------------------
               Use frame
            --------------------------------------------------------------*/
            *((uint16*)(outputImgPtr + dest_index))=
                                    *((uint16*)(frameImgPtr + frame_index));
            *((uint16*)(outputImgPtr + dest_index+2))=
                                  *((uint16*)(frameImgPtr + frame_index+2));
          }
          else
          {
            /*--------------------------------------------------------------
               convert 565 to 444 pixel
             -------------------------------------------------------------*/

            /*--------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
            --------------------------------------------------------------*/
            out =
                *(uint16*)((uint32)frameImgPtr + frame_index); //lint !e737
            r = (unsigned char)((out&0xF800)>>8);
            out2 = (uint16 ) ipl2_r444[r];
            r = (unsigned char)((out&0x07E0)>>3);
            out2 += (uint16) ipl2_g444[r];
            r = (unsigned char)((out&0x001F)<<3);
            out2 +=  (uint16) ipl2_b444[r];
            *((uint16 *) ((uint32)outputImgPtr + dest_index)) = //lint !e737
                                                                 out2; //lint !e737

            out =
               *(uint16*)((uint32)frameImgPtr + frame_index + 2); //lint !e737
            r = (unsigned char)((out&0xF800)>>8);
            out2 = (uint16) ipl2_r444[r];
            r = (unsigned char)((out&0x07E0)>>3);
            out2 += (uint16) ipl2_g444[r];
            r = (unsigned char)((out&0x001F)<<3);
            out2 += (uint16) ipl2_b444[r];
            *((uint16*)(outputImgPtr + dest_index+2))=out2;

          }

        }
        else
        {
          /*----------------------------------------------------------------
             Convert input to rgb
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
                    This is Cr
          ----------------------------------------------------------------*/
          cr = *((uint8*)(inputImgPtr + src_index));

          /*----------------------------------------------------------------
                  Next Byte is luma of first pixel
          ----------------------------------------------------------------*/
          lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

          /*----------------------------------------------------------------
                Next byte is cb
          ----------------------------------------------------------------*/
          cb =
           *( (uint8*) (inputImgPtr + src_index + (colInc << 1) ) ); //lint !e703

          /*----------------------------------------------------------------
              Next byte is luma of 2nd pixel
          ----------------------------------------------------------------*/
          lumaa2 =
           (int32) *((uint8*) (inputImgPtr + src_index + (colInc<<1) +1 ) ); //lint !e703

          /*----------------------------------------------------------------
           Following piece of code is a template for the YCrCb to RGB
           conversion when you find some bug on this make sure you fix all
           the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
            rTable, gTable, bTable);

          *((uint16*)(outputImgPtr + dest_index)) = out;
          *((uint16*)(outputImgPtr + dest_index+2)) = out2;
        }
        src_index += (colInc << 2); //lint !e703
        dest_index += 4;
        frame_index += 4;

      } /* End of col loop */

      src_index =
        src_index + (rowInc<<1) - (colInc<<1); //lint !e703 !e737
      dest_index =
        dest_index + ( (uint32) (o_img_ptr->dx - crop->dx) << 1 ); //lint !e703 !e737 !e713
      frame_index += frameIncr;

    } /* End of row loop */
  }
  else
  {
    /*----------------------------------------------------------------------
        More optimized loop for No framing case
    ----------------------------------------------------------------------*/

    /*----------------------------------------------------------------------
         Now loop through the image once
    ----------------------------------------------------------------------*/
    for ( row = 0; row < crop->dy; row++ )
    {
      for ( col = 0; col < (crop->dx); col=col+2 )
      {
        /*------------------------------------------------------------------
           Convert input to rgb
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
               This is Cr
        ------------------------------------------------------------------*/
        cr = *((uint8*)(inputImgPtr + src_index));

        /*------------------------------------------------------------------
          Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
              Next byte is cb
        ------------------------------------------------------------------*/
        cb =
           *( (uint8*)( inputImgPtr + src_index
                         + (colInc << 1 ) ) ); //lint !e703

        /*------------------------------------------------------------------
            Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 =  (int32) *((uint8*)(inputImgPtr +
                  src_index + (colInc <<1 ) + 1 ) ); //lint !e703

        /*------------------------------------------------------------------
         Following piece of code is a template for the YCrCb to RGB
         conversion when you find some bug on this make sure you fix all the
         templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
          rTable, gTable, bTable);

        *((uint16*)(outputImgPtr + dest_index)) = out;
        *((uint16*)(outputImgPtr + dest_index+2)) = out2;
        src_index += (colInc<<2); //lint !e703
        dest_index += 4;

      } /* End of col loop */

      src_index =
              src_index + (rowInc<<1) - (colInc<<1); //lint !e703
      dest_index =
            dest_index +
            (int32) ( (o_img_ptr->dx - crop->dx) << 1); //lint !e703
    }
  }

  return(IPL_SUCCESS);

} /* end of function ipl2_Rot180Frame_YCbCToRGB */

/*===========================================================================
FUNCTION ipl2_Rot090Frame_YCbCToRGB()

DESCRIPTION
  This function alters the converts a YCBCR image to an RGB flavor.
  Which includes RGB444/565/666. The function does framing 90 degree
  rotation and cropping as well.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr  - input image frame
  transparentValue - transparent val for framing
  rowInc         - row increment after each col copy - depends on rotation
  colInc         - the col inrement for iteration - depends on rotation
  crop           - the cropping needed if any

ARGUMENTS OUT
  o_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Alters the output buffer

==========================================================================*/
static ipl_status_type ipl2_Rot090Frame_YCbCToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                   */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                   */
  uint16 transparentValue, /* transparent value of pixel                 */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                   */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  int32 src_index,dest_index;
  int32 frame_index;
  uint32 row,col;
  ipl_image_type* input_frame_ptr = i_frame_ptr;
  ipl_image_type* output_img_ptr = o_img_ptr;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* outputImgPtr = output_img_ptr->imgPtr;
  unsigned char* frameImgPtr;
  register uint16 out, out2;
  register int32 cb,cr,r,cbb2, crr2, lumaa1=0, lumaa2=0;
  register int32 frameIncr = 0;
  unsigned char r1;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot090Frame_YCbCToRGB\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
      /*WARN*/
  }

  /*------------------------------------------------------------------------
         RGB666 requires special handling ... 32 bit output
  ------------------------------------------------------------------------*/
  switch ( output_img_ptr->cFormat )
  {
    case IPL_RGB666:
      return(ipl2_Rot090Frame_YCbCToRGB666( \
        i_img_ptr,    /* Input Image Pointer                     */
        i_frame_ptr,  /* Input Frame Pointer                     */
        transparentValue, /* transparent value of pixel                   */
        o_img_ptr,   /* Output Image Pointer                     */
        startPos,
        colInc, rowInc,  crop
        ) );
      /*--------------------------------------------------------------------
            Lint complains here. Ignoring
      --------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    case IPL_RGB565:
      /*--------------------------------------------------------------------
           initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
         initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    default:
      return( IPL_FAILURE);
      /*--------------------------------------------------------------------
          Lint Cribs
      --------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
     initialize the index to starting position
  ------------------------------------------------------------------------*/
  src_index = startPos * 2;
  dest_index = (int32) (crop->x + output_img_ptr->dx * crop->y) * 2;
  frame_index = 0;

  if ( input_frame_ptr )
  {

    frameImgPtr = input_frame_ptr->imgPtr;

    /*----------------------------------------------------------------------
        If the frame did not contain a valid frameImgPtr return
    ----------------------------------------------------------------------*/
    if(!frameImgPtr)
    {
      return( IPL_FAILURE );
    }

    frameIncr = (int32) ( i_frame_ptr->dx - crop->dx ) * 2;

    /*----------------------------------------------------------------------
         Now loop through the image once
    ----------------------------------------------------------------------*/
    for ( row = render_row_size; row; row-- )
    {
      for ( col = 0; col < render_col_size; col = col + 2 )
      {
        if (*(uint16*) (frameImgPtr + frame_index) != transparentValue)
        {
          if ( output_img_ptr->cFormat == IPL_RGB565 )
          {
            /*--------------------------------------------------------------
                           Use frame
            --------------------------------------------------------------*/
            *((uint16*)(outputImgPtr + dest_index))=
                                   *((uint16*)(frameImgPtr + frame_index));
            *((uint16*)(outputImgPtr + dest_index+2))=
                                  *((uint16*)(frameImgPtr + frame_index+2));
          }
          else
          {
            /*--------------------------------------------------------------
                   Use frame but convert it to rgb444
            --------------------------------------------------------------*/
            out =
             *(uint16*)( (uint32) frameImgPtr + frame_index); //lint !e737
            r1 = (unsigned char)((out&0xF800)>>8);
            out2 = ipl2_r444[r1];
            r1 = (unsigned char)((out&0x07E0)>>3);
            out2 += ipl2_g444[r1];
            r1 = (unsigned char)((out&0x001F)<<3);
            out2 += ipl2_b444[r1];
            *((uint16*)((uint32)outputImgPtr + dest_index))  //lint !e737
                                                  = out2; //lint !e737
            out =
                 *(uint16*)((uint32)frameImgPtr + frame_index + 2); //lint !e737
            r1 = (unsigned char)((out&0xF800)>>8);
            out2 = ipl2_r444[r1];
            r1 = (unsigned char)((out&0x07E0)>>3);
            out2 += ipl2_g444[r1];
            r1 = (unsigned char)((out&0x001F)<<3);
            out2 += ipl2_b444[r1];
            *((uint16*)(outputImgPtr + dest_index+2))=out2;
          }
        }
        else
        {
          /*----------------------------------------------------------------
             Convert input to rgb
           ---------------------------------------------------------------*/

          /*----------------------------------------------------------------
             This is Cb
          ----------------------------------------------------------------*/
          cb = *((uint8*)(inputImgPtr + src_index ) );
          cbb2 = *((uint8*)(inputImgPtr + src_index - 2));

          /*----------------------------------------------------------------
               Next Byte is luma of first pixel
          ----------------------------------------------------------------*/
          lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

          /*----------------------------------------------------------------
               Next byte is cr
          ----------------------------------------------------------------*/
          cr =
            *((uint8*)( inputImgPtr +
                        src_index + (colInc << 1) ) ); //lint !e703
          crr2 =
           *((uint8*)(inputImgPtr +
                       src_index + (colInc <<1 ) + 2 ) ); //lint !e703

          /*----------------------------------------------------------------
                Next byte is luma of 2nd pixel
          ----------------------------------------------------------------*/
          lumaa2 =
            *((uint8*)(inputImgPtr + src_index +
                       ( colInc <<1 ) + 1) ); //lint !e703

          /*----------------------------------------------------------------
            Adjust Cb and Cr for odd and even rows
          ----------------------------------------------------------------*/
          if ( row%2 )
          {
            cb = cbb2;
          }
          else
          {
            cr = crr2;
          }

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix all
            the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,
                                    rTable, gTable, bTable);


          *((uint16*)(outputImgPtr + dest_index)) = out;
          *((uint16*)(outputImgPtr + dest_index+2)) = out2;

        }

        src_index += (colInc<<2); //lint !e703
        dest_index += 4;
        frame_index += 4;

      } /* End of col loop */

      src_index =
        src_index + ( rowInc << 1) - ( colInc << 1 ); //lint !e703
      dest_index = dest_index +
        (int32) ( (output_img_ptr->dx - crop->dx) << 1); //lint !e703
      frame_index+=frameIncr;

    } /* End of row loop */

    return(IPL_SUCCESS);
  }
  else
  {
    /*----------------------------------------------------------------------
         more optimized code path for no framing case
     ---------------------------------------------------------------------*/

    /*----------------------------------------------------------------------
       Now loop through the image once
     ---------------------------------------------------------------------*/
    for ( row = 0; row < render_row_size; row++ )
    {
      for ( col = 0; col < render_col_size; col=col+2 )
      {
        /*------------------------------------------------------------------
            Convert input to rgb
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
             This is Cb
         -----------------------------------------------------------------*/
        cb = *((uint8*)(inputImgPtr + src_index));
        cbb2 = *((uint8*)(inputImgPtr + src_index - 2));

        /*------------------------------------------------------------------
           Next Byte is luma of first pixel
         -----------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
           Next byte is cr
        ------------------------------------------------------------------*/
        cr =
          *((uint8*)(inputImgPtr + src_index +
                     (colInc << 1) ) ); //lint !e703
        crr2 =
          *((uint8*)(inputImgPtr + src_index +
                     (colInc <<1 )+2) ); //lint !e703

        /*------------------------------------------------------------------
           Next byte is luma of 2nd pixel
         -----------------------------------------------------------------*/
        lumaa2 =
          *((uint8*)(inputImgPtr + src_index +
                     (colInc <<1 ) + 1)); //lint !e703

        /*------------------------------------------------------------------
            Swap Cb and Cr in case of Odd no of rows. Should consider
            moving this check outside.
        ------------------------------------------------------------------*/
        if ( row%2 )
        {
          cb = cbb2;
        }
        else
        {
          cr = crr2;
        }

        /*------------------------------------------------------------------
        Following piece of code is a template for the YCrCb to RGB
        conversion when you find some bug on this make sure you fix all the
        templates used in this file
       -------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,
                                  rTable, gTable, bTable);


        *((uint16*)(outputImgPtr + dest_index)) = out;
        *((uint16*)(outputImgPtr + dest_index+2)) = out2;

        src_index +=
           ( colInc << 2 ); //lint !e703
        dest_index += 4;

      } /* End of col loop */

      src_index = src_index +
        (rowInc <<1 ) - ( colInc << 1); //lint !e703

      dest_index = dest_index +
        (int32) ( (output_img_ptr->dx - crop->dx) << 1); //lint !e703

    } /* End of row loop */
    return(IPL_SUCCESS);
  }
} /* end of function ipl2_Rot090Frame_YCbCToRGB */

/*==========================================================================
FUNCTION ipl2_Rot270Frame_YCbCToRGB()

DESCRIPTION
  This function alters the converts a YCBCR image to an RGB flavor.
  Which includes RGB444/565/666. The function does framing 270 degree
  rotation and cropping as well.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr  - input image frame
  transparentValue - transparent val for framing
  startPos        - start position into the image
  rowInc         - row increment after each col copy - depends on rotation
  colInc         - the col inrement for iteration - depends on rotation
  crop           - the cropping needed if any

ARGUMENTS OUT
  o_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Alters the output buffer

==========================================================================*/
static ipl_status_type ipl2_Rot270Frame_YCbCToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                   */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                   */
  uint16 transparentValue, /* transparent value of pixel                 */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                    */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  int32 src_index,dest_index;
  int32 frame_index;
  uint32 row,col;
  ipl_image_type* input_frame_ptr = i_frame_ptr;
  ipl_image_type* output_img_ptr = o_img_ptr;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* outputImgPtr = output_img_ptr->imgPtr;
  unsigned char* frameImgPtr;
  unsigned char r1;
  unsigned short out;
  register int32 cb,cr;
  unsigned char cbb2=0,crr2=0;
  register long r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register int32 lumaa1, lumaa2=0;
  int32 frameIncr = 0;
  uint16 out2;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot270Frame_YCbCToRGB\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
      /*WARN*/
  }

  /*-----------------------------------------------------------------------
         RGB666 requires special handling ... 32 bit output
  ----------------------------------------------------------------------- */
  switch ( output_img_ptr->cFormat )
  {
    case IPL_RGB666:
      return(ipl2_Rot270Frame_YCbCToRGB666( \
        i_img_ptr,    /* Input Image Pointer                     */
        i_frame_ptr,  /* Input Frame Pointer                     */
        transparentValue, /* transparent value of pixel          */
        o_img_ptr,   /* Output Image Pointer                     */
        startPos,
        colInc, rowInc,  crop
        ) );
      /*-------------------------------------------------------------------
        Lint complains here ignoring
      --------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
    case IPL_RGB565:
      /*--------------------------------------------------------------------
           initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
           initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    default:
      /*-------------------------------------------------------------------
        Lint complains here ignoring
      --------------------------------------------------------------------*/
      return( IPL_FAILURE);
      /*NOTREACHED*/
      break;
  }
  /*------------------------------------------------------------------------
     initialize the index to starting position
  ------------------------------------------------------------------------*/

  src_index = startPos * 2;
  dest_index = (int32) ( (crop->x + output_img_ptr->dx * crop->y) * 2 );
  frame_index = 0;
  if ( i_frame_ptr )
  {
    frameImgPtr = input_frame_ptr->imgPtr;

    if(!frameImgPtr)
    {
      return( IPL_FAILURE );
    }

    frameIncr = (int32) ( (i_frame_ptr->dx - crop->dx) * 2 );
    /*----------------------------------------------------------------------
           Now loop through the image once
     ---------------------------------------------------------------------*/
    for ( row = 0; row < render_row_size; row++ )
    {
      for ( col = 0; col < render_col_size; col=col+2 )
      {
        if ( (*(uint16*) (frameImgPtr + frame_index)) != transparentValue)
        {
          if ( output_img_ptr->cFormat == IPL_RGB565 )
          {
            /*--------------------------------------------------------------
                               Use frame
            --------------------------------------------------------------*/
            *((uint16*)(outputImgPtr + dest_index))=
                                    *((uint16*)(frameImgPtr + frame_index));
            *((uint16*)(outputImgPtr + dest_index+2))=
                                  *((uint16*)(frameImgPtr + frame_index+2));
          }
          else
          {
            /*--------------------------------------------------------------
                 ** Convert frame to RGB444
            --------------------------------------------------------------*/
            out =
              *(uint16*)( (uint32) frameImgPtr + frame_index); //lint !e737
            r1 = (unsigned char)((out&0xF800)>>8);
            out2 = ipl2_r444[r1];
            r1 = (unsigned char)((out&0x07E0)>>3);
            out2 += ipl2_g444[r1];
            r1 = (unsigned char)((out&0x001F)<<3);
            out2 += ipl2_b444[r1];

            *((uint16*)((uint32)outputImgPtr + dest_index)) = //lint !e737
                                                           out2;
            out =
             *(uint16*)((uint32)frameImgPtr + frame_index + 2); //lint !e737
            r1 = (unsigned char)((out&0xF800)>>8);
            out2 = ipl2_r444[r1];
            r1 = (unsigned char)((out&0x07E0)>>3);
            out2 += ipl2_g444[r1];
            r1 = (unsigned char)((out&0x001F)<<3);
            out2 += ipl2_b444[r1];
            *((uint16*)(outputImgPtr + dest_index+2)) = //liunt !e737
                                                           out2;

          }

        }
        else
        {
          /*----------------------------------------------------------------
                   Convert input to rgb
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
               This is Cb
          ----------------------------------------------------------------*/
          cb = *((uint8*)(inputImgPtr + src_index - 2));
          cbb2 = *((uint8*)(inputImgPtr + src_index ));

          /*----------------------------------------------------------------
                 Next Byte is luma of first pixel
          ----------------------------------------------------------------*/
          lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

          /*----------------------------------------------------------------
               Next byte is cr
           ---------------------------------------------------------------*/
          cr =
            *((uint8*)(inputImgPtr + src_index +  //lint !e737
                       (colInc<<1) + 2 ) ); //lint !e737 !e703
          crr2 =
            *((uint8*)(inputImgPtr + src_index + //lint !e737
                        (colInc<<1) ) ); //lint !e737 !e703

          /*----------------------------------------------------------------
               Next byte is luma of 2nd pixel
          ----------------------------------------------------------------*/
          lumaa2 =
            *((uint8*)( inputImgPtr + src_index +  //lint !e737
                        (colInc<<1) + 1 )); //lint !e737 !e703

          if ( row%2 )
          {
            cb = cbb2;
          }
          else
          {
            cr = crr2;
          }

          /*----------------------------------------------------------------
              Following piece of code is a template for the YCrCb to RGB
              conversion when you find some bug on this make sure you fix
              all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
            rTable, gTable, bTable);

          *((uint16*)(outputImgPtr + dest_index)) = out;
          *((uint16*)(outputImgPtr + dest_index+2)) = out2;
        }
        src_index += (colInc<<2); //lint !e703
        dest_index += 4;
        frame_index += 4;
      } /* End of col loop */

      /*--------------------------------------------------------------------
        Increment the offsets for the next row
      --------------------------------------------------------------------*/
      src_index = src_index +
                  (rowInc<<1) - (colInc<<1);//lint !e703
      dest_index = dest_index +
                   (int32) ( ( (output_img_ptr->dx
                                - crop->dx) << 1) ); //lint 703
      frame_index += frameIncr;

    } /* End of row loop */
    return(IPL_SUCCESS);
  }
  else
  {
    /*----------------------------------------------------------------------
             MORE OPTMIZED LOOP
    ----------------------------------------------------------------------*/

    /*----------------------------------------------------------------------
         Now loop through the image once
    ----------------------------------------------------------------------*/
    for ( row = 0; row < crop->dy; row++ )
    {
      for ( col = 0; col < (crop->dx); col=col+2 )
      {
        /*------------------------------------------------------------------
             Convert input to rgb
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
             This is Cb
        ------------------------------------------------------------------*/
        cb = *((uint8*)(inputImgPtr + src_index - 2));
        cbb2 = *((uint8*)(inputImgPtr + src_index ));

        /*------------------------------------------------------------------
               Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
             Next byte is cr
         -----------------------------------------------------------------*/
        cr =
          *((uint8*)(inputImgPtr + src_index + (colInc<<1) + 2 ) ); //lint !e703
        crr2 =
          *( (uint8*) (inputImgPtr + src_index + (colInc<<1) ) ); //lint !e703

        /*------------------------------------------------------------------
             Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)
                   (inputImgPtr + src_index + (colInc << 1) + 1)); //lint !e703
        if ( row%2 )
        {
          cb = cbb2;
        }
        else
        {
          cr = crr2;
        }

        /*------------------------------------------------------------------
        Following piece of code is a template for the YCrCb to RGB
        conversion when you find some bug on this make sure you fix all the
        templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,
                                  rTable, gTable, bTable);

        *((uint16*)(outputImgPtr + dest_index)) = out;
        *((uint16*)(outputImgPtr + dest_index+2)) = out2;

        src_index += ( colInc << 2 ); //lint !e703
        dest_index += 4;

      } /* End of col loop */

      src_index =
        src_index + (rowInc << 1 ) - (colInc<<1); //lint !e703
      dest_index =
        dest_index + (int32) ( (output_img_ptr->dx - crop->dx) << 1); //lint !e703

    } /* End of row loop */
    return(IPL_SUCCESS);
  }

} /* end of function ipl2_Rot270Frame_YCbCToRGB */

/*==========================================================================

                          IPL2_YCBCR420.C

DESCRIPTION

    This file contains color convertion, rotation and farming of YCbCr4:2:0
    format images into other color including RGB565/444/666.  The conversion
    to YCbCr442 is not supported right now.

            ipl2_handle_YCbCrImg
                |
                |
-----------|-----|--------------
|          |                   |
|          |                   |--ipl2_Rot000Frame_YCrCbCr4202YCbCr
|          |                   |    (handle, rotation framing and cropping
|          |                   |      of YCbCr based image )
|          |                   |
|          |           ipl2_Rot000Frame_YCbCr420ToRGB(handle rotation)
|          |                       |
|          |                       | (rotation, and cropping )
|          |                       |_______ipl2_Rot090_YCbCr420ToRGB
|          |                       |       ipl2_Rot180_YCbCr420TpRGB
|          |                       |       ipl2_Rot270_YCbCr420ToRGB
|          |                       |       ipl2_Rot090_YCbCr420ToRGB666
|          |                       |       ipl2_Rot180_YCbCr420ToRGB666
|          |                       |       ipl2_Rot270_YCbCr420ToRGB666
|          |                       |
|          |                       |(rotation, cropping and framing)
|          |                ipl2_Rot090Frame_YCbCr420TpRGB
|          |                ipl2_Rot180Frame_YCbCr420ToRGB
|          |                ipl2_Rot270Frame_YCbCr420ToRGB
|          |                ipl2_Rot090Frame_YCbCr420ToRGB666
|          |                ipl2_Rot180Frame_YCbCr420RGB666
|          |                ipl2_Rot270Frame_YCbCr420ToRGB666
|          |                ipl2_Rot090Frame_YCbCr420ToRGB444
|          |                ipl2_Rot180Frame_YCbCr420RGB444
|          |                ipl2_Rot270Frame_YCbCr420ToRGB444
|          |
|          |(no rotation but there is framing and cropping)
|       ipl2_Rot000Frame_YCbCrToRGB444
|       ipl2_Rot000Frame_YCbCrToRGB565
|       ipl2_Rot000Frame_YCbCrToRGB666
|           |
|           |
|          ipl2_Rot000Frame_YCbCr420ToYCbCr ( to be  coded later)
|
ipl2_YCbCrToRGB (565/444 no rot no framimg,
|                                   cropping only, most speedy )
ipl2_YCbCrToRGB666
|
| (YCbCr442 O/P)
ipl2_YCbCripl2_CbToYCrCb (not coded)


EXTERNALIZED FUNCTIONS

  ipl2_handle_YCbCr420Img()
      Handles the color conversion, framing, rotation and cropping of
      YCbCr420 based images.

INITIALIZATION AND SEQUENCING REQUIREMENTS

  The library will function properly only if the ipl2_init()
  function is called before calling anything else.

Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.

=========================================================================*/

/*=========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     --------------------------------------------------------
05/24/04   srk     Linted updated the call flow. Gettiing review ready.
05/05/04   srk     Initially created.
========================================================================= */

/*===========================================================================

                          FUNCTION DEFINITIONS

===========================================================================*/



/*==========================================================================

FUNCTION IPL2_HANDLE_YCRCB420LPIMG

DESCRIPTION

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  icon_list_ptr - not used kept there for signature sake
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
/*ARGSUSED*/
static ipl_status_type ipl2_handle_YCrCb420lpImg
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  ipl_status_type status;

  MSG_LOW("inside ipl2_handle_YCrCb420lpImg\n");

  /*-----------------------------------------------------------------------
      For the kind of packing used in YUV420 array we need even no of cols
      for sure. For cases involoving rotation rows and cols will change and
      it is best to check for even rows and cols before proceeding.
      Supporting these will involve more complicated routines.
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dx & 0x1) || (i_img_ptr->dy & 0x1) )
  {
    IPL2_MSG_ERROR( "ipl2_handle_YCrCb420lpImg failed i_img_ptr->dx = %lu, /\
               i_img_ptr->dy  = %lu", (uint32) i_img_ptr->dx,
               (uint32)i_img_ptr->dy );

    return( IPL_FAILURE );
  }

  /*------------------------------------------------------------------------
      Current scheme will truncate it to lower even. Otherwise the
      alogorithms will become unnecessarily complex.
  -----------------------------------------------------------------------*/
  if( (crop->dx & 0x1) || (crop->dy & 0x1) )
  {
    /*----------------------------------------------------------------------
          Warn the user strongly
    ----------------------------------------------------------------------*/
    IPL2_MSG_HIGH( "ipl2_handle_YCrCb420lpImg proceeding with /\
               less than acceptable cropping params crop->dx = %lu, /\
               crop->dy  = %lu will like them both even ", (uint32) crop->dx,
               (uint32)crop->dy);

  }

  status = ipl2_RotFrame_YCrCb420lpToRGB(
             i_img_ptr,    /* Input Image Pointer            */
             input_frame_ptr,  /* Input Frame Pointer               */
             transparentValue, /* transparent value of pixel        */
             o_img_ptr,   /* Output Image Pointer                   */
             crop,
             rotate);
    return(status);
} 


/*==========================================================================

FUNCTION IPL2_HANDLE_YCBCR420IMG

DESCRIPTION

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  icon_list_ptr - not used kept there for signature sake
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
/*ARGSUSED*/
static ipl_status_type ipl2_handle_YCbCr420Img
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* input_frame_ptr,  /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  ipl_rotate90_type rotate,         /* Rotatation                       */
  ipl_icon_type** icon_list_ptr,    /* Ptr to null terminated icon list */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  ipl_status_type status;

  MSG_LOW("inside ipl2_handle_YCbCr420Img\n");

  /*-----------------------------------------------------------------------
      For the kind of packing used in YUV420 array we need even no of cols
      for sure. For cases involoving rotation rows and cols will change and
      it is best to check for even rows and cols before proceeding.
      Supporting these will involve more complicated routines.
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dx & 0x1) || (i_img_ptr->dy & 0x1) )
  {
    IPL2_MSG_ERROR( "ipl2_handle_YCbCr420Img failed i_img_ptr->dx = %lu, /\
               i_img_ptr->dy  = %lu", (uint32) i_img_ptr->dx,
               (uint32)i_img_ptr->dy );

    return( IPL_FAILURE );
  }

  /*------------------------------------------------------------------------
      Current scheme will truncate it to lower even. Otherwise the
      alogorithms will become unnecessarily complex.
  -----------------------------------------------------------------------*/
  if( (crop->dx & 0x1) || (crop->dy & 0x1) )
  {
    /*----------------------------------------------------------------------
          Warn the user strongly
    ----------------------------------------------------------------------*/
    IPL2_MSG_HIGH( "ipl2_handle_YCbCr420Img proceeding with /\
               less than acceptable cropping params crop->dx = %lu, /\
               crop->dy  = %lu will like them both even ", (uint32) crop->dx,
               (uint32)crop->dy );

  }

  /*------------------------------------------------------------------------
      Handle the simpler case of no rotation
  ------------------------------------------------------------------------*/
  if ( rotate == IPL_NOROT )
  {
    if ( i_img_ptr->dx < crop->dx )
    {
      /*--------------------------------------------------------------------
           Invalid settings
      --------------------------------------------------------------------*/
      return(IPL_FAILURE);
    }
    /*----------------------------------------------------------------------
        Dont rotate
        Call a more optimized version
    ----------------------------------------------------------------------*/
    if ( input_frame_ptr == NULL )
    {

      switch ( o_img_ptr->cFormat )
      {
        case IPL_YCbCr :
          /*----------------------------------------------------------------
              Not supported now
          ----------------------------------------------------------------*/
          return( IPL_FAILURE );
          /*NOTREACHED*/
          break;

        case IPL_RGB565 :
        case IPL_RGB444 :
        case IPL_RGB666 :

          return( ipl2_YCbCr420ToRGB(
                                                       i_img_ptr,
                                                       o_img_ptr,
                                                       crop ) );
          /*NOTREACHED*/
          break;

        default:
          IPL2_MSG_FATAL( "ipl2_handle_YCbCr420Img :: /\
               unknown o/p color format = %d ", o_img_ptr->cFormat);

          return( IPL_FAILURE );
          /*NOTREACHED*/
          break;
      }
    }
    else
    {
      /*--------------------------------------------------------------------
           This case is where there is no rotation but framing required
        ------------------------------------------------------------------*/
      switch ( o_img_ptr->cFormat )
      {
        case IPL_RGB444 :
          status =  ipl2_Rot000Frame_YCbCr420ToRGB444(
                      i_img_ptr, input_frame_ptr, o_img_ptr,
                      crop, transparentValue );
          break;


        case IPL_RGB666:
          status =  ipl2_Rot000Frame_YCbCr420ToRGB666(
                      i_img_ptr, input_frame_ptr, o_img_ptr,
                      crop, transparentValue );
          break;

        case IPL_RGB565 :
          status =  ipl2_Rot000Frame_YCbCr420ToRGB565(
                      i_img_ptr,
                      input_frame_ptr,
                      o_img_ptr,
                      crop,
                      transparentValue );

          break;



        case IPL_YCbCr:
            /*NOTSUPPORTED*/
        default:

          IPL2_MSG_FATAL( "ipl2_handle_YCbCr420Img :: /\
             unknown o/p color format = %d ", o_img_ptr->cFormat);

          /*----------------------------------------------------------------
              WE MIGHT NEED YCBCR AT SOME POINT
          ----------------------------------------------------------------*/
          status =  IPL_FAILURE;
          break;
      }

      return( status );

    }
  }
  else
  {
    /*----------------------------------------------------------------------
        Enter here for Framing
    ----------------------------------------------------------------------*/

    switch ( o_img_ptr->cFormat )
    {
      case IPL_RGB444 :
      case IPL_RGB666:
      case IPL_RGB565 :
        /* all the RGB flavors handled here */
        status = ipl2_RotFrame_YCbCr420ToRGB(
                   i_img_ptr,    /* Input Image Pointer            */
                   input_frame_ptr,  /* Input Frame Pointer               */
                   transparentValue, /* transparent value of pixel        */
                   o_img_ptr,   /* Output Image Pointer                   */
                   crop,
                   rotate
                   );
        break;



      case IPL_YCbCr:
      default:

        IPL2_MSG_FATAL( "ipl2_handle_YCbCr420Img :: /\
             unknown o/p color format = %d ", o_img_ptr->cFormat);
        /*------------------------------------------------------------------
            SUDEEP NEED THIS CODED
        ------------------------------------------------------------------*/
        status =  IPL_FAILURE;
        break;

    }

    return( status );

  }

  /*NOTREACHED*/
  return( IPL_SUCCESS );

} /* end of function ipl2_handle_YCbCr420Img */









/*==========================================================================

FUNCTION    IPL2_CONVERTANDCROP_YCBCR420TORGB()

DESCRIPTION
  This function will handle cropping, color converting of
  YCbCr420 based images to different RGB flavors. This function is more
  optimalif you are not cropping . This function is specifically designed
  for the favorable input condition where - there is no framing going on. So
  transparent value check is not needed. This function calls for help when
  the output is RGB666 .This because translation very different and output
  is32 bit value.

DEPENDENCIES
  None

ARGUMENTS IN
  ipl_image_type* input_img_ptr        Points to the input image
  ipl_rect_type* crop                  Cropping parameter

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/
static ipl_status_type ipl2_YCbCr420ToRGB
(
  ipl_image_type* input_img_ptr,        /* Points to the input image    */
  ipl_image_type* output_img_ptr,       /* Points to the output image   */
  ipl_rect_type* crop                   /* Crop config                  */
)
{
  register unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16*) output_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  uint32 input_row_size = input_img_ptr->dx;
  uint32 rowSize = output_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc=0,dest_index,destInc;
  uint32 row, col, cr_offset;

  MSG_LOW("inside ipl2_YCbCr420toRGB\n");

  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + output_img_ptr->dx * crop->y) << 1 /* * 2 */;

  switch ( output_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :
      return(ipl2_YCbCr420ToRGB666(
                                                    input_img_ptr,
                                                    output_img_ptr,
                                                    crop ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
      Calculate the offset before we start stuffing in the O/P buffer
  ------------------------------------------------------------------------*/
  outputImgPtr = (uint16 *) ((uint32)outputImgPtr +  (uint32) dest_index);

  /*------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------*/
  destInc = ( output_img_ptr->dx - crop->dx )  * 2;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entire image.

            input_img->dx
      <--------------------------------->
      _________________________________
      |_______________________|________|---------> rowInc = delta in dx
      |                       |        |
      |                       |        |
      |                       |        |
      |_______________________|________|
       <---------------------->
          crop->dx

       at the end of each row we need to avance the cropped pixels rowInc
  ------------------------------------------------------------------------*/
  rowInc = (input_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
              Y values                          Cb Vals          Cr Vals

        Following calculation takes us to the beginning of the Cb Vals
  ------------------------------------------------------------------------*/
  cb_ptr = input_img_ptr->imgPtr +
           ( input_img_ptr->dx * input_img_ptr->dy  );

  /*------------------------------------------------------------------------
      Takes us to the offset for Cb Vals
  ------------------------------------------------------------------------*/
  cr_offset = ( input_img_ptr->dx * input_img_ptr->dy  ) >> 2 /* /4 */;


  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y1|Y2|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y3|Y4|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *(inputImgPtr + 1);  /* corresponds to Y2 in the pic */

      /*--------------------------------------------------------------------
            Following line gets you Y3 and then base increments on
            inputImgPtr .. Hopefully
      --------------------------------------------------------------------*/
      lumaa3 = *(inputImgPtr++ + input_row_size);
      lumaa4 = *( inputImgPtr++ + input_row_size);

      /*--------------------------------------------------------------------
          Cb is for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we offset cb_ptr.
          If you look at the pics you can see that they both move in
          tandem
      --------------------------------------------------------------------*/
      ++cb_ptr;


      /*--------------------------------------------------------------------
        Take the delta from third to fourth. This is for faster
        computation as you see later. We are doing this in the reverse order
        because we will loose the original delta if do in the forward
        order
      --------------------------------------------------------------------*/
      lumaa4 -= lumaa3;

      /*--------------------------------------------------------------------
        Take the delta from second to third. This is for faster
        computation as you see later
      --------------------------------------------------------------------*/
      lumaa3 -= lumaa2;

      /*--------------------------------------------------------------------
        Take the delta from first to second. This is for faster
        computation as you see later
      --------------------------------------------------------------------*/
      lumaa2 -= lumaa1;


      /*--------------------------------------------------------------------
        Each of these comparisons add and compares are designed to force
        the compiler to do conditional execution
      --------------------------------------------------------------------*/
      r = lumaa1 + ipl2_CrToRTable[cr];
      /*--------------------------------------------------------------------
          If  r is -ve reinitialize out = 0 and start adding stuff as
          you need it. No need for an extra check for the second pixel
      --------------------------------------------------------------------*/
      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out = rTable[ r ];
      }
      else
      {
        out = 0;
      }

      /*--------------------------------------------------------------------
          Add the delta in Luma2 to calculate the next R value
      --------------------------------------------------------------------*/
      r += lumaa2;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out2 = rTable[ r ];
      }
      else
      {
        out2 = 0;
      }

      /*--------------------------------------------------------------------
          Add the delta b/w in 2 and 3 Luma
      --------------------------------------------------------------------*/
      r += lumaa3;



      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out3 = rTable[ r ];
      }
      else
      {
        out3 = 0;
      }

      /*--------------------------------------------------------------------
          Add the delta b/w 3 and 4 in Luma to get next R4
      --------------------------------------------------------------------*/
      r += lumaa4;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out4 = rTable[ r ];
      }
      else
      {
        out4 = 0;
      }



      r = lumaa1 - ipl2_CbToGTable[cb] - ipl2_CrToGTable[cr];

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out += gTable[r];
      }

      r += lumaa2;

      if (r > 255) r = 255;
      if ( r > 0 )
      {

        out2 += gTable[r];
      }

      r += lumaa3;

      if (r > 255) r = 255;
      if ( r > 0 )
      {

        out3 += gTable[r];
      }

      r += lumaa4;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out4 += gTable[r];
      }


      r = lumaa1 + ipl2_CbToBTable[cb];
      /*--------------------------------------------------------------------
         If we have -ve or zero value we dont need to do anthing as the
         translation or effect of that component on the whole pixel
         value isbound to be zero no matter what encoding RGB flavor we
         are using.
      --------------------------------------------------------------------*/
      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out += bTable[r];
      }

      r += lumaa2;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out2 += bTable[r];
      }

      r += lumaa3;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out3 += bTable[r];
      }

      r += lumaa4;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out4 += bTable[r];
      }

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 2 /4 --> rowSize /2
        which is same as rowSize >> 1;
    ----------------------------------------------------------------------*/

    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1)  + destInc ) ;

    inputImgPtr += (uint32) (rowInc  + input_row_size);

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cb_ptr += (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_YCbCr420ToRGB */








/*==========================================================================

FUNCTION    IPL2_CONVERTCROPANDFRAME_YCBCR420TORGB565()

DESCRIPTION
  This function will handle cropping, framing color converting of
  YCbCr420 based images to different RGB565 format.

DEPENDENCIES
  None

ARGUMENTS IN
  ipl_image_type* input_img_ptr        Points to the input image
  ipl_rect_type* crop                  Cropping parameter

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/
static ipl_status_type ipl2_Rot000Frame_YCbCr420ToRGB565
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  register unsigned char* inputImgPtr= i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register uint32 input_row_size = i_img_ptr->dx;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc=0,dest_index,destInc, frame_inc;
  uint32 fr_row_size = i_frame_ptr->dx;
  uint32 row, col, cr_offset ;

  MSG_LOW("inside ipl2_Rot000Frame_YCbCr420ToRGB565\n");

  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 1 /* * 2 */;

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 565 packing table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r5xx[0]);
  gTable = &(ipl2_gx6x[0] );
  bTable = &(ipl2_bxx5[0] );

  outputImgPtr = (uint16 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

            i_img->dx
      <--------------------------------->
      _________________________________
      |_______________________|________|---------> rowInc = delta in dx
      |                       |        |
      |                       |        |
      |                       |        |
      |_______________________|________|
       <---------------------->
          crop->dx
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
            Y values                               Cb Vals      Cr Vals
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
           ( i_img_ptr->dx * i_img_ptr->dy  );

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
      Calculate the frame_inc for each row completeion
  ------------------------------------------------------------------------*/
    frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
                 i_frame_ptr->dx;      /* to account for a row advanced */

    /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = *( (uint16 *) frameImgPtr );
        *( (uint16 *)outputImgPtr + 1) = *(  (uint16 *) frameImgPtr + 1);

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + fr_row_size) )
             != transparentValue )
        {
          /* copy the pixel as well */
          *( outputImgPtr++ + rowSize ) =
            *( (uint16 *) frameImgPtr + fr_row_size);

          *( outputImgPtr++ + rowSize ) =
            * ( (uint16 *) (frameImgPtr + fr_row_size + 1) );

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr += 2;

            /*--------------------------------------------------------------
              offset the cb_ptr for next pixel
            --------------------------------------------------------------*/
            cb_ptr++;
        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cb is for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr);

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr++ + cr_offset);


          /*----------------------------------------------------------------
              Next up is Lumaa1

              Y  |  Y
              Y  |  Y
              |
              |This is out Lumaa1
          ----------------------------------------------------------------*/
          lumaa1 = * ( inputImgPtr +  input_row_size);

          /*----------------------------------------------------------------
              Extract Lumaa2
              Y | Y

              Y | Y
                  |
                  | This is our Lumaa2

          ----------------------------------------------------------------*/
          lumaa2 = * ( (uint8 *) inputImgPtr + input_row_size + 1);

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr += 2;


        }


        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + fr_row_size ) )
                  != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs               Frame pairs

          The logic here is as follows
            We know that F3 != transparentValue
                So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

          Copy remaining ie : O3 = F3 and O4  = F4

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Cb is for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr);

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr++ + cr_offset);


        /*------------------------------------------------------------------
            Next up is Lumaa1

            |
            |This is the Lumaa1
            |
            Y  |  Y
            Y  |  Y

        ------------------------------------------------------------------*/
        lumaa1 = * ( inputImgPtr++);

        /*------------------------------------------------------------------
            Extract Lumaa2

            Y | Y ------Lumaa2

            Y | Y
        ------------------------------------------------------------------*/
        lumaa2 = * ( (uint8 *) inputImgPtr++);

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/
        *( outputImgPtr++ + rowSize ) =
                           * ( (uint16*)( frameImgPtr++ + fr_row_size) );
        *( outputImgPtr++ + rowSize ) =
                            * ( (uint16*)(frameImgPtr++ + fr_row_size) );

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        If we got here that means we need to offset Frame and process the
        conversion of the whole pixels
      --------------------------------------------------------------------*/
      frameImgPtr += 2;


      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y1|Y2|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y3|Y4|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *(inputImgPtr + 1);  /* corresponds to Y2 in the pic */

      /*--------------------------------------------------------------------
            Following line gets you Y3 and then base increments on
            inputImgPtr .. Hopefully
      --------------------------------------------------------------------*/
      lumaa3 = *(inputImgPtr++ + input_row_size);
      lumaa4 = *( inputImgPtr++ + input_row_size);

      /*--------------------------------------------------------------------
          Cb is for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we offset cb_ptr.
          If you look at the pics you can see that they both move in
          tandem
      --------------------------------------------------------------------*/
      ++cb_ptr;


      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                                  (out)
          Y | Y           (this macro     RGB444/565 | RGB444/565
                   + CB/CR ----------->
          Y | Y                           RGB444/565 | RGB444/565
                                                   (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );



      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;

    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 2 /4 --> rowSize /2
        which is same as rowSize >> 1;
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1)  + destInc ) ;

    inputImgPtr += (uint32) ( rowInc + input_row_size);

    /*----------------------------------------------------------------------
      We need to keep the frame in Tandem as well
      frameImgPtr is a uint16 ptr so *2 is built in in the following
      instruction
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc ;

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cb_ptr += (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot000Frame_YCbCr420ToRGB565 */




/*==========================================================================

FUNCTION IPL2_CONVERTROTATECROPANDFRAME_YCBCR420TOToRGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Framing is also supported

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_RotFrame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop,          /* cropping params */
  ipl_rotate90_type rotate      /* Rotatation                       */
)
{
  ipl_status_type status;

  MSG_LOW("inside ipl2_RotFrame_YCbCr420ToRGB\n");

  /*------------------------------------------------------------------------
    Handle rotation with framing and without framing in two different
    handlers
  ------------------------------------------------------------------------*/
  if ( !i_frame_ptr )
  {
    switch ( rotate )
    {

      case IPL_ROT90 :
        status = ipl2_Rot090_YCbCr420ToRGB(
                   i_img_ptr,
                   o_img_ptr,
                   crop
                   );
        break;

      case IPL_ROT180 :
        status = ipl2_Rot180_YCbCr420ToRGB(
                   i_img_ptr,
                   o_img_ptr,
                   crop
                   );
        break;

      case IPL_ROT270:
        status = ipl2_Rot270_YCbCr420ToRGB(
                   i_img_ptr,
                   o_img_ptr,
                   crop
                   );

        break;

      default:

        IPL2_MSG_FATAL( "ipl2_Rot000Frame :: /\
           unknown o/p rotation = %d ", rotate);

        status = IPL_FAILURE;
        break;

    }

    return( status );

  }
  else
  {
    switch ( rotate )
    {

      case IPL_ROT90 :
        /*------------------------------------------------------------------
          Handler for 90 degree rotation with framing
        ------------------------------------------------------------------*/
        status = ipl2_Rot090Frame_YCbCr420ToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   crop
                   );
        break;

      case IPL_ROT180 :
        /*------------------------------------------------------------------
          Handler for 180 degree rotation with framing
        ------------------------------------------------------------------*/

        status = ipl2_Rot180Frame_YCbCr420ToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   crop
                   );
        break;

      case IPL_ROT270:
        /*------------------------------------------------------------------
          Handler for 270 degree rotation with framing
        ------------------------------------------------------------------*/

        status = ipl2_Rot270Frame_YCbCr420ToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   crop
                   );
        break;

      default:
        IPL2_MSG_FATAL( "ipl2_Rot000Frame :: /\
                   unknown o/p rotation = %d ", rotate);

        status = IPL_FAILURE;
        break;

    }

    return( status );


  }

} /* end of function ipl2_Rot000Frame_YCbCr420ToRGB */




/*==========================================================================

FUNCTION    IPL2_CONVERTANDCROP_YCrCb420lpTORGB()

DESCRIPTION
  This function will handle cropping, color converting of
  YCbCr420 based images to different RGB flavors. This function is more
  optimalif you are not cropping . This function is specifically designed
  for the favorable input condition where - there is no framing going on. So
  transparent value check is not needed. This function calls for help when
  the output is RGB666 .This because translation very different and output
  is32 bit value.

DEPENDENCIES
  None

ARGUMENTS IN
  ipl_image_type* input_img_ptr        Points to the input image
  ipl_rect_type* crop                  Cropping parameter

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/
extern ipl_status_type ipl2_Rot000Frame_CropYCrCb420lpToRGB
(
  ipl_image_type* input_img_ptr,    /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  uint16 transparentValue,          /* Transparent pixel value          */
  ipl_image_type* output_img_ptr,   /* Points to the output image       */
  ipl_rect_type* icrop,             /* Crop config                      */
  ipl_rect_type* ocrop              /* Crop config                      */
)
{
  unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  uint16* outputImgPtr =(uint16*) output_img_ptr->imgPtr;
  uint16* frameImgPtr;
  uint32 fr_row_size;
  uint32 frame_inc;

  uint32 out = 0, out2 = 0, out3 = 0, out4 = 0;
  uint8 cb,cr;
  int32 lumaa1, lumaa2, lumaa3, lumaa4;
  int32 r;
  const uint16 *rTable;
  const uint16 *gTable;
  const uint16 *bTable;

  uint32 input_row_size = input_img_ptr->dx;
  uint32 rowSize = output_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0,dest_index,destInc;
  uint32 row, col;
  uint32 render_col_size;
  uint32 render_row_size;
  ipl_rect_type iicrop, oocrop;
  
  MSG_LOW("inside ipl2_Rot000Frame_CropYCrCb420lpToRGB\n");
  
  if (icrop == NULL)
  {
    iicrop.x = 0;
    iicrop.y = 0;
    iicrop.dx = input_img_ptr->dx;
    iicrop.dy = input_img_ptr->dy;
  }
  else
  {
    iicrop.x  = icrop->x;
    iicrop.y  = icrop->y;
    iicrop.dx = icrop->dx;
    iicrop.dy = icrop->dy;
  }

  if (ocrop == NULL)
  {
    oocrop.x = 0;
    oocrop.y = 0;
    oocrop.dx = output_img_ptr->dx;
    oocrop.dy = output_img_ptr->dy;
  }
  else
  {
    oocrop.x  = ocrop->x;
    oocrop.y  = ocrop->y;
    oocrop.dx = ocrop->dx;
    oocrop.dy = ocrop->dy;
  }

  /*------------------------------------------------------------------------
        In this scheme odd no of cols in a row will not work.
        I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_col_size = IPL_MIN(iicrop.dx, oocrop.dx);
  render_col_size &= (~0x1);

  render_row_size = IPL_MIN(iicrop.dy, oocrop.dy);
  render_row_size &= (~0x1);


  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = oocrop.x + output_img_ptr->dx * oocrop.y;

  switch ( output_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
        initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :
      /*
      return(ipl2_YCbCr420ToRGB666(
                                                    input_img_ptr,
                                                    output_img_ptr,
                                                    crop ) );
                                                    */
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
      Calculate the offset before we start stuffing in the O/P buffer
  ------------------------------------------------------------------------*/
  outputImgPtr += dest_index;

  /*------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------*/
  destInc = ( output_img_ptr->dx - oocrop.dx );

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entire image.

            input_img->dx
      <--------------------------------->
      _________________________________
      |_______________________|________|---------> rowInc = delta in dx
      |                       |        |
      |                       |        |
      |                       |        |
      |_______________________|________|
       <---------------------->
          crop->dx

       at the end of each row we need to avance the cropped pixels rowInc
  ------------------------------------------------------------------------*/
  rowInc = (input_img_ptr->dx - render_col_size);


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
              Y values                          Cb Vals          Cr Vals

        Following calculation takes us to the beginning of the Cb Vals
  ------------------------------------------------------------------------*/
  cr_ptr = input_img_ptr->clrPtr;


  // move input imgptr to icrop beginning
  inputImgPtr += (iicrop.x + input_img_ptr->dx * iicrop.y);
  cr_ptr += (2*(iicrop.x/2) + input_img_ptr->dx * iicrop.y/2);

  if (i_frame_ptr == NULL)
  {
    /*------------------------------------------------------------------------
        We process 2 rows at a time in this encoding. So we need half the
        number of iterations
    ------------------------------------------------------------------------*/
    for ( row = render_row_size/2; row; row-- )
    {
      /*----------------------------------------------------------------------
          We process 2 cols at a time we need half the number of coloumns
          iteratios.
      ----------------------------------------------------------------------*/
      for ( col = render_col_size/2; col; col-- )
      {
  
        /*--------------------------------------------------------------------
            The format of the YCbCr420 packing as follows
  
            |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
            |--------------------------------|---------|----------|
            |--------------------------------|---------|----------|
                  Y values                     Cb Vals    Cr Vals
        --------------------------------------------------------------------*/
  
  
        /*--------------------------------------------------------------------
            Take Luma of all four pixels. The Lumma Packing is as shown
            below
  
            |Y1|Y2|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y3|Y4|
        --------------------------------------------------------------------*/
        lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
        lumaa2 = *(inputImgPtr + 1);  /* corresponds to Y2 in the pic */
  
        /*--------------------------------------------------------------------
              Following line gets you Y3 and then base increments on
              inputImgPtr .. Hopefully
        --------------------------------------------------------------------*/
        lumaa3 = *(inputImgPtr++ + input_row_size);
        lumaa4 = *( inputImgPtr++ + input_row_size);
  
        /*--------------------------------------------------------------------
            Cb is for all the 4  Yavals
        --------------------------------------------------------------------*/
        cr = *(cr_ptr++);
  
        /*--------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        --------------------------------------------------------------------*/
        cb = *(cr_ptr++);
  
        /*--------------------------------------------------------------------
          Take the delta from third to fourth. This is for faster
          computation as you see later. We are doing this in the reverse order
          because we will loose the original delta if do in the forward
          order
        --------------------------------------------------------------------*/
        lumaa4 -= lumaa3;
  
        /*--------------------------------------------------------------------
          Take the delta from second to third. This is for faster
          computation as you see later
        --------------------------------------------------------------------*/
        lumaa3 -= lumaa2;
  
        /*--------------------------------------------------------------------
          Take the delta from first to second. This is for faster
          computation as you see later
        --------------------------------------------------------------------*/
        lumaa2 -= lumaa1;
  
  
        /*--------------------------------------------------------------------
          Each of these comparisons add and compares are designed to force
          the compiler to do conditional execution
        --------------------------------------------------------------------*/
        r = lumaa1 + ipl2_CrToRTable[cr];
        /*--------------------------------------------------------------------
            If  r is -ve reinitialize out = 0 and start adding stuff as
            you need it. No need for an extra check for the second pixel
        --------------------------------------------------------------------*/
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out = rTable[ r ];
        }
        else
        {
          out = 0;
        }
  
        /*--------------------------------------------------------------------
            Add the delta in Luma2 to calculate the next R value
        --------------------------------------------------------------------*/
        r += lumaa2;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out2 = rTable[ r ];
        }
        else
        {
          out2 = 0;
        }
  
        /*--------------------------------------------------------------------
            Add the delta b/w in 2 and 3 Luma
        --------------------------------------------------------------------*/
        r += lumaa3;
  
  
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out3 = rTable[ r ];
        }
        else
        {
          out3 = 0;
        }
  
        /*--------------------------------------------------------------------
            Add the delta b/w 3 and 4 in Luma to get next R4
        --------------------------------------------------------------------*/
        r += lumaa4;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out4 = rTable[ r ];
        }
        else
        {
          out4 = 0;
        }
  
  
  
        r = lumaa1 - ipl2_CbToGTable[cb] - ipl2_CrToGTable[cr];
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out += gTable[r];
        }
  
        r += lumaa2;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
  
          out2 += gTable[r];
        }
  
        r += lumaa3;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
  
          out3 += gTable[r];
        }
  
        r += lumaa4;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out4 += gTable[r];
        }
  
  
        r = lumaa1 + ipl2_CbToBTable[cb];
        /*--------------------------------------------------------------------
           If we have -ve or zero value we dont need to do anthing as the
           translation or effect of that component on the whole pixel
           value isbound to be zero no matter what encoding RGB flavor we
           are using.
        --------------------------------------------------------------------*/
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out += bTable[r];
        }
  
        r += lumaa2;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out2 += bTable[r];
        }
  
        r += lumaa3;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out3 += bTable[r];
        }
  
        r += lumaa4;
  
        if (r > 255) r = 255;
        if ( r > 0 )
        {
          out4 += bTable[r];
        }
  
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;
        *(outputImgPtr++ + rowSize) = (uint16) out3;
        *(outputImgPtr++ + rowSize) = (uint16) out4;
      }
  
      /*----------------------------------------------------------------------
          Need to add  number of coulumns * 2 /4 --> rowSize /2
          which is same as rowSize >> 1;
      ----------------------------------------------------------------------*/
  
      outputImgPtr += (rowSize + destInc);
  
      inputImgPtr += (uint32) (rowInc  + input_row_size);
  
      /*----------------------------------------------------------------------
        Remember each four pixels has same CB/CR combination. So we need
        to add number of pixels offset divided by 4
  
        YY
        -----------------maps to one cr/cb --> cr/cb
        YY
  
      ----------------------------------------------------------------------*/
      //cb_ptr += (rowInc) >> 1 /* divided by 2 */;
      cr_ptr += (rowInc);
    }
  }
  else
  {
  
    /*------------------------------------------------------------------------
        Calculate the frame_inc for each row completeion
    ------------------------------------------------------------------------*/
    fr_row_size = i_frame_ptr->dx;
    frameImgPtr = (uint16*) i_frame_ptr->imgPtr;
    frame_inc  = (i_frame_ptr->dx - render_col_size) /* to account for crop */ +
                   i_frame_ptr->dx;      /* to account for a row advanced */
  
  
    /*------------------------------------------------------------------------
        We process 2 rows at a time in this encoding. So we need half the
        number of iterations
    ------------------------------------------------------------------------*/
    for ( row = render_row_size/2; row; row-- )
    {
      /*----------------------------------------------------------------------
          We process 2 cols at a time we need half the number of coloumns
          iteratios.
      ----------------------------------------------------------------------*/
      for ( col = render_col_size/2; col; col-- )
      {
        // get our chroma, we are going to possible need this
        cb = *(cr_ptr++);
        cr = *(cr_ptr++);

        // do 4 pixels as a time, check upper right
        
        // upper left
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower left
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *(inputImgPtr + input_row_size);
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr++;

        // upper right
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower right 
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *(inputImgPtr + input_row_size);
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr++;
      }
  
      /*----------------------------------------------------------------------
          Need to add  number of coulumns * 2 /4 --> rowSize /2
          which is same as rowSize >> 1;
      ----------------------------------------------------------------------*/
  
      outputImgPtr +=  (rowSize + destInc);
  
      inputImgPtr += (uint32) (rowInc  + input_row_size);
      frameImgPtr += frame_inc;
      cr_ptr += (rowInc);
    }
  }

  return( IPL_SUCCESS );

} 






/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT90_YCRCB420LPTORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 90 degree.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
extern ipl_status_type ipl2_Rot090Frame_CropYCrCb420lpToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* icrop,         /* input cropping params */
  ipl_rect_type* ocrop          /* output cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 destInc, src_index;
  uint32 cr_src_index;
  uint32 row, col;
  uint16* frameImgPtr;
  uint32 fr_row_size;
  uint32 frame_inc;
  uint32 render_col_size;
  uint32 render_row_size;
  ipl_rect_type iicrop, oocrop;

  
  MSG_LOW("inside ipl2_Rot090Frame_CropYCrCb420lpToRGB\n");

  if (icrop == NULL)
  {
    iicrop.x = 0;
    iicrop.y = 0;
    iicrop.dx = i_img_ptr->dx;
    iicrop.dy = i_img_ptr->dy;
  }
  else
  {
    iicrop.x  = icrop->x;
    iicrop.y  = icrop->y;
    iicrop.dx = icrop->dx;
    iicrop.dy = icrop->dy;
  }

  if (ocrop == NULL)
  {
    oocrop.x = 0;
    oocrop.y = 0;
    oocrop.dx = o_img_ptr->dx;
    oocrop.dy = o_img_ptr->dy;
  }
  else
  {
    oocrop.x  = ocrop->x;
    oocrop.y  = ocrop->y;
    oocrop.dx = ocrop->dx;
    oocrop.dy = ocrop->dy;
  }

  
  /*------------------------------------------------------------------------
        In this scheme odd no of cols in a row will not work.
        I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size = IPL_MIN(iicrop.dx, oocrop.dy);
  render_row_size &= (~0x1);

  render_col_size = IPL_MIN(iicrop.dy, oocrop.dx);
  render_col_size &= (~0x1);
  
  
  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
              initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
    break;
  
    case IPL_RGB444 :
      /*--------------------------------------------------------------------
      initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
    break;
  
    case IPL_RGB666 :
      /*
      return( ipl2_Rot090_YCbCr420ToRGB666(
                                                      i_img_ptr,
                                                      o_img_ptr,
                                                      crop
                                                        ) );
                                                        */
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
      Lint complains -- ignoring
      -------------------------------------------------------------------*/
      /*NOTREACHED*/
    break;
  
    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
      Lint complains -- ignoring
      -------------------------------------------------------------------*/
      /*NOTREACHED*/
    break;
  }
  
  /*------------------------------------------------------------------------
    90 degree rotation needs starting the image from the same side  corner
    where the image starts and wroking upwards. Same with a 2 col offset
    and so on.

     inputImgPtr
     |
     |
     ^__________________________
     |                         |
   ^ |                         |
   | |                         |
   | |                         |
   | |_________________________|
     ^
     | ----> Go this way for rows
     |
   Offset it into the array to start
   picking Y values from here backwards on the same col
   as shown in the arrow leftside

   When offsetted by src_index ( = end of frame - row size )
      the inputImgPtr takes us to this location.
  ------------------------------------------------------------------------*/

  // THIS IS KEY, WHERE WE START
 
  // take us to the bottom left of the image
  src_index = (i_img_ptr->dx * (i_img_ptr->dy - 1));  

  // now go to the bottom left of the crop area for input
  src_index += (iicrop.x - ((i_img_ptr->dy - (iicrop.y + iicrop.dy)) * i_img_ptr->dx));
              

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - oocrop.dx) * 2;

  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector. So to offset
        correctly into CR plane we need subtract one more row from
        src_index which accounts for (src_index - i_img_ptr->dx) in the
        following calculation.
        _____________________________________________
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |------> Cb/Cr plane offset row before last  |
        |____________________________________________|
        ^
        |
        |
       Y plane offset
  ------------------------------------------------------------------------*/
  //cr_ptr = i_img_ptr->clrPtr +
  //         ((src_index >> 1 - i_img_ptr->dx));
  //cr_ptr = i_img_ptr->clrPtr + ((src_index - i_img_ptr->dx) >> 1);


  cr_src_index = (i_img_ptr->dx * (i_img_ptr->dy/2 - 1));  
  cr_src_index += (iicrop.x - ((i_img_ptr->dy/2 - (iicrop.y/2 + iicrop.dy/2)) * i_img_ptr->dx));

  cr_ptr = i_img_ptr->clrPtr + cr_src_index;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += oocrop.x + o_img_ptr->dx*oocrop.y;
  
  
  if (i_frame_ptr == NULL)
  {
    /*------------------------------------------------------------------------
       We process 2 cols at a time in this encoding. So we need half the
       number of iterations. Please note that row and col iterations are
       swapped.
    ------------------------------------------------------------------------*/
    for ( row = 0; row < render_row_size /2 ; row++ )
    {
      /*----------------------------------------------------------------------
          We process 2 rows at a time we need half the number of coloumns
          iteratios.
      ----------------------------------------------------------------------*/
      for ( col = render_col_size / 2; col; col-- )
      {
  
        /*--------------------------------------------------------------------
            The format of the YCbCr420 packing as follows
  
            |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
            |--------------------------------|---------|----------|
            |--------------------------------|---------|----------|
                  Y values                     Cb Vals    Cr Vals
        --------------------------------------------------------------------*/
  
  
        /*--------------------------------------------------------------------
            Take Luma of all four pixels. The Lumma Packing is as shown
            below
  
            |Y2|Y4|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y1|Y3|
  
            As we can see above this small 2 by 2 vector already 90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry.
        --------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );
        lumaa3 = *( inputImgPtr + 1 );
  
        /*--------------------------------------------------------------------
              Go back by one row
        --------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;
        lumaa2 = *( inputImgPtr );
        lumaa4 = *( inputImgPtr + 1 );
  
        /*--------------------------------------------------------------------
              Go back by one row so that next iteration works perfect
        --------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;
  
  
        /*--------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        --------------------------------------------------------------------*/
        cr = *(cr_ptr);
  
        /*--------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        --------------------------------------------------------------------*/
        cb = *(cr_ptr+1);

        /*--------------------------------------------------------------------
              We need to decrease the cb by row size /2 to get the next 4
              pixel cb/cr pair
        --------------------------------------------------------------------*/
        //cb_ptr -= input_row_size >> 1;
        cr_ptr -= input_row_size;
  
        /*--------------------------------------------------------------------
            The following is macro which replces a repetitive
            block of code which takes 4 lummas and a Cr/Cb combination
            to convert it to a RGB flavor with out and out 2 in two words.
            cannot be used for RGB666. because 2 pixels cant fit in one
            word
                                                (out)
            Y | Y                       RGB444/565 | RGB444/565
                     + CB/CR ----->
            Y | Y                       RGB444/565 | RGB444/565
                                               (out2)
        --------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                                lumaa4, cb, cr,  r, out,
                                                out2, out3, out4,
                                                rTable, gTable, bTable );
  
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;
        *(outputImgPtr++ + rowSize) = (uint16) out3;
        *(outputImgPtr++ + rowSize) = (uint16) out4;
      }
  
      /*----------------------------------------------------------------------
           Need to add  number of coulumns * 2 /4 --> rowSize /2
           which is same as rowSize >> 1; destInc accounts for the
           size mismatch b/w cropped image and output frame size
       ---------------------------------------------------------------------*/
      outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                        (rowSize << 1) + destInc );
  
  
      /*----------------------------------------------------------------------
          reinitialize the input and cb pointer to start on next coloumn
          last row
  
          Yn    | Yn + 1  | Yn + 4 | Yn + 5
          Yn+ 2 | Yn+3    | Yn + 6 | Yn + 7
  
          By doing this we are getting Yn + 7 which will be lumaa1 for
          our first pixel of our next iteration. Last +2 takes us from
          Yn+2 to Yn+7
  
          src_index +  input_row_size + 2 -
                     (rowInc * input_row_size) -  accounts for rows not
                                                  rendered for cropping
      ----------------------------------------------------------------------*/
      inputImgPtr = i_img_ptr->imgPtr + src_index + 2*row;  
      cr_ptr = i_img_ptr->clrPtr + cr_src_index + 2*row;  
    }
  }
  else
  {
    /*------------------------------------------------------------------------
        Calculate the frame_inc for each row completeion
    ------------------------------------------------------------------------*/
    fr_row_size = i_frame_ptr->dx;
    frameImgPtr = (uint16*) i_frame_ptr->imgPtr;
    frame_inc  = (i_frame_ptr->dx - oocrop.dx) /* to account for crop */ +
                   i_frame_ptr->dx;      /* to account for a row advanced */
  
  
    for ( row = 0; row < render_row_size /2 ; row++)
    {
      for ( col = render_col_size / 2; col; col-- )
      {
        // get our chroma
        cb = *(cr_ptr);
        cr = *(cr_ptr+1);
        cr_ptr -= input_row_size;

        // upper left
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *( inputImgPtr );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower left
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *( inputImgPtr + 1 );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr -= input_row_size; // GO BACK ONE ROW


        // upper right
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *( inputImgPtr );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower right 
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *( inputImgPtr + 1 );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr -= input_row_size; // GO BACK ANOTHER ROW
      }
  
      /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
      ---------------------------------------------------------------------*/
      outputImgPtr = (uint16 *) ( (uint8 *) outputImgPtr + 
          (rowSize << 1) + destInc );


      /*----------------------------------------------------------------------
         reinitialize the input and cb pointer to start on next coloumn
         last row
  
         Yn    | Yn + 1  | Yn + 4 | Yn + 5
         Yn+ 2 | Yn+3    | Yn + 6 | Yn + 7
  
         By doing this we are getting Yn + 7 which will be lumaa1 for
         our first pixel of our next iteration. Last +2 takes us from
         Yn+2 to Yn+7
  
         src_index +  input_row_size + 2 -
                    (rowInc * input_row_size) -  accounts for rows not
                                                 rendered for cropping
      ----------------------------------------------------------------------*/
      inputImgPtr = i_img_ptr->imgPtr + src_index + 2*row;  
      cr_ptr = i_img_ptr->clrPtr + cr_src_index + 2*row;  

      frameImgPtr += frame_inc;
    }
  }

  return( IPL_SUCCESS );

} 



/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT180_YCRCB420LPTORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
extern ipl_status_type ipl2_Rot180Frame_CropYCrCb420lpToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* icrop,         /* cropping params */
  ipl_rect_type* ocrop          /* cropping params */
)
{
  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0, dest_index, destInc;
  uint32 row, col;
  uint16* frameImgPtr;
  uint32 fr_row_size;
  uint32 frame_inc;
  uint32 render_col_size;
  uint32 render_row_size;
  ipl_rect_type iicrop, oocrop;

  MSG_LOW("inside ipl2_Rot180Frame_CropYCrCb420lpToRGB\n");

  if (icrop == NULL)
  {
    iicrop.x = 0;
    iicrop.y = 0;
    iicrop.dx = i_img_ptr->dx;
    iicrop.dy = i_img_ptr->dy;
  }
  else
  {
    iicrop.x  = icrop->x;
    iicrop.y  = icrop->y;
    iicrop.dx = icrop->dx;
    iicrop.dy = icrop->dy;
  }

  if (ocrop == NULL)
  {
    oocrop.x = 0;
    oocrop.y = 0;
    oocrop.dx = o_img_ptr->dx;
    oocrop.dy = o_img_ptr->dy;
  }
  else
  {
    oocrop.x  = ocrop->x;
    oocrop.y  = ocrop->y;
    oocrop.dx = ocrop->dx;
    oocrop.dy = ocrop->dy;
  }

  
  /*------------------------------------------------------------------------
        In this scheme odd no of cols in a row will not work.
        I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size = IPL_MIN(iicrop.dy, oocrop.dy);
  render_row_size &= (~0x1);

  render_col_size = IPL_MIN(iicrop.dx, oocrop.dx);
  render_col_size &= (~0x1);



  /*------------------------------------------------------------------------
      180 degree rotation needs starting the image from the extreme corner
      so lets add the whole frame size into the input image ptr and then
      starts decrementing rows

      inputImgPtr
      |
      |
      ^__________________________
      |                         |
      |                         |
      |                         |
      |                         |
      |_______________________|_|
                              |
                              |
                               Offset it into the array to start
                               picking Y values from here backwards
  ------------------------------------------------------------------------*/
  // go to the bottom right corner of the input crop window
  inputImgPtr += i_img_ptr->dx * (iicrop.y + iicrop.dy) + iicrop.x + iicrop.dx;


  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (oocrop.x + o_img_ptr->dx * oocrop.y);

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :

      /*
      return( ipl2_Rot180_YCbCr420ToRGB666(
                                                    i_img_ptr,
                                                    o_img_ptr,
                                                    crop
                                                     ) );
                                                     */
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  outputImgPtr += dest_index;

  /*------------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - render_col_size);

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

                    crop->dx
              <---------------------->

      cropped area
      delta  in dx
      ______|___________________________
      |________| ______________________|
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |________|_______________________|
      <-------------------------------->
            input_img->dx
      We are going backwards thats why this is decerementing
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - render_col_size);


  /*------------------------------------------------------------------------
          cr_ptr with respect to  YCbCr420 packing

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals    Cr Vals       |
                                                                           |
                                                                           ^
                                                                       cr_ptr
                                                                      is here
  ------------------------------------------------------------------------*/
  cr_ptr  = i_img_ptr->clrPtr;
  cr_ptr += i_img_ptr->dx * (iicrop.y/2 + iicrop.dy/2) + iicrop.x + iicrop.dx;


  if (i_frame_ptr == NULL)
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time in this encoding. So we need half the
        number of iterations
    ----------------------------------------------------------------------*/
    for ( row = render_row_size/2; row; row-- )
    {
      /*--------------------------------------------------------------------
          We process 2 cols at a time we need half the number of coloumns
          iteratios.
      --------------------------------------------------------------------*/
      for ( col = render_col_size/2; col; col-- )
      {
  
        lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
        lumaa2 = *( inputImgPtr - 1);  /* corresponds to Y2 in the pic */
        lumaa3 = *(inputImgPtr-- - input_row_size);
        lumaa4 = *(inputImgPtr-- - input_row_size);
  
        cr = *(cr_ptr);
        cb = *(cr_ptr+1);
        cr_ptr -= 2;
  
        /*------------------------------------------------------------------
            The following is macro which replces a repetitive
            block of code which takes 4 lummas and a Cr/Cb combination
            to convert it to a RGB flavor with out and out 2 in two words.
            cannot be used for RGB666. because 2 pixels cant fit in one
            word
                                                (out)
            Y | Y                       RGB444/565 | RGB444/565
                     + CB/CR ----->
            Y | Y                       RGB444/565 | RGB444/565
                                               (out2)
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                                lumaa4, cb, cr,  r, out,
                                                out2, out3, out4,
                                                rTable, gTable, bTable );
  
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;
        *(outputImgPtr++ + rowSize) = (uint16) out3;
        *(outputImgPtr++ + rowSize) = (uint16) out4;
      }
  
      /*--------------------------------------------------------------------
          Need to add  number of coulumns * 2 /4 --> rowSize /2
          which is same as rowSize >> 1;
      --------------------------------------------------------------------*/
      outputImgPtr += (rowSize + destInc);
  
      /*--------------------------------------------------------------------
        |<------- input_row_size  ----->|
        _______________________________
        |                              |
        |                              |
        |                              |
        |                              |
        |_____________________________X|-------> Where this operation
        |______________________________|         will take us
        |________|_____________________|
                 |
                 |
                 ^
                 inputImgPtr
       |-- rowInc-|
      --------------------------------------------------------------------*/
      inputImgPtr -= (uint32) (rowInc + input_row_size);
  
      /*--------------------------------------------------------------------
        Remember each four pixels has same CB/CR combination. So we need
        to add number of pixels offset divided by 4
  
        YY
        -----------------maps to one cr/cb --> cr/cb
        YY
  
      --------------------------------------------------------------------*/
      cr_ptr -= (rowInc);
    }
  }
  else
  {
    /*------------------------------------------------------------------------
        Calculate the frame_inc for each row completeion
    ------------------------------------------------------------------------*/
    fr_row_size = i_frame_ptr->dx;
    frameImgPtr = (uint16*) i_frame_ptr->imgPtr;
    frame_inc  = (i_frame_ptr->dx - render_col_size) /* to account for crop */ +
                   i_frame_ptr->dx;      /* to account for a row advanced */


    /*----------------------------------------------------------------------
        We process 2 rows at a time in this encoding. So we need half the
        number of iterations
    ----------------------------------------------------------------------*/
    for ( row = render_row_size/2; row; row-- )
    {
      /*--------------------------------------------------------------------
          We process 2 cols at a time we need half the number of coloumns
          iteratios.
      --------------------------------------------------------------------*/
      for ( col = render_col_size/2; col; col-- )
      {
  
        cb = *(cr_ptr);
        cr = *(cr_ptr+1);
        cr_ptr -= 2;


        // upper left
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower left
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *(inputImgPtr - input_row_size); 
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        inputImgPtr--;
        outputImgPtr++;
        frameImgPtr++;

        // upper right
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *inputImgPtr;
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }

        // lower right 
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *(inputImgPtr - input_row_size);
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        inputImgPtr--;
        outputImgPtr++;
        frameImgPtr++;
      }
  
      /*--------------------------------------------------------------------
          Need to add  number of coulumns * 2 /4 --> rowSize /2
          which is same as rowSize >> 1;
      --------------------------------------------------------------------*/
      outputImgPtr +=  (rowSize + destInc);
  
      /*--------------------------------------------------------------------
        |<------- input_row_size  ----->|
        _______________________________
        |                              |
        |                              |
        |                              |
        |                              |
        |_____________________________X|-------> Where this operation
        |______________________________|         will take us
        |________|_____________________|
                 |
                 |
                 ^
                 inputImgPtr
       |-- rowInc-|
      --------------------------------------------------------------------*/
      inputImgPtr -= (uint32) (rowInc + input_row_size);
  
      /*--------------------------------------------------------------------
        Remember each four pixels has same CB/CR combination. So we need
        to add number of pixels offset divided by 4
  
        YY
        -----------------maps to one cr/cb --> cr/cb
        YY
  
      --------------------------------------------------------------------*/
      cr_ptr -= (rowInc);
  
      frameImgPtr += frame_inc;
    }
  }

  return( IPL_SUCCESS );

} 


/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT270_YCRCB420LPTORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 270 degree.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
extern ipl_status_type ipl2_Rot270Frame_CropYCrCb420lpToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* icrop,         /* cropping params */
  ipl_rect_type* ocrop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 destInc, cr_src_index, src_index;
  uint32 row, col;
  uint16* frameImgPtr;
  uint32 fr_row_size;
  uint32 frame_inc;
  uint32 render_col_size;
  uint32 render_row_size;
  ipl_rect_type iicrop, oocrop;

  MSG_LOW("inside ipl2_Rot270Frame_CropYCrCb420lpToRGB\n");

  if (icrop == NULL)
  {
    iicrop.x = 0;
    iicrop.y = 0;
    iicrop.dx = i_img_ptr->dx;
    iicrop.dy = i_img_ptr->dy;
  }
  else
  {
    iicrop.x  = icrop->x;
    iicrop.y  = icrop->y;
    iicrop.dx = icrop->dx;
    iicrop.dy = icrop->dy;
  }

  if (ocrop == NULL)
  {
    oocrop.x = 0;
    oocrop.y = 0;
    oocrop.dx = o_img_ptr->dx;
    oocrop.dy = o_img_ptr->dy;
  }
  else
  {
    oocrop.x  = ocrop->x;
    oocrop.y  = ocrop->y;
    oocrop.dx = ocrop->dx;
    oocrop.dy = ocrop->dy;
  }


  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size = IPL_MIN(iicrop.dx, oocrop.dy);
  render_row_size &= (~0x1);
  render_col_size = IPL_MIN(iicrop.dy, oocrop.dx);
  render_col_size &= (~0x1);

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :
      /*
      return( ipl2_Rot270_YCbCr420ToRGB666(
                                                    i_img_ptr,
                                                    o_img_ptr,
                                                    crop
                                                    ) );
                                                    */
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
    270 degree rotation needs starting the image from the same side right
    corner from where the image starts and wroking downwards.
    - with a 2 col offset and so on.

      inputImgPtr
     |
     |
     ^__________________________
     |                         |  |
     |                         |  |
     |                         |  |
     |                         |  v  col increment
     |_________________________|
        <-----------------------
         row increment
  ------------------------------------------------------------------------*/
  src_index =  iicrop.dx + iicrop.x + i_img_ptr->dx*iicrop.y;

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index - 1;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - oocrop.dx) * 2;


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |   1/4 Yvals   |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector.
        _____________________________________________
        |                                  <--------||
        |                               Yplane/Cb    |
        |                               offset start |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |____________________________________________|

  ------------------------------------------------------------------------*/
  cr_src_index = iicrop.dx + iicrop.x + i_img_ptr->dx*iicrop.y/2 - 2;
  cr_ptr = i_img_ptr->clrPtr + cr_src_index;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += oocrop.x + o_img_ptr->dx*oocrop.y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
       swapped.
    ------------------------------------------------------------------------*/
  if (i_frame_ptr == NULL)
  {
    for ( row = render_row_size /2 ; row; row-- )
    {
      /*----------------------------------------------------------------------
          We process 2 rows at a time we need half the number of coloumns
          iteratios.
      ----------------------------------------------------------------------*/
      for ( col = render_col_size / 2; col; col-- )
      {
  
        lumaa1 = *( inputImgPtr );
        lumaa3 = *( inputImgPtr - 1 );
        inputImgPtr += input_row_size;
        lumaa2 = *( inputImgPtr );
        lumaa4 = *( inputImgPtr - 1 );
        inputImgPtr += input_row_size;
  
  
        cr = *(cr_ptr);
        cb = *(cr_ptr + 1);
        cr_ptr += input_row_size;
  
        /*--------------------------------------------------------------------
            The following is macro which replces a repetitive
            block of code which takes 4 lummas and a Cr/Cb combination
            to convert it to a RGB flavor with out and out 2 out3 and out4
            in four half words.
                                                (out)
            Y | Y                       RGB444/565 | RGB444/565
                     + CB/CR ----->
            Y | Y                       RGB444/565 | RGB444/565
                                               (out2)
        --------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                                lumaa4, cb, cr,  r, out,
                                                out2, out3, out4,
                                                rTable, gTable, bTable );
  
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;
        *(outputImgPtr++ + rowSize) = (uint16) out3;
        *(outputImgPtr++ + rowSize) = (uint16) out4;
  
      } 
      /*----------------------------------------------------------------------
           Need to add  number of coulumns * 2 /4 --> rowSize /2
           which is same as rowSize >> 1; destInc accounts for the
           size mismatch b/w cropped image and output frame size
       ---------------------------------------------------------------------*/
      outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                        (rowSize << 1) + destInc );
  
  
      /*----------------------------------------------------------------------
          reinitialize the input and cb pointer to start on next coloumn
          last row
  
          Yn    | Yn + 1  | Yn + 4 | Yn + 5
          Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8
  
          If we started our first iteration on Yn + 5 doing this we
          are getting Yn + 1.
  
        Since we are always on the first row offsetted by two than the
        previous one.
      ----------------------------------------------------------------------*/
      src_index -= 2;
      cr_src_index -= 2;

      inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;
      cr_ptr = i_img_ptr->clrPtr + (cr_src_index) - 2; 
  
    } /* end of row loop */
  }
  else
  {
    /*------------------------------------------------------------------------
        Calculate the frame_inc for each row completeion
    ------------------------------------------------------------------------*/
    fr_row_size = i_frame_ptr->dx;
    frameImgPtr = (uint16*) i_frame_ptr->imgPtr;
    frame_inc  = (i_frame_ptr->dx - oocrop.dx) /* to account for crop */ +
                   i_frame_ptr->dx;      /* to account for a row advanced */

    for ( row = render_row_size /2 ; row; row-- )
    {
      /*----------------------------------------------------------------------
          We process 2 rows at a time we need half the number of coloumns
          iteratios.
      ----------------------------------------------------------------------*/
      for ( col = render_col_size / 2; col; col-- )
      {
        // get our chroma
        cb = *(cr_ptr);
        cr = *(cr_ptr + 1);
        cr_ptr += input_row_size;
  

        // upper left
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *( inputImgPtr );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower left
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *( inputImgPtr - 1 );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr += input_row_size;


        // upper right
        if (*frameImgPtr != transparentValue)
        {
          *outputImgPtr = *frameImgPtr;
        }
        else
        {
          lumaa1 = *( inputImgPtr );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *outputImgPtr = (uint16) out;
        }


        // lower right 
        if (*(frameImgPtr + fr_row_size) != transparentValue)
        {
          *(outputImgPtr + rowSize) = *(frameImgPtr + fr_row_size); 
        }
        else
        {
          lumaa1 = *( inputImgPtr - 1 );
         IPL2_CONVERT_YCBCR_RGB_SINGLE(lumaa1,cb,cr,r,out,rTable,gTable,bTable);
          *(outputImgPtr + rowSize) = (uint16) out;
        }

        outputImgPtr++;
        frameImgPtr++;
        inputImgPtr += input_row_size;
      }
  
      /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
      ---------------------------------------------------------------------*/
      outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


      /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        If we started our first iteration on Yn + 5 doing this we
        are getting Yn + 1.

      Since we are always on the first row offsetted by two than the
      previous one.
      ----------------------------------------------------------------------*/
      src_index -= 2;
      cr_src_index -= 2;

      inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;

      cr_ptr = i_img_ptr->clrPtr + (cr_src_index) - 2; 
      frameImgPtr += frame_inc;
    } /* end of row loop */
  }

  return( IPL_SUCCESS );

} 




/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT90_YCBC420TORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 90 degree.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot090_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc = 0, destInc, cr_offset, src_index;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot090_YCbCr420ToRGB\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);


  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( i_img_ptr->dy < crop->dx )
  {
    /*----------------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :

      return( ipl2_Rot090_YCbCr420ToRGB666(
                                                    i_img_ptr,
                                                    o_img_ptr,
                                                    crop
                                                      ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
    90 degree rotation needs starting the image from the same side  corner
    where the image starts and wroking upwards. Same with a 2 col offset
    and so on.

     inputImgPtr
     |
     |
     ^__________________________
     |                         |
   ^ |                         |
   | |                         |
   | |                         |
   | |_________________________|
     ^
     | ----> Go this way for rows
     |
   Offset it into the array to start
   picking Y values from here backwards on the same col
   as shown in the arrow leftside

   When offsetted by src_index ( = end of frame - row size )
      the inputImgPtr takes us to this location.
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx * ( i_img_ptr->dy - 1);

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      rowInc is slightly misleading. we are talking wrt output vector
      lets say. I am subtracting no of cols in o/p from no of rows
      in input. All because of 90 degree rotation. We go 2 row at a time.
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dy - crop->dx );

  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector. So to offset
        correctly into CR plane we need subtract one more row from
        src_index which accounts for (src_index - i_img_ptr->dx) in the
        following calculation.
        _____________________________________________
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |------> Cb/Cr plane offset row before last  |
        |____________________________________________|
        ^
        |
        |
       Y plane offset
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
                   ( i_img_ptr->dx * i_img_ptr->dy  ) +
                   ( (src_index - i_img_ptr->dx)  >> 2);

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y2|Y4|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y1|Y3|

          As we can see above this small 2 by 2 vector already 90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr -= input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 7

        By doing this we are getting Yn + 7 which will be lumaa1 for
        our first pixel of our next iteration. Last +2 takes us from
        Yn+2 to Yn+7

        src_index +  input_row_size + 2 -
                   (rowInc * input_row_size) -  accounts for rows not
                                                rendered for cropping
    ----------------------------------------------------------------------*/
    inputImgPtr += src_index /* take to the earlier start */ +
                  2 /* advnce to next */ -
              ( ( (rowInc - 1) * input_row_size ) );/* account for cropping */

    cb_ptr += ((src_index + input_row_size) >> 2) + 1 -
              ( ( rowInc * input_row_size ) >> 2 );
  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot090_YCbCr420ToRGB */






/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT90_YCBC420TORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 90 degree. This function supports overlay
  of a frame also.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/

static ipl_status_type ipl2_Rot090Frame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop           /* cropping params */
)
{

  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc = 0, destInc, cr_offset, src_index, frame_inc;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot090Frame_YCbCr420ToRGB\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);


  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( ( i_img_ptr->dy < crop->dx ) ||
    (i_frame_ptr->dx < crop->dx) ||  (i_frame_ptr->dy < crop->dy) )

  {
    /*----------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :

      /*--------------------------------------------------------------------
        Increased complexity of this conversion of frame pixels itselves
        into a different flavor is dealt with this function. The function
        is very similar to the present one except fot the fact that it does
        do a frame pixel conversion from 565 to 444
      --------------------------------------------------------------------*/
      return( ipl2_Rot090Frame_YCbCr420ToRGB444(
                                                          i_img_ptr,
                                                          i_frame_ptr,
                                                          transparentValue,
                                                          o_img_ptr,
                                                          crop
                                                           ) );
      /*NOTREACHED*/
      break;

    case IPL_RGB666 :
      return( ipl2_Rot090Frame_YCbCr420ToRGB666(
                    i_img_ptr,
                    i_frame_ptr,
                    transparentValue,
                    o_img_ptr,
                    crop
                   ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
    90 degree rotation needs starting the image from the same side  corner
    where the image starts and wroking upwards. Same with a 2 col offset
    and so on.

     inputImgPtr
     |
     |
     ^__________________________
     |                         |
   ^ |                         |
   | |                         |
   | |                         |
   | |_________________________|
     ^
     | ----> Go this way for rows
     |
   Offset it into the array to start
   picking Y values from here backwards on the same col
   as shown in the arrow leftside

   When offsetted by src_index ( = end of frame - row size )
      the inputImgPtr takes us to this location.
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx * ( i_img_ptr->dy - 1);

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      rowInc is slightly misleading. we are talking wrt output vector
      lets say. I am subtracting no of cols in o/p from no of rows
      in input. All because of 90 degree rotation. We go 2 row at a time.
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dy - crop->dx );

  frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
               i_frame_ptr->dx;         /* to account for a row advanced */

  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector. So to offset
        correctly into CR plane we need subtract one more row from
        src_index which accounts for (src_index - i_img_ptr->dx) in the
        following calculation.
        _____________________________________________
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |------> Cb/Cr plane offset row before last  |
        |____________________________________________|
        ^
        |
        |
       Y plane offset
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
                   ( i_img_ptr->dx * i_img_ptr->dy  ) +
                   ( (src_index - i_img_ptr->dx)  >> 2);

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = *( (uint16 *) frameImgPtr );
        *( (uint16 *)outputImgPtr + 1) = *(  (uint16 *) frameImgPtr + 1);

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
          != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
              We are atuoincrementing frame because we are done with
              the current frame poistion
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize) =
            *( (uint16 *) frameImgPtr + frame_row_size);

          *( outputImgPtr++ + rowSize ) =
            * ( (uint16 *) (frameImgPtr + frame_row_size  + 1) );

          /*----------------------------------------------------------------
            Adjust the row position in Y plane for the next iteration
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size << 1 /* mulitiply by  2 */;

          /*----------------------------------------------------------------
                 We need to decrease the cb by row size /2 to get the next 4
                 pixel cb/cr pair
           ---------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1 /* divide by 2  */;


        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr );

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr + cr_offset);

          /*----------------------------------------------------------------
              Offset the cb for next iteration
          ----------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1;

          lumaa1 = *( inputImgPtr + 1 );

          /*----------------------------------------------------------------
                Go back by one row
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size;
          lumaa2 = *( inputImgPtr + 1 );

          /*----------------------------------------------------------------
                Go back by one row so that next iteration works perfect
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size;

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;
        }

        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
        != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs                     Frame pairs

        The logic here is as follows
          We know that F3 != transparentValue
              So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

        Copy remaining ie : O3 = F3 and O4  = F4

      --------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Take Luma of all four pixels. The Lumma Packing is as shown
            below

            |Y2|Y4|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y1|Y3|

            As we can see above this small 2 by 2 vector already 90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry.
        ------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go back by one row
        ------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;
        lumaa2 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go back by one row so that next iteration works perfect
        ------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;


        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr );

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr + cr_offset);

        /*------------------------------------------------------------------
              We need to decrease the cb by row size /2 to get the next 4
              pixel cb/cr pair
        ------------------------------------------------------------------*/
        cb_ptr -= input_row_size >> 1;



        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/
        *( outputImgPtr++ + rowSize ) =
          * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        *( outputImgPtr++ + rowSize ) =
          * ( (uint16*)(frameImgPtr++ + frame_row_size) );

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;


      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y2|Y4|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y1|Y3|

          As we can see above this small 2 by 2 vector already 90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr -= input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        By doing this we are getting Yn + 7 which will be lumaa1 for
        our first pixel of our next iteration. Last +2 takes us from
        Yn+2 to Yn+7

        src_index +  input_row_size + 2 -
                   (rowInc * input_row_size) -  accounts for rows not
                                                rendered for cropping
    ----------------------------------------------------------------------*/
    inputImgPtr += src_index /* take to the earlier start */ +
                   2 /* advnce to next */ -
            ( ( (rowInc - 1) * input_row_size ) );/* account for cropping */

    cb_ptr += ((src_index + input_row_size) >> 2) + 1 -
              ( ( rowInc * input_row_size ) >> 2 );

    /*----------------------------------------------------------------------
        Update the frame ptr
    ----------------------------------------------------------------------*/

    frameImgPtr += frame_inc;
  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot090Frame_YCbCr420ToRGB */







/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT180_YCBC420TORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot180_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0, dest_index, destInc, cb_offset;
  uint32 row, col;
/*------------------------------------------------------------------------*/

  MSG_LOW("inside ipl2_Rot180_YCbCr420ToRGB\n");


  /*------------------------------------------------------------------------
      180 degree rotation needs starting the image from the extreme corner
      so lets add the whole frame size into the input image ptr and then
      starts decrementing rows

      inputImgPtr
      |
      |
      ^__________________________
      |                         |
      |                         |
      |                         |
      |                         |
      |_______________________|_|
                              |
                              |
                               Offset it into the array to start
                               picking Y values from here backwards
  ------------------------------------------------------------------------*/
  inputImgPtr += i_img_ptr->dx * i_img_ptr->dy  - 1;



  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 1 /* * 2 */;

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :

      return( ipl2_Rot180_YCbCr420ToRGB666(
                                                    i_img_ptr,
                                                    o_img_ptr,
                                                    crop
                                                     ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  outputImgPtr = (uint16 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

                    crop->dx
              <---------------------->

      cropped area
      delta  in dx
      ______|___________________________
      |________| ______________________|
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |________|_______________________|
      <-------------------------------->
            input_img->dx
      We are going backwards thats why this is decerementing
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          cr_ptr with respect to  YCbCr420 packing

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals    Cr Vals       |
                                                                           |
                                                                           ^
                                                                       cr_ptr
                                                                      is here
  ------------------------------------------------------------------------*/
  cr_ptr = i_img_ptr->imgPtr +
         ( i_img_ptr->dx * i_img_ptr->dy  ) /* y array */ +
       (  ( i_img_ptr->dx * i_img_ptr->dy  ) >> 1 )/* cb array * 2 */
        - 1 /* to fetch the last element */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cb_offset =  (i_img_ptr->dx * i_img_ptr->dy  ) >> 2;


  /*----------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ----------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*--------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    --------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      /*------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      ------------------------------------------------------------------*/


      /*------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y4|Y3|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y2|Y1|
      ------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *( inputImgPtr - 1);  /* corresponds to Y2 in the pic */
      lumaa3 = *(inputImgPtr-- - input_row_size);
      lumaa4 = *(inputImgPtr-- - input_row_size);

      /*------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      ------------------------------------------------------------------*/
      cr = *(cr_ptr);

      /*------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      ------------------------------------------------------------------*/
      cb = *(cr_ptr - cb_offset);

      /*------------------------------------------------------------------
          We got both CB and Cr for this iteration we decrement cr_ptr.
          If you look at the pics you can see that they both (cb anc cr)
          move in tandem
      ------------------------------------------------------------------*/
      --cr_ptr;

      /*------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      ------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*--------------------------------------------------------------------
        Need to add  number of coulumns * 2 /4 --> rowSize /2
        which is same as rowSize >> 1;
    --------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1)  + destInc ) ;

    /*--------------------------------------------------------------------
      |<------- input_row_size  ----->|
      _______________________________
      |                              |
      |                              |
      |                              |
      |                              |
      |_____________________________X|-------> Where this operation
      |______________________________|         will take us
      |________|_____________________|
               |
               |
               ^
               inputImgPtr
     |-- rowInc-|
    --------------------------------------------------------------------*/
    inputImgPtr -= (uint32) (rowInc + input_row_size);

    /*--------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    --------------------------------------------------------------------*/
    cr_ptr -= (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot180_YCbCr420ToRGB */





/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT180_YCBC420TORGB

DESCRIPTION
  This function rotates crops Frames and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot180Frame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{

  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0, dest_index, destInc, cb_offset, frame_inc;
  uint32 row, col;

  MSG_LOW("inside ipl2_Rot180Frame_YCbCr420ToRGB\n");

  /*------------------------------------------------------------------------
      180 degree rotation needs starting the image from the extreme corner
      so lets add the whole frame size into the input image ptr and then
      starts decrementing rows

      inputImgPtr
      |
      |
      ^__________________________
      |                         |
      |                         |
      |                         |
      |                         |
      |_______________________|_|
                              |
                              |
                               Offset it into the array to start
                               picking Y values from here backwards
  ------------------------------------------------------------------------*/
  inputImgPtr += i_img_ptr->dx * i_img_ptr->dy  - 1;


  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 1 /* * 2 */;

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
          We are doing RGB444 conversion in this particular function
      --------------------------------------------------------------------*/
      return ( ipl2_Rot180Frame_YCbCr420ToRGB444(i_img_ptr,
                                                        i_frame_ptr,
                                                        transparentValue,
                                                        o_img_ptr,
                                                        crop
                                                           ) );
      /*NOTREACHED*/
      break;

    case IPL_RGB666 :
      return( ipl2_Rot180Frame_YCbCr420ToRGB666( i_img_ptr,
                                                        i_frame_ptr,
                                                        transparentValue,
                                                        o_img_ptr,
                                                        crop ) );

      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  outputImgPtr = (uint16 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

                    crop->dx
              <---------------------->

      cropped area
      delta  in dx
      ______|___________________________
      |________| ______________________|
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |________|_______________________|
      <-------------------------------->
            input_img->dx
      We are going backwards thats why this is decerementing
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          cr_ptr with respect to  YCbCr420 packing

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals    Cr Vals       |
                                                                           |
                                                                           ^
                                                                      cr_ptr
                                                                     is here
  ------------------------------------------------------------------------*/
  cr_ptr = i_img_ptr->imgPtr +
         ( i_img_ptr->dx * i_img_ptr->dy  ) /* y array */ +
       (  ( i_img_ptr->dx * i_img_ptr->dy  ) >> 1 )/* cb array * 2 */
        - 1 /* to fetch the last element */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cb_offset =  (i_img_ptr->dx * i_img_ptr->dy  ) >> 2;

  /*------------------------------------------------------------------------
      Increment in the Frame pointer on completion of each row.
  ------------------------------------------------------------------------*/
  frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
             i_frame_ptr->dx;         /* to account for a row advanced */


  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = *( (uint16 *) frameImgPtr );
        *( (uint16 *)outputImgPtr + 1) = *(  (uint16 *) frameImgPtr + 1);

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
                                                     != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) =
                          *( (uint16 *) frameImgPtr + frame_row_size);

          *( outputImgPtr++ + rowSize ) =
                       * ( (uint16 *) (frameImgPtr + frame_row_size  + 1) );

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr -= 2;

          /*----------------------------------------------------------------
              point cr_ptr to the immediate previous
          ----------------------------------------------------------------*/
          cr_ptr--;
        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cr = *(cr_ptr);

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cb = *(cr_ptr-- - cb_offset);


          /*----------------------------------------------------------------
              Next up is Lumaa1

              Y  |  Y ------------------ this is lumaa1
              Y  |  Y


          ----------------------------------------------------------------*/
          lumaa1 = * ( inputImgPtr -  input_row_size);

          /*----------------------------------------------------------------
                                      _________
                                     |        |
          This is our Lumaa2-------------     |
                                     |   Y1 | Y2
                                     |__ Y2 | Y4

          ----------------------------------------------------------------*/
          lumaa2 = * ( (uint8 *) inputImgPtr - input_row_size - 1 );

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                             out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr -= 2;


        }


        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
                                                      != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs               Frame pairs

          The logic here is as follows
            We know that F3 != transparentValue
                So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

          Copy remaining ie : O3 = F3 and O4  = F4

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cr = *(cr_ptr);

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cb = *(cr_ptr-- - cb_offset);


        /*------------------------------------------------------------------
            Next up is Lumaa1

            |
            |This is the Lumaa1
            |
            Y  |  Y
            Y  |  Y

        ------------------------------------------------------------------*/
        lumaa1 = * ( inputImgPtr--);

        /*------------------------------------------------------------------
            Extract Lumaa2

            Y | Y ------Lumaa2

            Y | Y
        ------------------------------------------------------------------*/
        lumaa2 = * ( (uint8 *) inputImgPtr--);

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                            out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/
        *( outputImgPtr++ + rowSize ) =
                       * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        *( outputImgPtr++ + rowSize ) =
                          * ( (uint16*)(frameImgPtr++ + frame_row_size) );

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
          We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y4|Y3|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y2|Y1|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *( inputImgPtr - 1);  /* corresponds to Y2 in the pic */
      lumaa3 = *(inputImgPtr-- - input_row_size);
      lumaa4 = *(inputImgPtr-- - input_row_size);

      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cr = *(cr_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cb = *(cr_ptr - cb_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we decrement cr_ptr.
          If you look at the pics you can see that they both (cb anc cr)
          move in tandem
      --------------------------------------------------------------------*/
      --cr_ptr;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 2 /4 --> rowSize /2
        which is same as rowSize >> 1;
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1)  + destInc ) ;

    /*----------------------------------------------------------------------
      |<------- input_row_size  ----->|
      _______________________________
      |                              |
      |                              |
      |                              |
      |                              |
      |_____________________________X|-------> Where this operation
      |______________________________|         will take us
      |________|_____________________|
               |
               |
               ^
               inputImgPtr
     |-- rowInc-|
    ----------------------------------------------------------------------*/
    inputImgPtr -= (uint32) (rowInc + input_row_size);

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cr_ptr -= (rowInc) >> 1 /* divided by 2 */;

    /*----------------------------------------------------------------------
      We need to keep the frame in Tandem as well
      frameImgPtr is a uint16 ptr so *2 is built in in the following
      instruction
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc;


  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot180Frame_YCbCr420ToRGB */


/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT270_YCBC420TORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 270 degree.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot270_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 destInc, cr_offset, src_index, cb_offset;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot270_YCbCr420ToRGB\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);


  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( i_img_ptr->dy < crop->dx )
  {
    /*----------------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      /*--------------------------------------------------------------------
        initialize the conversion with RGB444 table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r444[0]);
      gTable = &(ipl2_g444[0] );
      bTable = &(ipl2_b444[0] );
      break;

    case IPL_RGB666 :
      return( ipl2_Rot270_YCbCr420ToRGB666(
                                                    i_img_ptr,
                                                    o_img_ptr,
                                                    crop
                                                    ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
    270 degree rotation needs starting the image from the same side right
    corner from where the image starts and wroking downwards.
    - with a 2 col offset and so on.

      inputImgPtr
     |
     |
     ^__________________________
     |                         |  |
     |                         |  |
     |                         |  |
     |                         |  v  col increment
     |_________________________|
        <-----------------------
         row increment
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx;

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index - 1;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 2;


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |   1/4 Yvals   |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector.
        _____________________________________________
        |                                  <--------||
        |                               Yplane/Cb    |
        |                               offset start |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |____________________________________________|

  ------------------------------------------------------------------------*/
  cb_offset = ( i_img_ptr->dx * i_img_ptr->dy  );
  cb_ptr = i_img_ptr->imgPtr +
                    + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. Luma Extracion we do on the
          following lines of code assumes the following figure. Just by
          assuming the following geometry we get the 270 degree rotatin.
          You can see the tiny square changed to 90  degree
          anticlockwise now (  same 270 ).

          |Y3|Y1|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y4|Y2|

          As we can see above this small 2 by 2 vector already -90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr += input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 out3 and out4
          in four half words.
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;

    } /* end of col loop */

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        If we started our first iteration on Yn + 5 doing this we
        are getting Yn + 1.

      Since we are always on the first row offsetted by two than the
      previous one.
    ----------------------------------------------------------------------*/
    src_index -= 2;
    inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;

    cb_ptr = i_img_ptr->imgPtr + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;


  } /* end of row loop */

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot270_YCbCr420ToRGB */










/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT270_YCBC420TORGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 270 degree.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot270Frame_YCbCr420ToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 destInc, cr_offset, src_index, cb_offset, frame_inc;
  uint32 row, col;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot270Frame_YCbCr420ToRGB\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);



  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( ( i_img_ptr->dy < crop->dx ) ||
    (i_frame_ptr->dx < crop->dx) ||  (i_frame_ptr->dy < crop->dy) )

  {
    /*----------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  switch ( o_img_ptr->cFormat )
  {
    case IPL_RGB565:
      /*--------------------------------------------------------------------
            initialize the conversion with RGB 565 packing table
      --------------------------------------------------------------------*/
      rTable = &(ipl2_r5xx[0]);
      gTable = &(ipl2_gx6x[0] );
      bTable = &(ipl2_bxx5[0] );
      break;

    case IPL_RGB444 :
      return( ipl2_Rot270Frame_YCbCr420ToRGB444(i_img_ptr,
                                                           i_frame_ptr,
                                                           transparentValue,
                                                           o_img_ptr,
                                                           crop
                                                            ) );
      /*NOTREACHED*/
      break;

    case IPL_RGB666 :
            return( ipl2_Rot270Frame_YCbCr420ToRGB666(
                                                           i_img_ptr,
                                                           i_frame_ptr,
                                                           transparentValue,
                                                           o_img_ptr,
                                                           crop
                                                            ) );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;

    default:
      return( IPL_FAILURE );
      /*--------------------------------------------------------------------
        Lint complains -- ignoring
       -------------------------------------------------------------------*/
      /*NOTREACHED*/
      break;
  }

  /*------------------------------------------------------------------------
    270 degree rotation needs starting the image from the same side right
    corner from where the image starts and wroking downwards.
    - with a 2 col offset and so on.

      inputImgPtr
     |
     |
     ^__________________________
     |                         |  |
     |                         |  |
     |                         |  |
     |                         |  v  col increment
     |_________________________|
        <-----------------------
         row increment
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx;

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index - 1;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 2;


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector.
        _____________________________________________
        |                                  <--------||
        |                               Yplane/Cb    |
        |                               offset start |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |____________________________________________|

  ------------------------------------------------------------------------*/
  cb_offset = ( i_img_ptr->dx * i_img_ptr->dy  );
  cb_ptr = i_img_ptr->imgPtr +
                    + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;


  frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
                i_frame_ptr->dx;   /* to account for a row advanced */


  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = *( (uint16 *) frameImgPtr );
        *( (uint16 *)outputImgPtr + 1) = *(  (uint16 *) frameImgPtr + 1);

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
          != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
              We are atuoincrementing frame because we are done with
              the current frame poistion
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize) =
            *( (uint16 *) frameImgPtr + frame_row_size);

          *( outputImgPtr++ + rowSize ) =
            * ( (uint16 *) (frameImgPtr + frame_row_size  + 1) );

          /*----------------------------------------------------------------
            Adjust the row position in Y plane for the next iteration
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size << 1 /* mulitiply by  2 */;

          /*----------------------------------------------------------------
                 We need to increase the cb by row size /2 to get the next 4
                 pixel cb/cr pair
           ---------------------------------------------------------------*/
          cb_ptr += input_row_size >> 1 /* divide by 2  */;


        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
            Take Luma of all four pixels. Luma Extracion we do on the
            following lines of code assumes the following figure. Just by
            assuming the following geometry we get the 270 degree rotatin.
            You can see the tiny square changed to 90  degree
            anticlockwise now (  same 270 ).

            |Y3|Y1|             (this processing)   |I1|I2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y4|Y2|

            As we can see above this small 2 by 2 vector already -90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry. I1 and I2 represen
           ---------------------------------------------------------------*/
          lumaa1 = *( inputImgPtr - 1 );

          /*----------------------------------------------------------------
                Go forward by one row
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size;
          lumaa2 = *( inputImgPtr - 1 );

          /*------------------------------------------------------------------
                Go forward by one row so that next iteration works perfect
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size;


          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr );

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr + cr_offset);

          /*----------------------------------------------------------------
                We need to decrease the cb by row size /2 to get the next 4
                pixel cb/cr pair
          ----------------------------------------------------------------*/
          cb_ptr += input_row_size >> 1;



          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);

          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;
        }

        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
        != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2      F1   | F2
                  ----------->
          O3 | O4              I3 | I4      F3   |  F4
        o/p 2 pairs             I/P pairs   Frame pairs

        The logic here is as follows
          We know that F3 != transparentValue
              So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

        Copy remaining ie : O3 = F3 and O4  = F4

      --------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Take Luma of all four pixels. Luma Extracion we do on the
            following lines of code assumes the following figure. Just by
            assuming the following geometry we get the 270 degree rotatin.
            You can see the tiny square changed to 90  degree
            anticlockwise now (  same 270 ).

            |Y3|Y1|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |F3  |F4|
            |Y4|Y2|

            As we can see above this small 2 by 2 vector already -90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry. F3 and F4 are frame pixels on the corresponding
            positions
        ------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );

        inputImgPtr += input_row_size;
        lumaa2 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go forward by one row so that next iteration works perfect
        ------------------------------------------------------------------*/
        inputImgPtr += input_row_size;


        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr );

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr + cr_offset);

        /*------------------------------------------------------------------
              We need to increase the cb by row size /2 to get the next 4
              pixel cb/cr pair
        ------------------------------------------------------------------*/
        cb_ptr += input_row_size >> 1;


        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/
        *( outputImgPtr++ + rowSize ) =
          * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        *( outputImgPtr++ + rowSize ) =
          * ( (uint16*)(frameImgPtr++ + frame_row_size) );

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. Luma Extracion we do on the
          following lines of code assumes the following figure. Just by
          assuming the following geometry we get the 270 degree rotatin.
          You can see the tiny square changed to 90  degree
          anticlockwise now (  same 270 ).

          |Y3|Y1|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y4|Y2|

          As we can see above this small 2 by 2 vector already -90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr += input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 out3 and out4
          in four half words.
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;

    } /* end of col loop */

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        If we started our first iteration on Yn + 5 doing this we
        are getting Yn + 1.

      Since we are always on the first row offsetted by two than the
      previous one.
    ----------------------------------------------------------------------*/
    src_index -= 2;
    inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;

    cb_ptr = i_img_ptr->imgPtr + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

    /*----------------------------------------------------------------------
        Update the frame ptr
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc;


  } /* end of row loop */

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot270Frame_YCbCr420ToRGB */
/*===========================================================================

                    IPL2_CONVERT_YCBCRToRGB666.c

DESCRIPTION
  This file contains the implementation of the IPL APIs. Below is an
  approximate call flow. Compressed into this function header.

EXTERNALIZED FUNCTIONS
  ipl2_YCbCrToRGB666()
    Takes YCbCr based images and spits out a cropped and framed
      version of it color coded in RGB666 format.

  ipl2_Rot270Frame_YCbCToRGB666()
    Takes YCbCr based images and spits out a cropped  framed and rotated
    (270 degree) version of it color coded in RGB666 format.

  ipl2_Rot090Frame_YCbCToRGB666()
    Takes YCbCr based images and spits out a cropped  framed and rotated
    (90 degree) version of it color coded in RGB666 format.

  ipl2_Rot180Frame_YCbCToRGB666()
    Takes YCbCr based images and spits out a cropped  framed and rotated
    (180 degree) version of it color coded in RGB666 format.



INITIALIZATION AND SEQUENCING REQUIREMENTS
   The functions will fail if the lookup tables are not initialized properly.

Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
===========================================================================*/

/*===========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     ----------------------------------------------------------
05/01/04   srk     Review comments from David, Roy, Nish, Ramesh, Jun and
                   Nikhil.
04/20/04   srk     Initially created to keep all the YCBCR to RGB666 color
                   conversion routintes. All routines are exposed to
                   ipl_YCBCR.c
=========================================================================== */


/*===========================================================================
FUNCTION ipl2_Rot270Frame_YCbCToRGB666()

DESCRIPTION
  This function alters the converts a YCBCR image to an RGB666 flavor.
   The function does framing 270 degree rotation and cropping as well.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr  - input image frame
  transparentValue - transparent val for framing
  startPos        - start position into the image
  rowInc         - row increment after each col copy - depends on rotation
  colInc         - the col inrement for iteration - depends on rotation
  crop           - the cropping needed if any

ARGUMENTS OUT
  o_img_ptr - Points to the output image


RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Alters the output buffer

===========================================================================*/
static ipl_status_type ipl2_Rot270Frame_YCbCToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index, dest_index;
  uint32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* frameImgPtr = (i_frame_ptr==NULL)?NULL:i_frame_ptr->imgPtr;
  uint32 out32;
  uint32* data_out = (uint32*)o_img_ptr->imgPtr;
  register int32 lumaa1,lumaa2,cb,cr;
  uint8 cbb2, crr2;
  register long r;
  register uint32 frameIncr = 0;
  register uint32 out;
  register uint32 out2;
  register const uint32 *rTable = &(ipl2_r666[0]);
  register const uint32 *gTable = &(ipl2_g666[0]);
  register const uint32 *bTable = &(ipl2_b666[0]);
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot270Frame_YCbCToRGB666\n");

  /*------------------------------------------------------------------------
      CAUTION :: This function has a lot of left shifts on negative values.
      These are  generally not recommended becuase it will produce wrong
      results for some compiler CPU setups.

      Since for ARM there is separate arithmatic ASE instruction and most
      of our sfhits are left this is not a problem. Hence we are ignoring
      all the lint waring on this front. This lint error e 703
  ------------------------------------------------------------------------*/
  if( i_frame_ptr && !frameImgPtr )
  {

    return(IPL_FAILURE);
  }
  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
      /*WARN*/
  }


  /*------------------------------------------------------------------------
      initialize the index to starting position
  ------------------------------------------------------------------------*/
  src_index = ( ( uint32 ) startPos ) * 2;  //lint !e703
  dest_index = (uint32) ( (crop->x +
                           o_img_ptr->dx * crop->y) << 1 ); //lint !e703
  frame_index = 0;

  if ( i_frame_ptr )
  {
    frameIncr = (i_frame_ptr->dx - crop->dx) << 1; //lint !e703
  }

  dest_index = dest_index << 1; //lint !e703

  /*------------------------------------------------------------------------
      Loop through the image once
  ------------------------------------------------------------------------*/
  for ( row = 0; row < render_row_size; row++ )
  {
    for ( col = 0; col < render_col_size; col=col+2 )
    {
      /*--------------------------------------------------------------------
          Suppressing a lint warning we have the opening check on
          frameImgPtr
      --------------------------------------------------------------------*/
      if ( (frameImgPtr != NULL) &&
           ((*(uint16*)(frameImgPtr + frame_index)) //lint !e613
                                      != transparentValue) ) //lint !e613
      {

        /*------------------------------------------------------------------
            Convert the pixels to RGB666

            Suppress the lint warning because we NULL check
            in the beginnig
        ------------------------------------------------------------------*/
        out = *(uint16*)((uint32)frameImgPtr + frame_index); //lint !e613
        r = (unsigned char)( (out & 0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *((uint32*)((uint32)data_out + dest_index))=out32;
        out = *(uint16*)((uint32)frameImgPtr + frame_index + 2); //lint !e613
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *((uint32*)((uint32)data_out + dest_index+4))=out32;
      }
      else
      {
        /*------------------------------------------------------------------
            Convert the input to RGB666
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
              This is Cb
        ------------------------------------------------------------------*/
        cb = *((uint8*)(inputImgPtr + src_index - 2));
        cbb2 = *((uint8*)(inputImgPtr + src_index));
        /*------------------------------------------------------------------
            Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
            Next byte is cr
        ------------------------------------------------------------------*/
        cr = *((uint8*)( inputImgPtr + src_index +
                         ( colInc << 1 ) ) + 2); //lint !e703
        crr2 = *((uint8*)( inputImgPtr + src_index +
                            ( colInc << 1 ) ) ); //lint !e703

        /*------------------------------------------------------------------
            Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr + src_index+
                            ( colInc << 1 )+1)); //lint !e703

        /*------------------------------------------------------------------
            Adjust Cb and Cr for odd and even rows
         -----------------------------------------------------------------*/
        if ( row%2 )
        {
          cb = cbb2;
        }
        else
        {
          cr = crr2;
        }


        /*------------------------------------------------------------------
          invoke the conversion macro
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
                                   rTable, gTable, bTable);

        *((uint32*)((uint32)data_out + dest_index))=out;

        *((uint32*)((uint32)data_out + dest_index+4)) = out2;
      }

      src_index += (colInc << 2); //lint !e703
      dest_index += 8;
      frame_index += 4;

    } /* End of col loop */

    src_index = src_index + (rowInc<<1) - (colInc<<1);  //lint !e703
    dest_index = dest_index + ( (o_img_ptr->dx - crop->dx) << 2); //lint !e703
    frame_index += frameIncr;

  } /* End of row loop */

  return(IPL_SUCCESS);
} /* end of function ipl2_Rot270Frame_YCbCToRGB666 */

/*===========================================================================

FUNCTION ipl2_YCbCrToRGB666()

DESCRIPTION
  This function will handle cropping, color converting of
  YCbCr based images to different RGB666 code. This function is more optimal
  if you are not cropping and you are not using transparent value. . This
  function is specifically designed for the favorable input
  condition where - there is no framing going on. So transparent value check
  is not needed. This function calls for help when the output is RGB666 .
  This because translation very different and output is 32 bit value.

DEPENDENCIES
  None

ARGUMENTS IN
  ipl_image_type* input_img_ptr        Points to the input image
  ipl_rect_type* crop                  Cropping parameter

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

===========================================================================*/
static ipl_status_type ipl2_YCbCrToRGB666
(
  ipl_image_type* input_img_ptr,        /* Points to the input image      */
  ipl_image_type* output_img_ptr,       /* Points to the output image     */
  ipl_rect_type* crop                   /* Crop config                    */
)
{
  register unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32*) output_img_ptr->imgPtr;
  register uint32 out, out2;
  register uint8 cb,cr;
  register unsigned char lumaa1;
  register int32 lumaa2;
  register int32 r;
  register uint8 *endPtr;
  register const uint32 *rTable = &(ipl2_r666[0]);
  register const uint32 *gTable = &(ipl2_g666[0]);
  register const uint32 *bTable = &(ipl2_b666[0]);
  int32 row,col;
  uint32 dest_index, rowInc=0, destInc;

  MSG_LOW("inside ipl2_YCbCrToRGB666\n");

  /*------------------------------------------------------------------------
    CAUTION :: This function has a lot of left shifts on negative values.
    These are  generally not recommended becuase it will produce wrong
    results for some compiler CPU setups.

    Since for ARM there is separate arithmatic ASE instruction and most
    of our sfhits are left this is not a problem. Hence we are ignoring
    all the lint waring on this front. This lint error e 703
------------------------------------------------------------------------*/

  /*------------------------------------------------------------------------

  ------------------------------------------------------------------------*/
  dest_index = (crop->x +
                output_img_ptr->dx*crop->y) << 2; //lint !e703

  rowInc = (input_img_ptr->dx - crop->dx ) * 2;

  outputImgPtr = (uint32 *) ((uint32)outputImgPtr +  dest_index);
  destInc = ( output_img_ptr->dx - crop->dx) << 2; //lint !e703

  /*------------------------------------------------------------------------
      if rowInc and colInc are zero we can take a more optimized approach
  ------------------------------------------------------------------------*/
  if ( !rowInc && !destInc )
  {

    endPtr = (uint8 *) inputImgPtr + (crop->dy * crop->dx) * 2;
    while ( endPtr > inputImgPtr )
    {

      /*--------------------------------------------------------------------
          Convert the input to RGB666
      --------------------------------------------------------------------*/
      cb = (*((uint8*)(inputImgPtr++)));

      /*--------------------------------------------------------------------
          Next Byte is luma of first pixel
      --------------------------------------------------------------------*/
      lumaa1 = *((uint8*)(inputImgPtr++));

      /*--------------------------------------------------------------------
          CR of the current pixel
      --------------------------------------------------------------------*/
      cr = (*((uint8*) (inputImgPtr++)));

      /*--------------------------------------------------------------------
          get the next luma value
      --------------------------------------------------------------------*/
      lumaa2 = *((uint8*)(inputImgPtr++));

      /*--------------------------------------------------------------------
         Following piece of code is a template for the YCrCb to RGB
         conversion when you find some bug on this make sure you fix all the
        templates used in this file
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,
                                rTable, gTable, bTable);

      *outputImgPtr++ = out;
      *outputImgPtr++ = out2;

    } /* End while loop */

  }
  else
  {
    /*----------------------------------------------------------------------
      Do a row coloumn loop
    ----------------------------------------------------------------------*/
    for ( row = (int32) crop->dy; row; row-- )
    {
      for ( col = (int32) crop->dx/2; col; col-- )
      {
        /*------------------------------------------------------------------
            This is Cb
        ------------------------------------------------------------------*/
        cb = (*((uint8*)(inputImgPtr++)));
        /*------------------------------------------------------------------
            Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
              Next byte is cr
        ------------------------------------------------------------------*/
        cr = (*((uint8*) (inputImgPtr++)));

        /*------------------------------------------------------------------
            get the next luma value
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr++));

        /*--------------------------------------------------------------------
           Following piece of code is a template for the YCrCb to RGB
           conversion when you find some bug on this make sure you fix all
           the templates used in this file
        --------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
                                   rTable, gTable, bTable);

        *outputImgPtr++ = out;
        *outputImgPtr++ = out2;

      } /* End of col loop */

      inputImgPtr = (uint8*)((uint32)inputImgPtr + rowInc);
      outputImgPtr = (uint32 *) ((uint32 )outputImgPtr + destInc);

    } /* End of row loop */
    return(IPL_SUCCESS);
  }

  return( IPL_SUCCESS );


} /* end of function ipl2_YCbCrToRGB666 */

/*===========================================================================
FUNCTION ipl2_Rot180Frame_YCbCToRGB666()

DESCRIPTION
  This function alters the converts a YCBCR image to  RGB666 flavor.
  The function does framing 180 degree rotation and cropping as well.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr  - input image frame
  transparentValue - transparent val for framing
  rowInc         - row increment after each col copy - depends on rotation
  colInc         - the col inrement for iteration - depends on rotation
  crop           - the cropping needed if any

ARGUMENTS OUT
  o_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Alters the output buffer

===========================================================================*/
static ipl_status_type ipl2_Rot180Frame_YCbCToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index;
  uint32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* frameImgPtr = (i_frame_ptr==NULL)?NULL:i_frame_ptr->imgPtr;
  register uint32 out, out2, out32;
  register const uint32 *rTable = &(ipl2_r666[0]);
  register const uint32 *gTable = &(ipl2_g666[0]);
  register const uint32 *bTable = &(ipl2_b666[0]);
  register uint8 cb,cr, lumaa1=0;
  register int32 r, lumaa2=0;
  uint32 frameIncr = 0;
  register uint32* data_out = (uint32*)o_img_ptr->imgPtr;

  MSG_LOW("inside ipl2_Rot180Frame_YCbCToRGB666\n");

  /*------------------------------------------------------------------------
    CAUTION :: This function has a lot of left shifts on negative values.
    These are  generally not recommended becuase it will produce wrong
    results for some compiler CPU setups.

    Since for ARM there is separate arithmatic ASE instruction and most
    of our sfhits are left this is not a problem. Hence we are ignoring
    all the lint waring on this front. This lint error e 703
------------------------------------------------------------------------*/

  if( i_frame_ptr && !frameImgPtr )
  {

    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
      initialize the index to starting position
  ------------------------------------------------------------------------*/
  src_index = startPos<<1;  //lint !e703
  dest_index = (crop->x + o_img_ptr->dx*crop->y) <<1;
  frame_index = 0;

  if ( i_frame_ptr )
  {
    frameIncr = (int32) (i_frame_ptr->dx - crop->dx) << 1; //lint !e703
  }

  dest_index = dest_index << 1;

  /*------------------------------------------------------------------------
      Loop the image on row/coloumn basis
  ------------------------------------------------------------------------*/
  for ( row = 0; row < crop->dy; row++ )
  {
    for ( col = 0; col < (crop->dx); col=col+2 )
    {
      if ( (frameImgPtr != NULL) && \
           ((*(uint16*)(frameImgPtr + frame_index)) != transparentValue) )
      {
        /*------------------------------------------------------------------

                 ** Convert frame to rgb 666

        ------------------------------------------------------------------*/
        out = *(uint16*)((uint32)frameImgPtr + frame_index);
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *((uint32*)((uint32)data_out + dest_index))=out32;
        out = *(uint16*)((uint32)frameImgPtr + frame_index + 2);
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *((uint32*)((uint32)data_out + dest_index+4))=out32;
      }
      else
      {

        /*------------------------------------------------------------------
          ** Convert input to rgb666
        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
           This is Cr
        ------------------------------------------------------------------*/
        cr = *((uint8*)(inputImgPtr + src_index));

        /*------------------------------------------------------------------
          Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
            Next byte is cb
        ------------------------------------------------------------------*/
        cb = *((uint8*)(inputImgPtr + src_index +
                        (colInc<<1))); //lint !e703

        /*------------------------------------------------------------------
            Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr + src_index+
                            (colInc<<1)+1)); //lint !e703

        /*------------------------------------------------------------------
         Following piece of code is a template for the YCrCb to RGB
         conversion when you find some bug on this make sure you fix all the
        templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2, \
                                   rTable, gTable, bTable);

        *((uint32*)((uint32)data_out + dest_index))=out;
        *((uint32*)((uint32)data_out + dest_index+4)) = out2;

      }
      src_index += (colInc<<2); //lint !e703
      dest_index += 8;
      frame_index += 4;

    } /* End of col loop */

    src_index = src_index + (rowInc<<1) - (colInc<<1);  //lint !e703
    dest_index = dest_index +
      (uint32) ( (o_img_ptr->dx - crop->dx) << 2); //lint !e703
     frame_index += frameIncr;

  } /* End of row loop */

  return(IPL_SUCCESS);

} /* end of function ipl2_Rot180Frame_YCbCToRGB666 */

/*===========================================================================

FUNCTION ipl2_Rot000Frame_YCbCrToRGB666()

DESCRIPTION
  As the name indicates this function caters for the case of converting a
  YCrCb based image to a RGB666 coded image. The function does rotation
  and framing as well.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr  - input image frame
  i_frame_ptr    - input frame for transparent overlays
  crop           -  Crop config
  transparentValue - transparent value for overlay


ARGUMENTS OUT
  output_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Changes the output image buffer

===========================================================================*/
static ipl_status_type ipl2_Rot000Frame_YCbCrToRGB666
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
)
{

  uint32 dest_index, destInc, rowInc;
  uint32 row,col;
  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  unsigned char r1;
  register uint32 out, out2, out32;
  register int32 cb,cr;
  register unsigned char lumaa1=0;
  register int32 lumaa2;
  register long r;
  register uint32* data_out = (uint32*)o_img_ptr->imgPtr;
  register const uint32 *rTable = &(ipl2_r666[0]);
  register const uint32 *gTable = &(ipl2_g666[0]);
  register const uint32 *bTable = &(ipl2_b666[0]);

  MSG_LOW("inside ipl2_Rot000Frame_YCbCrToRGB666\n");

  /*------------------------------------------------------------------------
    CAUTION :: This function has a lot of left shifts on negative values.
    These are  generally not recommended becuase it will produce wrong
    results for some compiler CPU setups.

    Since for ARM there is separate arithmatic ASE instruction and most
    of our sfhits are left this is not a problem. Hence we are ignoring
    all the lint waring on this front. This lint error e 703
------------------------------------------------------------------------*/

  if( !frameImgPtr )
  {

    return( IPL_FAILURE );
  }
  /*------------------------------------------------------------------------
      initialize the index to starting position
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx*crop->y) << 2; //lint !e703
  rowInc = (i_img_ptr->dx - crop->dx )<<1; //lint !e703
  destInc = ( o_img_ptr->dx - crop->dx)<<2; //lint !e703


  data_out = (uint32*)((uint32)data_out +  (dest_index<<1)); //lint !e703

  /*------------------------------------------------------------------------
      Loop through the image on row coloumn basis
  ------------------------------------------------------------------------*/
  for ( row = crop->dy; row; row-- )
  {
    for ( col = crop->dx/2; col; col-- )
    {
      /*--------------------------------------------------------------------
          We are NULL checkin this variable thats why we are suppressing
          Lint warning 613
      --------------------------------------------------------------------*/
      if ( *(uint16*)(frameImgPtr) != transparentValue ) //lint !e613
      {
        /*------------------------------------------------------------------
          ** Copy Over the Frame and convert from 565 to 666
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr); //lint !e613
        r1 = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r1];
        r1 = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r1];
        r1 = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r1];
        *data_out = out32;
        data_out++;
        frameImgPtr++; //lint !e613
        out = *(uint16*)(frameImgPtr);
        r1 = (unsigned char)((out&0xF800)>>8); //lint !e613
        out32 = ipl2_r666[r1];
        r1 = (unsigned char)((out&0x07E0)>>3); //lint !e613
        out32 += ipl2_g666[r1];
        r1 = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r1];
        *data_out = out32;
        data_out++;
        frameImgPtr++; //lint !e613
        inputImgPtr+=4;
      }
      else
      {
        /*------------------------------------------------------------------
            Advance the image pointer
        ------------------------------------------------------------------*/
        frameImgPtr += 2; //lint !e613
        /*------------------------------------------------------------------
            Convert the pixel to RGB 666
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            This is CB
        ------------------------------------------------------------------*/
        cb = (uint32)(*((uint8*)(inputImgPtr++)));

        /*------------------------------------------------------------------
             Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
             Next byte is cr
        ------------------------------------------------------------------*/
        cr = (uint32)(*((uint8*)(inputImgPtr++)));

        /*------------------------------------------------------------------
           Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr++));

        /*------------------------------------------------------------------
         Following piece of code is a template for the YCrCb to RGB
         conversion when you find some bug on this make sure you fix all the
         templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,  \
                                  rTable, gTable, bTable);

        *data_out++ = out;
        *data_out++ = out2;
      }
    } /* End of col loop */

    inputImgPtr = (uint8*)((uint32)inputImgPtr + rowInc);
    frameImgPtr = (uint16*)((uint32)frameImgPtr + rowInc);
    data_out = (uint32*)((uint32)data_out + destInc);

  } /* End of row loop */

  return(IPL_SUCCESS);

} /* end of function ipl2_Rot000Frame_YCbCrToRGB666 */

/*===========================================================================
FUNCTION ipl2_Rot090Frame_YCbCToRGB666()

DESCRIPTION
  This function alters the converts a YCBCR image to  RGB666 flavor.
  The function does framing 90 degree rotation and cropping as well.

DEPENDENCIES
  None

ARGUMENTS IN
  i_img_ptr  - input image frame
  transparentValue - transparent val for framing
  rowInc         - row increment after each col copy - depends on rotation
  colInc         - the col inrement for iteration - depends on rotation
  crop           - the cropping needed if any

ARGUMENTS OUT
  o_img_ptr - Points to the output image

RETURN VALUE
  Status - success or failure

SIDE EFFECTS
  Alters the output buffer

===========================================================================*/
static ipl_status_type ipl2_Rot090Frame_YCbCToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index;
  uint32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  unsigned char* frameImgPtr = (i_frame_ptr==NULL)?NULL:i_frame_ptr->imgPtr;
  register int32 lumaa1,lumaa2,cb,cr, r;
  unsigned char cbb2=0,crr2=0;
  uint32 frameIncr = 0;
  uint32* data_out = (uint32*)o_img_ptr->imgPtr;
  register uint32 out, out2, out32;
  register const uint32 *rTable = &(ipl2_r666[0]);
  register const uint32 *gTable = &(ipl2_g666[0]);
  register const uint32 *bTable = &(ipl2_b666[0]);
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot090Frame_YCbCToRGB666\n");

  /*------------------------------------------------------------------------
    CAUTION :: This function has a lot of left shifts on negative values.
    These are  generally not recommended becuase it will produce wrong
    results for some compiler CPU setups.

    Since for ARM there is separate arithmatic ASE instruction and most
    of our sfhits are left this is not a problem. Hence we are ignoring
    all the lint waring on this front. This lint error e 703

  ------------------------------------------------------------------------*/

  if( i_frame_ptr && !frameImgPtr )
  {

    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
      /*WARN*/
  }

  /*------------------------------------------------------------------------
   initialize the index to starting position
  ------------------------------------------------------------------------*/
  src_index = startPos << 1;  //lint !e703
  dest_index = (crop->x + o_img_ptr->dx*crop->y) << 1; //lint !e703
  frame_index = 0;
  if ( i_frame_ptr )
  {
    frameIncr = (i_frame_ptr->dx - crop->dx )<<1; //lint !e703
  }

  dest_index = dest_index << 1; //lint !e703

  /*------------------------------------------------------------------------
      Now loop through the image once
  ------------------------------------------------------------------------*/
  for ( row = 0; row < render_row_size; row++ )
  {
    for ( col = 0; col < render_col_size; col=col+2 )
    {
      if ( (frameImgPtr != NULL) && \
            ((*(uint16*)(frameImgPtr + frame_index)) != transparentValue) )
      {

        /*------------------------------------------------------------------
             Use frame but convert it to rgb666
        ------------------------------------------------------------------*/
        out = *(uint16*)((uint32)frameImgPtr + frame_index);
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *((uint32*)((uint32)data_out + dest_index))=out32;

        out = *(uint16*)((uint32)frameImgPtr + frame_index + 2);
        r = (unsigned char)((out&0xF800)>>8);
        out32 = ipl2_r666[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out32 += ipl2_g666[r];
        r = (unsigned char)((out&0x001F)<<3);
        out32 += ipl2_b666[r];
        *((uint32*)((uint32)data_out + dest_index+4))=out32;
      }
      else
      {
        /*------------------------------------------------------------------
           Convert input to rgb
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
              This is Cb
        ------------------------------------------------------------------*/
        cb = *((uint8*)(inputImgPtr + src_index));
        cbb2 = *((uint8*)(inputImgPtr + src_index - 2));

        /*------------------------------------------------------------------
             Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index + 1));

        /*------------------------------------------------------------------
               Next byte is cr
        ------------------------------------------------------------------*/
        cr = *((uint8*)(inputImgPtr +
                        src_index + (colInc<<1))); //lint !e703
        crr2 = *((uint8*)(inputImgPtr +
                          src_index + (colInc<<1) + 2)); //lint !e703
        /*------------------------------------------------------------------
             Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr +
                            src_index + (colInc<<1) + 1)); //lint !e703

        /*------------------------------------------------------------------
          Adjust Cb and Cr for odd and even rows
        ------------------------------------------------------------------*/
        if ( row%2 )
        {
          cb = cbb2;
        }
        else
        {
          cr = crr2;
        }


        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix all
          the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out, out2,  \
                                  rTable, gTable, bTable);

        *((uint32*)((uint32)data_out + dest_index)) = out;
        *((uint32*)((uint32)data_out + dest_index + 4)) = out2;
      }

      src_index += (colInc<<2); //lint !e703
      dest_index += 8;
      frame_index += 4;

    } /* End of col loop */

    src_index = src_index + (rowInc<<1) - (colInc<<1);  //lint !e703
    dest_index = dest_index +
       ( (o_img_ptr->dx - crop->dx) << 2); //lint !e703
    frame_index+=frameIncr;

  } /* End of row loop */

  return(IPL_SUCCESS);

} /* end of function ipl2_Rot090Frame_YCbCToRGB666 */
/*===========================================================================

                          IPL2_YCBCR2YCBCR.C

DESCRIPTION
  This file contains the routines which are used for image conversions
  involving YCbCr input and output.

EXTERNALIZED FUNCTIONS

  ipl2_YCbCrToYCrCb()
    Takes YCbCr based images and spits out a cropped version of it.

  ipl2_Rot000Frame_YCbCrToYCbCr()
    Takes YCbCr based images and spits out a cropped and framed
    version of it.

  ipl2_Rot000Frame_YCbCrToYCbCr()
    Takes YCbCr based images and spits out a cropped and framed and rotated
    version of it.


Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
===========================================================================

===========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     ---------------------------------------------------------
05/04/04   srk     Rework based on review commenrs from, Jun, Nish, Ramesh,
                   David, Roy and Nikhil
04/19/04   srk     Initially created.
=========================================================================== */



/*===========================================================================

                          FUNCTION DEFINITIONS

===========================================================================*/


/*===========================================================================

FUNCTION ipl2_RotFrame_YCbCrToYCbCr()

DESCRIPTION
  This function is responsible for Cropping Framing and rotation of YCbCr
  based image. Output format is YCbCr. Entry function into this filie.

DEPENDENCIES
None

ARGUMENTS IN
    input_img_ptr,   - Input Image Pointer
    i_frame_ptr - Input Frame Pointer
    transparentValue -transparent value of pixel
    crop - Crop Parameters
    rotate - Rotatation

ARGUMENTS IN
    o_img_ptr -Output Image Pointer

RETURN VALUE
  Status -  Success of Faiilure

SIDE EFFECTS
  Ouput buffer is populated with the processed image.

===========================================================================*/
static ipl_status_type ipl2_RotFrame_YCbCrToYCbCr
(
  ipl_image_type* input_img_ptr,    /* Input Image Pointer           */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer               */
  uint16 transparentValue, /* transparent value of pixel             */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer               */
  ipl_rect_type* crop,
  ipl_rotate90_type rotate         /* Rotatation                     */
)
{
  int32 startPos, colInc, rowInc;

  MSG_LOW("inside ipl2_RotFrame_YCbCrToYCbCr\n");

    switch ( rotate )
    {
      case IPL_ROT90 :
        {
          /*----------------------------------------------------------------
               Rotate 90 clockwise.
          ----------------------------------------------------------------*/
          startPos = (int32) (  input_img_ptr->dx *
                          (  (input_img_ptr->dy - 1 ) ) );
          colInc = -(int32) input_img_ptr->dx;
          rowInc = (int32) ( (input_img_ptr->dx)*(input_img_ptr->dy-1)+1 -
                         (input_img_ptr->dy - crop->dx)*input_img_ptr->dx );

          if ( input_img_ptr->dy < crop->dx )
          {
            /*--------------------------------------------------------------
                 Invalid settings
            --------------------------------------------------------------*/
            return(IPL_FAILURE);
          }


          return(ipl2_Rot090Frame_YCbCrToYCbCr(
                               input_img_ptr,
                               i_frame_ptr,
                               transparentValue,
                               o_img_ptr, startPos,
                               colInc,
                               rowInc,
                               crop)  );

        }

        /*NOTREACHED*/
        break;

      case IPL_ROT180 :
        {
          /*----------------------------------------------------------------
               Rotate 180 clockwise.  Dont reflect
          ----------------------------------------------------------------*/
          startPos = (int32) ( (input_img_ptr->dx*input_img_ptr->dy)-1);
          colInc = -1;
          rowInc = (int32) -1 - (int32) (  input_img_ptr->dx -
                                   crop->dx);
          if ( input_img_ptr->dx < crop->dx )
          {

            /*--------------------------------------------------------------
                   Invalid settings
            --------------------------------------------------------------*/
            return(IPL_FAILURE);
          }
          return(ipl2_Rot180Frame_YCbCrToYCbCr(
                               input_img_ptr,
                               i_frame_ptr,
                               transparentValue,
                               o_img_ptr, startPos,
                               colInc,
                               rowInc,
                               crop)  );


        }
        /*NOTREACHED*/
        break;

      case IPL_ROT270 :
        {
          /*----------------------------------------------------------------
               Rotate 270 clockwise.  Dont reflect
          ----------------------------------------------------------------*/
          startPos = (int32) (input_img_ptr->dx - 1);
          colInc = (int32) input_img_ptr->dx;
          rowInc = (int32) ( -(int32)(input_img_ptr->dx)*(input_img_ptr->dy-1) -1 + //lint !e737
                    (input_img_ptr->dy - crop->dx)*input_img_ptr->dx );

          if ( input_img_ptr->dy < crop->dx )
          {
            /*--------------------------------------------------------------
                 Invalid settings
            --------------------------------------------------------------*/
            return(IPL_FAILURE);
          }

          return(ipl2_Rot270Frame_YCbCrToYCbCr(
                               input_img_ptr,
                               i_frame_ptr,
                               transparentValue,
                               o_img_ptr, startPos,
                               colInc,
                               rowInc,
                               crop)  );
        }
        /*NOTREACHED*/
        break;

      default :
        {
          IPL2_MSG_FATAL( "ipl2_RotFrame :: /\
                          uknonw to rotaion param = %d", rotate);

          /*----------------------------------------------------------------
               Option Not supported
          ----------------------------------------------------------------*/
          return(IPL_FAILURE);
        }
        /*NOTREACHED*/
        break;
    }

    /*NOTREACHED*/
    return(IPL_SUCCESS );

} /* end of function ipl2_RotFrame_YCbCrToYCbCr */

/*===========================================================================

FUNCTION ipl2_Rot270Frame_YCbCrToYCbCr()

DESCRIPTION
  This function is responsible for Cropping Framing and rotation of YCbCr
  based image. Output format is YCbCr.

DEPENDENCIES
None

ARGUMENTS IN
    input_img_ptr,   - Input Image Pointer
    i_frame_ptr - Input Frame Pointer
    transparentValue -transparent value of pixel
    crop - Crop Parameters
    startPos - start position within the image (for rotaion + cropping)
    colInc   - rotation param
    rowInc   -  rotation param
    destInc  - rotation param

ARGUMENTS OUT
      o_img_ptr -Output Image Pointer

RETURN VALUE
Status -  Success of Faiilure

SIDE EFFECTS
Ouput buffer is populated with the processed image.

===========================================================================*/
static ipl_status_type ipl2_Rot270Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                */
  uint16 transparentValue, /* transparent value of pixel              */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index;
  uint32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* outputImgPtr = o_img_ptr->imgPtr;
  unsigned char* frameImgPtr = (i_frame_ptr==NULL)?NULL:i_frame_ptr->imgPtr;
  register unsigned short out;
  register unsigned short r1,g1,b1;
  int32 crr, cbb;
  unsigned char lumaa1=0,lumaa2=0,cbb2=0,crr2=0;
  uint32 frameIncr = 0;

  MSG_LOW("inside ipl2_Rot270Frame_YCbCrToYCbCr\n");

  /*------------------------------------------------------------------------
  LINT SUPPRESSION :: This function has a lot of left shifts on negative
  values.
  These are  generally not recommended becuase it will produce wrong
  results for some compiler CPU setups.

  Since for ARM there is separate arithmatic shift ASR instruction and
  most of our sfhits are left this is not a problem. Hence we are ignoring
  all the lint warning on this instance. This lint error e 703
  ------------------------------------------------------------------------*/

  /*------------------------------------------------------------------------
        initialize the index to starting position
  ------------------------------------------------------------------------*/
  src_index = startPos << 1;  //lint !e703
  dest_index = (crop->x + o_img_ptr->dx*crop->y) <<1; //lint !e703
  frame_index = 0;


  if (i_frame_ptr)
  {
    /*----------------------------------------------------------------------
        if frame did not contain a valid image lets throw error
    ----------------------------------------------------------------------*/
    if(!frameImgPtr)
    {
      return( IPL_FAILURE );
    }
    frameIncr = (i_frame_ptr->dx - crop->dx) * 2;   //lint !e703
  }

  /*------------------------------------------------------------------------
      Do a row coloumn pass on the image
  ------------------------------------------------------------------------*/
  for ( row = 0; row < crop->dy; row++ )
  {
    for ( col = 0; col < (crop->dx); col=col+2 )
    {
      if ( (i_frame_ptr != NULL) &&
           ((*(uint16*)(frameImgPtr + frame_index))  //lint !e613
            != transparentValue) ) //lint !e613
      {
        /*------------------------------------------------------------------
            Need to convert the frame input YCbCr
        ------------------------------------------------------------------*/
        /* 1st pixel */
        out = *((uint16*)(frameImgPtr + frame_index)); //lint !e613
        r1 = out >> 8 ;
        g1 = (out >> 3) & 0xff ;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index)) = 
          ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        /* 2nd pixel */
        out = *((uint16*)(frameImgPtr + frame_index + 2)); //lint !e613
        r1 = out >> 8;
        g1 = (out >> 3) & 0xff;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
          ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
      }
      else
      {
        /*------------------------------------------------------------------
           This is Cb
        ------------------------------------------------------------------*/
        cbb = *((uint8*)(inputImgPtr + src_index));
        cbb2 = *((uint8*)(inputImgPtr + src_index + 2));
        /*------------------------------------------------------------------

           Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
             Next byte is cr
        ------------------------------------------------------------------*/
        crr = *((uint8*)(inputImgPtr +
                         src_index + (colInc<<1)) );  //lint !e703
        crr2 = *((uint8*)(inputImgPtr + src_index
                          + (colInc<<1)+2)); //lint !e703
        /*------------------------------------------------------------------
          Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr + src_index+
                            (colInc << 1 ) + 1 )); //lint !e703
        /*------------------------------------------------------------------
            Pick the right CR and CB for each row rotated
        ------------------------------------------------------------------*/
        if ( row%2 )
        {
          crr = crr2;
        }
        else
        {
          cbb = cbb2;
        }
        *((uint8*)(outputImgPtr + dest_index))     = (uint8) cbb;
        *((uint8*)(outputImgPtr + dest_index + 1)) = (uint8) lumaa1;
        *((uint8*)(outputImgPtr + dest_index + 2)) = (uint8) crr;
        *((uint8*)(outputImgPtr + dest_index + 3)) = (uint8) lumaa2;
      }
      src_index += (colInc << 2); //lint !e703
      dest_index += 4;
      frame_index += 4;
    } /* End of col loop */

    src_index = src_index + (rowInc<<1) - (colInc<<1); //lint !e703
    dest_index = dest_index +
      ( (o_img_ptr->dx - crop->dx) << 1); //lint !e703
    frame_index += frameIncr;

  } /* End of row loop */

  return (IPL_SUCCESS);

} /* end of function ipl2_Rot270Frame_YCbCrToYCbCr */

/*===========================================================================

FUNCTION ipl2_Rot180Frame_YCbCrToYCbCr()

DESCRIPTION
  This function is responsible for Cropping Framing and rotation of YCbCr
  based image. The rotation is fixed at 180 degree.
  Output format is YCbCr. Entry function into this filie.

DEPENDENCIES
None

ARGUMENTS IN
    input_img_ptr,   - Input Image Pointer
    i_frame_ptr - Input Frame Pointer
    transparentValue -transparent value of pixel
    crop - Crop Parameters
    startPos - start position within the image (for rotaion + cropping)
    colInc   - rotation param
    rowInc   -  rotation param
    destInc  - rotation param

ARGUMENTS IN
    o_img_ptr -Output Image Pointer

RETURN VALUE
  Status -  Success of Faiilure

SIDE EFFECTS
  Ouput buffer is populated with the processed image.

===========================================================================*/

static ipl_status_type ipl2_Rot180Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                    */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                    */
  uint16 transparentValue, /* transparent value of pixel                  */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                    */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index;
  uint32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* outputImgPtr = o_img_ptr->imgPtr;
  unsigned char* frameImgPtr = (i_frame_ptr==NULL)?NULL:i_frame_ptr->imgPtr;
  register uint16 out;
  register uint32 frameIncr = 0;
  register unsigned char r1,g1,b1;
  register unsigned char cr,cb;
  unsigned char lumaa1=0,lumaa2=0;

  MSG_LOW("inside ipl2_Rot180Frame_YCbCrToYCbCr\n");

  /*------------------------------------------------------------------------
    LINT SUPPRESSION :: This function has a lot of left shifts on negative
    values.
    These are  generally not recommended becuase it will produce wrong
    results for some compiler CPU setups.

    Since for ARM there is separate arithmatic shift ASR instruction and
    most of our sfhits are left this is not a problem. Hence we are ignoring
    all the lint warning on this instance. This lint error e 703
  ------------------------------------------------------------------------*/

  if( i_frame_ptr && !frameImgPtr )
  {
    return(IPL_FAILURE);
  }



 /*-------------------------------------------------------------------------
      initialize the index to starting position

 -------------------------------------------------------------------------*/
  src_index = (uint32) ( startPos * 2 );
  dest_index = (crop->x + o_img_ptr->dx * crop->y) * 2;
  frame_index = 0;

  if ( i_frame_ptr )
  {
    if( !frameImgPtr )
    {
      return( IPL_FAILURE );
    }
    frameIncr = ( (i_frame_ptr->dx - crop->dx) * 2 );
  }

  /*------------------------------------------------------------------------
    Now do a row/col loop since we need rotation
  ------------------------------------------------------------------------*/
  for ( row = 0; row < crop->dy; row++ )
  {
    for ( col = 0; col < (crop->dx); col=col+2 )
    {
      if ( (i_frame_ptr != NULL) && ((*(uint16*)(frameImgPtr + //lint !e613
                     frame_index)) != transparentValue) ) //lint !e613
      {

        /*------------------------------------------------------------------
            Convert the frame to YCbCr
        ------------------------------------------------------------------*/

        /* 1st pixel */
        out = *((uint16*)(frameImgPtr + frame_index));    //lint !e613
        r1 = out >> 8 ;
        g1 = (out >> 3) & 0xff ;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index)) = 
          ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        /* 2nd pixel */
        out = *((uint16*)(frameImgPtr + frame_index + 2)); //lint !e613
        r1 = out >> 8;
        g1 = (out >> 3) & 0xff;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
          ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
      }
      else
      {
        /*------------------------------------------------------------------
            This is CB
        ------------------------------------------------------------------*/
        cr = *((uint8*)(inputImgPtr + src_index));

        /*------------------------------------------------------------------
           Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
            Next byte is cr
        ------------------------------------------------------------------*/
        cb = *((uint8*)(inputImgPtr + src_index+(colInc<<1))); //lint !e703

        /*------------------------------------------------------------------
             Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr +
                             src_index+(colInc<<1)+1)); //lint !e703
        *((uint8*)(outputImgPtr + dest_index))     = (uint8) cb;
        *((uint8*)(outputImgPtr + dest_index + 1)) = (uint8) lumaa1;
        *((uint8*)(outputImgPtr + dest_index + 2)) = (uint8) cr;
        *((uint8*)(outputImgPtr + dest_index + 3)) = (uint8) lumaa2;
      }

      src_index += (colInc<<2); //lint !e703
      dest_index += 4;
      frame_index += 4;

    } /* End of col loop */
    src_index = src_index +
      (rowInc<<1) - (colInc<<1);  //lint !e703
    dest_index = dest_index +
      ( (o_img_ptr->dx - crop->dx) << 1); //lint !e703
    frame_index += frameIncr;

  } /* End of row loop */

  return (IPL_SUCCESS);
}  /* end of function ipl2_Rot180Frame_YCbCrToYCbCr */

/*===========================================================================

FUNCTION ipl2_Rot000Frame_YCbCrToYCbCr()

DESCRIPTION
  This function is responsible for Cropping Framing  of YCbCr
  based image. Output format is YCbCr.

DEPENDENCIES
None

ARGUMENTS IN
    input_img_ptr,   - Input Image Pointer
    i_frame_ptr - Input Frame Pointer
    transparentValue -transparent value of pixel
    crop - Crop Parameters

ARGUMENTS OUT
    o_img_ptr -Output Image Pointer

RETURN VALUE
Status -  Success of Faiilure

SIDE EFFECTS
Ouput buffer is populated with the processed image.

===========================================================================*/

static ipl_status_type ipl2_Rot000Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the frame              */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  uint32 src_index, dest_index,destInc, frame_index ;
  uint32 row,col;
  uint32 rowInc  = 0;
  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16*) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16*)((i_frame_ptr==NULL)?NULL:i_frame_ptr->imgPtr);
  register unsigned char cr,cb;
  register unsigned char r1,g1,b1;
  register unsigned char lumaa1=0,lumaa2=0;
  register uint16 out;

  MSG_LOW("inside ipl2_Rot000Frame_YCbCrToYCbCr\n");

  /*------------------------------------------------------------------------
       initialize the index to starting position
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx*crop->y) <<1;
  rowInc = (i_img_ptr->dx - crop->dx )* 2;
  destInc = ( o_img_ptr->dx - crop->dx) * 2;
  frame_index = 0;
  src_index = 0;

  /*------------------------------------------------------------------------
       * reposition the output image to match with the cropping parameter.
       * So that it is correctly positioned in the output frame
  ------------------------------------------------------------------------*/
    outputImgPtr = (uint16*)((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Do a row/col loop
  ------------------------------------------------------------------------*/
  for(row = 0; row < crop->dy; row++)
  {
    for(col = 0; col < (crop->dx); col=col+2)
    {
      if ( (i_frame_ptr != NULL) &&
           ((*(uint16*)((uint32)frameImgPtr + frame_index)) != transparentValue)) //lint !e613
      {

        /*------------------------------------------------------------------
            Convert the pixel pair to YCbCr
        ------------------------------------------------------------------*/
        /* 1st pixel */
        out = *((uint16*)((uint32)frameImgPtr + frame_index)); //lint !e613
        r1 = out >> 8 ;
        g1 = (out >> 3) & 0xff ;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index)) = 
          ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        /* 2nd pixel */
        out = *((uint16*)((uint32)frameImgPtr + frame_index + 2));
        r1 = out >> 8;
        g1 = (out >> 3) & 0xff;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
          ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
      }
      else
      {
        /*------------------------------------------------------------------
            This is Cb
        ------------------------------------------------------------------*/
        cb = *((uint8*)((uint32)inputImgPtr + src_index));
        /*------------------------------------------------------------------
             Next Byte is luma of first pixel
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)((uint32)inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
             Next byte is cr
        ------------------------------------------------------------------*/
        cr = *((uint8*)((uint32)inputImgPtr + src_index+2));
        /*------------------------------------------------------------------
             Next byte is luma of 2nd pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)((uint32)inputImgPtr + src_index+3));
        *((uint8*)((uint32)outputImgPtr + dest_index)) = (uint8) cb;
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = (uint8) lumaa1;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = (uint8) cr;
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = (uint8) lumaa2;
      }

      src_index += 4; /* byte addressed */
      dest_index += 4;
      frame_index += 4;

    } /* End of col loop */

    src_index = src_index + rowInc;  /* byte addressed */
    frame_index = frame_index + rowInc;  /* byte addressed */
    dest_index = dest_index + destInc;

  } /* End of row loop */

  return IPL_SUCCESS;

} /* end of function ipl2_Rot000Frame_YCbCrToYCbCr */


/*===========================================================================

FUNCTION ipl2_YCbCrToYCbCr()

DESCRIPTION
  This function takes YCrCb based image and converts into another cropped
   YCrCb based image.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr  - input image frame
  crop           -  Crop config

ARGUMENTS OUT
  output_img_ptr - Points to the output image


 RETURN VALUE
  Status - success for failure

SIDE EFFECTS
  None

===========================================================================*/

static ipl_status_type ipl2_YCbCrToYCbCr
(
  ipl_image_type* input_img_ptr,        /* Points to the input image      */
  ipl_image_type* output_img_ptr,       /* Points to the output image     */
  ipl_rect_type* crop                   /* Crop config                    */
)
{
  register unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32*) output_img_ptr->imgPtr;
  register uint8 cb,cr;
  register unsigned char lumaa1;
  register int32 lumaa2;
  uint32 row,col;
  uint32 src_index,rowInc=0,dest_index;

  MSG_LOW("inside ipl2_YCbCrToYCbCr\n");

  /*------------------------------------------------------------------------
     initialize the index to starting position
  ------------------------------------------------------------------------*/
  src_index = 0;  /* byte addressed */
  dest_index = (crop->x + output_img_ptr->dx*crop->y) * 2;
  rowInc = (input_img_ptr->dx - crop->dx )* 2;

  /*------------------------------------------------------------------------
      Do a row col loop on the image
  ------------------------------------------------------------------------*/
  for ( row = 0; row < crop->dy; row++ )
  {
    for ( col = 0; col < (crop->dx); col=col+2 )
    {
      /*--------------------------------------------------------------------
           This is Cb
      --------------------------------------------------------------------*/
      cb = *((uint8*)(inputImgPtr + src_index));

      /*--------------------------------------------------------------------
         Next Byte is luma of first pixel
      --------------------------------------------------------------------*/
      lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

      /*--------------------------------------------------------------------
           Next byte is cr
      --------------------------------------------------------------------*/
      cr = *((uint8*)(inputImgPtr + src_index+2));

      /*--------------------------------------------------------------------
         Next byte is luma of 2nd pixel
      --------------------------------------------------------------------*/
      lumaa2 = *((uint8*)(inputImgPtr + src_index+3));
      *((uint8*)((uint32)outputImgPtr + dest_index)) = (uint8) cb;
      *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = (uint8) lumaa1;
      *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = (uint8) cr;
      *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = (uint8) lumaa2;
      src_index += 4; /* byte addressed */
      dest_index += 4;

    } /* End of col loop */

    src_index = src_index + rowInc;  /* byte addressed */
    dest_index = dest_index + ( (output_img_ptr->dx - crop->dx) << 1);

  } /* End of row loop */

  return IPL_SUCCESS;

} /* end of function ipl2_YCbCrToYCbCr */

/*===========================================================================
FUNCTION ipl2_Rot090Frame_YCbCrToYCbCr()

DESCRIPTION
  This function is responsible for Cropping Framing and rotation of YCbCr
  based image. The rotation is fixed at 90 degrees.
  Output format is YCbCr. Entry function into this filie.

DEPENDENCIES
None

ARGUMENTS IN
    input_img_ptr,   - Input Image Pointer
    i_frame_ptr - Input Frame Pointer
    transparentValue -transparent value of pixel
    crop - Crop Parameters
    startPos - start position within the image (for rotaion + cropping)
    colInc   - rotation param
    rowInc   -  rotation param
    destInc  - rotation param

ARGUMENTS IN
      o_img_ptr -Output Image Pointer


RETURN VALUE
Status -  Success of Faiilure

SIDE EFFECTS
Ouput buffer is populated with the processed image.

===========================================================================*/

static ipl_status_type ipl2_Rot090Frame_YCbCrToYCbCr
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer                     */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer                     */
  uint16 transparentValue, /* transparent value of pixel                   */
  ipl_image_type* o_img_ptr,   /* Output Image Pointer                     */
  int32 startPos,
  int32 colInc,
  int32 rowInc,
  ipl_rect_type* crop
)
{
  uint32 src_index,dest_index;
  uint32 frame_index;
  uint32 row,col;
  unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  unsigned char* outputImgPtr = o_img_ptr->imgPtr;
  unsigned char* frameImgPtr = (i_frame_ptr==NULL)?
                    NULL:i_frame_ptr->imgPtr;
  register uint16 out;
  register int32 lumaa1=0, lumaa2=0;
  register uint32 frameIncr = 0;
  unsigned char cbb=0,crr=0,cbb2=0,crr2=0;
  unsigned char r1,g1,b1;

  MSG_LOW("inside ipl2_Rot090Frame_YCbCrToYCbCr\n");

  /*------------------------------------------------------------------------
     initialize the index to starting position
   -----------------------------------------------------------------------*/
  src_index = (uint32) ( startPos * 2) ;  /* byte addressed */
  dest_index =  (uint32) ( (crop->x + o_img_ptr->dx*crop->y) * 2 );
  frame_index = 0;
  if ( i_frame_ptr )
  {
    if( !frameImgPtr )
    {
      return( IPL_FAILURE );
    }
    frameIncr = (uint32) ( (i_frame_ptr->dx - crop->dx) * 2 );
  }

  /*------------------------------------------------------------------------
      Do a row/col loop
  ------------------------------------------------------------------------*/
  for ( row = 0; row < crop->dy; row++ )
  {
    for ( col = 0; col < (crop->dx); col=col+2 )
    {
      if ( (i_frame_ptr != NULL) &&
           ((*(uint16*)(frameImgPtr + frame_index)) != transparentValue) ) //lint !e613
      {

        /*------------------------------------------------------------------
            Convert from RGB to YCbCr
        ------------------------------------------------------------------*/
        /* 1st pixel */
        out = *((uint16*)(frameImgPtr + frame_index)); //lint !e613
        r1 = out >> 8 ;
        g1 = (out >> 3) & 0xff ;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index)) = 
          ipl2_rgb565ToCbR[r1] + ipl2_rgb565ToCbG[g1] + ipl2_rgb565ToCbB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 1)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];

        /* 2nd pixel */
        out = *((uint16*)(frameImgPtr + frame_index + 2)); //lint !e613
        r1 = out >> 8;
        g1 = (out >> 3) & 0xff;
        b1 = out & 0xff;
        *((uint8*)((uint32)outputImgPtr + dest_index + 2)) = 
          ipl2_rgb565ToCrR[r1] + ipl2_rgb565ToCrG[g1] + ipl2_rgb565ToCrB[b1];
        *((uint8*)((uint32)outputImgPtr + dest_index + 3)) = 
          ipl2_rgb565ToYR[r1] + ipl2_rgb565ToYG[g1] + ipl2_rgb565ToYB[b1];
      }
      else
      {

        /*------------------------------------------------------------------
            Cb pair
        ------------------------------------------------------------------*/
        cbb = *((uint8*)(inputImgPtr + src_index));
        cbb2 = *((uint8*)(inputImgPtr + src_index + 2));

        /*------------------------------------------------------------------
            Luma
        ------------------------------------------------------------------*/
        lumaa1 = *((uint8*)(inputImgPtr + src_index+1));

        /*------------------------------------------------------------------
            Next up is Cr
        ------------------------------------------------------------------*/
        crr = *((uint8*)(inputImgPtr +
                         src_index+ (colInc << 1))); //lint !e703
        crr2 = *((uint8*)(inputImgPtr +
                          src_index+(colInc << 1) + 2)); //lint !e703
        /*------------------------------------------------------------------
            Luma of second pixel
        ------------------------------------------------------------------*/
        lumaa2 = *((uint8*)(inputImgPtr + src_index+
                            (colInc << 1)+1)); //lint !e703

        if ( row%2 )
        {
          cbb = cbb2;
        }
        else
        {
          crr = crr2;
        }
        *((uint8*)(outputImgPtr + dest_index)) = (uint8) cbb;
        *((uint8*)(outputImgPtr + dest_index + 1)) = (uint8) lumaa1;
        *((uint8*)(outputImgPtr + dest_index + 2)) = (uint8) crr;
        *((uint8*)(outputImgPtr + dest_index + 3)) = (uint8) lumaa2;

      }
      src_index += (colInc<<2); //lint !e703
      dest_index += 4;
      frame_index += 4;

    } /* End of col loop */

    src_index = src_index +
        (rowInc<<1) - (colInc<<1);  //lint !e703
    dest_index = dest_index +
      ( (o_img_ptr->dx - crop->dx) << 1); //lint !e703
    frame_index += frameIncr;

  } /* End of row loop */

  return (IPL_SUCCESS);

}


/*==========================================================================

                        IPL2_CONVERT_YCBCR420TORGB444.C

DESCRIPTION

  This file handles all the specialised routines for YCbCr420 to RGB444
  conversion. These are mainly routines which has framing on top of the
  input frame. There is parellels all this routines in the RGB565.


EXTERNALIZED FUNCTIONS

  ipl2_Rot000Frame_YCbCr420ToRGB444()

      Handles color conversion in combination with framing and O/P being
      RGB444. This function is an exact parellel to the function
      ipl2_Rot000Frame_YCbCr420ToRGB565 defined in the file
      ipl2_YCbCr420.c

  ipl2_Rot090Frame_YCbCr420ToRGB444()

      Handles color convertion rotation cropping and framing of a YCbCr420
      based image. The output is RGB444 image. The degree of rotation is
      90 degree clockwise.

  ipl2_Rot180Frame_YCbCr420ToRGB444()

      Handles color convertion rotation cropping and framing of a YCbCr420
      based image. The output is RGB444 image. The degree of rotation is
      180 degree clockwise.

  ipl2_Rot270Frame_YCbCr420ToRGB444()

      Handles color convertion rotation cropping and framing of a YCbCr420
      based image. The output is RGB444 image. The degree of rotation is
      180 degree clockwise.


INITIALIZATION AND SEQUENCING REQUIREMENTS

  The library will function properly only if the ipl2_init()
  function is called before calling anything else.

Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.

=========================================================================*/

/*=========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     --------------------------------------------------------
05/24/04   srk     Linted
05/15/04   srk     Initially created.
========================================================================= */

/*===========================================================================

                          FUNCTION DEFINITIONS

===========================================================================*/
/*==========================================================================

FUNCTION    IPL2_CONVERTCROPANDFRAME_YCBCR420TORGB444()

DESCRIPTION
  This function will handle cropping, framing color converting of
  YCbCr420 based images to different RGB444 format.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr        Points to the input image
  crop                 Cropping parameter
  i_frame_ptr,        Points to the frame image. This in conjunction
                      with transparent val will determine the overlay
  transparentValue    the transparent value for framing. If the
                      frame pixel does not match this value it and the follo
                      -ing is copied to the O/P image

ARGUMENTS OUT
  output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/

static ipl_status_type ipl2_Rot000Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the input frame        */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  register unsigned char* inputImgPtr= i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register uint32 input_row_size = i_img_ptr->dx;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 dest_index, destInc, frame_inc;
  uint32 rowInc=0;
  uint32 fr_row_size = i_frame_ptr->dx;
  uint32 row, col, cr_offset ;

  MSG_LOW("inside ipl2_Rot000Frame_YCbCr420ToRGB444\n");

  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 1 /* * 2 */;

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 444 packing table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r444[0]);
  gTable = &(ipl2_g444[0] );
  bTable = &(ipl2_b444[0] );

  /*------------------------------------------------------------------
    Offset into O/P for relocation in Y.
  ------------------------------------------------------------------*/
  outputImgPtr = (uint16 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

            i_img->dx
      <--------------------------------->
      _________________________________
      |_______________________|________|---------> rowInc = delta in dx
      |                       |        |
      |                       |        |
      |                       |        |
      |_______________________|________|
       <---------------------->
          crop->dx
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
            Y values                               Cb Vals      Cr Vals
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
           ( i_img_ptr->dx * i_img_ptr->dy  );

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;


  /*------------------------------------------------------------------------
      Calculate the frame increment after each row completeion
  ------------------------------------------------------------------------*/
    frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
                 i_frame_ptr->dx;      /* to account for a row advanced */

  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *outputImgPtr = (uint16) out2;

        /*------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *(outputImgPtr + 1) = (uint16) out2;

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + fr_row_size) )
             != transparentValue )
        {

          /*----------------------------------------------------------------
            The input pixels in the frame is always assumed RGB565 encoded.
            So any other color format will have to get color converted ver-
            sion of the frame pixels. This is not needed if it is a RGB565
            output
          ----------------------------------------------------------------*/
          /* copy the pixel as well */
          out =  *( (uint16 *) frameImgPtr + fr_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = ipl2_r444[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += ipl2_g444[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += ipl2_b444[r];
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
            color covert the second pixel
          ----------------------------------------------------------------*/
          out = * ( (uint16 *) (frameImgPtr + fr_row_size + 1) );
          r = (unsigned char)((out&0xF800)>>8);
          out2 = ipl2_r444[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += ipl2_g444[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += ipl2_b444[r];
          *( outputImgPtr++ + rowSize) = (uint16) out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr += 2;


          /*----------------------------------------------------------------
              Advance the cb ptr for the next pixel
          ----------------------------------------------------------------*/
          cb_ptr++;
        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cb is for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr);

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr++ + cr_offset);


          /*----------------------------------------------------------------
              Next up is Lumaa1

              Y  |  Y
              Y  |  Y
              |
              |This is out Lumaa1
          ----------------------------------------------------------------*/
          lumaa1 = * ( inputImgPtr +  input_row_size);

          /*----------------------------------------------------------------
              Extract Lumaa2
              Y | Y

              Y | Y
                  |
                  | This is our Lumaa2

          ----------------------------------------------------------------*/
          lumaa2 = * ( (uint8 *) inputImgPtr + input_row_size + 1);

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr += 2;


        }


        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + fr_row_size) )
                != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs               Frame pairs

          The logic here is as follows
            We know that F3 != transparentValue
                So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

          Copy remaining ie : O3 = F3 and O4  = F4

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Cb is for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr);

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr++ + cr_offset);


        /*------------------------------------------------------------------
            Next up is Lumaa1

            |
            |This is the Lumaa1
            |
            Y  |  Y
            Y  |  Y

        ------------------------------------------------------------------*/
        lumaa1 = * ( inputImgPtr++);

        /*------------------------------------------------------------------
            Extract Lumaa2

            Y | Y ------Lumaa2

            Y | Y
        ------------------------------------------------------------------*/
        lumaa2 = * ( (uint8 *) inputImgPtr++);

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                      out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;

         /*-----------------------------------------------------------------
            The input pixels in the frame is always assumed RGB565 encoded.
            So any other color format will have to get color converted ver-
            sion of the frame pixels. This is not needed if it is a RGB565
            output
        ------------------------------------------------------------------*/

        out = * ( (uint16*)( frameImgPtr++ + fr_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *( outputImgPtr++ + rowSize ) = (uint16) out2;

        /*------------------------------------------------------------------
          color convert the second pixel to RGB444
        ------------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + fr_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *( outputImgPtr++ + rowSize ) = (uint16) out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        If we got here that means we need to offset Frame and process the
        conversion of the whole pixels
      --------------------------------------------------------------------*/
      frameImgPtr += 2;


      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y1|Y2|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y3|Y4|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *(inputImgPtr + 1);  /* corresponds to Y2 in the pic */

      /*--------------------------------------------------------------------
            Following line gets you Y3 and then base increments on
            inputImgPtr .. Hopefully
      --------------------------------------------------------------------*/
      lumaa3 = *(inputImgPtr++ + input_row_size);
      lumaa4 = *( inputImgPtr++ + input_row_size);

      /*--------------------------------------------------------------------
          Cb is for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we offset cb_ptr.
          If you look at the pics you can see that they both move in
          tandem
      --------------------------------------------------------------------*/
      ++cb_ptr;


      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                                  (out)
          Y | Y           (this macro     RGB444/565 | RGB444/565
                   + CB/CR ----------->
          Y | Y                           RGB444/565 | RGB444/565
                                                   (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );



      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;

    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 2 /4 --> rowSize /2
        which is same as rowSize >> 1;
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1)  + destInc ) ;

    inputImgPtr += (uint32) ( rowInc + input_row_size);

    /*----------------------------------------------------------------------
      We need to keep the frame in Tandem as well
      frameImgPtr is a uint16 ptr so *2 is built in in the following
      instruction
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc;

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cb_ptr += (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot000Frame_YCbCr420ToRGB444 */



/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT90_YCBC420TORGB444

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 90 degree. This function supports overlay
  of a frame also.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot090Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{

  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc = 0, destInc, cr_offset, src_index, frame_inc;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot090Frame_YCbCr420ToRGB444\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
    IPL2_MSG_HIGH( "convertCropRot090Frame_YCbCr420ToRGB444 proceeding with /\
                 less than perfect crop setting /\
                 crop->dy = %lu, /\
                 i_img_ptr->dy = %lu", crop->dy,
                 i_img_ptr->dy);
    IPL2_MSG_HIGH( "convertCropRot090Frame_YCbCr420ToRGB444 proceeding with /\
             less than perfect crop setting /\
             crop->dx = %lu, /\
             i_img_ptr->dy = %lu", crop->dy,
             i_img_ptr->dy);

  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( ( i_img_ptr->dy < crop->dx ) ||
    (i_frame_ptr->dx < crop->dx) ||  (i_frame_ptr->dy < crop->dy) )

  {
    /*----------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 444 packing table
  ------------------------------------------------------------------------*/
  rTable = &( ipl2_r444[0] );
  gTable = &( ipl2_g444[0] );
  bTable = &( ipl2_b444[0] );

  /*------------------------------------------------------------------------
    90 degree rotation needs starting the image from the same side  corner
    where the image starts and wroking upwards. Same with a 2 col offset
    and so on.

     inputImgPtr
     |
     |
     ^__________________________
     |                         |
   ^ |                         |
   | |                         |
   | |                         |
   | |_________________________|
     ^
     | ----> Go this way for rows
     |
   Offset it into the array to start
   picking Y values from here backwards on the same col
   as shown in the arrow leftside

   When offsetted by src_index ( = end of frame - row size )
      the inputImgPtr takes us to this location.
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx * ( i_img_ptr->dy - 1);

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      rowInc is slightly misleading. we are talking wrt output vector
      lets say. I am subtracting no of cols in o/p from no of rows
      in input. All because of 90 degree rotation. We go 2 row at a time.
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dy - crop->dx );

  frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
               i_frame_ptr->dx;         /* to account for a row advanced */

  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector. So to offset
        correctly into CR plane we need subtract one more row from
        src_index which accounts for (src_index - i_img_ptr->dx) in the
        following calculation.
        _____________________________________________
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |------> Cb/Cr plane offset row before last  |
        |____________________________________________|
        ^
        |
        |
       Y plane offset
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
                   ( i_img_ptr->dx * i_img_ptr->dy  ) +
                   ( (src_index - i_img_ptr->dx)  >> 2);

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 444
        -----==-----------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *outputImgPtr = (uint16) out2;

       /*-------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *(outputImgPtr + 1) = (uint16) out2;

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
              != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
              We are atuoincrementing frame because we are done with
              the current frame poistion
          ----------------------------------------------------------------*/

          /*---------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize )  = (uint16) out2;

         /*-----------------------------------------------------------------
              color convert and copy the next pixel
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size + 1);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = (uint16) out2;


          /*----------------------------------------------------------------
            Adjust the row position in Y plane for the next iteration
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size << 1 /* mulitiply by  2 */;

          /*----------------------------------------------------------------
                 We need to decrease the cb by row size /2 to get the next 4
                 pixel cb/cr pair
           ---------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1 /* divide by 2  */;


        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr );

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr + cr_offset);

          /*----------------------------------------------------------------
              Offset the cb for next iteration
          ----------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1;

          lumaa1 = *( inputImgPtr + 1 );

          /*----------------------------------------------------------------
                Go back by one row
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size;
          lumaa2 = *( inputImgPtr + 1 );

          /*----------------------------------------------------------------
                Go back by one row so that next iteration works perfect
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size;




          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);


          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;
        }

        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
        != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
        O3 | O4              I3 | I4    F3   |  F4
        o/p 2 pairs               Frame pairs

        The logic here is as follows
          We know that F3 != transparentValue
              So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

        Copy remaining ie : O3 = F3 and O4  = F4

      --------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Take Luma of all four pixels. The Lumma Packing is as shown
            below

            |Y2|Y4|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y1|Y3|

            As we can see above this small 2 by 2 vector already 90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry.
        ------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go back by one row
        ------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;
        lumaa2 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go back by one row so that next iteration works perfect
        ------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;


        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr );

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr + cr_offset);

        /*------------------------------------------------------------------
              We need to decrease the cb by row size /2 to get the next 4
              pixel cb/cr pair
        ------------------------------------------------------------------*/
        cb_ptr -= input_row_size >> 1;



        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/

        /*---------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 444
        ----------------------------------------------------------------*/
        out =  * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize )  = (uint16) out2;

       /*-----------------------------------------------------------------
            color convert and copy the next pixel
        ----------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = (uint16) out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;


      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y2|Y4|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y1|Y3|

          As we can see above this small 2 by 2 vector already 90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr -= input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        By doing this we are getting Yn + 7 which will be lumaa1 for
        our first pixel of our next iteration. Last +2 takes us from
        Yn+2 to Yn+7

        src_index +  input_row_size + 2 -
                   (rowInc * input_row_size) -  accounts for rows not
                                                rendered for cropping
    ----------------------------------------------------------------------*/
    inputImgPtr += src_index /* take to the earlier start */ +
                   2 /* advnce to next */ -
            ( ( (rowInc - 1) * input_row_size ) );/* account for cropping */

    cb_ptr += ((src_index + input_row_size) >> 2) + 1 -
              ( ( rowInc * input_row_size ) >> 2 );

    /*----------------------------------------------------------------------
        Update the frame ptr
    ----------------------------------------------------------------------*/

    frameImgPtr += frame_inc;
  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot090Frame_YCbCr420ToRGB444 */

/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT180_YCBC420TORGB444

DESCRIPTION
  This function rotates crops Frames and color convert a YUV420 based
  frame into RGB444 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/

static ipl_status_type ipl2_Rot180Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{

  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0, dest_index, destInc, cb_offset;
  uint32 row, col;

  MSG_LOW("inside ipl2_Rot180Frame_YCbCr420ToRGB444\n");

  /*------------------------------------------------------------------------
      180 degree rotation needs starting the image from the extreme corner
      so lets add the whole frame size into the input image ptr and then
      starts decrementing rows

      inputImgPtr
      |
      |
      ^__________________________
      |                         |
      |                         |
      |                         |
      |                         |
      |_______________________|_|
                              |
                              |
                               Offset it into the array to start
                               picking Y values from here backwards
  ------------------------------------------------------------------------*/
  inputImgPtr += i_img_ptr->dx * i_img_ptr->dy  - 1;


  /*------------------------------------------------------------------------
     In the output RGB565/444 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 1 /* * 2 */;

  /*--------------------------------------------------------------------
        initialize the conversion with RGB 444 packing table
  --------------------------------------------------------------------*/
  rTable = &(ipl2_r444[0]);
  gTable = &(ipl2_g444[0] );
  bTable = &(ipl2_b444[0] );


  outputImgPtr = (uint16 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 2 bytes per pixel for RGB565/444
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 2;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

                    crop->dx
              <---------------------->

      cropped area
      delta  in dx
      ______|___________________________
      |________| ______________________|
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |________|_______________________|
      <-------------------------------->
            input_img->dx
      We are going backwards thats why this is decerementing
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          cr_ptr with respect to  YCbCr420 packing

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals    Cr Vals       |
                                                                           |
                                                                           ^
                                                                      cr_ptr
                                                                     is here
  ------------------------------------------------------------------------*/
  cr_ptr = i_img_ptr->imgPtr +
         ( i_img_ptr->dx * i_img_ptr->dy  ) /* y array */ +
       (  ( i_img_ptr->dx * i_img_ptr->dy  ) >> 1 )/* cb array * 2 */
        - 1 /* to fetch the last element */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cb_offset =  (i_img_ptr->dx * i_img_ptr->dy  ) >> 2;


  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/
                /*------------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 444
        -----==-----------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *outputImgPtr = (uint16) out2;

       /*-------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + input_row_size) )
                                                     != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
          ----------------------------------------------------------------*/


          /*---------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize )  = (uint16) out2;

         /*-----------------------------------------------------------------
              color convert and copy the next pixel
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size + 1);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr -= 2;


          /*----------------------------------------------------------------
           Move on to next cr value
          ----------------------------------------------------------------*/
          cr_ptr--;
        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cr = *(cr_ptr);

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cb = *(cr_ptr-- - cb_offset);


          /*----------------------------------------------------------------
              Next up is Lumaa1

              Y  |  Y ------------------ this is lumaa1
              Y  |  Y


          ----------------------------------------------------------------*/
          lumaa1 = * ( inputImgPtr -  input_row_size);

          /*----------------------------------------------------------------
                                      _________
                                     |        |
          This is our Lumaa2-------------     |
                                     |   Y1 | Y2
                                     |__ Y2 | Y4

          ----------------------------------------------------------------*/
          lumaa2 = * ( (uint8 *) inputImgPtr - input_row_size - 1 );

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                             out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr -= 2;


        }


        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
                                                      != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs               Frame pairs

          The logic here is as follows
            We know that F3 != transparentValue
                So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

          Copy remaining ie : O3 = F3 and O4  = F4

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cr = *(cr_ptr);

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cb = *(cr_ptr-- - cb_offset);


        /*------------------------------------------------------------------
            Next up is Lumaa1

            |
            |This is the Lumaa1
            |
            Y  |  Y
            Y  |  Y

        ------------------------------------------------------------------*/
        lumaa1 = * ( inputImgPtr--);

        /*------------------------------------------------------------------
            Extract Lumaa2

            Y | Y ------Lumaa2

            Y | Y
        ------------------------------------------------------------------*/
        lumaa2 = * ( (uint8 *) inputImgPtr--);

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                            out2,  rTable, gTable, bTable);

        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
            Copy Over the Frame and convert from 565 to 444
        ----------------------------------------------------------------*/
        out =  * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize )  = (uint16) out2;

       /*-----------------------------------------------------------------
            color convert and copy the next pixel
        ----------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = (uint16) out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
          We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y4|Y3|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y2|Y1|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *( inputImgPtr - 1);  /* corresponds to Y2 in the pic */
      lumaa3 = *(inputImgPtr-- - input_row_size);
      lumaa4 = *(inputImgPtr-- - input_row_size);

      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cr = *(cr_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cb = *(cr_ptr - cb_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we decrement cr_ptr.
          If you look at the pics you can see that they both (cb anc cr)
          move in tandem
      --------------------------------------------------------------------*/
      --cr_ptr;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;
    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 2 /4 --> rowSize /2
        which is same as rowSize >> 1;
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1)  + destInc ) ;

    /*----------------------------------------------------------------------
      |<------- input_row_size  ----->|
      _______________________________
      |                              |
      |                              |
      |                              |
      |                              |
      |_____________________________X|-------> Where this operation
      |______________________________|         will take us
      |________|_____________________|
               |
               |
               ^
               inputImgPtr
     |-- rowInc-|
    ----------------------------------------------------------------------*/
    inputImgPtr -= (uint32) (rowInc + input_row_size);

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cr_ptr -= (rowInc) >> 1 /* divided by 2 */;

    /*----------------------------------------------------------------------
      We need to keep the frame in Tandem as well
      frameImgPtr is a uint16 ptr so *2 is built in in the following
      instruction
    ----------------------------------------------------------------------*/
    frameImgPtr += (input_row_size + rowInc) ;


  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot180Frame_YCbCr420ToRGB444 */

/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT270_YCBC420TORGB444

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444 format. Since RGB666 has a differtent packing
  altogether this function calls another helper function in that case.
  The degree of rotation is 270 degree.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot270Frame_YCbCr420ToRGB444
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint16* outputImgPtr =(uint16 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint16 *rTable;
  register const uint16 *gTable;
  register const uint16 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 destInc, cr_offset, src_index, cb_offset, frame_inc;
  uint32 row, col;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot270Frame_YCbCr420ToRGB444\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
       IPL2_MSG_HIGH( "convertCropRot090Frame_YCbCr420ToRGB444 proceeding with /\
                 less than perfect crop setting /\
                 crop->dy = %lu, /\
                 i_img_ptr->dy = %lu", crop->dy,
                 i_img_ptr->dy);

      IPL2_MSG_HIGH( "convertCropRot090Frame_YCbCr420ToRGB444 proceeding with /\
               less than perfect crop setting /\
               crop->dx = %lu, /\
               i_img_ptr->dy = %lu", crop->dy,
               i_img_ptr->dy);
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( i_img_ptr->dy < crop->dx )
  {
    /*----------------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( ( i_img_ptr->dy < crop->dx ) ||
    (i_frame_ptr->dx < crop->dx) ||  (i_frame_ptr->dy < crop->dy) )

  {
    /*----------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*--------------------------------------------------------------------
        initialize the conversion with RGB 565 packing table
  --------------------------------------------------------------------*/
  rTable = &( ipl2_r444[0] );
  gTable = &( ipl2_g444[0] );
  bTable = &( ipl2_b444[0] );


  /*------------------------------------------------------------------------
    270 degree rotation needs starting the image from the same side right
    corner from where the image starts and wroking downwards.
    - with a 2 col offset and so on.

      inputImgPtr
     |
     |
     ^__________________________
     |                         |  |
     |                         |  |
     |                         |  |
     |                         |  v  col increment
     |_________________________|
        <-----------------------
         row increment
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx;

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index - 1;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 2;


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector.
        _____________________________________________
        |                                  <--------||
        |                               Yplane/Cb    |
        |                               offset start |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |____________________________________________|

  ------------------------------------------------------------------------*/
  cb_offset = ( i_img_ptr->dx * i_img_ptr->dy  );
  cb_ptr = i_img_ptr->imgPtr +
                    + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;


  frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
                i_frame_ptr->dx;   /* to account for a row advanced */


  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

         /*------------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *outputImgPtr = (uint16) out2;

        /*------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = ipl2_r444[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += ipl2_g444[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += ipl2_b444[r];
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
          != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
              We are atuoincrementing frame because we are done with
              the current frame poistion
          ----------------------------------------------------------------*/

                    /*---------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 444
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize )  = (uint16) out2;

         /*-----------------------------------------------------------------
              color convert and copy the next pixel
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size + 1);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = (uint16) out2;

          /*----------------------------------------------------------------
            Adjust the row position in Y plane for the next iteration
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size << 1 /* mulitiply by  2 */;

          /*----------------------------------------------------------------
                 We need to increase the cb by row size /2 to get the next 4
                 pixel cb/cr pair
           ---------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1 /* divide by 2  */;


        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
            Take Luma of all four pixels. Luma Extracion we do on the
            following lines of code assumes the following figure. Just by
            assuming the following geometry we get the 270 degree rotatin.
            You can see the tiny square changed to 90  degree
            anticlockwise now (  same 270 ).

            |Y3|Y1|             (this processing)   |I1|I2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y4|Y2|

            As we can see above this small 2 by 2 vector already -90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry. I1 and I2 represen
           ---------------------------------------------------------------*/
          lumaa1 = *( inputImgPtr - 1 );

          /*----------------------------------------------------------------
                Go forward by one row
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size;
          lumaa2 = *( inputImgPtr - 1 );

          /*------------------------------------------------------------------
                Go back by one row so that next iteration works perfect
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size;


          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr );

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr + cr_offset);

          /*----------------------------------------------------------------
                We need to decrease the cb by row size /2 to get the next 4
                pixel cb/cr pair
          ----------------------------------------------------------------*/
          cb_ptr += input_row_size >> 1;



          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);

          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/


          *( outputImgPtr++ + rowSize ) = (uint16) out;
          *( outputImgPtr++ + rowSize ) = (uint16) out2;
        }

        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
        != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
        O3 | O4              I3 | I4    F3   |  F4
        o/p 2 pairs               Frame pairs

        The logic here is as follows
          We know that F3 != transparentValue
              So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

        Copy remaining ie : O3 = F3 and O4  = F4

      --------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Take Luma of all four pixels. Luma Extracion we do on the
            following lines of code assumes the following figure. Just by
            assuming the following geometry we get the 270 degree rotatin.
            You can see the tiny square changed to 90  degree
            anticlockwise now (  same 270 ).

            |Y3|Y1|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |F3  |F4|
            |Y4|Y2|

            As we can see above this small 2 by 2 vector already -90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry. F3 and F4 are frame pixels on the corresponding
            positions
        ------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );

        inputImgPtr += input_row_size;
        lumaa2 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go forward by one row so that next iteration works perfect
        ------------------------------------------------------------------*/
        inputImgPtr += input_row_size;


        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr );

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr + cr_offset);

        /*------------------------------------------------------------------
              We need to increase the cb by row size /2 to get the next 4
              pixel cb/cr pair
        ------------------------------------------------------------------*/
        cb_ptr += input_row_size >> 1;

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = (uint16) out;
        *(outputImgPtr + 1) = (uint16) out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 444
        ------------------------------------------------------------------*/
        out =  * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize )  = (uint16) out2;

       /*-------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = (uint16) out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. Luma Extracion we do on the
          following lines of code assumes the following figure. Just by
          assuming the following geometry we get the 270 degree rotatin.
          You can see the tiny square changed to 90  degree
          anticlockwise now (  same 270 ).

          |Y3|Y1|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y4|Y2|

          As we can see above this small 2 by 2 vector already -90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr += input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 out3 and out4
          in four half words.
                                              (out)
          Y | Y                       RGB444/565 | RGB444/565
                   + CB/CR ----->
          Y | Y                       RGB444/565 | RGB444/565
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = (uint16) out;
      *(outputImgPtr + 1) = (uint16) out2;
      *(outputImgPtr++ + rowSize) = (uint16) out3;
      *(outputImgPtr++ + rowSize) = (uint16) out4;

    } /* end of col loop */

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 2 /4 --> rowSize /2
         which is same as rowSize >> 1; destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint16 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 1) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        If we started our first iteration on Yn + 5 doing this we
        are getting Yn + 1.

      Since we are always on the first row offsetted by two than the
      previous one.
    ----------------------------------------------------------------------*/
    src_index -= 2;
    inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;

    cb_ptr = i_img_ptr->imgPtr + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

    /*----------------------------------------------------------------------
        Update the frame ptr
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc;


  } /* end of row loop */

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot270Frame_YCbCr420ToRGB444 */
/*==========================================================================

                        IPL2_CONVERT_YCBCR420TORGB666.C

DESCRIPTION

  This file handles all the specialised routines for YCbCr420 to RGB666
  conversion. These are mainly routines which has framing on top of the
  input frame. There is parellels all this routines in the RGB565.


EXTERNALIZED FUNCTIONS

  ipl2_YCbCr420ToRGB666

    Handles color conversion and cropping of a YCbCr420 encoded image to
    RGB666 format.

  ipl2_Rot000Frame_YCbCr420ToRGB666()

      Handles color conversion in combination with framing and O/P being
      RGB444. This function is an exact parellel to the function
      ipl2_Rot000Frame_YCbCr420ToRGB565 defined in the file
      ipl2_YCbCr420.c

  ipl2_Rot090_YCbCr420ToRGB666()

      Color convert rotate and crop a YUV420 buffer to RGB666. The anlge of
      rotation is 90 degree.

  ipl2_Rot090Frame_YCbCr420ToRGB666()

      Handles color convertion rotation cropping and framing of a YCbCr420
      based image. The output is RGB666 image. The degree of rotation is
      90 degree clockwise.

  ipl2_Rot180_YCbCr420ToRGB666()

      Color convert rotate and crop a YUV420 buffer to RGB666. The anlge of
      rotation is 180 degree.


  ipl2_Rot180Frame_YCbCr420ToRGB666()

      Handles color convertion rotation cropping and framing of a YCbCr420
      based image. The output is RGB666 image. The degree of rotation is
      180 degree clockwise.

  ipl2_Rot270_YCbCr420ToRGB666()

      Color convert rotate and crop a YUV420 buffer to RGB666. The anlge of
      rotation is 270 degree.

  ipl2_Rot270Frame_YCbCr420ToRGB666()

      Handles color convertion rotation cropping and framing of a YCbCr420
      based image. The output is RGB666 image. The degree of rotation is
      180 degree clockwise.


INITIALIZATION AND SEQUENCING REQUIREMENTS

  The library will function properly only if the ipl2_init()
  function is called before calling anything else.

Copyright (c) 2008 Qualcomm Technologies, Inc.
All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.

=========================================================================*/

/*=========================================================================

                      EDIT HISTORY FOR FILE

This section contains comments describing changes made to this file.
Notice that changes are listed in reverse chronological order.

$Header: //depot/asic/sandbox/users/ninadp/android/mm-camera/qcamera/ipl/ipl_rotAddCrop.c#1 $

when       who     what, where, why
--------   ---     --------------------------------------------------------
05/17/04   srk     Initially created.
========================================================================= */


 /* end of function ipl2_handle_YCbCr420Img */

/*==========================================================================

FUNCTION    IPL2_CONVERTANDCROP_YCBCR420TORGB666

DESCRIPTION
  This function will handle cropping, color converting of
  YCbCr420 based images to RGB666. This function is more
  optimalif you are not cropping . This function is specifically designed
  for the favorable input condition where - there is no framing going on. So
  transparent value check is not needed. This function calls for help when
  the output is RGB666 .This because translation very different and output
  is32 bit value.

DEPENDENCIES
  None

ARGUMENTS IN
  ipl_image_type* input_img_ptr        Points to the input image
  ipl_rect_type* crop                  Cropping parameter

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/
static ipl_status_type ipl2_YCbCr420ToRGB666
(
  ipl_image_type* input_img_ptr,        /* Points to the input image    */
  ipl_image_type* output_img_ptr,       /* Points to the output image   */
  ipl_rect_type* crop                   /* Crop config                  */
)
{
  register unsigned char* inputImgPtr=input_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) output_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  uint32 input_row_size = input_img_ptr->dx;
  uint32 rowSize = output_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc=0,dest_index,destInc;
  uint32 row, col, cr_offset;

  MSG_LOW("inside ipl2_YCbCr420ToRGB666\n");

  /*------------------------------------------------------------------------
     In the output RGB666 array each pixel is 2 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + output_img_ptr->dx * crop->y) << 2 /* X 4 */;

  /*------------------------------------------------------------------------
    initialize the conversion with RGB666 table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );

  outputImgPtr = (uint32 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------
      Destination should increment 4 bytes per pixel for RGB666
      encoding.
  ------------------------------------------------------------------*/
  destInc = ( output_img_ptr->dx - crop->dx) * 4;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

            input_img->dx
      <--------------------------------->
      _________________________________
      |_______________________|________|---------> rowInc = delta in dx
      |                       |        |
      |                       |        |
      |                       |        |
      |_______________________|________|
       <---------------------->
          crop->dx
  ------------------------------------------------------------------------*/
  rowInc = (input_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                     Cb Vals    Cr Vals
  ------------------------------------------------------------------------*/
  cb_ptr = input_img_ptr->imgPtr +
           ( input_img_ptr->dx * input_img_ptr->dy  );

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( input_img_ptr->dx * input_img_ptr->dy  ) >> 2 /* /4 */;


  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y1|Y2|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y3|Y4|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *(inputImgPtr + 1);  /* corresponds to Y2 in the pic */

      /*--------------------------------------------------------------------
            Following line gets you Y3 and then base increments on
            inputImgPtr .. Hopefully
      --------------------------------------------------------------------*/
      lumaa3 = *(inputImgPtr++ + input_row_size);
      lumaa4 = *( inputImgPtr++ + input_row_size);

      /*--------------------------------------------------------------------
          Cb is for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we offset cb_ptr.
          If you look at the pics you can see that they both move in
          tandem
      --------------------------------------------------------------------*/
      ++cb_ptr;


      /*--------------------------------------------------------------------
        Take the delta from third to fourth. This is for faster
        computation as you see later. We are doing this in the reverse order
        because we will loose the original delta if do in the forward
        order
      --------------------------------------------------------------------*/
      lumaa4 -= lumaa3;

      /*--------------------------------------------------------------------
        Take the delta from second to third. This is for faster
        computation as you see later
      --------------------------------------------------------------------*/
      lumaa3 -= lumaa2;

      /*--------------------------------------------------------------------
        Take the delta from first to second. This is for faster
        computation as you see later
      --------------------------------------------------------------------*/
      lumaa2 -= lumaa1;


      /*--------------------------------------------------------------------
        Each of these comparisons add and compares are designed to force
        the compiler to do conditional execution
      --------------------------------------------------------------------*/
      r = lumaa1 + ipl2_CrToRTable[cr];
      /*--------------------------------------------------------------------
          If  r is -ve reinitialize out = 0 and start adding stuff as
          you need it. No need for an extra check for the second pixel
      --------------------------------------------------------------------*/
      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out = rTable[ r ];
      }
      else
      {
        out = 0;
      }

      /*--------------------------------------------------------------------
          Add the delta in Luma2 to calculate the next R value
      --------------------------------------------------------------------*/
      r += lumaa2;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out2 = rTable[ r ];
      }
      else
      {
        out2 = 0;
      }

      /*--------------------------------------------------------------------
          Add the delta b/w in 2 and 3 Luma
      --------------------------------------------------------------------*/
      r += lumaa3;



      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out3 = rTable[ r ];
      }
      else
      {
        out3 = 0;
      }

      /*--------------------------------------------------------------------
          Add the delta b/w 3 and 4 in Luma to get next R4
      --------------------------------------------------------------------*/
      r += lumaa4;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out4 = rTable[ r ];
      }
      else
      {
        out4 = 0;
      }



      r = lumaa1 - ipl2_CbToGTable[cb] - ipl2_CrToGTable[cr];

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out += gTable[r];
      }

      r += lumaa2;

      if (r > 255) r = 255;
      if ( r > 0 )
      {

        out2 += gTable[r];
      }

      r += lumaa3;

      if (r > 255) r = 255;
      if ( r > 0 )
      {

        out3 += gTable[r];
      }

      r += lumaa4;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out4 += gTable[r];
      }


      r = lumaa1 + ipl2_CbToBTable[cb];
      /*--------------------------------------------------------------------
         If we have -ve or zero value we dont need to do anthing as the
         translation or effect of that component on the whole pixel
         value isbound to be zero no matter what encoding RGB flavor we
         are using.
      --------------------------------------------------------------------*/
      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out += bTable[r];
      }

      r += lumaa2;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out2 += bTable[r];
      }

      r += lumaa3;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out3 += bTable[r];
      }

      r += lumaa4;

      if (r > 255) r = 255;
      if ( r > 0 )
      {
        out4 += bTable[r];
      }

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;
    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 4
        Plus the the cropping offset
    ----------------------------------------------------------------------*/

    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2)  + destInc ) ;

    inputImgPtr += (uint32) (rowInc  + input_row_size);

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cb_ptr += (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_YCbCr420ToRGB666 */


/*==========================================================================

FUNCTION    IPL2_CONVERTCROPANDFRAME_YCBCR420TORGB666()

DESCRIPTION
  This function will handle cropping, framing color converting of
  YCbCr420 based images RGB666 format.

DEPENDENCIES
  None

ARGUMENTS IN
  input_img_ptr        Points to the input image
  crop                  Cropping parameter
  i_frame_ptr,        Points to the frame image. This in conjunction
                      with transparent val will determine the overlay
  transparentValue    the transparent value for framing. If the
                      frame pixel does not match this value it and the follo
                      -ing is copied to the O/P image

ARGUMENTS OUT
  ipl_image_type* output_img_ptr       Points to the output image

RETURN VALUE
  Status

SIDE EFFECTS
  Alters the output image buffer with the cropped/converted frame.

==========================================================================*/

static ipl_status_type ipl2_Rot000Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,        /* Points to the input image        */
  ipl_image_type* i_frame_ptr,      /* Points to the input frame        */
  ipl_image_type* o_img_ptr,        /* Points to the output image       */
  ipl_rect_type* crop,              /* Crop config                      */
  uint16 transparentValue           /* Transparent pixel value          */
)
{
  register unsigned char* inputImgPtr= i_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register uint32 input_row_size = i_img_ptr->dx;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc=0,dest_index,destInc, frame_inc;
  uint32 fr_row_size = i_frame_ptr->dx;
  uint32 row, col, cr_offset ;

  MSG_LOW("inside ipl2_Rot000Frame_YCbCr420ToRGB666\n");

  /*------------------------------------------------------------------------
     In the output RGB666 array each pixel is 4 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 2 /* * 2 */;

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 666 packing table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );

  /*------------------------------------------------------------------
    Offset into O/P for relocation in Y.
  ------------------------------------------------------------------*/
  outputImgPtr = (uint32 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 4 bytes per pixel for RGB666
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 4;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

            i_img->dx
      <--------------------------------->
      _________________________________
      |_______________________|________|---------> rowInc = delta in dx
      |                       |        |
      |                       |        |
      |                       |        |
      |_______________________|________|
       <---------------------->
          crop->dx
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
            Y values                               Cb Vals      Cr Vals
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
           ( i_img_ptr->dx * i_img_ptr->dy  );

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;


  /*------------------------------------------------------------------------
      Calculate the frame increment after each row completeion
  ------------------------------------------------------------------------*/
    frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
                 i_frame_ptr->dx;      /* to account for a row advanced */

  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 666
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *outputImgPtr = out2;

        /*------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *(outputImgPtr + 1) = out2;

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + fr_row_size) )
             != transparentValue )
        {

          /*----------------------------------------------------------------
            The input pixels in the frame is always assumed RGB565 encoded.
            So any other color format will have to get color converted ver-
            sion of the frame pixels. This is not needed if it is a RGB565
            output
          ----------------------------------------------------------------*/
          /* copy the pixel as well */
          out =  *( (uint16 *) frameImgPtr + fr_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = out2;

          /*----------------------------------------------------------------
            color covert the second pixel
          ----------------------------------------------------------------*/
          out = * ( (uint16 *) (frameImgPtr + fr_row_size + 1) );
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize) = out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr += 2;

          /*----------------------------------------------------------------
            Advance cb_ptr by one
          ----------------------------------------------------------------*/
          cb_ptr++;

        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cb is for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr);

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr++ + cr_offset);


          /*----------------------------------------------------------------
              Next up is Lumaa1

              Y  |  Y
              Y  |  Y
              |
              |This is out Lumaa1
          ----------------------------------------------------------------*/
          lumaa1 = * ( inputImgPtr +  input_row_size);

          /*----------------------------------------------------------------
              Extract Lumaa2
              Y | Y

              Y | Y
                  |
                  | This is our Lumaa2

          ----------------------------------------------------------------*/
          lumaa2 = * ( (uint8 *) inputImgPtr + input_row_size + 1);

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize) = out;
          *( outputImgPtr++ + rowSize ) = out2;

          /*----------------------------------------------------------------
               Essentially our business with these 4 pixels are done
          ------------------------------------------------------------------*/
          inputImgPtr += 2;


        }
        /*------------------------------------------------------------------
            Advance the frame by 2 pixels
        ------------------------------------------------------------------*/
        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + fr_row_size) )
                != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs               Frame pairs

          The logic here is as follows
            We know that F3 != transparentValue
                So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

          Copy remaining ie : O3 = F3 and O4  = F4

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Cb is for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr);

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr++ + cr_offset);


        /*------------------------------------------------------------------
            Next up is Lumaa1

            |
            |This is the Lumaa1
            |
            Y  |  Y
            Y  |  Y

        ------------------------------------------------------------------*/
        lumaa1 = * ( inputImgPtr++);

        /*------------------------------------------------------------------
            Extract Lumaa2

            Y | Y ------Lumaa2

            Y | Y
        ------------------------------------------------------------------*/
        lumaa2 = * ( (uint8 *) inputImgPtr++);

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                      out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = out;
        *(outputImgPtr + 1) = out2;

         /*-----------------------------------------------------------------
            The input pixels in the frame is always assumed RGB565 encoded.
            So any other color format will have to get color converted ver-
            sion of the frame pixels. This is not needed if it is a RGB565
            output
        ------------------------------------------------------------------*/

        out = * ( (uint16*)( frameImgPtr++ + fr_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = out2;

        /*------------------------------------------------------------------
          color convert the second pixel to RGB666
        ------------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + fr_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        If we got here that means we need to offset Frame and process the
        conversion of the whole pixels
      --------------------------------------------------------------------*/
      frameImgPtr += 2;


      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y1|Y2|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y3|Y4|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *(inputImgPtr + 1);  /* corresponds to Y2 in the pic */

      /*--------------------------------------------------------------------
            Following line gets you Y3 and then base increments on
            inputImgPtr .. Hopefully
      --------------------------------------------------------------------*/
      lumaa3 = *(inputImgPtr++ + input_row_size);
      lumaa4 = *( inputImgPtr++ + input_row_size);

      /*--------------------------------------------------------------------
          Cb is for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we offset cb_ptr.
          If you look at the pics you can see that they both move in
          tandem
      --------------------------------------------------------------------*/
      ++cb_ptr;


      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                                  (out)
          Y | Y           (this macro     RGB666 | RGB666
                   + CB/CR ----------->
          Y | Y                           RGB666 | RGB666
                                                   (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );



      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;

    }

    /*----------------------------------------------------------------------
        Advance O/P frame by one row. Each row occupies rowSize * 4 bytes
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2)  + destInc ) ;

    /*----------------------------------------------------------------------
        We need to advance i/p by one row
    ----------------------------------------------------------------------*/
    inputImgPtr += (uint32) ( rowInc + input_row_size);

    /*----------------------------------------------------------------------
      We need to keep the frame in Tandem as well
      frameImgPtr is a uint16 ptr so *2 is built in in the following
      instruction
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc;

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cb_ptr += (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot000Frame_YCbCr420ToRGB666 */


/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT90_YCBC420TORGB666

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB666 format.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot090_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop           /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc = 0,  destInc, cr_offset, src_index;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                           crop->dy;

  MSG_LOW("inside ipl2_Rot090_YCbCr420ToRGB666\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if ( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
    /*WARN*/
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( i_img_ptr->dy < crop->dx )
  {
    /*----------------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*--------------------------------------------------------------------
        initialize the conversion with RGB 666 packing table
  --------------------------------------------------------------------*/
  rTable = &( ipl2_r666[0] );
  gTable = &( ipl2_g666[0] );
  bTable = &( ipl2_b666[0] );

  /*------------------------------------------------------------------------
    90 degree rotation needs starting the image from the same side  corner
    where the image starts and wroking upwards. Same with a 2 col offset
    and so on.

     inputImgPtr
     |
     |
     ^__________________________
     |                         |
   ^ |                         |
   | |                         |
   | |                         |
   | |_________________________|
     ^
     | ----> Go this way for rows
     |
   Offset it into the array to start
   picking Y values from here backwards on the same col
   as shown in the arrow leftside

   When offsetted by src_index ( = end of frame - row size )
      the inputImgPtr takes us to this location.
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx * ( i_img_ptr->dy - 1);

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index;

  /*------------------------------------------------------------------------
       We need to subtract cropped colomn size. Addition here is byte
       addressed. For RGB666 packing we need 4 bytes per pixel
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) *  4;

  /*------------------------------------------------------------------------
      rowInc is slightly misleading. we are talking wrt output vector
      lets say. I am subtracting no of cols in o/p from no of rows
      in input. All because of 90 degree rotation. We go 2 row at a time.
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dy - crop->dx );

  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector. So to offset
        correctly into CR plane we need subtract one more row from
        src_index which accounts for (src_index - i_img_ptr->dx) in the
        following calculation.
        _____________________________________________
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |------> Cb/Cr plane offset row before last  |
        |____________________________________________|
        ^
        |
        |
       Y plane offset
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
           ( i_img_ptr->dx * i_img_ptr->dy  ) +
           ( (src_index - i_img_ptr->dx)  >> 2);

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation;  word addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y2|Y4|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y1|Y3|

          As we can see above this small 2 by 2 vector already 90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr -= input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB666 | RGB666
                   + CB/CR ----->
          Y | Y                       RGB666 | RGB666
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;
    }

    /*----------------------------------------------------------------------
         The rowInc * 4 taekes us to next row. destInc accounts for the
         size mismatch b/w cropped image and output frame size
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2 ) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        By doing this we are getting Yn + 7 which will be lumaa1 for
        our first pixel of our next iteration. Last +2 takes us from
        Yn+2 to Yn+7

        src_index +  input_row_size + 2 -
                   (rowInc * input_row_size) -  accounts for rows not
                                                rendered for cropping
    ----------------------------------------------------------------------*/
    inputImgPtr += src_index /* take to the earlier start */ +
                   2 /* advnce to next */ -
                   ( ( (rowInc - 1) * input_row_size ) );/* account for cropping */

    cb_ptr += ((src_index + input_row_size) >> 2) + 1 -
              ( ( rowInc * input_row_size ) >> 2 );
  }

  return( IPL_SUCCESS );

} /* end of ipl2_Rot090_YCbCr420ToRGB666 */

/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT90_YCBC420TORGB666

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB666 format.
  The degree of rotation is 90 degree. This function supports overlay
  of a frame also.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do
  transparentValue is the 16 bit transparent pixel value


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/

static ipl_status_type ipl2_Rot090Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{

  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 rowInc = 0,  destInc, cr_offset, src_index, frame_inc;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot090Frame_YCbCr420ToRGB666\n");


  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
      /*WARN*/
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( ( i_img_ptr->dy < crop->dx ) ||
    (i_frame_ptr->dx < crop->dx) ||  (i_frame_ptr->dy < crop->dy) )

  {
    /*----------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 666 packing table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );

  /*------------------------------------------------------------------------
    90 degree rotation needs starting the image from the same side  corner
    where the image starts and wroking upwards. Same with a 2 col offset
    and so on.

     inputImgPtr
     |
     |
     ^__________________________
     |                         |
   ^ |                         |
   | |                         |
   | |                         |
   | |_________________________|
     ^
     | ----> Go this way for rows
     |
   Offset it into the array to start
   picking Y values from here backwards on the same col
   as shown in the arrow leftside

   When offsetted by src_index ( = end of frame - row size )
      the inputImgPtr takes us to this location.
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx * ( i_img_ptr->dy - 1);

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
      Every pixel is a word
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 4;

  /*------------------------------------------------------------------------
      rowInc is slightly misleading. we are talking wrt output vector
      lets say. I am subtracting no of cols in o/p from no of rows
      in input. All because of 90 degree rotation. We go 2 row at a time.
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dy - crop->dx );

  frame_inc  = (i_frame_ptr->dx - crop->dx) /* to account for crop */ +
               i_frame_ptr->dx;         /* to account for a row advanced */

  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector. So to offset
        correctly into CR plane we need subtract one more row from
        src_index which accounts for (src_index - i_img_ptr->dx) in the
        following calculation.
        _____________________________________________
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |------> Cb/Cr plane offset row before last  |
        |____________________________________________|
        ^
        |
        |
       Y plane offset
  ------------------------------------------------------------------------*/
  cb_ptr = i_img_ptr->imgPtr +
                   ( i_img_ptr->dx * i_img_ptr->dy  ) +
                   ( (src_index - i_img_ptr->dx)  >> 2);

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; word addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 666
        -----==-----------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *outputImgPtr = out2;

       /*-------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *(outputImgPtr + 1) = out2;

        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
          != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
              We are atuoincrementing frame because we are done with
              the current frame poistion
          ----------------------------------------------------------------*/

          /*---------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 666
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize )  = out2;

         /*-----------------------------------------------------------------
              color convert and copy the next pixel
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size + 1);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = out2;


          /*----------------------------------------------------------------
            Adjust the row position in Y plane for the next iteration
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size << 1 /* mulitiply by  2 */;

          /*----------------------------------------------------------------
                 We need to decrease the cb by row size /2 to get the next 4
                 pixel cb/cr pair
           ---------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1 /* divide by 2  */;


        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr );

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr + cr_offset);

          /*----------------------------------------------------------------
              Offset the cb for next iteration
          ----------------------------------------------------------------*/
          cb_ptr -= input_row_size >> 1;

          lumaa1 = *( inputImgPtr + 1 );

          /*----------------------------------------------------------------
                Go back by one row
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size;
          lumaa2 = *( inputImgPtr + 1 );

          /*----------------------------------------------------------------
                Go back by one row so that next iteration works perfect
          ----------------------------------------------------------------*/
          inputImgPtr -= input_row_size;




          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);


          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = out;
          *( outputImgPtr++ + rowSize ) = out2;
        }

        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
        != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
        O3 | O4              I3 | I4    F3   |  F4
        o/p 2 pairs               Frame pairs

        The logic here is as follows
          We know that F3 != transparentValue
              So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

        Copy remaining ie : O3 = F3 and O4  = F4

      --------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Take Luma of all four pixels. The Lumma Packing is as shown
            below

            |Y2|Y4|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y1|Y3|

            As we can see above this small 2 by 2 vector already 90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry.
        ------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go back by one row
        ------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;
        lumaa2 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go back by one row so that next iteration works perfect
        ------------------------------------------------------------------*/
        inputImgPtr -= input_row_size;


        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr );

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr + cr_offset);

        /*------------------------------------------------------------------
              We need to decrease the cb by row size /2 to get the next 4
              pixel cb/cr pair
        ------------------------------------------------------------------*/
        cb_ptr -= input_row_size >> 1;



        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = out;
        *(outputImgPtr + 1) = out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/

        /*---------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 666
        ----------------------------------------------------------------*/
        out =  * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize )  = out2;

       /*-----------------------------------------------------------------
            color convert and copy the next pixel
        ----------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;


      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y2|Y4|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y1|Y3|

          As we can see above this small 2 by 2 vector already 90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr + 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr -= input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr -= input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                              (out)
          Y | Y                       RGB666 | RGB666
                   + CB/CR ----->
          Y | Y                       RGB666 | RGB666
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;
    }

    /*----------------------------------------------------------------------
        Need to offset the already rendered following row (rowSize << 2)
        accounts for this. DestInc takes care of cropping.
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        By doing this we are getting Yn + 7 which will be lumaa1 for
        our first pixel of our next iteration. Last +2 takes us from
        Yn+2 to Yn+7

        src_index +  input_row_size + 2 -
                   (rowInc * input_row_size) -  accounts for rows not
                                                rendered for cropping
    ----------------------------------------------------------------------*/
    inputImgPtr += src_index /* take to the earlier start */ +
                   2 /* advnce to next */ -
            ( ( (rowInc - 1) * input_row_size ) );/* account for cropping */

    cb_ptr += ((src_index + input_row_size) >> 2) + 1 -
              ( ( rowInc * input_row_size ) >> 2 );

    /*----------------------------------------------------------------------
        Update the frame ptr
    ----------------------------------------------------------------------*/

    frameImgPtr += frame_inc;
  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot090Frame_YCbCr420ToRGB666 */




/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT180_YCBC420TORGB666

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB666 format.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot180_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop           /* cropping params */
)
{
  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint32 * outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0, dest_index, destInc, cb_offset;
  uint32 row, col;

  MSG_LOW("inside ipl2_Rot180_YCbCr420ToRGB666\n");


  /*------------------------------------------------------------------------
      180 degree rotation needs starting the image from the extreme corner
      so lets add the whole frame size into the input image ptr and then
      starts decrementing rows

      inputImgPtr
      |
      |
      ^__________________________
      |                         |
      |                         |
      |                         |
      |                         |
      |_______________________|_|
                              |
                              |
                               Offset it into the array to start
                               picking Y values from here backwards
  ------------------------------------------------------------------------*/
  inputImgPtr += i_img_ptr->dx * i_img_ptr->dy  - 1;



  /*------------------------------------------------------------------------
     In the output RGB666 array each pixel is 4 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 2 /* * 2 */;

  /*--------------------------------------------------------------------
        initialize the conversion with RGB 666 packing table
  --------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );

  outputImgPtr = (uint32 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 4 bytes per pixel for RGB666
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 4;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

                    crop->dx
              <---------------------->

      cropped area
      delta  in dx
      ______|___________________________
      |________| ______________________|
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |________|_______________________|
      <-------------------------------->
            input_img->dx
      We are going backwards thats why this is decerementing
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          cr_ptr with respect to  YCbCr420 packing

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals    Cr Vals       |
                                                                           |
                                                                           ^
                                                                       cr_ptr
                                                                      is here
  ------------------------------------------------------------------------*/
  cr_ptr = i_img_ptr->imgPtr +
           ( i_img_ptr->dx * i_img_ptr->dy  ) /* y array */ +
           (  ( i_img_ptr->dx * i_img_ptr->dy  ) >> 1 )/* cb array * 2 */
           - 1 /* to fetch the last element */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cb_offset =  (i_img_ptr->dx * i_img_ptr->dy  ) >> 2;


  /*------------------------------------------------------------------------
      If the crop setting is such that we do not need to adjust the output
      pointer inside the loop . We will use a more optimized loop. Also
      this loop assumes we have an even number of rows and coloumns. WHAT
      HAPPENS IF WE HAVE ODD NO OF COLS ..? IS IT ALLOWED IN THIS ENCODING ?
      QUESTION TO FOLKS
------------------------------------------------------------------------*/
  /*----------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ----------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*--------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    --------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      /*------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      ------------------------------------------------------------------*/


      /*------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y4|Y3|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y2|Y1|
      ------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *( inputImgPtr - 1);  /* corresponds to Y2 in the pic */
      lumaa3 = *(inputImgPtr-- - input_row_size);
      lumaa4 = *(inputImgPtr-- - input_row_size);

      /*------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      ------------------------------------------------------------------*/
      cr = *(cr_ptr);

      /*------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      ------------------------------------------------------------------*/
      cb = *(cr_ptr - cb_offset);

      /*------------------------------------------------------------------
          We got both CB and Cr for this iteration we decrement cr_ptr.
          If you look at the pics you can see that they both (cb anc cr)
          move in tandem
      ------------------------------------------------------------------*/
      --cr_ptr;

      /*------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 4 half words.

                                           (out)
          Y | Y                       RGB666 | RGB666
                   + CB/CR ----->
          Y | Y                       RGB666 | RGB666
                                           (out2)
      ------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;
    }

    /*--------------------------------------------------------------------
        Need to add  number of coulumns * 4
        destInc takes care of cropping
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2)  + destInc ) ;

    /*--------------------------------------------------------------------
      |<------- input_row_size  ----->|
      _______________________________
      |                              |
      |                              |
      |                              |
      |                              |
      |_____________________________X|-------> Where this operation
      |______________________________|         will take us
      |________|_____________________|
               |
               |
               ^
               inputImgPtr
     |-- rowInc-|
    --------------------------------------------------------------------*/
    inputImgPtr -= (uint32) (rowInc + input_row_size);

    /*--------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    --------------------------------------------------------------------*/
    cr_ptr -= (rowInc) >> 1 /* divided by 2 */;

  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot180_YCbCr420ToRGB666 */

/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT180_YCBC420TORGB666

DESCRIPTION
  This function rotates crops Frames and color convert a YUV420 based
  frame into RGB666 format.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  transparentValue - transparent value for framing

ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/

static ipl_status_type ipl2_Rot180Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{

  register unsigned char* inputImgPtr=i_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cr_ptr;
  uint32 rowInc=0, dest_index, destInc, cb_offset;
  uint32 row, col;

  MSG_LOW("inside ipl2_Rot180Frame_YCbCr420ToRGB666\n");

  /*------------------------------------------------------------------------
      180 degree rotation needs starting the image from the extreme corner
      so lets add the whole frame size into the input image ptr and then
      starts decrementing rows

      inputImgPtr
      |
      |
      ^__________________________
      |                         |
      |                         |
      |                         |
      |                         |
      |_______________________|_|
                              |
                              |
                               Offset it into the array to start
                               picking Y values from here backwards
  ------------------------------------------------------------------------*/
  inputImgPtr += i_img_ptr->dx * i_img_ptr->dy  - 1;


  /*------------------------------------------------------------------------
     In the output RGB666 array each pixel is 4 bytes and so
     we offset into the buffer the same way
  ------------------------------------------------------------------------*/
  dest_index = (crop->x + o_img_ptr->dx * crop->y) << 2 /* X 2 */;

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 444 packing table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );


  outputImgPtr = (uint32 *) ((uint32)outputImgPtr +  dest_index);

  /*------------------------------------------------------------------------
      Destination should increment 4 bytes per pixel for RGB666
      encoding.
  ------------------------------------------------------------------------*/
  destInc = ( o_img_ptr->dx - crop->dx) * 4;

  /*------------------------------------------------------------------------
      In this case the Y values are a byte array covering the entier image.

                    crop->dx
              <---------------------->

      cropped area
      delta  in dx
      ______|___________________________
      |________| ______________________|
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |        |                       |
      |________|_______________________|
      <-------------------------------->
            input_img->dx
      We are going backwards thats why this is decerementing
  ------------------------------------------------------------------------*/
  rowInc = (i_img_ptr->dx - crop->dx );


  /*------------------------------------------------------------------------
          cr_ptr with respect to  YCbCr420 packing

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals    Cr Vals       |
                                                                           |
                                                                           ^
                                                                      cr_ptr
                                                                     is here
  ------------------------------------------------------------------------*/
  cr_ptr = i_img_ptr->imgPtr +
         ( i_img_ptr->dx * i_img_ptr->dy  ) /* y array */ +
       (  ( i_img_ptr->dx * i_img_ptr->dy  ) >> 1 )/* cb array * 2 */
        - 1 /* to fetch the last element */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cb_offset =  (i_img_ptr->dx * i_img_ptr->dy  ) >> 2;


  /*------------------------------------------------------------------------
      We process 2 rows at a time in this encoding. So we need half the
      number of iterations
  ------------------------------------------------------------------------*/
  for ( row = crop->dy/2; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 cols at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = crop->dx/2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the current two pixels in the  Frame
        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame and convert from 666
        -----==-----------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *outputImgPtr = out2;

       /*-------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *(outputImgPtr + 1) = out2;


        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + input_row_size) )
                                                     != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
          ----------------------------------------------------------------*/


          /*---------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 666
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize )  = out2;

          /*----------------------------------------------------------------
              color convert and copy the next pixel
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size + 1);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = out2;

          /*----------------------------------------------------------------
             Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr -= 2;

          /*----------------------------------------------------------------
              need to move cr_ptr by one
          ----------------------------------------------------------------*/
          cr_ptr--;

        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cr = *(cr_ptr);

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cb = *(cr_ptr-- - cb_offset);


          /*----------------------------------------------------------------
              Next up is Lumaa1

              Y  |  Y ------------------ this is lumaa1
              Y  |  Y


          ----------------------------------------------------------------*/
          lumaa1 = * ( inputImgPtr -  input_row_size);

          /*----------------------------------------------------------------
                                      _________
                                     |        |
          This is our Lumaa2-------------     |
                                     |   Y1 | Y2
                                     |__ Y2 | Y4

          ----------------------------------------------------------------*/
          lumaa2 = * ( (uint8 *) inputImgPtr - input_row_size - 1 );

          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                             out2,  rTable, gTable, bTable);




          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/
          *( outputImgPtr++ + rowSize ) = out;
          *( outputImgPtr++ + rowSize ) = out2;

          /*----------------------------------------------------------------
             Essentially our business with these 4 pixels are done
          ----------------------------------------------------------------*/
          inputImgPtr -= 2;


        }

        /*------------------------------------------------------------------
            Advance frame by 2 pixels
        ------------------------------------------------------------------*/
        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
                                                      != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
          O3 | O4              I3 | I4    F3   |  F4
          o/p 2 pairs               Frame pairs

          The logic here is as follows
            We know that F3 != transparentValue
                So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

          Copy remaining ie : O3 = F3 and O4  = F4

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cr = *(cr_ptr);

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cb = *(cr_ptr-- - cb_offset);


        /*------------------------------------------------------------------
            Next up is Lumaa1

            |
            |This is the Lumaa1
            |
            Y  |  Y
            Y  |  Y

        ------------------------------------------------------------------*/
        lumaa1 = * ( inputImgPtr--);

        /*------------------------------------------------------------------
            Extract Lumaa2

            Y | Y ------Lumaa2

            Y | Y
        ------------------------------------------------------------------*/
        lumaa2 = * ( (uint8 *) inputImgPtr--);

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
                                            out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/
        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = out;
        *(outputImgPtr + 1) = out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/
                /*---------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 666
        ----------------------------------------------------------------*/
        out =  * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize )  = out2;

        /*------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
          We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. The Lumma Packing is as shown
          below

          |Y4|Y3|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y2|Y1|
      --------------------------------------------------------------------*/
      lumaa1 = *inputImgPtr;  /* corresponds to Y1 in the pic */
      lumaa2 = *( inputImgPtr - 1);  /* corresponds to Y2 in the pic */
      lumaa3 = *(inputImgPtr-- - input_row_size);
      lumaa4 = *(inputImgPtr-- - input_row_size);

      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cr = *(cr_ptr);

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cb = *(cr_ptr - cb_offset);

      /*--------------------------------------------------------------------
          We got both CB and Cr for this iteration we decrement cr_ptr.
          If you look at the pics you can see that they both (cb anc cr)
          move in tandem
      --------------------------------------------------------------------*/
      --cr_ptr;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 in two words.
          cannot be used for RGB666. because 2 pixels cant fit in one
          word
                                            (out)
          Y | Y                       RGB666 | RGB666
                   + CB/CR ----->
          Y | Y                       RGB666 | RGB666
                                           (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;
    }

    /*----------------------------------------------------------------------
        Need to add  number of coulumns * 4 Plus we need to account for
        cropping
    ----------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2)  + destInc ) ;

    /*----------------------------------------------------------------------
      |<------- input_row_size  ----->|
      _______________________________
      |                              |
      |                              |
      |                              |
      |                              |
      |_____________________________X|-------> Where this operation
      |______________________________|         will take us
      |________|_____________________|
               |
               |
               ^
               inputImgPtr
     |-- rowInc-|
    ----------------------------------------------------------------------*/
    inputImgPtr -= (uint32) (rowInc + input_row_size);

    /*----------------------------------------------------------------------
      Remember each four pixels has same CB/CR combination. So we need
      to add number of pixels offset divided by 4

      YY
      -----------------maps to one cr/cb --> cr/cb
      YY

    ----------------------------------------------------------------------*/
    cr_ptr -= (rowInc) >> 1 /* divided by 2 */;

    /*----------------------------------------------------------------------
      We need to keep the frame in Tandem as well
      frameImgPtr is a uint16 ptr so *2 is built in in the following
      instruction
    ----------------------------------------------------------------------*/
    frameImgPtr += (input_row_size + rowInc) ;


  }

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot180Frame_YCbCr420ToRGB666 */


/*==========================================================================

FUNCTION IPL2_CONVERTCROPANDROT270_YCBC420TORGB666

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB666 format.

  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot270_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32 destInc, cr_offset, src_index, cb_offset;
  uint32 row, col;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                           crop->dy;

  MSG_LOW("inside ipl2_Rot270_YCbCr420ToRGB666\n");

  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if ( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
    /*WARN*/
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( i_img_ptr->dy < crop->dx )
  {
    /*----------------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*--------------------------------------------------------------------
        initialize the conversion with RGB 666 packing table
  --------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );


  /*------------------------------------------------------------------------
    270 degree rotation needs starting the image from the same side right
    corner from where the image starts and wroking downwards.
    - with a 2 col offset and so on.

      inputImgPtr
     |
     |
     ^__________________________
     |                         |  |
     |                         |  |
     |                         |  |
     |                         |  v  col increment
     |_________________________|
        <-----------------------
         row increment
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx;

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index - 1;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 4;


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector.
        _____________________________________________
        |                                  <--------||
        |                               Yplane/Cb    |
        |                               offset start |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |____________________________________________|

  ------------------------------------------------------------------------*/
  cb_offset = ( i_img_ptr->dx * i_img_ptr->dy  );
  cb_ptr = i_img_ptr->imgPtr +
           + cb_offset +
           ( src_index  >> 1) - 1 /* end of prev row */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;

  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. Luma Extracion we do on the
          following lines of code assumes the following figure. Just by
          assuming the following geometry we get the 270 degree rotatin.
          You can see the tiny square changed to 90  degree
          anticlockwise now (  same 270 ).

          |Y3|Y1|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y4|Y2|

          As we can see above this small 2 by 2 vector already -90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr += input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 out3 and out4
          in four half words.
                                            (out)
          Y | Y                       RGB666 | RGB666
                   + CB/CR ----->
          Y | Y                       RGB666 | RGB666
                                           (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
        lumaa4, cb, cr,  r, out,
        out2, out3, out4,
        rTable, gTable, bTable );

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;

    } /* end of col loop */

    /*----------------------------------------------------------------------
         Need to add  number of coulumns * 4 and crop gap
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        If we started our first iteration on Yn + 5 doing this we
        are getting Yn + 1.

      Since we are always on the first row offsetted by two than the
      previous one.
    ----------------------------------------------------------------------*/
    src_index -= 2;
    inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;

    cb_ptr = i_img_ptr->imgPtr + cb_offset +
             ( src_index  >> 1) - 1 /* end of prev row */;


  } /* end of row loop */

  return( IPL_SUCCESS );

} /* end of functiion ipl2_Rot270_YCbCr420ToRGB666 */
/*==========================================================================

FUNCTION IPL2_CONVERTCROPFRAMEANDROT270_YCBC420TORGB666

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB666 format.
  Crop with rotation: In this case the orientation of cropped image is
  assumed with respect to output.So the effect will be rotate the image
  and then do a cropping for the specifed parameters.

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_Rot270Frame_YCbCr420ToRGB666
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop          /* cropping params */
)
{
  register unsigned char* inputImgPtr = i_img_ptr->imgPtr;
  register uint32* outputImgPtr =(uint32 *) o_img_ptr->imgPtr;
  register uint16* frameImgPtr = (uint16 *) i_frame_ptr->imgPtr;
  register uint32 out, out2, out3, out4;
  register uint8 cb,cr;
  register int32 lumaa1, lumaa2, lumaa3, lumaa4;
  register int32 r;
  register const uint32 *rTable;
  register const uint32 *gTable;
  register const uint32 *bTable;
  register uint32 input_row_size = i_img_ptr->dx;
  uint32 rowSize = o_img_ptr->dx;
  uint8 *cb_ptr;
  uint32  destInc, cr_offset, src_index, cb_offset, frame_inc;
  uint32 row, col;
  uint32 frame_row_size = i_frame_ptr->dx;
  uint32 render_col_size = (i_img_ptr->dy < crop->dx) ? i_img_ptr->dy :
                           crop->dx;
  uint32 render_row_size = (i_img_ptr->dx < crop->dy) ? i_img_ptr->dx :
                            crop->dy;

  MSG_LOW("inside ipl2_Rot270Frame_YCbCr420ToRGB666\n");


  /*------------------------------------------------------------------------
      In this scheme odd no of cols in a row will not work.
      I am truncating it to nearest lower even
  ------------------------------------------------------------------------*/
  render_row_size &=   (~0x1);
  render_col_size &=   (~0x1);

  /*------------------------------------------------------------------------
      In this case we will actully truncate the image to fit it
      But this begs a warning
  ------------------------------------------------------------------------*/
  if( (i_img_ptr->dy < crop->dx) || (i_img_ptr->dx < crop->dy) )
  {
      /*WARN*/
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( i_img_ptr->dy < crop->dx )
  {
    /*----------------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
      If crop coloumns are more than what the actual row size of input
      image return error
  ------------------------------------------------------------------------*/
  if ( ( i_img_ptr->dy < crop->dx ) ||
    (i_frame_ptr->dx < crop->dx) ||  (i_frame_ptr->dy < crop->dy) )

  {
    /*----------------------------------------------------------------
               Invalid settings
    ----------------------------------------------------------------*/
    return(IPL_FAILURE);
  }

  /*------------------------------------------------------------------------
        initialize the conversion with RGB 444 packing table
  ------------------------------------------------------------------------*/
  rTable = &(ipl2_r666[0]);
  gTable = &(ipl2_g666[0] );
  bTable = &(ipl2_b666[0] );


  /*------------------------------------------------------------------------
    270 degree rotation needs starting the image from the same side right
    corner from where the image starts and wroking downwards.
    - with a 2 col offset and so on.

      inputImgPtr
     |
     |
     ^__________________________
     |                         |  |
     |                         |  |
     |                         |  |
     |                         |  v  col increment
     |_________________________|
        <-----------------------
         row increment
  ------------------------------------------------------------------------*/
  src_index =  i_img_ptr->dx;

  /*------------------------------------------------------------------------
      set the starting position of input image pointer properly offset
  ------------------------------------------------------------------------*/
  inputImgPtr  += src_index - 1;

  /*------------------------------------------------------------------------
      Since we swapped rows for cols at the end of every row iteration
      we need to offset the o/p for the unrendered pixels. We need to
      subtract cropped colomn size. Addition here is byte addressed. Each
      pixel is 4 byes.
  ------------------------------------------------------------------------*/
  destInc = (o_img_ptr->dx - crop->dx) * 4;


  /*------------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

  |   (dx*dy) no of Y values = cr_offset )   |1/4 Yvals      |1/4 Yvals    |
  |------------------------------------------|---------------|-------------|
  |------------------------------------------|---------------|-------------|
        Y values                                  Cb Vals       Cr Vals
        src_index is actually one row off interms of cb and cr plane. This
        is because every odd follows the previous cb\cr vector.
        _____________________________________________
        |                                  <--------||
        |                               Yplane/Cb    |
        |                               offset start |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |                                            |
        |____________________________________________|

  ------------------------------------------------------------------------*/
  cb_offset = ( i_img_ptr->dx * i_img_ptr->dy  );
  cb_ptr = i_img_ptr->imgPtr +
                    + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

  /*------------------------------------------------------------------------
      This assumes even no of coloumns. Need to discuss
  ------------------------------------------------------------------------*/
  cr_offset = ( i_img_ptr->dx * i_img_ptr->dy  ) >> 2 /* /4 */;


  frame_inc  = (i_frame_ptr->dx - crop->dx) + /* to account for crop */
                i_frame_ptr->dx;   /* to account for a row advanced */


  /*------------------------------------------------------------------------
    Offset into output buffer to do relocation; half ward addressed
    addition
  ------------------------------------------------------------------------*/
  outputImgPtr += crop->x + o_img_ptr->dx*crop->y;

  /*------------------------------------------------------------------------
     We process 2 cols at a time in this encoding. So we need half the
     number of iterations. Please note that row and col iterations are
     swapped.
  ------------------------------------------------------------------------*/
  for ( row = render_row_size /2 ; row; row-- )
  {
    /*----------------------------------------------------------------------
        We process 2 rows at a time we need half the number of coloumns
        iteratios.
    ----------------------------------------------------------------------*/
    for ( col = render_col_size / 2; col; col-- )
    {

      if ( *(uint16*)(frameImgPtr) != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2         F1   | F2
                  ----------->            +
          O3 | O4              I3 | I4         F3   |  F4
          o/p 2 pairs          I/P Frame        Frame/TVal pairs

          The logic here is as follows
            We know that F1 != transparentValue
                So copy that o/p ie : O1  = F1 & O2 = F2
            if know that F3 != transparentValue
                Copy them as well ie : O3 = F3 and O4  = F4
            else
                  O3 = RGB(I3) where RGB denotes color conversion to RGB
                  O4 = RGB(I4) where RGB denotes color conversion to RGB

        ------------------------------------------------------------------*/

         /*------------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 666
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *outputImgPtr = out2;

        /*------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = *(uint16*)(frameImgPtr + 1);
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *(outputImgPtr + 1) = out2;


        /*------------------------------------------------------------------
            Since we are taking 4 pixels at a time on the other half
            the frame and transparent value should also take 4 Pixels.
            We are checking the next row to see if we find a match in
            transparency
        ------------------------------------------------------------------*/
        if ( * ( (uint16*)(frameImgPtr + frame_row_size) )
          != transparentValue )
        {
          /*----------------------------------------------------------------
              We need to copy these two pixels in Backward order
              We are atuoincrementing frame because we are done with
              the current frame poistion
          ----------------------------------------------------------------*/

                    /*---------------------------------------------------------------
              Copy Over the Frame and convert from 565 to 666
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize )  = out2;

         /*-----------------------------------------------------------------
              color convert and copy the next pixel
          ----------------------------------------------------------------*/
          out = *(uint16*)(frameImgPtr + frame_row_size + 1);
          r = (unsigned char)((out&0xF800)>>8);
          out2 = rTable[r];
          r = (unsigned char)((out&0x07E0)>>3);
          out2 += gTable[r];
          r = (unsigned char)((out&0x001F)<<3);
          out2 += bTable[r];
          *( outputImgPtr++ + rowSize ) = out2;

          /*----------------------------------------------------------------
            Adjust the row position in Y plane for the next iteration
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size << 1 /* mulitiply by  2 */;

          /*----------------------------------------------------------------
                 We need to decrease the cb by row size /2 to get the next 4
                 pixel cb/cr pair
           ---------------------------------------------------------------*/
          cb_ptr += input_row_size >> 1 /* divide by 2  */;


        }
        else
        {
          /*----------------------------------------------------------------
              We need to convert the pixel and store here
          ----------------------------------------------------------------*/

          /*----------------------------------------------------------------
            Take Luma of all four pixels. Luma Extracion we do on the
            following lines of code assumes the following figure. Just by
            assuming the following geometry we get the 270 degree rotatin.
            You can see the tiny square changed to 90  degree
            anticlockwise now (  same 270 ).

            |Y3|Y1|             (this processing)   |I1|I2|
                  ---Cb, Cr  ------------------->   |RGB3|RGB4|
            |Y4|Y2|

            As we can see above this small 2 by 2 vector already -90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry. I1 and I2 represen
           ---------------------------------------------------------------*/
          lumaa1 = *( inputImgPtr - 1 );

          /*----------------------------------------------------------------
                Go forward by one row
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size;
          lumaa2 = *( inputImgPtr - 1 );

          /*------------------------------------------------------------------
                Go back by one row so that next iteration works perfect
          ----------------------------------------------------------------*/
          inputImgPtr += input_row_size;


          /*----------------------------------------------------------------
              Cr is same for all the 4  Yavals
          ----------------------------------------------------------------*/
          cb = *(cb_ptr );

          /*----------------------------------------------------------------
              Get the Cr for all 4 Y vals
          ----------------------------------------------------------------*/
          cr = *(cb_ptr + cr_offset);

          /*----------------------------------------------------------------
                We need to decrease the cb by row size /2 to get the next 4
                pixel cb/cr pair
          ----------------------------------------------------------------*/
          cb_ptr += input_row_size >> 1;



          /*----------------------------------------------------------------
            Following piece of code is a template for the YCrCb to RGB
            conversion when you find some bug on this make sure you fix
             all the templates used in this file
          ----------------------------------------------------------------*/
          IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
            out2,  rTable, gTable, bTable);

          /*----------------------------------------------------------------
              Save converted pixel
          ----------------------------------------------------------------*/


          *( outputImgPtr++ + rowSize ) = out;
          *( outputImgPtr++ + rowSize ) = out2;
        }

        frameImgPtr += 2;
        /*------------------------------------------------------------------
              We are not falling through
        ------------------------------------------------------------------*/
        continue;
      }
      else if ( * ( (uint16*)(frameImgPtr + input_row_size) )
        != transparentValue )
      {
        /*------------------------------------------------------------------
          Logic for this whole code block
          O1 | O2              I1 | I2    F1   | F2
                  ----------->
        O3 | O4              I3 | I4    F3   |  F4
        o/p 2 pairs               Frame pairs

        The logic here is as follows
          We know that F3 != transparentValue
              So copy that o/p ie : O1  = RGB(I1) & O2 = RGB(I2)

        Copy remaining ie : O3 = F3 and O4  = F4

      --------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            We need to convert the pixel and store here
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Take Luma of all four pixels. Luma Extracion we do on the
            following lines of code assumes the following figure. Just by
            assuming the following geometry we get the 270 degree rotatin.
            You can see the tiny square changed to 90  degree
            anticlockwise now (  same 270 ).

            |Y3|Y1|             (this processing)   |RGB1|RGB2|
                  ---Cb, Cr  ------------------->   |F3  |F4|
            |Y4|Y2|

            As we can see above this small 2 by 2 vector already -90 degree
            transposed by this one assignment. Cb and Cr remains the same.
            One less worry. F3 and F4 are frame pixels on the corresponding
            positions
        ------------------------------------------------------------------*/
        lumaa1 = *( inputImgPtr );

        inputImgPtr += input_row_size;
        lumaa2 = *( inputImgPtr );

        /*------------------------------------------------------------------
              Go forward by one row so that next iteration works perfect
        ------------------------------------------------------------------*/
        inputImgPtr += input_row_size;


        /*------------------------------------------------------------------
            Cr is same for all the 4  Yavals
        ------------------------------------------------------------------*/
        cb = *(cb_ptr );

        /*------------------------------------------------------------------
            Get the Cr for all 4 Y vals
        ------------------------------------------------------------------*/
        cr = *(cb_ptr + cr_offset);

        /*------------------------------------------------------------------
              We need to increase the cb by row size /2 to get the next 4
              pixel cb/cr pair
        ------------------------------------------------------------------*/
        cb_ptr += input_row_size >> 1;

        /*------------------------------------------------------------------
          Following piece of code is a template for the YCrCb to RGB
          conversion when you find some bug on this make sure you fix
           all the templates used in this file
        ------------------------------------------------------------------*/
        IPL2_CONVERT_YCBCR_RGB(lumaa1, lumaa2, cr, cb, r, out,
          out2,  rTable, gTable, bTable);

        /*------------------------------------------------------------------
            Copy the pixels which are from Frame

        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the Frame
        ------------------------------------------------------------------*/
        *outputImgPtr = out;
        *(outputImgPtr + 1) = out2;


        /*------------------------------------------------------------------
            Now copy the 2 pixels in the second row of frame to the output
        ------------------------------------------------------------------*/

        /*------------------------------------------------------------------
            Copy Over the Frame and convert from 565 to 444
        ------------------------------------------------------------------*/
        out =  * ( (uint16*)( frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize )  = out2;

       /*-------------------------------------------------------------------
            color convert and copy the next pixel
        ------------------------------------------------------------------*/
        out = * ( (uint16*)(frameImgPtr++ + frame_row_size) );
        r = (unsigned char)((out&0xF800)>>8);
        out2 = rTable[r];
        r = (unsigned char)((out&0x07E0)>>3);
        out2 += gTable[r];
        r = (unsigned char)((out&0x001F)<<3);
        out2 += bTable[r];
        *( outputImgPtr++ + rowSize ) = out2;

        /*------------------------------------------------------------------
            We are done with all the four pixels so we do not fall
            though from here
        ------------------------------------------------------------------*/
        continue;
      }

      /*--------------------------------------------------------------------
        We need to offset the Frame to move along as we render the buffer
      --------------------------------------------------------------------*/
      frameImgPtr += 2;

      /*--------------------------------------------------------------------
          The format of the YCbCr420 packing as follows

          |   (dx*dy) of Y values )        |1/4 Yvals|1/4 Yvals |
          |--------------------------------|---------|----------|
          |--------------------------------|---------|----------|
                Y values                     Cb Vals    Cr Vals
      --------------------------------------------------------------------*/


      /*--------------------------------------------------------------------
          Take Luma of all four pixels. Luma Extracion we do on the
          following lines of code assumes the following figure. Just by
          assuming the following geometry we get the 270 degree rotatin.
          You can see the tiny square changed to 90  degree
          anticlockwise now (  same 270 ).

          |Y3|Y1|             (this processing)   |RGB1|RGB2|
                ---Cb, Cr  ------------------->   |RGB3|RGB4|
          |Y4|Y2|

          As we can see above this small 2 by 2 vector already -90 degree
          transposed by this one assignment. Cb and Cr remains the same.
          One less worry.
      --------------------------------------------------------------------*/
      lumaa1 = *( inputImgPtr );
      lumaa3 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;
      lumaa2 = *( inputImgPtr );
      lumaa4 = *( inputImgPtr - 1 );

      /*--------------------------------------------------------------------
            Go back by one row so that next iteration works perfect
      --------------------------------------------------------------------*/
      inputImgPtr += input_row_size;


      /*--------------------------------------------------------------------
          Cr is same for all the 4  Yavals
      --------------------------------------------------------------------*/
      cb = *(cb_ptr );

      /*--------------------------------------------------------------------
          Get the Cr for all 4 Y vals
      --------------------------------------------------------------------*/
      cr = *(cb_ptr + cr_offset);

      /*--------------------------------------------------------------------
            We need to decrease the cb by row size /2 to get the next 4
            pixel cb/cr pair
      --------------------------------------------------------------------*/
      cb_ptr += input_row_size >> 1;

      /*--------------------------------------------------------------------
          The following is macro which replces a repetitive
          block of code which takes 4 lummas and a Cr/Cb combination
          to convert it to a RGB flavor with out and out 2 out3 and out4
          in four half words.
                                              (out)
          Y | Y                       RGB666 | RGB666
                   + CB/CR ----->
          Y | Y                       RGB666 | RGB666
                                             (out2)
      --------------------------------------------------------------------*/
      IPL2_CONVERT_YCBCR420TORGB_HALFWORD( lumaa1, lumaa2, lumaa3,
                                              lumaa4, cb, cr,  r, out,
                                              out2, out3, out4,
                                              rTable, gTable, bTable );

      *outputImgPtr = out;
      *(outputImgPtr + 1) = out2;
      *(outputImgPtr++ + rowSize) = out3;
      *(outputImgPtr++ + rowSize) = out4;

    } /* end of col loop */

    /*----------------------------------------------------------------------
         Need to add  number of coulumns in the equivalent o/p image.
         This rowSize * 4 destInc accounts for the
         size mismatch b/w cropped image and output frame size
     ---------------------------------------------------------------------*/
    outputImgPtr =  (uint32 *) ( (uint8 *) outputImgPtr +
                      (rowSize << 2) + destInc );


    /*----------------------------------------------------------------------
        reinitialize the input and cb pointer to start on next coloumn
        last row

        Yn    | Yn + 1  | Yn + 4 | Yn + 5
        Yn+ 2 | Yn+3    | Yn + 6 | Yn + 8

        If we started our first iteration on Yn + 5 doing this we
        are getting Yn + 1.

      Since we are always on the first row offsetted by two than the
      previous one.
    ----------------------------------------------------------------------*/
    src_index -= 2;
    inputImgPtr = i_img_ptr->imgPtr + src_index  - 1;

    cb_ptr = i_img_ptr->imgPtr + cb_offset +
                   ( src_index  >> 1) - 1 /* end of prev row */;

    /*----------------------------------------------------------------------
        Update the frame ptr
    ----------------------------------------------------------------------*/
    frameImgPtr += frame_inc;


  } /* end of row loop */

  return( IPL_SUCCESS );

} /* end of function ipl2_Rot270Frame_YCbCr420ToRGB666 */



/*==========================================================================

FUNCTION IPL2_CONVERTROTATECROPANDFRAME_YCRCB420LPTOToRGB

DESCRIPTION
  This function rotates crops and color convert a YUV420 based
  frame into RGB444/565/666 format. Framing is also supported

DEPENDENCIES
  None



ARGUMENTS IN
  i_img_ptr points to the input image
  i_frame_ptr points to the frame image
  crop is a structure informing ipl how to crop
  rotate is the rotation to do


ARGUMENTS OUT
  o_img_ptr points to the output image

RETURN VALUE
  IPL_SUCCESS   is operation was succesful
  IPL_FAILURE   otherwise

SIDE EFFECTS
  Modifies the output image buffer

==========================================================================*/
static ipl_status_type ipl2_RotFrame_YCrCb420lpToRGB
(
  ipl_image_type* i_img_ptr,    /* Input Image Pointer      */
  ipl_image_type* i_frame_ptr,  /* Input Frame Pointer      */
  uint16 transparentValue,      /* transparent value of pixel    */
  ipl_image_type* o_img_ptr,    /* Output Image Pointer      */
  ipl_rect_type* crop,          /* cropping params */
  ipl_rotate90_type rotate      /* Rotatation                       */
)
{

  ipl_status_type status;


  MSG_LOW("inside ipl2_RotFrame_YCrCb420lpToRGB\n");

    switch ( rotate )
    {
      case IPL_NOROT :
        /*------------------------------------------------------------------
          Handler for 0 degree rotation with framing
        ------------------------------------------------------------------*/
        status = ipl2_Rot000Frame_CropYCrCb420lpToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   NULL,
                   crop);
        break;

      case IPL_ROT90 :
        /*------------------------------------------------------------------
          Handler for 90 degree rotation with framing
        ------------------------------------------------------------------*/
        status = ipl2_Rot090Frame_CropYCrCb420lpToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   NULL,
                   crop);
        break;

      case IPL_ROT180 :
        /*------------------------------------------------------------------
          Handler for 180 degree rotation with framing
        ------------------------------------------------------------------*/

        status = ipl2_Rot180Frame_CropYCrCb420lpToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   NULL,
                   crop);
        break;

      case IPL_ROT270:
        /*------------------------------------------------------------------
          Handler for 270 degree rotation with framing
        ------------------------------------------------------------------*/
        status = ipl2_Rot270Frame_CropYCrCb420lpToRGB(
                   i_img_ptr,
                   i_frame_ptr,
                   transparentValue,
                   o_img_ptr,
                   NULL,
                   crop);
        break;

      default:
        IPL2_MSG_FATAL( "ipl2_Rot000Frame :: /\
                   unknown o/p rotation = %d ", rotate);

        status = IPL_FAILURE;
        break;

    }

    return( status );
} 


/*lint -restore */
