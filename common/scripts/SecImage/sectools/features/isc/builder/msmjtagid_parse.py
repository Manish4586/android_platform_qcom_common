#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Tue Oct 22 12:50:38 2013 by generateDS.py version 2.11a.
#
#Usage: python msmjtagid_parse.py --msm_jtag_mapping_file=msm_jtag_id.xml --msmid=8x10 --msmid=8974

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    raise ImportError
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        raise ImportError
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                raise ImportError
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    filename=None
    if args>0:
        filename=args[0]
    if kwargs.has_key('source'):
        filename=kwargs['source']
    if filename is None:
        raise RuntimeError, 'No Filename found!'

    doc=msm_jtag_id_elementtree(doc,filename)

    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class jtag_id_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, id=None, jtag_id=None, jtag_id_existsing_list=None):
        self.id = _cast(None, id)
        if jtag_id is None:
            self.jtag_id = []
        else:
            self.jtag_id = jtag_id
        if jtag_id_existsing_list is None:
            self.jtag_id_existsing_list = []
        else:
            self.jtag_id_existsing_list = jtag_id_existsing_list
    def factory(*args_, **kwargs_):
        if jtag_id_list.subclass:
            return jtag_id_list.subclass(*args_, **kwargs_)
        else:
            return jtag_id_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_jtag_id(self): return self.jtag_id
    def set_jtag_id(self, jtag_id): self.jtag_id = jtag_id
    def add_jtag_id(self, value): self.jtag_id.append(value)
    def insert_jtag_id(self, index, value): self.jtag_id[index] = value
    def get_jtag_id_existsing_list(self): return self.jtag_id_existsing_list
    def set_jtag_id_existsing_list(self, jtag_id_existsing_list): self.jtag_id_existsing_list = jtag_id_existsing_list
    def add_jtag_id_existsing_list(self, value): self.jtag_id_existsing_list.append(value)
    def insert_jtag_id_existsing_list(self, index, value): self.jtag_id_existsing_list[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.jtag_id or
            self.jtag_id_existsing_list
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id_list', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='jtag_id_list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='msmjtagids:', name_='jtag_id_list'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id_list', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for jtag_id_ in self.jtag_id:
            jtag_id_.export(outfile, level, namespace_, name_='jtag_id', pretty_print=pretty_print)
        for jtag_id_existsing_list_ in self.jtag_id_existsing_list:
            jtag_id_existsing_list_.export(outfile, level, namespace_, name_='jtag_id_existsing_list', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='jtag_id_list'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('jtag_id=[\n')
        level += 1
        for jtag_id_ in self.jtag_id:
            showIndent(outfile, level)
            outfile.write('model_.jtag_id(\n')
            jtag_id_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('jtag_id_existsing_list=[\n')
        level += 1
        for jtag_id_existsing_list_ in self.jtag_id_existsing_list:
            showIndent(outfile, level)
            outfile.write('model_.jtag_id_existsing_list(\n')
            jtag_id_existsing_list_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'jtag_id':
            obj_ = jtag_id.factory()
            obj_.build(child_)
            self.jtag_id.append(obj_)
        elif nodeName_ == 'jtag_id_existsing_list':
            obj_ = jtag_id_existsing_list.factory()
            obj_.build(child_)
            self.jtag_id_existsing_list.append(obj_)
# end class jtag_id_list


class jtag_id(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if jtag_id.subclass:
            return jtag_id.subclass(*args_, **kwargs_)
        else:
            return jtag_id(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='jtag_id')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='msmjtagids:', name_='jtag_id'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='jtag_id'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class jtag_id


class jtag_id_existsing_list(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, idref=None):
        self.idref = _cast(None, idref)
        pass
    def factory(*args_, **kwargs_):
        if jtag_id_existsing_list.subclass:
            return jtag_id_existsing_list.subclass(*args_, **kwargs_)
        else:
            return jtag_id_existsing_list(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id_existsing_list', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='jtag_id_existsing_list')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='msmjtagids:', name_='jtag_id_existsing_list'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (self.gds_format_string(quote_attrib(self.idref).encode(ExternalEncoding), input_name='idref'), ))
    def exportChildren(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id_existsing_list', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='jtag_id_existsing_list'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref="%s",\n' % (self.idref,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class jtag_id_existsing_list


class jtag_id_list_clone(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, idref=None, id=None):
        self.idref = _cast(None, idref)
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if jtag_id_list_clone.subclass:
            return jtag_id_list_clone.subclass(*args_, **kwargs_)
        else:
            return jtag_id_list_clone(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idref(self): return self.idref
    def set_idref(self, idref): self.idref = idref
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id_list_clone', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='jtag_id_list_clone')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='msmjtagids:', name_='jtag_id_list_clone'):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            outfile.write(' idref=%s' % (self.gds_format_string(quote_attrib(self.idref).encode(ExternalEncoding), input_name='idref'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='msmjtagids:', name_='jtag_id_list_clone', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='jtag_id_list_clone'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idref is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            showIndent(outfile, level)
            outfile.write('idref="%s",\n' % (self.idref,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idref', node)
        if value is not None and 'idref' not in already_processed:
            already_processed.add('idref')
            self.idref = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class jtag_id_list_clone


class MsmJtagIds(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, version=None, jtag_id_list=None, jtag_id_list_clone=None):
        self.version = _cast(None, version)
        if jtag_id_list is None:
            self.jtag_id_list = []
        else:
            self.jtag_id_list = jtag_id_list
        if jtag_id_list_clone is None:
            self.jtag_id_list_clone = []
        else:
            self.jtag_id_list_clone = jtag_id_list_clone
    def factory(*args_, **kwargs_):
        if MsmJtagIds.subclass:
            return MsmJtagIds.subclass(*args_, **kwargs_)
        else:
            return MsmJtagIds(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_jtag_id_list(self): return self.jtag_id_list
    def set_jtag_id_list(self, jtag_id_list): self.jtag_id_list = jtag_id_list
    def add_jtag_id_list(self, value): self.jtag_id_list.append(value)
    def insert_jtag_id_list(self, index, value): self.jtag_id_list[index] = value
    def get_jtag_id_list_clone(self): return self.jtag_id_list_clone
    def set_jtag_id_list_clone(self, jtag_id_list_clone): self.jtag_id_list_clone = jtag_id_list_clone
    def add_jtag_id_list_clone(self, value): self.jtag_id_list_clone.append(value)
    def insert_jtag_id_list_clone(self, index, value): self.jtag_id_list_clone[index] = value
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def hasContent_(self):
        if (
            self.jtag_id_list or
            self.jtag_id_list_clone
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='msmjtagids:', name_='MsmJtagIds', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MsmJtagIds')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='msmjtagids:', name_='MsmJtagIds'):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
    def exportChildren(self, outfile, level, namespace_='msmjtagids:', name_='MsmJtagIds', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for jtag_id_list_ in self.jtag_id_list:
            jtag_id_list_.export(outfile, level, namespace_, name_='jtag_id_list', pretty_print=pretty_print)
        for jtag_id_list_clone_ in self.jtag_id_list_clone:
            jtag_id_list_clone_.export(outfile, level, namespace_, name_='jtag_id_list_clone', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MsmJtagIds'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('jtag_id_list=[\n')
        level += 1
        for jtag_id_list_ in self.jtag_id_list:
            showIndent(outfile, level)
            outfile.write('model_.jtag_id_list(\n')
            jtag_id_list_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('jtag_id_list_clone=[\n')
        level += 1
        for jtag_id_list_clone_ in self.jtag_id_list_clone:
            showIndent(outfile, level)
            outfile.write('model_.jtag_id_list_clone(\n')
            jtag_id_list_clone_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        self.gen_jtag_hash()
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'jtag_id_list':
            obj_ = jtag_id_list.factory()
            obj_.build(child_)
            self.jtag_id_list.append(obj_)
        elif nodeName_ == 'jtag_id_list_clone':
            obj_ = jtag_id_list_clone.factory()
            obj_.build(child_)
            self.jtag_id_list_clone.append(obj_)
    def jtag_ids_from_string(self, target_string):
        return jtag_ids_from_string(self.jtag_hash, target_string)
    def gen_jtag_hash(self):
        self.jtag_hash=jtag_hash_from_elements(self)

        return
# end class MsmJtagIds


GDSClassesMapping = {
}


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=True):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'jtag_id_list'
        rootClass = jtag_id_list
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:msmjtagids="uri:MsmJtagIds"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=True):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'jtag_id_list'
        rootClass = jtag_id_list
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=True):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = jtag_id_list
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_="jtag_id_list",
            namespacedef_='xmlns:msmjtagids="uri:MsmJtagIds"')
    return rootObj


def parseLiteral(inFileName, silence=True):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'jtag_id_list'
        rootClass = jtag_id_list
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from msmjtagid_parse import *\n\n')
        sys.stdout.write('import msmjtagid_parse as model_\n\n')
        sys.stdout.write('rootObj = model_.rootTag(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj

def get_jtag_dict_from_msmid(msmid, msm_jtag_mapping_file):
    if type(msmid) is not list:
        msmid = [msmid]
    jtag_elements_tree=parse(msm_jtag_mapping_file, silence=True)
    jtag_dict=jtag_elements_tree.jtag_ids_from_string(target_string=msmid)
    return jtag_dict

def main():
    (options, args) = parse_args()

    try:
        jtag_dict = get_jtag_dict_from_msmid(options.gensecimage_msmid, options.msm_jtag_mapping_file)
    except Exception, e:
        sys.stderr.write(str(e))
        sys.exit(1)
    did_key=False
    string_of_dic='{'
    for cur_key in sorted(jtag_dict.keys()):
        did_key=True
        string_of_dic+="'{0}':'{1}',".format(cur_key,jtag_dict[cur_key])
    if did_key:
        string_of_dic=string_of_dic[:-1]
    string_of_dic+='}'

    print string_of_dic

CURRENT_VERSION = '1.0.1'

from collections import namedtuple
hash_keyref=namedtuple('hash_keyref', ['key','hash'])

def copy_dict_excluding_keys(dict_to_copy, keys_to_exclude=[]):
    final_dict={}

    for cur_excluded_key in keys_to_exclude:
        final_dict.update(dict((cur_key, cur_value) for (cur_key, cur_value) in dict_to_copy.iteritems() if not cur_key==cur_excluded_key))

    return final_dict

class my_element(etree_._Element, object):
    __dict__={}
    def __init__(self,*args,**kwargs):
        #Arguments are (tag=None, attrib={}, orig_elem=None, nsmap=None, **extra)
        newargs=args
        new_kwargs={}
        orig_element=None
        nsmap=None
        tag=None
        tag_in_list=False

        if len(args)>0:
            tag=args[0]
            newargs=args[:]
            tag_in_list=True
        if len(newargs)>1:
            attrib=newargs[1]
        if len(newargs)>2:
            orig_element=newargs[2]
            #print 'chopping off orig_elem' #dbg
            newargs=newargs[0:2,3:]
        if len(newargs)>2:
            nsmap=newargs[2]
            #print 'chopping off nsmap' #dbg
            newargs=newargs[0:2,3:]
        if kwargs.has_key('orig_elem'):
            orig_element=kwargs['orig_elem']
        if kwargs.has_key('tag'):
            tag=kwargs['tag']
        if orig_element is not None:
            tag=orig_element.tag
        elif tag is not None:
            pass
        else:
            error_str='ERROR: neither parameter "orig_elem" (argument 3) "tag" (argument 3) could not be found when creating my_element class object; one or these arguments is required'
            raise RuntimeError, error_str
        if not tag_in_list:
            new_kwargs['tag']=tag
        if kwargs.has_key('nsmap'):
            nsmap=kwargs['nsmap']
        extra=copy_dict_excluding_keys(kwargs,['orig_elem','nsmap','attrib','tag'])
        if kwargs.has_key('attrib'):
            attrib=kwargs['attrib']
            attrib = attrib.copy()
            attrib.update(extra)
            new_kwargs['attrib']=attrib
        elif len(newargs)>1: #list should hold (tag, attrib) parameters at this point
            attrib = newargs[1]
            attrib = attrib.copy()
            attrib.update(extra)
            newargs[1]=attrib
        elif orig_element is not None:
            attrib = orig_element.attrib
            attrib = attrib.copy()
            attrib.update(extra)
            new_kwargs['attrib']=attrib
        else:
            #Enables the default for attrib
            attrib = {}
            attrib.update(extra)
            new_kwargs['attrib']=attrib

        ## debug ##
        '''print 'my_element args: {0}'.format(args)
        print 'my_element kwargs: {0}'.format(kwargs)
        print ""
        print 'my_element newargs: {0}'.format(newargs)
        print 'my_element new_kwargs: {0}'.format(new_kwargs)'''

        super(my_element, self).__init__(*newargs,**new_kwargs)
        if orig_element is not None:
            self.tag=orig_element.tag
            self.attrib=orig_element.attrib
            self.text = orig_element.text
            self.tail = orig_element.tail
            self._children = orig_element[:]
        self.nsmap=nsmap
        self.replace_children()

    def add_nsmap_to_all_nodes(self, nsmap):
        pass
    def replace_children(self):
        list_of_children=[]

        list_of_children=self._children
        for cur_element_index in range(0,len(list_of_children)):
            cur_element=list_of_children[cur_element_index]
            list_of_children[cur_element_index]=my_element(orig_elem=cur_element, nsmap=self.nsmap)
        return

class msm_jtag_id_elementtree(etree_.ElementTree, object):
    __dict__={}

    def __init__(self,*args,**kwargs):
        newargs=args
        if args>0:
            orig_element_tree=args[0]
            #del args[0]
            newargs=newargs[1:]
        if args>1:
            filename=args[1]
            newargs=newargs[1:]
        if kwargs.has_key('orig_et'):
            orig_element_tree=kwargs['orig_et']
            del kwargs['orig_et']
        if kwargs.has_key('filename'):
            orig_element_tree=kwargs['filename']
            del kwargs['filename']

        super(msm_jtag_id_elementtree,self).__init__(*newargs,**kwargs)
        self._setroot(orig_element_tree.getroot())
        self.filename=filename
        self.nsmap=self.make_nsmap()
        self.add_nsmap_to_all_nodes(self.nsmap)

    def make_nsmap(self):
        nsmap={}
        namespace_regex_str=r'^xmlns:(?P<nsname>.*)'
        namespace_regex=None

        #print "Making NSMap"
        import xml.dom.minidom
        minidom_doc=xml.dom.minidom.parse(self.filename)
        minidom_elem=minidom_doc.documentElement

        namespace_regex=re_.compile(namespace_regex_str)


        for cur_item in minidom_elem.attributes.keys():
            #print "Attribute '{0}'='{1}'".format(cur_item, minidom_elem.attributes[cur_item])
            results=namespace_regex.search(cur_item)
            if results is not None:
                nsname=results.group('nsname')
                nsmap[nsname]=minidom_elem.attributes[cur_item].value

        #print nsmap

        return nsmap

    def add_nsmap_to_all_nodes(self, nsmap):
        list_of_children=[]

        root_element=self.getroot()

        if root_element is not None:
            root_element=my_element(orig_elem=self.getroot(),nsmap=nsmap)
            self._root=root_element

        return root_element

def showIndentString(level, pretty_print=True):
    ret_string=''
    if pretty_print:
        for idx in range(level):
            ret_string+='    '
    return ret_string

def jtag_ids_from_string(jtag_hash, target_string):
    final_jtag_id_dict={}

    if isinstance(target_string,basestring):
        target_string_list=[target_string]
    else:
        target_string_list=target_string

    for cur_string in target_string:
        cur_jtag_dict=traverse_jtag_hash(jtag_hash,cur_string)

        for cur_key in cur_jtag_dict.keys():
            if final_jtag_id_dict.has_key(cur_key):
                error_str='ERROR: jtag_ids_from_string - Key "{0}" already exists in final_jtag_id_dict!  All jtag_id name attributes should be unique. Did you ask for overlapping jtag_id_list\'s?'.format(cur_key)
                raise RuntimeError, error_str
            final_jtag_id_dict[cur_key]=cur_jtag_dict[cur_key]

    return final_jtag_id_dict

def jtag_hash_from_elements(jtag_elements_tree, silent=True):
    #print 'jtag_hash_from_elements'
    level=0
    hash_of_jtag_id_lists={}
    jtag_id_names_dict={}

    if len(jtag_elements_tree.jtag_id_list)>0:
        ret_string=showIndentString(level)
        ret_string+="jtag_id_list=[\n"
        level += 1
        for jtag_id_list_ in jtag_elements_tree.jtag_id_list:
            ret_string+=showIndentString(level)
            ret_string+="(\n"
            level += 1
            jtag_id_list_id=jtag_id_list_.get_id()

            ret_string+=showIndentString(level)
            ret_string+="id='{0}',\n".format(jtag_id_list_id)

            if hash_of_jtag_id_lists.has_key(jtag_id_list_id):
                error_str='ERROR: jtag_hash_from_elements - hash_of_jtag_id_lists already has a key "{0}". '.format(jtag_id_list_id)
                error_str+='jtag id field values should be unique throughout xml'
                raise RuntimeError, error_str
            hash_of_jtag_id_lists[jtag_id_list_id]=None

            if jtag_id_list_.hasContent_():
                found_jtag_ids=False
                if len(jtag_id_list_.jtag_id)>0:
                    found_jtag_ids=True
                    hash_of_jtag_id_lists[jtag_id_list_id]=[]
                    ret_string+=showIndentString(level)
                    ret_string+="jtag_id=[\n"
                    level += 1
                    for jtag_id_ in jtag_id_list_.jtag_id:
                        jtag_id_name=jtag_id_.get_name()
                        jtag_id_value=jtag_id_.get_valueOf_()
                        if jtag_id_names_dict.has_key(jtag_id_name):
                            error_str='ERROR: jtag_hash_from_elements - Key "{0}" already exists in jtag_id_names_dict!  All jtag_id name attributes should be unique.'.format(jtag_id_name)
                            raise RuntimeError, error_str
                        jtag_id_names_dict[jtag_id_name]=jtag_id_value
                        jtag_id_dict={jtag_id_name:jtag_id_value}
                        hash_of_jtag_id_lists[jtag_id_list_id].append(jtag_id_dict)

                        ret_string+=showIndentString(level)
                        ret_string+="%s,\n" % (quote_python(repr(jtag_id_dict)).encode(ExternalEncoding))
                    level -= 1
                    ret_string+=showIndentString(level)
                    ret_string+="],\n"
                if len(jtag_id_list_.jtag_id_existsing_list)>0:
                    if not found_jtag_ids:
                        hash_of_jtag_id_lists[jtag_id_list_id]=[]
                    ret_string+=showIndentString(level)
                    ret_string+="jtag_id_existsing_list=[\n"
                    level += 1
                    for jtag_id_existsing_list_ in jtag_id_list_.jtag_id_existsing_list:
                        pass
                        ret_string+=showIndentString(level)
                        ret_string+="(\n"

                        level += 1
                        ret_string+=showIndentString(level)
                        jtag_id_existsing_list_idref=jtag_id_existsing_list_.idref
                        ret_string+="idref=\"%s\",\n" % (jtag_id_existsing_list_idref,)
                        level -= 1
                        ret_string+=showIndentString(level)
                        ret_string+="),\n"

                        hash_of_jtag_id_lists[jtag_id_list_id].append(hash_keyref(jtag_id_existsing_list_idref,hash_of_jtag_id_lists))
                    level -= 1
                    ret_string+=showIndentString(level)
                    ret_string+="],\n"
            level -= 1

            ret_string+=showIndentString(level)
            ret_string+="),\n"
        level -= 1
        ret_string+=showIndentString(level)
        ret_string+="],\n"
    if len(jtag_elements_tree.jtag_id_list_clone)>0:
        ret_string+=showIndentString(level)
        ret_string+="jtag_id_list_clone=[\n"
        level += 1

        for jtag_id_list_clone_ in jtag_elements_tree.jtag_id_list_clone:
            ret_string+=showIndentString(level)
            ret_string+="(\n"
            level += 1
            jtag_id_list_clone_id=jtag_id_list_clone_.get_id()
            jtag_id_list_clone_idref=jtag_id_list_clone_.get_idref()

            if hash_of_jtag_id_lists.has_key(jtag_id_list_clone_id):
                error_str='ERROR: jtag_hash_from_elements - hash_of_jtag_id_lists already has a key "{0}". '.format(jtag_id_list_clone_id)
                error_str+='jtag id field values should be unique throughout xml'
                raise RuntimeError, error_str
            hash_of_jtag_id_lists[jtag_id_list_clone_id]=[]

            ret_string+=showIndentString(level)
            ret_string+="id='{0}',\n".format(jtag_id_list_clone_id)
            ret_string+=showIndentString(level)
            ret_string+="idref='{0}',\n".format(jtag_id_list_clone_idref)
            level -= 1
            ret_string+=showIndentString(level)
            ret_string+="),\n"
            hash_of_jtag_id_lists[jtag_id_list_clone_id].append(hash_keyref(jtag_id_list_clone_idref, hash_of_jtag_id_lists))

        level -= 1
        ret_string+=showIndentString(level)
        ret_string+="],\n"

    if not silent:
        print ret_string

    validate_jtag_hash(hash_of_jtag_id_lists)

    return hash_of_jtag_id_lists

def validate_jtag_hash(hash_of_jtag_id_lists):
    #This function ensures that there are no failing references from clones or references
    #as well as verifying there are no infinite recursion scenarios
    for cur_key in hash_of_jtag_id_lists.keys():
        traverse_jtag_hash(hash_of_jtag_id_lists,cur_key)

    return

def traverse_jtag_hash(hash_of_jtag_id_lists,cur_key,traversed_keys=[], root_traverse=True):
    #print "Traverse to '{0}'".format(cur_key)
    copy_of_traversed_keys=traversed_keys[:]
    copy_of_traversed_keys.append(cur_key)
    values_list=[]
    values_dict={}

    if not hash_of_jtag_id_lists.has_key(cur_key):
        error_str='ERROR: traverse_jtag_hash - Requested key "{0}" does not exist in hash_of_jtag_id_lists'.format(cur_key)
        raise RuntimeError, error_str

    for cur_item in hash_of_jtag_id_lists[cur_key]:
        if isinstance(cur_item,hash_keyref):
            if cur_item.key in copy_of_traversed_keys:
                error_str='ERROR: traverse_jtag_hash - Key "{0}" already traversed!  This would result in an infinite loop!'.format(cur_item.key)
                raise RuntimeError, error_str
            elif not cur_item.hash.has_key(cur_item.key):
                error_str='ERROR: traverse_jtag_hash - Requested key "{0}" does not exist in cur_item.hash for "{1}" key in hash_of_jtag_id_lists'.format(cur_item.key,cur_key)
                raise RuntimeError, error_str
            else:
                values_list.extend(traverse_jtag_hash(cur_item.hash,cur_item.key,traversed_keys=copy_of_traversed_keys, root_traverse=False))
        else:
            values_list.append(cur_item)

    if root_traverse:
        for cur_dict in values_list:
            for cur_key in cur_dict.keys():
                if values_dict.has_key(cur_key):
                    error_str='ERROR: traverse_jtag_hash - Key "{0}" already exists in values_dict!  All jtag_id name attributes should be unique.'.format(cur_key)
                    raise RuntimeError, error_str
                values_dict[cur_key]=cur_dict[cur_key]
        return_data=values_dict
    else:
        return_data=values_list

    return return_data

def parse_args():
    from optparse import OptionParser
    usage = "Usage: python %prog [options]"
    version = "%prog " + CURRENT_VERSION
    general_help_msg = "Try using the -h option for more help information for this program."

    parser = OptionParser(usage=usage, version=version)
    parser.add_option("--msmid", dest="gensecimage_msmid", action="append",
                      help="Msmid to sign images. Msmid maps to JTAG ID defined in msm_jtag_mapping_file. Support multiple msmids")
    parser.add_option("--msm_jtag_mapping_file", dest="msm_jtag_mapping_file",
                      help="Path for MSM to JTAG mapping file", metavar="FILE")

    (options, args) = parser.parse_args()

    if options.gensecimage_msmid is None and options.msm_jtag_mapping_file is None:
        parser.print_help()
        sys.exit(0)
    if options.gensecimage_msmid is None:
        parser.error("msmid is not specified. "+general_help_msg)
    if options.msm_jtag_mapping_file is None:
        parser.error("msm_jtag_mapping_file is not specified. "+general_help_msg)

    return (options, args)

if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "MsmJtagIds",
    "jtag_id",
    "jtag_id_existsing_list",
    "jtag_id_list",
    "jtag_id_list_clone"
]
