/* GPSONE_BIT_API TOOL VERSION: 4.39 */
/* GENERATED: THU JUN 10 2010 */
/*=============================================================================
                    G P S O N E _ B I T _ A P I _ S V C . C

GENERAL DESCRIPTION
  This is an AUTO GENERATED file that dispatches RPC requests targetting the
  gpsone_bit_api api.

  ---------------------------------------------------------------------------
  Copyright (c) 2010,2012 Qualcomm Technologies, Inc.
  All Rights Reserved. Qualcomm Technologies Proprietary and Confidential.
  ---------------------------------------------------------------------------
=============================================================================*/

/*=============================================================================

                              Edit History

                             AUTO GENERATED                                  */
/* Generated by following versions of Htorpc modules:
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/htorpc.pl#2
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Start.pm#1
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Htoxdr.pm#1
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/XDR.pm#1
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Output.pm#2
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Parser.pm#1
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/Metacomments.pm#1
Id: //source/qcom/qct/core/mproc/tools/rel/05.01/htorpc/lib/Htorpc/SymbolTable.pm#1

gpsone_bit_api Definition File(s):
Id: //source/qcom/qct/modem/gps/sandbox/ruih/bit/inc/gpsone_bit_api.h#16
=============================================================================*/
/*=============================================================================
$Header: //source/qcom/qct/modem/gps/sandbox/ruih/bit/rpc/src/gpsone_bit_api_svc.c#6 $
=============================================================================*/


/* Include files */
#include "oncrpc.h"
#include "gpsone_bit_api.h"
#include "gpsone_bit_api_rpc.h"

/* Only one copy needed per API */
//static opaque_auth Gpsone_bit_apiCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Gpsone_bit_apiVerf = { ONCRPC_AUTH_NONE, 0, 0 };

static opaque_auth Gpsone_bit_apicbCred = { ONCRPC_AUTH_NONE, 0, 0 };
static opaque_auth Gpsone_bit_apicbVerf = { ONCRPC_AUTH_NONE, 0, 0 };

/*=======================================================================
            Arg structs for the abnormal exit of client handlers
=======================================================================*/

typedef struct
{
  gpsone_bit_transport_handle_type transport_handle;

} gpsone_bit_deregister_release_args_s_type;

static boolean gpsone_bit_deregister_release_args_s_type_compare(void *s1, void *s2)
{
  gpsone_bit_deregister_release_args_s_type *ss1 = (gpsone_bit_deregister_release_args_s_type *) s1;
  gpsone_bit_deregister_release_args_s_type *ss2 = (gpsone_bit_deregister_release_args_s_type *) s2;

  if ( s1 == NULL || s2 == NULL )
  {
    return (s1 == s2);
  }

  if ( ss1->transport_handle != ss2->transport_handle )
  {
    return FALSE;
  }

  return TRUE;
} /* gpsone_bit_deregister_release_args_s_type_compare */
/*=======================================================================
           Default handlers called upon abnormal client exit
=======================================================================*/

static void gpsone_bit_register_release(void *__rel_args)
{
  gpsone_bit_deregister( ((gpsone_bit_deregister_release_args_s_type *)__rel_args)->transport_handle );
  oncrpc_mem_free(__rel_args);
} /* gpsone_bit_register_release */
/*=======================================================================
             Prototypes for the API's RPC Server Functions
=======================================================================*/

static void gpsone_bit_apiprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv );
static void gpsone_bit_api_null_0x00010001( xdr_s_type *svc );
static void gpsone_bit_api_rpc_glue_code_info_remote_0x00010001( xdr_s_type *svc );
static void gpsone_bit_api_api_versions_0x00010001( xdr_s_type *srv );

static void gpsone_bit_register_0x00010001( xdr_s_type *srv );

static void gpsone_bit_deregister_0x00010001( xdr_s_type *srv );

static void gpsone_bit_notify_0x00010001( xdr_s_type *srv );


/*=======================================================================
             Prototypes for the API's Callback RPC clients
=======================================================================*/

static gpsone_bit_status_e_type gpsone_bit_open_f_type_clnt_0x00010001(gpsone_bit_transport_handle_type transport_handle,  const gpsone_bit_open_params_type *open_param);

static gpsone_bit_status_e_type gpsone_bit_close_f_type_clnt_0x00010001(gpsone_bit_transport_handle_type transport_handle,  const gpsone_bit_close_params_type *close_param);

static gpsone_bit_status_e_type gpsone_bit_connect_f_type_clnt_0x00010001(gpsone_bit_transport_handle_type transport_handle,  uint32 transaction_id,  const gpsone_bit_connect_params_type *connect_param);

static gpsone_bit_status_e_type gpsone_bit_disconnect_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint32 transaction_id,
  const gpsone_bit_disconnect_params_type *disconnect_param
);

static gpsone_bit_status_e_type gpsone_bit_send_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint32 transaction_id,
  uint8 *send_buf,
  uint32 length
);

static gpsone_bit_status_e_type gpsone_bit_recv_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint8 *recv_buf,
  uint32 max_buf_size,
  uint32 *bytes_returned,
  uint32 *bytes_leftover
);

static gpsone_bit_status_e_type gpsone_bit_ioctl_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint32 transaction_id,
  gpsone_bit_ioctl_e_type ioctl_request,
  const gpsone_bit_ioctl_params_type *ioctl_param
);

/******************************************************************************/
/*=======================================================================
             API RPC Server Implementation
=======================================================================*/
static uint32 gpsone_bit_api_api_versions_table[] = { 0x00010001 };

uint32 * gpsone_bit_api_api_versions(uint32 *size_entries)
{
  *size_entries = sizeof( gpsone_bit_api_api_versions_table) / sizeof(uint32);
  return gpsone_bit_api_api_versions_table;
}

void gpsone_bit_api_app_init( void )
{
  (void) svc_register_auto_apiversions(GPSONE_BIT_APIPROG, GPSONE_BIT_APIVERS, gpsone_bit_apiprog_0x00010001,
                                       gpsone_bit_api_api_versions);
} /* gpsone_bit_api_app_init */

void gpsone_bit_api_app_lock( boolean lock )
{
  svc_lock( GPSONE_BIT_APIPROG, GPSONE_BIT_APIVERS, lock );
} /* gpsone_bit_api_app_lock */

static void gpsone_bit_apiprog_0x00010001 ( struct svc_req *rqstp, xdr_s_type *srv )
{
  switch ( rqstp->rq_proc ) {
    case ONCRPC_GPSONE_BIT_API_NULL_PROC:
      gpsone_bit_api_null_0x00010001( srv );
      break;
    case ONCRPC_GPSONE_BIT_API_RPC_GLUE_CODE_INFO_REMOTE_PROC:
      gpsone_bit_api_rpc_glue_code_info_remote_0x00010001( srv );
      break;
    case ONCRPC_GPSONE_BIT_REGISTER_PROC:
      gpsone_bit_register_0x00010001( srv );
      break;
    case ONCRPC_GPSONE_BIT_DEREGISTER_PROC:
      gpsone_bit_deregister_0x00010001( srv );
      break;
    case ONCRPC_GPSONE_BIT_NOTIFY_PROC:
      gpsone_bit_notify_0x00010001( srv );
      break;
    case ONCRPC_GPSONE_BIT_API_API_VERSIONS_PROC:
      gpsone_bit_api_api_versions_0x00010001( srv );
      break;

    default:
      // invalid RPC procedure number
      (void) XDR_MSG_DONE( srv );
      svcerr_default_err( srv, rqstp, gpsone_bit_api_api_versions  );
      break;
  }

  oncrpcxdr_mem_free( srv );
} /* gpsone_bit_apiprog_0x00010001 */

/******************************************************************************/

static void gpsone_bit_api_null_0x00010001( xdr_s_type *srv )
{
  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &Gpsone_bit_apiVerf ) ) {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* gpsone_bit_api_null_0x00010001 */

static void gpsone_bit_api_rpc_glue_code_info_remote_0x00010001( xdr_s_type *srv )
{
  uint32 toolvers   = GPSONE_BIT_API_TOOLVERS; /* 4.39 */
  uint32 proghash   = 0x00010001; /* 0x00010001 */
  uint32 cbproghash = 0x00010001; /* 0x00010001 */
  uint32 features   = GPSONE_BIT_API_FEATURES; /* ONCRPC Server Cleanup Support */


  if ( ! XDR_MSG_DONE( srv ) ) {
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  if ( ! xdr_reply_msg_start( srv, &Gpsone_bit_apiVerf ) ||
       ! XDR_SEND_UINT32( srv, &toolvers ) ||
       ! XDR_SEND_UINT32( srv, &features ) ||
       ! XDR_SEND_UINT32( srv, &proghash ) ||
       ! XDR_SEND_UINT32( srv, &cbproghash ) )
  {
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* gpsone_bit_api_rpc_glue_code_info_remote_0x00010001 */

static void gpsone_bit_register_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 cb_id1;
  uint32 cb_id2;
  uint32 cb_id3;
  uint32 cb_id4;
  uint32 cb_id5;
  uint32 cb_id6;
  uint32 cb_id7;
  boolean output_pointer_not_null;
  gpsone_bit_register_params_type *reg_param = NULL;
  gpsone_bit_transport_handle_type *transport_handle = NULL;
  gpsone_bit_open_f_type *cb1;
  gpsone_bit_close_f_type *cb2;
  gpsone_bit_connect_f_type *cb3;
  gpsone_bit_disconnect_f_type *cb4;
  gpsone_bit_send_f_type *cb5;
  gpsone_bit_recv_f_type *cb6;
  gpsone_bit_ioctl_f_type *cb7;

  gpsone_bit_status_e_type gpsone_bit_register_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  XDR_RECV_POINTER( srv, &reg_param, xdr_gpsone_bit_api_recv_gpsone_bit_register_params_type, xdr_status );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    /* The server must know whether to allocate memory for the output parameter
     * transport_handle or not. A boolean is received to indicate that.
     */
    xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      transport_handle = oncrpcxdr_mem_alloc( srv, sizeof(*transport_handle) );
    }
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id1 );
  }

  /*lint -save -e611*/
  cb1 = (gpsone_bit_open_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_open_f_type_clnt_0x00010001, srv, cb_id1 );
  /*lint -restore */

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id2 );
  }

  /*lint -save -e611*/
  cb2 = (gpsone_bit_close_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_close_f_type_clnt_0x00010001, srv, cb_id2 );
  /*lint -restore */

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id3 );
  }

  /*lint -save -e611*/
  cb3 = (gpsone_bit_connect_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_connect_f_type_clnt_0x00010001, srv, cb_id3 );
  /*lint -restore */

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id4 );
  }

  /*lint -save -e611*/
  cb4 = (gpsone_bit_disconnect_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_disconnect_f_type_clnt_0x00010001, srv, cb_id4 );
  /*lint -restore */

  /* XDR OP NUMBER = 7 */
  if ( xdr_status )
  {
    xdr_op_number = 7;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id5 );
  }

  /*lint -save -e611*/
  cb5 = (gpsone_bit_send_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_send_f_type_clnt_0x00010001, srv, cb_id5 );
  /*lint -restore */

  /* XDR OP NUMBER = 8 */
  if ( xdr_status )
  {
    xdr_op_number = 8;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id6 );
  }

  /*lint -save -e611*/
  cb6 = (gpsone_bit_recv_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_recv_f_type_clnt_0x00010001, srv, cb_id6 );
  /*lint -restore */

  /* XDR OP NUMBER = 9 */
  if ( xdr_status )
  {
    xdr_op_number = 9;
    xdr_status = XDR_RECV_UINT32( srv, &cb_id7 );
  }

  /*lint -save -e611*/
  cb7 = (gpsone_bit_ioctl_f_type *) rpc_svc_callback_register( (void *) gpsone_bit_ioctl_f_type_clnt_0x00010001, srv, cb_id7 );
  /*lint -restore */

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  gpsone_bit_register_result = gpsone_bit_register(reg_param, transport_handle, cb1, cb2, cb3, cb4, cb5, cb6, cb7);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Gpsone_bit_apiVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &gpsone_bit_register_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &transport_handle, XDR_SEND_UINT16, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }

  { /* -------------------------------------------------------------------------
     * Register a release handler for this function with ONCRPC to be called
     * if the client dies before calling gpsone_bit_deregister
     */
    gpsone_bit_deregister_release_args_s_type *__rel_args;
    __rel_args = oncrpc_mem_alloc(sizeof(gpsone_bit_deregister_release_args_s_type));
    memset((void *)__rel_args, 0, sizeof(gpsone_bit_deregister_release_args_s_type));

    __rel_args->transport_handle = *transport_handle;

    oncrpc_register_client_exit_notification_cb( srv,
                                                 gpsone_bit_register_release,
                                                  __rel_args );
  } /* ---------------------------------------------------------------------- */
} /* gpsone_bit_register_0x00010001 */

static void gpsone_bit_deregister_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  gpsone_bit_transport_handle_type transport_handle = 0;

  gpsone_bit_status_e_type gpsone_bit_deregister_result;


  gpsone_bit_deregister_release_args_s_type __comp_args;
  gpsone_bit_deregister_release_args_s_type *__saved_args = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT16( srv, &transport_handle );

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  { /* -------------------------------------------------------------------------
     * Deregister the release handler from ONCRPC since the client called
     * the release API on its own.
     */
    __comp_args.transport_handle = transport_handle;

    __saved_args = (gpsone_bit_deregister_release_args_s_type *) oncrpc_unregister_client_exit_notification_cb
                               ( srv,
                                 gpsone_bit_register_release,
                                 &__comp_args,
                                 gpsone_bit_deregister_release_args_s_type_compare );
  } /* ---------------------------------------------------------------------- */

  gpsone_bit_deregister_result = gpsone_bit_deregister(transport_handle);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Gpsone_bit_apiVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &gpsone_bit_deregister_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }

  { /* -------------------------------------------------------------------------
     * Free the data that was allocated for the saved struct ( __saved_args )
     */
    if ( __saved_args != NULL )
    {
      oncrpc_mem_free(__saved_args);
    }
  } /* ---------------------------------------------------------------------- */
} /* gpsone_bit_deregister_0x00010001 */

static void gpsone_bit_notify_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  gpsone_bit_transport_handle_type transport_handle = 0;
  gpsone_bit_session_handle_type session_handle = 0;
  uint32 transaction_id = 0;
  gpsone_bit_event_payload_type *event_payload = NULL;

  gpsone_bit_status_e_type gpsone_bit_notify_result;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = XDR_RECV_UINT16( srv, &transport_handle );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_UINT16( srv, &session_handle );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( srv, &transaction_id );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    XDR_RECV_POINTER( srv, &event_payload, xdr_gpsone_bit_api_recv_gpsone_bit_event_payload_type, xdr_status );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  gpsone_bit_notify_result = gpsone_bit_notify(transport_handle, session_handle, transaction_id, event_payload);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Gpsone_bit_apiVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_ENUM( srv, &gpsone_bit_notify_result );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* gpsone_bit_notify_0x00010001 */

/*===========================================================================
              API Standard function for api versioning
===========================================================================*/

static void gpsone_bit_api_api_versions_0x00010001( xdr_s_type *srv )
{
  boolean xdr_status = TRUE;
  int xdr_op_number = 0;
  uint32 i;
  boolean output_pointer_not_null;
  uint32 length_uint32;
  uint32 *len = NULL;

  uint32 *gpsone_bit_api_api_versions_result = NULL;

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  /* The server must know whether to allocate memory for the output parameter
   * len or not. A boolean is received to indicate that.
   */
  xdr_status = XDR_RECV_UINT8( srv, &output_pointer_not_null );

  if ( xdr_status && output_pointer_not_null ) {
    len = oncrpcxdr_mem_alloc( srv, sizeof(*len) );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( srv ) || ! xdr_status ) {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_decode reply
    svcerr_decode( srv );
    return;
  }

  gpsone_bit_api_api_versions_result = gpsone_bit_api_api_versions(len);

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_reply_msg_start( srv, &Gpsone_bit_apiVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    if ( gpsone_bit_api_api_versions_result != NULL ) {
      length_uint32 = *len;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );

      /* XDR OP NUMBER = 3 */
      if ( xdr_status )
      {
        xdr_op_number  = 3;

        /* Calling array of XDR routines */
        for ( i = 0; xdr_status && i < (length_uint32); i++ ) {
          /*lint -save -e545*/
          xdr_status = XDR_SEND_UINT32( srv, &(gpsone_bit_api_api_versions_result[i]) );
          /*lint -restore */
        }
      }
    } else {
      length_uint32 = 0;

      xdr_status = XDR_SEND_UINT32( srv, &length_uint32 );
    }
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    /*lint -save -e123*/
    XDR_SEND_POINTER( srv, &len, XDR_SEND_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR( srv, xdr_op_number );
    // send svcerr_systemerr reply
    svcerr_systemerr( srv );
    return;
  }

  if ( ! XDR_MSG_SEND( srv, NULL ) ) {
    XDR_MSG_SEND_ERR( srv, NULL );
  }
} /* gpsone_bit_api_api_versions_0x00010001 */

/*===========================================================================
              API Callback Clients
===========================================================================*/

static gpsone_bit_status_e_type gpsone_bit_open_f_type_clnt_0x00010001(gpsone_bit_transport_handle_type transport_handle,  const gpsone_bit_open_params_type *open_param)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_OPEN_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_OPEN_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    XDR_SEND_POINTER( clnt, &open_param, xdr_gpsone_bit_api_send_gpsone_bit_open_params_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_open_f_type_clnt_0x00010001 */


static gpsone_bit_status_e_type gpsone_bit_close_f_type_clnt_0x00010001(gpsone_bit_transport_handle_type transport_handle,  const gpsone_bit_close_params_type *close_param)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_CLOSE_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_CLOSE_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    XDR_SEND_POINTER( clnt, &close_param, xdr_gpsone_bit_api_send_gpsone_bit_close_params_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_close_f_type_clnt_0x00010001 */


static gpsone_bit_status_e_type gpsone_bit_connect_f_type_clnt_0x00010001(gpsone_bit_transport_handle_type transport_handle,  uint32 transaction_id,  const gpsone_bit_connect_params_type *connect_param)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_CONNECT_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_CONNECT_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_UINT32( clnt, &transaction_id );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    XDR_SEND_POINTER( clnt, &connect_param, xdr_gpsone_bit_api_send_gpsone_bit_connect_params_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_connect_f_type_clnt_0x00010001 */


static gpsone_bit_status_e_type gpsone_bit_disconnect_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint32 transaction_id,
  const gpsone_bit_disconnect_params_type *disconnect_param
)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_DISCONNECT_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_DISCONNECT_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_UINT16( clnt, &session_handle );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_SEND_UINT32( clnt, &transaction_id );
  }

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    XDR_SEND_POINTER( clnt, &disconnect_param, xdr_gpsone_bit_api_send_gpsone_bit_disconnect_params_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_disconnect_f_type_clnt_0x00010001 */


static gpsone_bit_status_e_type gpsone_bit_send_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint32 transaction_id,
  uint8 *send_buf,
  uint32 length
)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  unsigned long int length_unsigned_long_int;
  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_SEND_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_SEND_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_UINT16( clnt, &session_handle );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_SEND_UINT32( clnt, &transaction_id );
  }

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    if ( send_buf != NULL ) {
      length_unsigned_long_int = length;
      length_unsigned_long_int = ( length_unsigned_long_int > GPSONE_BIT_MAX_BUF_SIZE ? GPSONE_BIT_MAX_BUF_SIZE : length_unsigned_long_int );

      xdr_status = XDR_SEND_UINT32( clnt, &length_unsigned_long_int );

      /* XDR OP NUMBER = 7 */
      if ( xdr_status )
      {
        xdr_op_number  = 7;
        xdr_status = XDR_SEND_BYTES(clnt, send_buf, length_unsigned_long_int);
      }
    } else {
      length_unsigned_long_int = 0;

      xdr_status = XDR_SEND_UINT32( clnt, &length_unsigned_long_int );
    }
  }

  /* XDR OP NUMBER = 8 */
  if ( xdr_status )
  {
    xdr_op_number = 8;
    xdr_status = XDR_SEND_UINT32( clnt, &length );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_send_f_type_clnt_0x00010001 */


static gpsone_bit_status_e_type gpsone_bit_recv_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint8 *recv_buf,
  uint32 max_buf_size,
  uint32 *bytes_returned,
  uint32 *bytes_leftover
)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  boolean output_pointer_not_null;
  uint32 length_uint32;
  unsigned long int length_unsigned_long_int;
  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_RECV_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_RECV_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_UINT16( clnt, &session_handle );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    /* Send TRUE if recv_buf is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use. Also since this is
     * a pointer to a variable array, we need to send the maximum size of the
     * array too.
     */
    output_pointer_not_null = (recv_buf != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );

    if ( xdr_status && output_pointer_not_null ) {
      length_uint32 = GPSONE_BIT_MAX_BUF_SIZE;

      xdr_status = XDR_SEND_UINT32( clnt, &length_uint32 );

    }
  }

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    xdr_status = XDR_SEND_UINT32( clnt, &max_buf_size );
  }

  /* XDR OP NUMBER = 7 */
  if ( xdr_status )
  {
    xdr_op_number = 7;
    /* Send TRUE if bytes_returned is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (bytes_returned != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  /* XDR OP NUMBER = 8 */
  if ( xdr_status )
  {
    xdr_op_number = 8;
    /* Send TRUE if bytes_leftover is not NULL and FALSE otherwise so that the server
     * can correctly allocate memory for the service to use
     */
    output_pointer_not_null = (bytes_leftover != NULL);

    xdr_status = XDR_SEND_UINT8( clnt, &output_pointer_not_null );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_RECV_UINT32( clnt, &length_unsigned_long_int );

    /* XDR OP NUMBER = 4 */
    if ( xdr_status && length_unsigned_long_int > 0 )
    {
      xdr_op_number  = 4;
      if ( recv_buf != NULL ) {
        xdr_status = XDR_RECV_BYTES(clnt, recv_buf, length_unsigned_long_int);
      }
    }
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &bytes_returned, XDR_RECV_UINT32, xdr_status );
    /*lint -restore */
  }

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    /*lint -save -e123*/
    XDR_RECV_POINTER( clnt, &bytes_leftover, XDR_RECV_UINT32, xdr_status );
    /*lint -restore */
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_recv_f_type_clnt_0x00010001 */


static gpsone_bit_status_e_type gpsone_bit_ioctl_f_type_clnt_0x00010001(
  gpsone_bit_transport_handle_type transport_handle,
  gpsone_bit_session_handle_type session_handle,
  uint32 transaction_id,
  gpsone_bit_ioctl_e_type ioctl_request,
  const gpsone_bit_ioctl_params_type *ioctl_param
)
{
  xdr_s_type       *clnt          = NULL;
  rpc_reply_header  reply_header;
  rpc_cb_data_type *rpc_cb_data   = NULL;
  boolean           xdr_status    = TRUE;
  int               xdr_op_number = 0;

  gpsone_bit_status_e_type cmd_cb_func_result;


  rpc_cb_data = rpc_svc_cb_data_lookup();

  if ( rpc_cb_data == NULL )
  {
    RPC_SVC_CB_DATA_LOOKUP_ERR();
    return GPSONE_BIT_STATUS_FAIL;
  }

  clnt = rpc_clnt_for_callback( rpc_cb_data );

  oncrpcxdr_mem_free( clnt );

  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;
  xdr_status = xdr_call_msg_start( clnt,
                                   GPSONE_BIT_APICBPROG, GPSONE_BIT_IOCTL_F_TYPE_VERS,
                                   ONCRPC_GPSONE_BIT_IOCTL_F_TYPE_PROC, &Gpsone_bit_apicbCred, &Gpsone_bit_apicbVerf );

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_SEND_UINT32( clnt, &rpc_cb_data->cb_id );
  }

  /* XDR OP NUMBER = 3 */
  if ( xdr_status )
  {
    xdr_op_number = 3;
    xdr_status = XDR_SEND_UINT16( clnt, &transport_handle );
  }

  /* XDR OP NUMBER = 4 */
  if ( xdr_status )
  {
    xdr_op_number = 4;
    xdr_status = XDR_SEND_UINT16( clnt, &session_handle );
  }

  /* XDR OP NUMBER = 5 */
  if ( xdr_status )
  {
    xdr_op_number = 5;
    xdr_status = XDR_SEND_UINT32( clnt, &transaction_id );
  }

  /* XDR OP NUMBER = 6 */
  if ( xdr_status )
  {
    xdr_op_number = 6;
    xdr_status = XDR_SEND_ENUM( clnt, &ioctl_request );
  }

  /* XDR OP NUMBER = 7 */
  if ( xdr_status )
  {
    xdr_op_number = 7;
    XDR_SEND_POINTER( clnt, &ioctl_param, xdr_gpsone_bit_api_send_gpsone_bit_ioctl_params_type, xdr_status );
  }

  if ( ! xdr_status )
  {
    XDR_OP_ERR(clnt, xdr_op_number);
    return GPSONE_BIT_STATUS_FAIL;
  }

  /* Send the RPC message and block waiting for a reply */
  if ( ! XDR_MSG_SEND( clnt, &reply_header ) )
  {
    XDR_MSG_SEND_ERR( clnt, &reply_header );
    return GPSONE_BIT_STATUS_FAIL;
  }
  /* XDR OP NUMBER = 1 */
  xdr_op_number = 1;

  if ( reply_header.stat != RPC_MSG_ACCEPTED ) {
    XDR_CALL_REJECTED_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  if ( reply_header.u.ar.stat != RPC_ACCEPT_SUCCESS ) {
    XDR_ERR_ON_SERVER_ERR( clnt, &reply_header );
    xdr_status = FALSE;
  }

  /* XDR OP NUMBER = 2 */
  if ( xdr_status )
  {
    xdr_op_number = 2;
    xdr_status = XDR_RECV_ENUM( clnt, &cmd_cb_func_result );
  }

  if ( xdr_status )
  {
    xdr_op_number++;
  }

  if ( ! XDR_MSG_DONE( clnt ) || ! xdr_status )
  {
        XDR_OP_ERR( clnt, xdr_op_number );
    return GPSONE_BIT_STATUS_FAIL;
  }

  return cmd_cb_func_result;
} /* gpsone_bit_ioctl_f_type_clnt_0x00010001 */


